{
    "BezierCurve:evaluate": {
        "descr": "Evaluate Bézier curve at parameter t. The parameter must be between 0 and 1 (inclusive).",
        "name": "BezierCurve:evaluate",
        "params": [
            {
                "descr": "Where to evaluate the curve.",
                "name": "number t"
            },
            {
                "descr": "x coordinate of the curve at parameter t.",
                "name": "number x"
            },
            {
                "descr": "y coordinate of the curve at parameter t.",
                "name": "number y"
            }
        ],
        "path": "love/beziercurve-evaluate",
        "syntax": "x,y = BezierCurve:evaluate(t)",
        "type": "love.math"
    },
    "BezierCurve:getControlPoint": {
        "descr": "Get coordinates of the i-th control point. Indices start with 1.",
        "name": "BezierCurve:getControlPoint",
        "params": [
            {
                "descr": "Index of the control point.",
                "name": "number i"
            },
            {
                "descr": "Position of the control point along the x axis.",
                "name": "number x"
            },
            {
                "descr": "Position of the control point along the y axis.",
                "name": "number y"
            }
        ],
        "path": "love/beziercurve-getcontrolpoint",
        "syntax": "x, y = BezierCurve:getControlPoint(i)",
        "type": "love.math"
    },
    "BezierCurve:getControlPointCount": {
        "descr": "Get the number of control points in the Bézier curve.",
        "name": "BezierCurve:getControlPointCount",
        "params": [
            {
                "descr": "The number of control points.",
                "name": "number count"
            }
        ],
        "path": "love/beziercurve-getcontrolpointcount",
        "syntax": "count = BezierCurve:getControlPointCount( )",
        "type": "love.math"
    },
    "BezierCurve:getDegree": {
        "descr": "Get degree of the Bézier curve. The degree is equal to number-of-control-points - 1.",
        "name": "BezierCurve:getDegree",
        "params": [
            {
                "descr": "Degree of the Bézier curve.",
                "name": "number degree"
            }
        ],
        "path": "love/beziercurve-getdegree",
        "syntax": "degree = BezierCurve:getDegree( )",
        "type": "love.math"
    },
    "BezierCurve:getDerivative": {
        "descr": "Get the derivative of the Bézier curve.",
        "name": "BezierCurve:getDerivative",
        "params": [
            {
                "descr": "The derivative curve.",
                "name": "BezierCurve derivative"
            }
        ],
        "path": "love/beziercurve-getderivative",
        "syntax": "derivative = BezierCurve:getDerivative()",
        "type": "love.math"
    },
    "BezierCurve:getSegment": {
        "descr": "Gets a BezierCurve that corresponds to the specified segment of this BezierCurve.",
        "name": "BezierCurve:getSegment",
        "params": [
            {
                "descr": "The starting point along the curve. ",
                "name": "number startpoint"
            },
            {
                "descr": "The end of the segment. Must be between 0 and 1.",
                "name": "number endpoint"
            },
            {
                "descr": "A BezierCurve that corresponds to the specified segment.",
                "name": "BezierCurve curve"
            }
        ],
        "path": "love/beziercurve-getsegment",
        "syntax": "curve = BezierCurve:getSegment( startpoint, endpoint )",
        "type": "love.math"
    },
    "BezierCurve:insertControlPoint": {
        "descr": "Insert control point after the i-th control point. Indices start with 1. Negative indices wrap around: -1 is the last control point, -2 the one before the last, etc.",
        "name": "BezierCurve:insertControlPoint",
        "params": [
            {
                "descr": "Position of the control point along the x axis.",
                "name": "number x"
            },
            {
                "descr": "Position of the control point along the y axis.",
                "name": "number y"
            },
            {
                "descr": "Index of the control point.",
                "name": "number i (-1)"
            }
        ],
        "path": "love/beziercurve-insertcontrolpoint",
        "syntax": "BezierCurve:insertControlPoint(x, y, i)",
        "type": "love.math"
    },
    "BezierCurve:removeControlPoint": {
        "descr": "Removes the specified control point.",
        "name": "BezierCurve:removeControlPoint",
        "params": [
            {
                "descr": "The index of the control point to remove.",
                "name": "number index"
            }
        ],
        "path": "love/beziercurve-removecontrolpoint",
        "syntax": "BezierCurve:removeControlPoint( index )",
        "type": "love.math"
    },
    "BezierCurve:render": {
        "descr": "Get a list of coordinates to be used with love.graphics.line.",
        "name": "BezierCurve:render",
        "params": [
            {
                "descr": "Number of recursive subdivision steps.",
                "name": "number depth (5)"
            },
            {
                "descr": "List of x,y-coordinate pairs of points on the curve.",
                "name": "table coordinates"
            }
        ],
        "path": "love/beziercurve-render",
        "syntax": "coordinates = BezierCurve:render(depth)",
        "type": "love.math"
    },
    "BezierCurve:renderSegment": {
        "descr": "Get a list of coordinates on a specific part of the curve, to be used with love.graphics.line.",
        "name": "BezierCurve:renderSegment",
        "params": [
            {
                "descr": "The starting point along the curve. ",
                "name": "number startpoint"
            },
            {
                "descr": "The end of the segment to render. ",
                "name": "number endpoint"
            },
            {
                "descr": "Number of recursive subdivision steps.",
                "name": "number depth (5)"
            },
            {
                "descr": "List of x,y-coordinate pairs of points on the specified part of the curve.",
                "name": "table coordinates"
            }
        ],
        "path": "love/beziercurve-rendersegment",
        "syntax": "coordinates = BezierCurve:renderSegment( startpoint, endpoint, depth )",
        "type": "love.math"
    },
    "BezierCurve:rotate": {
        "descr": "Rotate the Bézier curve by an angle.",
        "name": "BezierCurve:rotate",
        "params": [
            {
                "descr": "Rotation angle in radians.",
                "name": "number angle"
            },
            {
                "descr": "X coordinate of the rotation center.",
                "name": "number ox (0)"
            },
            {
                "descr": "Y coordinate of the rotation center.",
                "name": "number oy (0)"
            }
        ],
        "path": "love/beziercurve-rotate",
        "syntax": "BezierCurve:rotate(angle, ox, oy)",
        "type": "love.math"
    },
    "BezierCurve:scale": {
        "descr": "Scale the Bézier curve by a factor.",
        "name": "BezierCurve:scale",
        "params": [
            {
                "descr": "Scale factor.",
                "name": "number s"
            },
            {
                "descr": "X coordinate of the scaling center.",
                "name": "number ox (0)"
            },
            {
                "descr": "Y coordinate of the scaling center.",
                "name": "number oy (0)"
            }
        ],
        "path": "love/beziercurve-scale",
        "syntax": "BezierCurve:scale(s, ox, oy)",
        "type": "love.math"
    },
    "BezierCurve:setControlPoint": {
        "descr": "Set coordinates of the i-th control point. Indices start with 1.",
        "name": "BezierCurve:setControlPoint",
        "params": [
            {
                "descr": "Index of the control point.",
                "name": "number i"
            },
            {
                "descr": "Position of the control point along the x axis.",
                "name": "number x"
            },
            {
                "descr": "Position of the control point along the y axis.",
                "name": "number y"
            }
        ],
        "path": "love/beziercurve-setcontrolpoint",
        "syntax": "BezierCurve:setControlPoint(i, x, y)",
        "type": "love.math"
    },
    "BezierCurve:translate": {
        "descr": "Move the Bézier curve by an offset.",
        "name": "BezierCurve:translate",
        "params": [
            {
                "descr": "Offset along the x axis.",
                "name": "number dx"
            },
            {
                "descr": "Offset along the y axis.",
                "name": "number dy"
            }
        ],
        "path": "love/beziercurve-translate",
        "syntax": "BezierCurve:translate(dx, dy)",
        "type": "love.math"
    },
    "Body:applyAngularImpulse": {
        "descr": "Applies an angular impulse to a body. This makes a single, instantaneous addition to the body momentum.",
        "name": "Body:applyAngularImpulse",
        "params": [
            {
                "descr": "The impulse in kilogram-square meter per second.",
                "name": "number impulse"
            }
        ],
        "path": "love/body-applyangularimpulse",
        "syntax": "Body:applyAngularImpulse( impulse )",
        "type": "love.physics"
    },
    "Body:applyForce": {
        "descr": "Apply force to a Body.",
        "name": "Body:applyForce",
        "params": [
            {
                "descr": "The x component of force to apply to the center of mass.",
                "name": "number fx"
            },
            {
                "descr": "The y component of force to apply to the center of mass.",
                "name": "number fy"
            }
        ],
        "path": "love/body-applyforce",
        "syntax": "Body:applyForce( fx, fy )",
        "type": "love.physics"
    },
    "Body:applyImpulse": {
        "descr": "Applies an impulse to a body. This makes a single, instantaneous addition to the body momentum.",
        "name": "Body:applyImpulse",
        "params": [
            {
                "descr": "The x component of the impulse.",
                "name": "number ix"
            },
            {
                "descr": "The y component of the impulse.",
                "name": "number iy"
            },
            {
                "descr": "The x position to apply the impulse.",
                "name": "number x"
            },
            {
                "descr": "The y position to apply the impulse.",
                "name": "number y"
            }
        ],
        "path": "love/body-applyimpulse",
        "syntax": "Body:applyImpulse( ix, iy, x, y )",
        "type": "love.physics"
    },
    "Body:applyLinearImpulse": {
        "descr": "Applies an impulse to a body. This makes a single, instantaneous addition to the body momentum.",
        "name": "Body:applyLinearImpulse",
        "params": [
            {
                "descr": "The x component of the impulse applied to the center of mass.",
                "name": "number ix"
            },
            {
                "descr": "The y component of the impulse applied to the center of mass.",
                "name": "number iy"
            }
        ],
        "path": "love/body-applylinearimpulse",
        "syntax": "Body:applyLinearImpulse( ix, iy )",
        "type": "love.physics"
    },
    "Body:applyTorque": {
        "descr": "Apply torque to a body.",
        "name": "Body:applyTorque",
        "params": [
            {
                "descr": "The torque to apply.",
                "name": "number torque"
            }
        ],
        "path": "love/body-applytorque",
        "syntax": "Body:applyTorque( torque )",
        "type": "love.physics"
    },
    "Body:destroy": {
        "descr": "Explicitly destroys the Body and all fixtures and joints attached to it.",
        "name": "Body:destroy",
        "params": [],
        "path": "love/body-destroy",
        "syntax": "Body:destroy( )",
        "type": "love.physics"
    },
    "Body:getAllowSleeping": {
        "descr": "Return whether a body is allowed to sleep.",
        "name": "Body:getAllowSleeping",
        "params": [
            {
                "descr": "True when the body is allowed to sleep.",
                "name": "boolean status"
            }
        ],
        "path": "love/body-getallowsleeping",
        "syntax": "status = Body:getAllowSleeping( )",
        "type": "love.physics"
    },
    "Body:getAngle": {
        "descr": "Get the angle of the body.",
        "name": "Body:getAngle",
        "params": [
            {
                "descr": "The angle in radians.",
                "name": "number angle"
            }
        ],
        "path": "love/body-getangle",
        "syntax": "angle = Body:getAngle( )",
        "type": "love.physics"
    },
    "Body:getAngularDamping": {
        "descr": "Gets the Angular damping of the Body",
        "name": "Body:getAngularDamping",
        "params": [
            {
                "descr": "The value of the angular damping.",
                "name": "number damping"
            }
        ],
        "path": "love/body-getangulardamping",
        "syntax": "damping = Body:getAngularDamping( )",
        "type": "love.physics"
    },
    "Body:getAngularVelocity": {
        "descr": "Get the angular velocity of the Body.",
        "name": "Body:getAngularVelocity",
        "params": [
            {
                "descr": "The angular velocity in radians/second.",
                "name": "number w"
            }
        ],
        "path": "love/body-getangularvelocity",
        "syntax": "w = Body:getAngularVelocity( )",
        "type": "love.physics"
    },
    "Body:getContactList": {
        "descr": "Gets a list of all Contacts attached to the Body.",
        "name": "Body:getContactList",
        "params": [
            {
                "descr": "A list with all contacts associated with the Body.",
                "name": "table contacts"
            }
        ],
        "path": "love/body-getcontactlist",
        "syntax": "contacts = Body:getContactList( )",
        "type": "love.physics"
    },
    "Body:getFixtureList": {
        "descr": "Returns a table with all fixtures.",
        "name": "Body:getFixtureList",
        "params": [
            {
                "descr": "A sequence with all fixtures.",
                "name": "table fixtures"
            }
        ],
        "path": "love/body-getfixturelist",
        "syntax": "fixtures = Body:getFixtureList( )",
        "type": "love.physics"
    },
    "Body:getGravityScale": {
        "descr": "Returns the gravity scale factor.",
        "name": "Body:getGravityScale",
        "params": [
            {
                "descr": "The gravity scale factor.",
                "name": "number scale"
            }
        ],
        "path": "love/body-getgravityscale",
        "syntax": "scale = Body:getGravityScale( )",
        "type": "love.physics"
    },
    "Body:getInertia": {
        "descr": "Gets the rotational inertia of the body.",
        "name": "Body:getInertia",
        "params": [
            {
                "descr": "The rotational inertial of the body.",
                "name": "number inertia"
            }
        ],
        "path": "love/body-getinertia",
        "syntax": "inertia = Body:getInertia( )",
        "type": "love.physics"
    },
    "Body:getJointList": {
        "descr": "Returns a table containing the Joints attached to this Body.",
        "name": "Body:getJointList",
        "params": [
            {
                "descr": "A sequence with the Joints attached to the Body.",
                "name": "table joints"
            }
        ],
        "path": "love/body-getjointlist",
        "syntax": "joints = Body:getJointList( )",
        "type": "love.physics"
    },
    "Body:getLinearDamping": {
        "descr": "Gets the linear damping of the Body.",
        "name": "Body:getLinearDamping",
        "params": [
            {
                "descr": "The value of the linear damping.",
                "name": "number damping"
            }
        ],
        "path": "love/body-getlineardamping",
        "syntax": "damping = Body:getLinearDamping( )",
        "type": "love.physics"
    },
    "Body:getLinearVelocity": {
        "descr": "Gets the linear velocity of the Body from its center of mass.",
        "name": "Body:getLinearVelocity",
        "params": [
            {
                "descr": "The x-component of the velocity vector",
                "name": "number x"
            },
            {
                "descr": "The y-component of the velocity vector",
                "name": "number y"
            }
        ],
        "path": "love/body-getlinearvelocity",
        "syntax": "x, y = Body:getLinearVelocity( )",
        "type": "love.physics"
    },
    "Body:getLinearVelocityFromLocalPoint": {
        "descr": "Get the linear velocity of a point on the body.",
        "name": "Body:getLinearVelocityFromLocalPoint",
        "params": [
            {
                "descr": "The x position to measure velocity.",
                "name": "number x"
            },
            {
                "descr": "The y position to measure velocity.",
                "name": "number y"
            },
            {
                "descr": "The x component of velocity at point (x,y).",
                "name": "number vx"
            },
            {
                "descr": "The y component of velocity at point (x,y).",
                "name": "number vy"
            }
        ],
        "path": "love/body-getlinearvelocityfromlocalpoint",
        "syntax": "vx, vy = Body:getLinearVelocityFromLocalPoint( x, y )",
        "type": "love.physics"
    },
    "Body:getLinearVelocityFromWorldPoint": {
        "descr": "Get the linear velocity of a point on the body.",
        "name": "Body:getLinearVelocityFromWorldPoint",
        "params": [
            {
                "descr": "The x position to measure velocity.",
                "name": "number x"
            },
            {
                "descr": "The y position to measure velocity.",
                "name": "number y"
            },
            {
                "descr": "The x component of velocity at point (x,y).",
                "name": "number vx"
            },
            {
                "descr": "The y component of velocity at point (x,y).",
                "name": "number vy"
            }
        ],
        "path": "love/body-getlinearvelocityfromworldpoint",
        "syntax": "vx, vy = Body:getLinearVelocityFromWorldPoint( x, y )",
        "type": "love.physics"
    },
    "Body:getLocalCenter": {
        "descr": "Get the center of mass position in local coordinates.",
        "name": "Body:getLocalCenter",
        "params": [
            {
                "descr": "The x coordinate of the center of mass.",
                "name": "number x"
            },
            {
                "descr": "The y coordinate of the center of mass.",
                "name": "number y"
            }
        ],
        "path": "love/body-getlocalcenter",
        "syntax": "x, y = Body:getLocalCenter( )",
        "type": "love.physics"
    },
    "Body:getLocalPoint": {
        "descr": "Transform a point from world coordinates to local coordinates.",
        "name": "Body:getLocalPoint",
        "params": [
            {
                "descr": "The x position in world coordinates.",
                "name": "number worldX"
            },
            {
                "descr": "The y position in world coordinates.",
                "name": "number worldY"
            },
            {
                "descr": "The x position in local coordinates.",
                "name": "number localX"
            },
            {
                "descr": "The y position in local coordinates.",
                "name": "number localY"
            }
        ],
        "path": "love/body-getlocalpoint",
        "syntax": "localX, localY = Body:getLocalPoint( worldX, worldY )",
        "type": "love.physics"
    },
    "Body:getLocalVector": {
        "descr": "Transform a vector from world coordinates to local coordinates.",
        "name": "Body:getLocalVector",
        "params": [
            {
                "descr": "The vector x component in world coordinates.",
                "name": "number worldX"
            },
            {
                "descr": "The vector y component in world coordinates.",
                "name": "number worldY"
            },
            {
                "descr": "The vector x component in local coordinates.",
                "name": "number localX"
            },
            {
                "descr": "The vector y component in local coordinates.",
                "name": "number localY"
            }
        ],
        "path": "love/body-getlocalvector",
        "syntax": "localX, localY = Body:getLocalVector( worldX, worldY )",
        "type": "love.physics"
    },
    "Body:getMass": {
        "descr": "Get the mass of the body.",
        "name": "Body:getMass",
        "params": [
            {
                "descr": "The mass of the body (in kilograms).",
                "name": "number mass"
            }
        ],
        "path": "love/body-getmass",
        "syntax": "mass = Body:getMass( )",
        "type": "love.physics"
    },
    "Body:getMassData": {
        "descr": "Returns the mass, its center, and the rotational inertia.",
        "name": "Body:getMassData",
        "params": [
            {
                "descr": "The x position of the center of mass.",
                "name": "number x"
            },
            {
                "descr": "The y position of the center of mass.",
                "name": "number y"
            },
            {
                "descr": "The mass of the body.",
                "name": "number mass"
            },
            {
                "descr": "The rotational inertia.",
                "name": "number inertia"
            }
        ],
        "path": "love/body-getmassdata",
        "syntax": "x, y, mass, inertia = Body:getMassData( )",
        "type": "love.physics"
    },
    "Body:getPosition": {
        "descr": "Get the position of the body.",
        "name": "Body:getPosition",
        "params": [
            {
                "descr": "The x position.",
                "name": "number x"
            },
            {
                "descr": "The y position.",
                "name": "number y"
            }
        ],
        "path": "love/body-getposition",
        "syntax": "x, y = Body:getPosition( )",
        "type": "love.physics"
    },
    "Body:getType": {
        "descr": "Returns the type of the body.",
        "name": "Body:getType",
        "params": [
            {
                "descr": "The body type.",
                "name": "BodyType type"
            }
        ],
        "path": "love/body-gettype",
        "syntax": "type = Body:getType( )",
        "type": "love.physics"
    },
    "Body:getUserData": {
        "descr": "Returns the Lua value associated with this Body.",
        "name": "Body:getUserData",
        "params": [
            {
                "descr": "The Lua value associated with the Body.",
                "name": "mixed value"
            }
        ],
        "path": "love/body-getuserdata",
        "syntax": "value = Body:getUserData( )",
        "type": "love.physics"
    },
    "Body:getWorld": {
        "descr": "Gets the World the body lives in.",
        "name": "Body:getWorld",
        "params": [
            {
                "descr": "The world the body lives in.",
                "name": "World world"
            }
        ],
        "path": "love/body-getworld",
        "syntax": "world = Body:getWorld( )",
        "type": "love.physics"
    },
    "Body:getWorldCenter": {
        "descr": "Get the center of mass position in world coordinates.",
        "name": "Body:getWorldCenter",
        "params": [
            {
                "descr": "The x coordinate of the center of mass.",
                "name": "number x"
            },
            {
                "descr": "The y coordinate of the center of mass.",
                "name": "number y"
            }
        ],
        "path": "love/body-getworldcenter",
        "syntax": "x, y = Body:getWorldCenter( )",
        "type": "love.physics"
    },
    "Body:getWorldPoint": {
        "descr": "Transform a point from local coordinates to world coordinates.",
        "name": "Body:getWorldPoint",
        "params": [
            {
                "descr": "The x position in local coordinates.",
                "name": "number localX"
            },
            {
                "descr": "The y position in local coordinates.",
                "name": "number localY"
            },
            {
                "descr": "The x position in world coordinates.",
                "name": "number worldX"
            },
            {
                "descr": "The y position in world coordinates.",
                "name": "number worldY"
            }
        ],
        "path": "love/body-getworldpoint",
        "syntax": "worldX, worldY = Body:getWorldPoint( localX, localY )",
        "type": "love.physics"
    },
    "Body:getWorldPoints": {
        "descr": "Transforms multiple points from local coordinates to world coordinates.",
        "name": "Body:getWorldPoints",
        "params": [
            {
                "descr": "The x position of the first point.",
                "name": "number x1"
            },
            {
                "descr": "The y position of the first point.",
                "name": "number y1"
            },
            {
                "descr": "The x position of the second point.",
                "name": "number x2"
            },
            {
                "descr": "The y position of the second point.",
                "name": "number y2"
            },
            {
                "descr": "The transformed x position of the first point.",
                "name": "number x1"
            },
            {
                "descr": "The transformed y position of the first point.",
                "name": "number y1"
            },
            {
                "descr": "The transformed x position of the second point.",
                "name": "number x2"
            },
            {
                "descr": "The transformed y position of the second point.",
                "name": "number y2"
            }
        ],
        "path": "love/body-getworldpoints",
        "syntax": "x1, y1, x2, y2, ... = Body:getWorldPoints( x1, y1, x2, y2, ... )",
        "type": "love.physics"
    },
    "Body:getWorldVector": {
        "descr": "Transform a vector from local coordinates to world coordinates.",
        "name": "Body:getWorldVector",
        "params": [
            {
                "descr": "The vector x component in local coordinates.",
                "name": "number localX"
            },
            {
                "descr": "The vector y component in local coordinates.",
                "name": "number localY"
            },
            {
                "descr": "The vector x component in world coordinates.",
                "name": "number worldX"
            },
            {
                "descr": "The vector y component in world coordinates.",
                "name": "number worldY"
            }
        ],
        "path": "love/body-getworldvector",
        "syntax": "worldX, worldY = Body:getWorldVector( localX, localY )",
        "type": "love.physics"
    },
    "Body:getX": {
        "descr": "Get the x position of the body in world coordinates.",
        "name": "Body:getX",
        "params": [
            {
                "descr": "The x position in world coordinates.",
                "name": "number x"
            }
        ],
        "path": "love/body-getx",
        "syntax": "x = Body:getX( )",
        "type": "love.physics"
    },
    "Body:getY": {
        "descr": "Get the y position of the body in world coordinates.",
        "name": "Body:getY",
        "params": [
            {
                "descr": "The y position in world coordinates.",
                "name": "number y"
            }
        ],
        "path": "love/body-gety",
        "syntax": "y = Body:getY( )",
        "type": "love.physics"
    },
    "Body:isActive": {
        "descr": "Returns whether the body is actively used in the simulation.",
        "name": "Body:isActive",
        "params": [
            {
                "descr": "True if the body is active or false if not.",
                "name": "boolean status"
            }
        ],
        "path": "love/body-isactive",
        "syntax": "status = Body:isActive( )",
        "type": "love.physics"
    },
    "Body:isAwake": {
        "descr": "Returns the sleep status of the body.",
        "name": "Body:isAwake",
        "params": [
            {
                "descr": "True if the body is awake or false if not.",
                "name": "boolean status"
            }
        ],
        "path": "love/body-isawake",
        "syntax": "status = Body:isAwake( )",
        "type": "love.physics"
    },
    "Body:isBullet": {
        "descr": "Get the bullet status of a body.",
        "name": "Body:isBullet",
        "params": [
            {
                "descr": "The bullet status of the body.",
                "name": "boolean status"
            }
        ],
        "path": "love/body-isbullet",
        "syntax": "status = Body:isBullet( )",
        "type": "love.physics"
    },
    "Body:isDestroyed": {
        "descr": "Gets whether the Body is destroyed. Destroyed bodies cannot be used.",
        "name": "Body:isDestroyed",
        "params": [
            {
                "descr": "Whether the Body is destroyed.",
                "name": "boolean destroyed"
            }
        ],
        "path": "love/body-isdestroyed",
        "syntax": "destroyed = Body:isDestroyed( )",
        "type": "love.physics"
    },
    "Body:isDynamic": {
        "descr": "Get the dynamic status of the body.",
        "name": "Body:isDynamic",
        "params": [
            {
                "descr": "The dynamic status of the body.",
                "name": "boolean status"
            }
        ],
        "path": "love/body-isdynamic",
        "syntax": "status = Body:isDynamic( )",
        "type": "love.physics"
    },
    "Body:isFixedRotation": {
        "descr": "Returns whether the body rotation is locked.",
        "name": "Body:isFixedRotation",
        "params": [
            {
                "descr": "True if the body's rotation is locked or false if not.",
                "name": "boolean fixed"
            }
        ],
        "path": "love/body-isfixedrotation",
        "syntax": "fixed = Body:isFixedRotation( )",
        "type": "love.physics"
    },
    "Body:isFrozen": {
        "descr": "Get the frozen status of the body.",
        "name": "Body:isFrozen",
        "params": [
            {
                "descr": "The frozen status of the body.",
                "name": "boolean status"
            }
        ],
        "path": "love/body-isfrozen",
        "syntax": "status = Body:isFrozen( )",
        "type": "love.physics"
    },
    "Body:isSleeping": {
        "descr": "Get the sleeping status of a body.",
        "name": "Body:isSleeping",
        "params": [
            {
                "descr": "The sleeping status of the body.",
                "name": "boolean status"
            }
        ],
        "path": "love/body-issleeping",
        "syntax": "status = Body:isSleeping( )",
        "type": "love.physics"
    },
    "Body:isSleepingAllowed": {
        "descr": "Returns the sleeping behaviour of the body.",
        "name": "Body:isSleepingAllowed",
        "params": [
            {
                "descr": "True if the body is allowed to sleep or false if not.",
                "name": "boolean allowed"
            }
        ],
        "path": "love/body-issleepingallowed",
        "syntax": "allowed = Body:isSleepingAllowed( )",
        "type": "love.physics"
    },
    "Body:isStatic": {
        "descr": "Get the static status of the body.",
        "name": "Body:isStatic",
        "params": [
            {
                "descr": "The static status of the body.",
                "name": "boolean status"
            }
        ],
        "path": "love/body-isstatic",
        "syntax": "status = Body:isStatic( )",
        "type": "love.physics"
    },
    "Body:putToSleep": {
        "descr": "Put the body to sleep.",
        "name": "Body:putToSleep",
        "params": [],
        "path": "love/body-puttosleep",
        "syntax": "Body:putToSleep( )",
        "type": "love.physics"
    },
    "Body:resetMassData": {
        "descr": "Resets the mass of the body by recalculating it from the mass properties of the fixtures.",
        "name": "Body:resetMassData",
        "params": [],
        "path": "love/body-resetmassdata",
        "syntax": "Body:resetMassData( )",
        "type": "love.physics"
    },
    "Body:setActive": {
        "descr": "Sets whether the body is active in the world.",
        "name": "Body:setActive",
        "params": [
            {
                "descr": "If the body is active or not.",
                "name": "boolean active"
            }
        ],
        "path": "love/body-setactive",
        "syntax": "Body:setActive( active )",
        "type": "love.physics"
    },
    "Body:setAllowSleeping": {
        "descr": "Set the sleep behaviour of a body.",
        "name": "Body:setAllowSleeping",
        "params": [
            {
                "descr": "Permission for the body to sleep.",
                "name": "boolean permission"
            }
        ],
        "path": "love/body-setallowsleeping",
        "syntax": "Body:setAllowSleeping( permission )",
        "type": "love.physics"
    },
    "Body:setAngle": {
        "descr": "Set the angle of the body.",
        "name": "Body:setAngle",
        "params": [
            {
                "descr": "The angle in radians.",
                "name": "number angle"
            }
        ],
        "path": "love/body-setangle",
        "syntax": "Body:setAngle( angle )",
        "type": "love.physics"
    },
    "Body:setAngularDamping": {
        "descr": "Sets the angular damping of a Body",
        "name": "Body:setAngularDamping",
        "params": [
            {
                "descr": "The new angular damping.",
                "name": "number damping"
            }
        ],
        "path": "love/body-setangulardamping",
        "syntax": "Body:setAngularDamping( damping )",
        "type": "love.physics"
    },
    "Body:setAngularVelocity": {
        "descr": "Sets the angular velocity of a Body.",
        "name": "Body:setAngularVelocity",
        "params": [
            {
                "descr": "The new angular velocity, in radians per second",
                "name": "number w"
            }
        ],
        "path": "love/body-setangularvelocity",
        "syntax": "Body:setAngularVelocity( w )",
        "type": "love.physics"
    },
    "Body:setAwake": {
        "descr": "Wakes the body up or puts it to sleep.",
        "name": "Body:setAwake",
        "params": [
            {
                "descr": "The body sleep status.",
                "name": "boolean awake"
            }
        ],
        "path": "love/body-setawake",
        "syntax": "Body:setAwake( awake )",
        "type": "love.physics"
    },
    "Body:setBullet": {
        "descr": "Set the bullet status of a body.",
        "name": "Body:setBullet",
        "params": [
            {
                "descr": "The bullet status of the body.",
                "name": "boolean status"
            }
        ],
        "path": "love/body-setbullet",
        "syntax": "Body:setBullet( status )",
        "type": "love.physics"
    },
    "Body:setFixedRotation": {
        "descr": "Set whether a body has fixed rotation.",
        "name": "Body:setFixedRotation",
        "params": [
            {
                "descr": "Whether the body should have fixed rotation.",
                "name": "boolean isFixed"
            }
        ],
        "path": "love/body-setfixedrotation",
        "syntax": "Body:setFixedRotation( isFixed )",
        "type": "love.physics"
    },
    "Body:setGravityScale": {
        "descr": "Sets a new gravity scale factor for the body.",
        "name": "Body:setGravityScale",
        "params": [
            {
                "descr": "The new gravity scale factor.",
                "name": "number scale"
            }
        ],
        "path": "love/body-setgravityscale",
        "syntax": "Body:setGravityScale( scale )",
        "type": "love.physics"
    },
    "Body:setInertia": {
        "descr": "Set the inertia of a body.",
        "name": "Body:setInertia",
        "params": [
            {
                "descr": "The new moment of inertia, in kilograms * pixel squared.",
                "name": "number inertia"
            }
        ],
        "path": "love/body-setinertia",
        "syntax": "Body:setInertia( inertia )",
        "type": "love.physics"
    },
    "Body:setLinearDamping": {
        "descr": "Sets the linear damping of a Body",
        "name": "Body:setLinearDamping",
        "params": [
            {
                "descr": "The new linear damping",
                "name": "number ld"
            }
        ],
        "path": "love/body-setlineardamping",
        "syntax": "Body:setLinearDamping( ld )",
        "type": "love.physics"
    },
    "Body:setLinearVelocity": {
        "descr": "Sets a new linear velocity for the Body.",
        "name": "Body:setLinearVelocity",
        "params": [
            {
                "descr": "The x-component of the velocity vector.",
                "name": "number x"
            },
            {
                "descr": "The y-component of the velocity vector.",
                "name": "number y"
            }
        ],
        "path": "love/body-setlinearvelocity",
        "syntax": "Body:setLinearVelocity( x, y )",
        "type": "love.physics"
    },
    "Body:setMass": {
        "descr": "Sets a new body mass.",
        "name": "Body:setMass",
        "params": [
            {
                "descr": "The mass, in kilograms.",
                "name": "number mass"
            }
        ],
        "path": "love/body-setmass",
        "syntax": "body:setMass( mass )",
        "type": "love.physics"
    },
    "Body:setMassData": {
        "descr": "Overrides the calculated mass data.",
        "name": "Body:setMassData",
        "params": [
            {
                "descr": "The x position of the center of mass.",
                "name": "number x"
            },
            {
                "descr": "The y position of the center of mass.",
                "name": "number y"
            },
            {
                "descr": "The mass of the body.",
                "name": "number mass"
            },
            {
                "descr": "The rotational inertia.",
                "name": "number inertia"
            }
        ],
        "path": "love/body-setmassdata",
        "syntax": "Body:setMassData( x, y, mass, inertia )",
        "type": "love.physics"
    },
    "Body:setMassFromShapes": {
        "descr": "Sets mass properties from attatched shapes.",
        "name": "Body:setMassFromShapes",
        "params": [],
        "path": "love/body-setmassfromshapes",
        "syntax": "Body:setMassFromShapes( )",
        "type": "love.physics"
    },
    "Body:setPosition": {
        "descr": "Set the position of the body.",
        "name": "Body:setPosition",
        "params": [
            {
                "descr": "The x position.",
                "name": "number x"
            },
            {
                "descr": "The y position.",
                "name": "number y"
            }
        ],
        "path": "love/body-setposition",
        "syntax": "Body:setPosition( x, y )",
        "type": "love.physics"
    },
    "Body:setSleepingAllowed": {
        "descr": "Sets the sleeping behaviour of the body. Should sleeping be allowed, a body at rest will automatically sleep. A sleeping body is not simulated unless it collided with an awake body. Be wary that one can end up with a situation like a floating sleeping body if the floor was removed.",
        "name": "Body:setSleepingAllowed",
        "params": [
            {
                "descr": "True if the body is allowed to sleep or false if not.",
                "name": "boolean allowed"
            }
        ],
        "path": "love/body-setsleepingallowed",
        "syntax": "Body:setSleepingAllowed( allowed )",
        "type": "love.physics"
    },
    "Body:setType": {
        "descr": "Sets a new body type.",
        "name": "Body:setType",
        "params": [
            {
                "descr": "The new type.",
                "name": "BodyType type"
            }
        ],
        "path": "love/body-settype",
        "syntax": "Body:setType( type )",
        "type": "love.physics"
    },
    "Body:setUserData": {
        "descr": "Associates a Lua value with the Body.",
        "name": "Body:setUserData",
        "params": [
            {
                "descr": "The Lua value to associate with the Body.",
                "name": "mixed value"
            }
        ],
        "path": "love/body-setuserdata",
        "syntax": "Body:setUserData( value )",
        "type": "love.physics"
    },
    "Body:setX": {
        "descr": "Set the x position of the body.",
        "name": "Body:setX",
        "params": [
            {
                "descr": "The x position.",
                "name": "number x"
            }
        ],
        "path": "love/body-setx",
        "syntax": "Body:setX( x )",
        "type": "love.physics"
    },
    "Body:setY": {
        "descr": "Set the y position of the body.",
        "name": "Body:setY",
        "params": [
            {
                "descr": "The y position.",
                "name": "number y"
            }
        ],
        "path": "love/body-sety",
        "syntax": "Body:setY( y )",
        "type": "love.physics"
    },
    "Body:wakeUp": {
        "descr": "Wake a sleeping body up.",
        "name": "Body:wakeUp",
        "params": [],
        "path": "love/body-wakeup",
        "syntax": "Body:wakeUp( )",
        "type": "love.physics"
    },
    "Canvas:clear": {
        "descr": "Clears the contents of a Canvas to a specific color.",
        "name": "Canvas:clear",
        "params": [],
        "path": "love/canvas-clear",
        "syntax": "Canvas:clear( )",
        "type": "love.graphics"
    },
    "Canvas:getDimensions": {
        "descr": "Gets the width and height of the Canvas.",
        "name": "Canvas:getDimensions",
        "params": [
            {
                "descr": "The width of the Canvas, in pixels.",
                "name": "number width"
            },
            {
                "descr": "The height of the Canvas, in pixels.",
                "name": "number height"
            }
        ],
        "path": "love/canvas-getdimensions",
        "syntax": "width, height = Canvas:getDimensions( )",
        "type": "love.graphics"
    },
    "Canvas:getFSAA": {
        "descr": "Gets the number of antialiasing samples used when drawing to the Canvas.",
        "name": "Canvas:getFSAA",
        "params": [
            {
                "descr": "The number of antialiasing samples used by the canvas when drawing to it.",
                "name": "number samples"
            }
        ],
        "path": "love/canvas-getfsaa",
        "syntax": "samples = Canvas:getFSAA( )",
        "type": "love.graphics"
    },
    "Canvas:getFilter": {
        "descr": "Gets the filter mode of the Canvas.",
        "name": "Canvas:getFilter",
        "params": [
            {
                "descr": "Filter mode used when minifying the canvas.",
                "name": "FilterMode min"
            },
            {
                "descr": "Filter mode used when magnifying the canvas.",
                "name": "FilterMode mag"
            }
        ],
        "path": "love/canvas-getfilter",
        "syntax": "min, mag = Canvas:getFilter( )",
        "type": "love.graphics"
    },
    "Canvas:getFormat": {
        "descr": "Gets the texture format of the Canvas.",
        "name": "Canvas:getFormat",
        "params": [
            {
                "descr": "The format of the Canvas.",
                "name": "CanvasFormat format"
            }
        ],
        "path": "love/canvas-getformat",
        "syntax": "format = Canvas:getFormat( )",
        "type": "love.graphics"
    },
    "Canvas:getHeight": {
        "descr": "Gets the height of the Canvas.",
        "name": "Canvas:getHeight",
        "params": [
            {
                "descr": "The height of the Canvas, in pixels.",
                "name": "number height"
            }
        ],
        "path": "love/canvas-getheight",
        "syntax": "height = Canvas:getHeight( )",
        "type": "love.graphics"
    },
    "Canvas:getImageData": {
        "descr": "Generates ImageData from the contents of the Canvas. Think of it as taking a screenshot of the hidden screen that is the Canvas.",
        "name": "Canvas:getImageData",
        "params": [
            {
                "descr": "The new ImageData made from the Canvas' image.",
                "name": "ImageData data"
            }
        ],
        "path": "love/canvas-getimagedata",
        "syntax": "data = Canvas:getImageData( )",
        "type": "love.graphics"
    },
    "Canvas:getMSAA": {
        "descr": "Gets the number of multisample antialiasing (MSAA) samples used when drawing to the Canvas.",
        "name": "Canvas:getMSAA",
        "params": [
            {
                "descr": "The number of multisample antialiasing samples used by the canvas when drawing to it.",
                "name": "number samples"
            }
        ],
        "path": "love/canvas-getmsaa",
        "syntax": "samples = Canvas:getMSAA( )",
        "type": "love.graphics"
    },
    "Canvas:getPixel": {
        "descr": "Gets the pixel at the specified position from a Canvas.",
        "name": "Canvas:getPixel",
        "params": [
            {
                "descr": "The position of the pixel on the x-axis.",
                "name": "number x"
            },
            {
                "descr": "The position of the pixel on the y-axis.",
                "name": "number y"
            },
            {
                "descr": "The red component (0-255).",
                "name": "number r"
            },
            {
                "descr": "The green component (0-255).",
                "name": "number g"
            },
            {
                "descr": "The blue component (0-255).",
                "name": "number b"
            },
            {
                "descr": "The alpha component (0-255).",
                "name": "number a"
            }
        ],
        "path": "love/canvas-getpixel",
        "syntax": "r, g, b, a = Canvas:getPixel( x, y )",
        "type": "love.graphics"
    },
    "Canvas:getWidth": {
        "descr": "Gets the width of the Canvas.",
        "name": "Canvas:getWidth",
        "params": [
            {
                "descr": "The width of the Canvas, in pixels.",
                "name": "number width"
            }
        ],
        "path": "love/canvas-getwidth",
        "syntax": "width = Canvas:getWidth( )",
        "type": "love.graphics"
    },
    "Canvas:getWrap": {
        "descr": "Gets the wrapping properties of a Canvas.",
        "name": "Canvas:getWrap",
        "params": [
            {
                "descr": "Horizontal wrapping mode of the Canvas.",
                "name": "WrapMode horiz"
            },
            {
                "descr": "Vertical wrapping mode of the Canvas.",
                "name": "WrapMode vert"
            }
        ],
        "path": "love/canvas-getwrap",
        "syntax": "horiz, vert = Canvas:getWrap( )",
        "type": "love.graphics"
    },
    "Canvas:newImageData": {
        "descr": "Generates ImageData from the contents of the Canvas.",
        "name": "Canvas:newImageData",
        "params": [
            {
                "descr": "The new ImageData made from the Canvas' contents.",
                "name": "ImageData data"
            }
        ],
        "path": "love/canvas-newimagedata",
        "syntax": "data = Canvas:newImageData( )",
        "type": "love.graphics"
    },
    "Canvas:renderTo": {
        "descr": "Render to the Canvas using a function.",
        "name": "Canvas:renderTo",
        "params": [
            {
                "descr": "A function performing drawing operations.",
                "name": "function func"
            }
        ],
        "path": "love/canvas-renderto",
        "syntax": "Canvas:renderTo( func )",
        "type": "love.graphics"
    },
    "Canvas:setFilter": {
        "descr": "Sets the filter mode of the Canvas.",
        "name": "Canvas:setFilter",
        "params": [
            {
                "descr": "Filter mode to use when minifying the canvas.",
                "name": "FilterMode min"
            },
            {
                "descr": "Filter mode to use when magnifying the canvas.",
                "name": "FilterMode mag"
            }
        ],
        "path": "love/canvas-setfilter",
        "syntax": "Canvas:setFilter( min, mag )",
        "type": "love.graphics"
    },
    "Canvas:setWrap": {
        "descr": "Sets the wrapping properties of a Canvas.",
        "name": "Canvas:setWrap",
        "params": [
            {
                "descr": "Horizontal wrapping mode of the Canvas.",
                "name": "WrapMode horiz"
            },
            {
                "descr": "Vertical wrapping mode of the Canvas.",
                "name": "WrapMode vert"
            }
        ],
        "path": "love/canvas-setwrap",
        "syntax": "Canvas:setWrap( horiz, vert )",
        "type": "love.graphics"
    },
    "ChainShape:getChildEdge": {
        "descr": "Returns a child of the shape as an EdgeShape.",
        "name": "ChainShape:getChildEdge",
        "params": [
            {
                "descr": "The index of the child.",
                "name": "number index"
            },
            {
                "descr": "The child as an EdgeShape.",
                "name": "EdgeShape shape"
            }
        ],
        "path": "love/chainshape-getchildedge",
        "syntax": "shape = ChainShape:getChildEdge( index )",
        "type": "love.physics"
    },
    "ChainShape:getNextVertex": {
        "descr": "Gets the vertex that establishes a connection to the next shape.",
        "name": "ChainShape:getNextVertex",
        "params": [
            {
                "descr": "The x-component of the vertex, or nil if ChainShape:setNextVertex hasn't been called.",
                "name": "number x (nil)"
            },
            {
                "descr": "The y-component of the vertex, or nil if ChainShape:setNextVertex hasn't been called.",
                "name": "number y (nil)"
            }
        ],
        "path": "love/chainshape-getnextvertex",
        "syntax": "x, y = ChainShape:getNextVertex( )",
        "type": "love.physics"
    },
    "ChainShape:getPoint": {
        "descr": "Returns a point of the shape.",
        "name": "ChainShape:getPoint",
        "params": [
            {
                "descr": "The index of the point to return.",
                "name": "number index"
            },
            {
                "descr": "The x-coordinate of the point.",
                "name": "number x"
            },
            {
                "descr": "The y-coordinate of the point.",
                "name": "number y"
            }
        ],
        "path": "love/chainshape-getpoint",
        "syntax": "x, y = ChainShape:getPoint( index )",
        "type": "love.physics"
    },
    "ChainShape:getPoints": {
        "descr": "Returns all points of the shape.",
        "name": "ChainShape:getPoints",
        "params": [
            {
                "descr": "The x-coordinate of the first point.",
                "name": "number x1"
            },
            {
                "descr": "The y-coordinate of the first point.",
                "name": "number y1"
            },
            {
                "descr": "The x-coordinate of the second point.",
                "name": "number x2"
            },
            {
                "descr": "The y-coordinate of the second point.",
                "name": "number y2"
            }
        ],
        "path": "love/chainshape-getpoints",
        "syntax": "x1, y1, x2, y2, ... = ChainShape:getPoints( )",
        "type": "love.physics"
    },
    "ChainShape:getPreviousVertex": {
        "descr": "Gets the vertex that establishes a connection to the previous shape.",
        "name": "ChainShape:getPreviousVertex",
        "params": [
            {
                "descr": "The x-component of the vertex, or nil if ChainShape:setPreviousVertex hasn't been called.",
                "name": "number x (nil)"
            },
            {
                "descr": "The y-component of the vertex, or nil if ChainShape:setPreviousVertex hasn't been called.",
                "name": "number y (nil)"
            }
        ],
        "path": "love/chainshape-getpreviousvertex",
        "syntax": "x, y = ChainShape:getPreviousVertex( )",
        "type": "love.physics"
    },
    "ChainShape:getVertexCount": {
        "descr": "Returns the number of vertices the shape has.",
        "name": "ChainShape:getVertexCount",
        "params": [
            {
                "descr": "The number of vertices.",
                "name": "number count"
            }
        ],
        "path": "love/chainshape-getvertexcount",
        "syntax": "count = ChainShape:getVertexCount( )",
        "type": "love.physics"
    },
    "ChainShape:setNextVertex": {
        "descr": "Sets a vertex that establishes a connection to the next shape.",
        "name": "ChainShape:setNextVertex",
        "params": [
            {
                "descr": "The x-component of the vertex.",
                "name": "number x"
            },
            {
                "descr": "The y-component of the vertex.",
                "name": "number y"
            }
        ],
        "path": "love/chainshape-setnextvertex",
        "syntax": "ChainShape:setNextVertex( x, y )",
        "type": "love.physics"
    },
    "ChainShape:setPrevVertex": {
        "descr": "Sets a vertex that establishes a connection to the previous shape.",
        "name": "ChainShape:setPrevVertex",
        "params": [
            {
                "descr": "The x-component of the vertex.",
                "name": "number x"
            },
            {
                "descr": "The y-component of the vertex.",
                "name": "number y"
            }
        ],
        "path": "love/chainshape-setprevvertex",
        "syntax": "ChainShape:setPrevVertex( x, y )",
        "type": "love.physics"
    },
    "ChainShape:setPreviousVertex": {
        "descr": "Sets a vertex that establishes a connection to the previous shape.",
        "name": "ChainShape:setPreviousVertex",
        "params": [
            {
                "descr": "The x-component of the vertex.",
                "name": "number x"
            },
            {
                "descr": "The y-component of the vertex.",
                "name": "number y"
            }
        ],
        "path": "love/chainshape-setpreviousvertex",
        "syntax": "ChainShape:setPreviousVertex( x, y )",
        "type": "love.physics"
    },
    "Channel:clear": {
        "descr": "Clears all the messages in the Channel queue.",
        "name": "Channel:clear",
        "params": [],
        "path": "love/channel-clear",
        "syntax": "Channel:clear( )",
        "type": "love.thread"
    },
    "Channel:count": {
        "descr": "Retrieves the number of messages in the thread Channel queue.",
        "name": "Channel:count",
        "params": [
            {
                "descr": "The number of messages in the queue.",
                "name": "number count"
            }
        ],
        "path": "love/channel-count",
        "syntax": "value = Channel:getCount( )",
        "type": "love.thread"
    },
    "Channel:demand": {
        "descr": "Retrieves the value of a Channel message and removes it from the message queue.",
        "name": "Channel:demand",
        "params": [
            {
                "descr": "The contents of the message.",
                "name": "value value"
            }
        ],
        "path": "love/channel-demand",
        "syntax": "value = Channel:demand( )",
        "type": "love.thread"
    },
    "Channel:getCount": {
        "descr": "Retrieves the number of messages in the thread Channel queue.",
        "name": "Channel:getCount",
        "params": [
            {
                "descr": "The number of messages in the queue.",
                "name": "number count"
            }
        ],
        "path": "love/channel-getcount",
        "syntax": "value = Channel:getCount( )",
        "type": "love.thread"
    },
    "Channel:peek": {
        "descr": "Retrieves the value of a Channel message, but leaves it in the queue.",
        "name": "Channel:peek",
        "params": [
            {
                "descr": "The contents of the message.",
                "name": "value value"
            }
        ],
        "path": "love/channel-peek",
        "syntax": "value = Channel:peek( )",
        "type": "love.thread"
    },
    "Channel:performAtomic": {
        "descr": "Executes the specified function atomically with respect to this Channel.",
        "name": "Channel:performAtomic",
        "params": [
            {
                "descr": "The function to call, the form of function(channel, arg1, arg2, ...) end. ",
                "name": "function func"
            },
            {
                "descr": "Additional arguments that the given function will receive when it is called.",
                "name": "any arg1"
            },
            {
                "descr": "Additional arguments that the given function will receive when it is called.",
                "name": "any ..."
            },
            {
                "descr": "The first return value of the given function (if any.)",
                "name": "any ret1"
            },
            {
                "descr": "Any other return values.",
                "name": "any ..."
            }
        ],
        "path": "love/channel-performatomic",
        "syntax": "ret1, ... = Channel:performAtomic( func, arg1, ... )",
        "type": "love.thread"
    },
    "Channel:pop": {
        "descr": "Retrieves the value of a Channel message and removes it from the message queue.",
        "name": "Channel:pop",
        "params": [
            {
                "descr": "The contents of the message.",
                "name": "value value"
            }
        ],
        "path": "love/channel-pop",
        "syntax": "value = Channel:pop( )",
        "type": "love.thread"
    },
    "Channel:push": {
        "descr": "Send a message to the thread Channel.",
        "name": "Channel:push",
        "params": [
            {
                "descr": "The contents of the message.",
                "name": "value value"
            }
        ],
        "path": "love/channel-push",
        "syntax": "Channel:push( value )",
        "type": "love.thread"
    },
    "Channel:supply": {
        "descr": "Send a message to the thread Channel and wait for a thread to accept it.",
        "name": "Channel:supply",
        "params": [
            {
                "descr": "The contents of the message.",
                "name": "value value"
            }
        ],
        "path": "love/channel-supply",
        "syntax": "Channel:supply( value )",
        "type": "love.thread"
    },
    "CircleShape:getLocalCenter": {
        "descr": "Get the center of the circle in local coordinates.",
        "name": "CircleShape:getLocalCenter",
        "params": [
            {
                "descr": "The x position of the circle in local coordinates.",
                "name": "number lx"
            },
            {
                "descr": "The y position of the circle in local coordinates.",
                "name": "number ly"
            }
        ],
        "path": "love/circleshape-getlocalcenter",
        "syntax": "lx, ly = CircleShape:getLocalCenter( )",
        "type": "love.physics"
    },
    "CircleShape:getPoint": {
        "descr": "Gets the center point of the circle shape.",
        "name": "CircleShape:getPoint",
        "params": [
            {
                "descr": "The x-component of the center point of the circle.",
                "name": "number x"
            },
            {
                "descr": "The y-component of the center point of the circle.",
                "name": "number y"
            }
        ],
        "path": "love/circleshape-getpoint",
        "syntax": "x, y = CircleShape:getPoint( )",
        "type": "love.physics"
    },
    "CircleShape:getRadius": {
        "descr": "Gets the radius of the circle shape.",
        "name": "CircleShape:getRadius",
        "params": [
            {
                "descr": "The radius of the circle",
                "name": "number radius"
            }
        ],
        "path": "love/circleshape-getradius",
        "syntax": "radius = CircleShape:getRadius( )",
        "type": "love.physics"
    },
    "CircleShape:getWorldCenter": {
        "descr": "Get the center of the circle in world coordinates.",
        "name": "CircleShape:getWorldCenter",
        "params": [
            {
                "descr": "The x position of the circle in world coordinates.",
                "name": "number wx"
            },
            {
                "descr": "The y position of the circle in world coordinates.",
                "name": "number wy"
            }
        ],
        "path": "love/circleshape-getworldcenter",
        "syntax": "wx, wy = CircleShape:getWorldCenter( )",
        "type": "love.physics"
    },
    "CircleShape:setPoint": {
        "descr": "Sets the location of the center of the circle shape.",
        "name": "CircleShape:setPoint",
        "params": [
            {
                "descr": "The x-component of the new center point of the circle.",
                "name": "number x"
            },
            {
                "descr": "The y-component of the new center point of the circle.",
                "name": "number y"
            }
        ],
        "path": "love/circleshape-setpoint",
        "syntax": "x, y = CircleShape:setPoint( x, y )",
        "type": "love.physics"
    },
    "CircleShape:setRadius": {
        "descr": "Sets the radius of the circle.",
        "name": "CircleShape:setRadius",
        "params": [
            {
                "descr": "The radius of the circle",
                "name": "number radius"
            }
        ],
        "path": "love/circleshape-setradius",
        "syntax": "CircleShape:setRadius( radius )",
        "type": "love.physics"
    },
    "CompressedData:getFormat": {
        "descr": "Gets the compression format of the CompressedData.",
        "name": "CompressedData:getFormat",
        "params": [
            {
                "descr": "The format of the CompressedData.",
                "name": "CompressedDataFormat format"
            }
        ],
        "path": "love/compresseddata-getformat",
        "syntax": "format = CompressedData:getFormat( )",
        "type": "love.math"
    },
    "CompressedImageData:getDimensions": {
        "descr": "Gets the width and height of the CompressedImageData.",
        "name": "CompressedImageData:getDimensions",
        "params": [
            {
                "descr": "The width of the CompressedImageData.",
                "name": "number width"
            },
            {
                "descr": "The height of the CompressedImageData.",
                "name": "number height"
            }
        ],
        "path": "love/compressedimagedata-getdimensions",
        "syntax": "width, height = CompressedImageData:getDimensions( )",
        "type": "love.image"
    },
    "CompressedImageData:getFormat": {
        "descr": "Gets the format of the CompressedImageData.",
        "name": "CompressedImageData:getFormat",
        "params": [
            {
                "descr": "The format of the CompressedImageData.",
                "name": "CompressedImageFormat format"
            }
        ],
        "path": "love/compressedimagedata-getformat",
        "syntax": "format = CompressedImageData:getFormat( )",
        "type": "love.image"
    },
    "CompressedImageData:getHeight": {
        "descr": "Gets the height of the CompressedImageData.",
        "name": "CompressedImageData:getHeight",
        "params": [
            {
                "descr": "The height of the CompressedImageData.",
                "name": "number height"
            }
        ],
        "path": "love/compressedimagedata-getheight",
        "syntax": "height = CompressedImageData:getHeight( )",
        "type": "love.image"
    },
    "CompressedImageData:getMipmapCount": {
        "descr": "Gets the number of mipmap levels in the CompressedImageData. The base mipmap level (original image) is included in the count.",
        "name": "CompressedImageData:getMipmapCount",
        "params": [
            {
                "descr": "The number of mipmap levels stored in the CompressedImageData.",
                "name": "number mipmaps"
            }
        ],
        "path": "love/compressedimagedata-getmipmapcount",
        "syntax": "mipmaps = CompressedImageData:getMipmapCount( )",
        "type": "love.image"
    },
    "CompressedImageData:getWidth": {
        "descr": "Gets the width of the CompressedImageData.",
        "name": "CompressedImageData:getWidth",
        "params": [
            {
                "descr": "The width of the CompressedImageData.",
                "name": "number width"
            }
        ],
        "path": "love/compressedimagedata-getwidth",
        "syntax": "width = CompressedImageData:getWidth( )",
        "type": "love.image"
    },
    "Contact:getChildren": {
        "descr": "Gets the child indices of the shapes of the two colliding fixtures. For ChainShapes, an index of 1 is the first edge in the chain.",
        "name": "Contact:getChildren",
        "params": [
            {
                "descr": "The child index of the first fixture's shape.",
                "name": "number indexA"
            },
            {
                "descr": "The child index of the second fixture's shape.",
                "name": "number indexB"
            }
        ],
        "path": "love/contact-getchildren",
        "syntax": "indexA, indexB = Contact:getChildren( )",
        "type": "love.physics"
    },
    "Contact:getFixtures": {
        "descr": "Gets the two Fixtures that hold the shapes that are in contact.",
        "name": "Contact:getFixtures",
        "params": [
            {
                "descr": "The first Fixture.",
                "name": "Fixture fixtureA"
            },
            {
                "descr": "The second Fixture.",
                "name": "Fixture fixtureB"
            }
        ],
        "path": "love/contact-getfixtures",
        "syntax": "fixtureA, fixtureB = Contact:getFixtures( )",
        "type": "love.physics"
    },
    "Contact:getFriction": {
        "descr": "Get the friction between two shapes that are in contact.",
        "name": "Contact:getFriction",
        "params": [
            {
                "descr": "The friction of the contact.",
                "name": "number friction"
            }
        ],
        "path": "love/contact-getfriction",
        "syntax": "friction = Contact:getFriction( )",
        "type": "love.physics"
    },
    "Contact:getNormal": {
        "descr": "Get the normal vector between two shapes that are in contact.",
        "name": "Contact:getNormal",
        "params": [
            {
                "descr": "The x component of the normal vector.",
                "name": "number nx"
            },
            {
                "descr": "The y component of the normal vector.",
                "name": "number ny"
            }
        ],
        "path": "love/contact-getnormal",
        "syntax": "nx, ny = Contact:getNormal( )",
        "type": "love.physics"
    },
    "Contact:getPosition": {
        "descr": "Get the location of the contact point between two shapes.",
        "name": "Contact:getPosition",
        "params": [
            {
                "descr": "The x coordinate of the contact point.",
                "name": "number cx"
            },
            {
                "descr": "The y coordinate of the contact point.",
                "name": "number cy"
            }
        ],
        "path": "love/contact-getposition",
        "syntax": "cx, cy = Contact:getPosition( )",
        "type": "love.physics"
    },
    "Contact:getPositions": {
        "descr": "Returns the contact points of the two colliding fixtures. There can be one or two points.",
        "name": "Contact:getPositions",
        "params": [
            {
                "descr": "The x coordinate of the first contact point.",
                "name": "number x1"
            },
            {
                "descr": "The y coordinate of the first contact point.",
                "name": "number y1"
            },
            {
                "descr": "The x coordinate of the second contact point.",
                "name": "number x2"
            },
            {
                "descr": "The y coordinate of the second contact point.",
                "name": "number y2"
            }
        ],
        "path": "love/contact-getpositions",
        "syntax": "x1, y1, x2, y2 = Contact:getPositions( )",
        "type": "love.physics"
    },
    "Contact:getRestitution": {
        "descr": "Get the restitution between two shapes that are in contact.",
        "name": "Contact:getRestitution",
        "params": [
            {
                "descr": "The restitution between the two shapes.",
                "name": "number restitution"
            }
        ],
        "path": "love/contact-getrestitution",
        "syntax": "restitution = Contact:getRestitution( )",
        "type": "love.physics"
    },
    "Contact:getSeparation": {
        "descr": "Get the separation between two shapes that are in contact.",
        "name": "Contact:getSeparation",
        "params": [
            {
                "descr": "The separation between the two shapes.",
                "name": "number distance"
            }
        ],
        "path": "love/contact-getseparation",
        "syntax": "distance = Contact:getSeparation( )",
        "type": "love.physics"
    },
    "Contact:getVelocity": {
        "descr": "Get the linear impact velocity of a contact.",
        "name": "Contact:getVelocity",
        "params": [
            {
                "descr": "The x component of the velocity vector.",
                "name": "number vx"
            },
            {
                "descr": "The y component of the velocity vector.",
                "name": "number vy"
            }
        ],
        "path": "love/contact-getvelocity",
        "syntax": "vx, vy = Contact:getVelocity( )",
        "type": "love.physics"
    },
    "Contact:isEnabled": {
        "descr": "Returns whether the contact is enabled. The collision will be ignored if a contact gets disabled in the post solve callback.",
        "name": "Contact:isEnabled",
        "params": [
            {
                "descr": "True if enabled, false otherwise.",
                "name": "boolean enabled"
            }
        ],
        "path": "love/contact-isenabled",
        "syntax": "enabled = Contact:isEnabled( )",
        "type": "love.physics"
    },
    "Contact:isTouching": {
        "descr": "Returns whether the two colliding fixtures are touching each other.",
        "name": "Contact:isTouching",
        "params": [
            {
                "descr": "True if they touch or false if not.",
                "name": "boolean touching"
            }
        ],
        "path": "love/contact-istouching",
        "syntax": "touching = Contact:isTouching( )",
        "type": "love.physics"
    },
    "Contact:resetFriction": {
        "descr": "Resets the contact friction to the mixture value of both fixtures.",
        "name": "Contact:resetFriction",
        "params": [],
        "path": "love/contact-resetfriction",
        "syntax": "Contact:resetFriction( )",
        "type": "love.physics"
    },
    "Contact:resetRestitution": {
        "descr": "Resets the contact restitution to the mixture value of both fixtures.",
        "name": "Contact:resetRestitution",
        "params": [],
        "path": "love/contact-resetrestitution",
        "syntax": "Contact:resetRestitution( )",
        "type": "love.physics"
    },
    "Contact:setEnabled": {
        "descr": "Enables or disables the contact.",
        "name": "Contact:setEnabled",
        "params": [
            {
                "descr": "True to enable or false to disable.",
                "name": "boolean enabled"
            }
        ],
        "path": "love/contact-setenabled",
        "syntax": "Contact:setEnabled( enabled )",
        "type": "love.physics"
    },
    "Contact:setFriction": {
        "descr": "Sets the contact friction.",
        "name": "Contact:setFriction",
        "params": [
            {
                "descr": "The contact friction.",
                "name": "number friction"
            }
        ],
        "path": "love/contact-setfriction",
        "syntax": "Contact:setFriction( friction )",
        "type": "love.physics"
    },
    "Contact:setRestitution": {
        "descr": "Sets the contact restitution.",
        "name": "Contact:setRestitution",
        "params": [
            {
                "descr": "The contact restitution.",
                "name": "number restitution"
            }
        ],
        "path": "love/contact-setrestitution",
        "syntax": "Contact:setRestitution( restitution )",
        "type": "love.physics"
    },
    "Cursor:getType": {
        "descr": "Gets the type of the Cursor.",
        "name": "Cursor:getType",
        "params": [
            {
                "descr": "The type of the Cursor.",
                "name": "CursorType ctype"
            }
        ],
        "path": "love/cursor-gettype",
        "syntax": "ctype = Cursor:getType( )",
        "type": "love.mouse"
    },
    "Data:getPointer": {
        "descr": "Gets a pointer to the Data. Can be used with libraries such as LuaJIT's FFI.",
        "name": "Data:getPointer",
        "params": [
            {
                "descr": "A raw pointer to the Data.",
                "name": "light userdata pointer"
            }
        ],
        "path": "love/data-getpointer",
        "syntax": "pointer = Data:getPointer( )",
        "type": "love"
    },
    "Data:getSize": {
        "descr": "Gets the Data's size in bytes.",
        "name": "Data:getSize",
        "params": [
            {
                "descr": "The size of the Data in bytes.",
                "name": "number size"
            }
        ],
        "path": "love/data-getsize",
        "syntax": "size = Data:getSize( )",
        "type": "love"
    },
    "Data:getString": {
        "descr": "Gets the full Data as a string.",
        "name": "Data:getString",
        "params": [
            {
                "descr": "The raw data.",
                "name": "string data"
            }
        ],
        "path": "love/data-getstring",
        "syntax": "data = Data:getString( )",
        "type": "love"
    },
    "Decoder:getBitDepth": {
        "descr": "Returns the number of bits per sample.",
        "name": "Decoder:getBitDepth",
        "params": [
            {
                "descr": "Either 8, or 16.",
                "name": "number bitDepth"
            }
        ],
        "path": "love/decoder-getbitdepth",
        "syntax": "bitDepth = Decoder:getBitDepth( )",
        "type": "love.sound"
    },
    "Decoder:getBits": {
        "descr": "Returns the number of bits per sample.",
        "name": "Decoder:getBits",
        "params": [
            {
                "descr": "Either 8, or 16.",
                "name": "number bitSize"
            }
        ],
        "path": "love/decoder-getbits",
        "syntax": "bitSize = Decoder:getBits( )",
        "type": "love.sound"
    },
    "Decoder:getChannels": {
        "descr": "Returns the number of channels in the stream.",
        "name": "Decoder:getChannels",
        "params": [
            {
                "descr": "1 for mono, 2 for stereo.",
                "name": "number channels"
            }
        ],
        "path": "love/decoder-getchannels",
        "syntax": "channels = Decoder:getChannels( )",
        "type": "love.sound"
    },
    "Decoder:getDuration": {
        "descr": "Gets the duration of the sound file. It may not always be sample-accurate, and it may return -1 if the duration cannot be determined at all.",
        "name": "Decoder:getDuration",
        "params": [
            {
                "descr": "The duration of the sound file in seconds, or -1 if it cannot be determined.",
                "name": "number duration"
            }
        ],
        "path": "love/decoder-getduration",
        "syntax": "duration = Decoder:getDuration( )",
        "type": "love.sound"
    },
    "Decoder:getSampleRate": {
        "descr": "Returns the sample rate of the Decoder.",
        "name": "Decoder:getSampleRate",
        "params": [
            {
                "descr": "Number of samples per second.",
                "name": "number rate"
            }
        ],
        "path": "love/decoder-getsamplerate",
        "syntax": "rate = Decoder:getSampleRate( )",
        "type": "love.sound"
    },
    "DistanceJoint:getDamping": {
        "descr": "Gets the damping ratio.",
        "name": "DistanceJoint:getDamping",
        "params": [
            {
                "descr": "The damping ratio.",
                "name": "number ratio"
            }
        ],
        "path": "love/distancejoint-getdamping",
        "syntax": "ratio = DistanceJoint:getDamping( )",
        "type": "love.physics"
    },
    "DistanceJoint:getDampingRatio": {
        "descr": "Gets the damping ratio.",
        "name": "DistanceJoint:getDampingRatio",
        "params": [
            {
                "descr": "The damping ratio.",
                "name": "number ratio"
            }
        ],
        "path": "love/distancejoint-getdampingratio",
        "syntax": "ratio = DistanceJoint:getDampingRatio( )",
        "type": "love.physics"
    },
    "DistanceJoint:getFrequency": {
        "descr": "Gets the response speed.",
        "name": "DistanceJoint:getFrequency",
        "params": [
            {
                "descr": "The response speed.",
                "name": "number Hz"
            }
        ],
        "path": "love/distancejoint-getfrequency",
        "syntax": "Hz = DistanceJoint:getFrequency( )",
        "type": "love.physics"
    },
    "DistanceJoint:getLength": {
        "descr": "Gets the equilibrium distance between the two Bodies.",
        "name": "DistanceJoint:getLength",
        "params": [
            {
                "descr": "The length between the two Bodies.",
                "name": "number l"
            }
        ],
        "path": "love/distancejoint-getlength",
        "syntax": "l = DistanceJoint:getLength( )",
        "type": "love.physics"
    },
    "DistanceJoint:setDamping": {
        "descr": "Sets the damping ratio.",
        "name": "DistanceJoint:setDamping",
        "params": [
            {
                "descr": "The damping ratio.",
                "name": "number ratio"
            }
        ],
        "path": "love/distancejoint-setdamping",
        "syntax": "DistanceJoint:setDamping( ratio )",
        "type": "love.physics"
    },
    "DistanceJoint:setDampingRatio": {
        "descr": "Sets the damping ratio.",
        "name": "DistanceJoint:setDampingRatio",
        "params": [
            {
                "descr": "The damping ratio.",
                "name": "number ratio"
            }
        ],
        "path": "love/distancejoint-setdampingratio",
        "syntax": "DistanceJoint:setDampingRatio( ratio )",
        "type": "love.physics"
    },
    "DistanceJoint:setFrequency": {
        "descr": "Sets the response speed.",
        "name": "DistanceJoint:setFrequency",
        "params": [
            {
                "descr": "The response speed.",
                "name": "number Hz"
            }
        ],
        "path": "love/distancejoint-setfrequency",
        "syntax": "DistanceJoint:setFrequency( Hz )",
        "type": "love.physics"
    },
    "DistanceJoint:setLength": {
        "descr": "Sets the equilibrium distance between the two Bodies.",
        "name": "DistanceJoint:setLength",
        "params": [
            {
                "descr": "The length between the two Bodies.",
                "name": "number l"
            }
        ],
        "path": "love/distancejoint-setlength",
        "syntax": "DistanceJoint:setLength( l )",
        "type": "love.physics"
    },
    "EdgeShape:getNextVertex": {
        "descr": "Gets the vertex that establishes a connection to the next shape.",
        "name": "EdgeShape:getNextVertex",
        "params": [
            {
                "descr": "The x-component of the vertex, or nil if EdgeShape:setNextVertex hasn't been called.",
                "name": "number x (nil)"
            },
            {
                "descr": "The y-component of the vertex, or nil if EdgeShape:setNextVertex hasn't been called.",
                "name": "number y (nil)"
            }
        ],
        "path": "love/edgeshape-getnextvertex",
        "syntax": "x, y = EdgeShape:getNextVertex( )",
        "type": "love.physics"
    },
    "EdgeShape:getPoints": {
        "descr": "Returns the local coordinates of the edge points.",
        "name": "EdgeShape:getPoints",
        "params": [
            {
                "descr": "The x-component of the first vertex.",
                "name": "number x1"
            },
            {
                "descr": "The y-component of the first vertex.",
                "name": "number y1"
            },
            {
                "descr": "The x-component of the second vertex.",
                "name": "number x2"
            },
            {
                "descr": "The y-component of the second vertex.",
                "name": "number y2"
            }
        ],
        "path": "love/edgeshape-getpoints",
        "syntax": "x1, y1, x2, y2 = EdgeShape:getPoints( )",
        "type": "love.physics"
    },
    "EdgeShape:getPreviousVertex": {
        "descr": "Gets the vertex that establishes a connection to the previous shape.",
        "name": "EdgeShape:getPreviousVertex",
        "params": [
            {
                "descr": "The x-component of the vertex, or nil if EdgeShape:setPreviousVertex hasn't been called.",
                "name": "number x (nil)"
            },
            {
                "descr": "The y-component of the vertex, or nil if EdgeShape:setPreviousVertex hasn't been called.",
                "name": "number y (nil)"
            }
        ],
        "path": "love/edgeshape-getpreviousvertex",
        "syntax": "x, y = EdgeShape:getPreviousVertex( )",
        "type": "love.physics"
    },
    "EdgeShape:setNextVertex": {
        "descr": "Sets a vertex that establishes a connection to the next shape.",
        "name": "EdgeShape:setNextVertex",
        "params": [
            {
                "descr": "The x-component of the vertex.",
                "name": "number x"
            },
            {
                "descr": "The y-component of the vertex.",
                "name": "number y"
            }
        ],
        "path": "love/edgeshape-setnextvertex",
        "syntax": "EdgeShape:setNextVertex( x, y )",
        "type": "love.physics"
    },
    "EdgeShape:setPreviousVertex": {
        "descr": "Sets a vertex that establishes a connection to the previous shape.",
        "name": "EdgeShape:setPreviousVertex",
        "params": [
            {
                "descr": "The x-component of the vertex.",
                "name": "number x"
            },
            {
                "descr": "The y-component of the vertex.",
                "name": "number y"
            }
        ],
        "path": "love/edgeshape-setpreviousvertex",
        "syntax": "EdgeShape:setPreviousVertex( x, y )",
        "type": "love.physics"
    },
    "File):close": {
        "descr": "Closes a File.",
        "name": "File):close",
        "params": [
            {
                "descr": "Whether closing was successful.",
                "name": "boolean success"
            }
        ],
        "path": "love/(file)-close",
        "syntax": "success = File:close( )",
        "type": "love.filesystem"
    },
    "File):eof": {
        "descr": "If the end-of-file has been reached",
        "name": "File):eof",
        "params": [
            {
                "descr": "Whether EOF has been reached",
                "name": "boolean eof"
            }
        ],
        "path": "love/(file)-eof",
        "syntax": "eof = File:eof( )",
        "type": "love.filesystem"
    },
    "File):flush": {
        "descr": "Flushes any buffered written data in the file to the disk.",
        "name": "File):flush",
        "params": [
            {
                "descr": "Whether the file successfully flushed any buffered data to the disk.",
                "name": "boolean success"
            },
            {
                "descr": "The error string, if an error occurred and the file could not be flushed.",
                "name": "string err (nil)"
            }
        ],
        "path": "love/(file)-flush",
        "syntax": "success, err = File:flush( )",
        "type": "love.filesystem"
    },
    "File):getBuffer": {
        "descr": "Gets the buffer mode of a file.",
        "name": "File):getBuffer",
        "params": [
            {
                "descr": "The current buffer mode of the file.",
                "name": "BufferMode mode"
            },
            {
                "descr": "The maximum size in bytes of the file's buffer.",
                "name": "number size"
            }
        ],
        "path": "love/(file)-getbuffer",
        "syntax": "mode, size = File:getBuffer( )",
        "type": "love.filesystem"
    },
    "File):getFilename": {
        "descr": "Gets the filename that the File object was created with. If the file object originated from the love.filedropped callback, the filename will be the full platform-dependent file path.",
        "name": "File):getFilename",
        "params": [
            {
                "descr": "The filename of the File.",
                "name": "string filename"
            }
        ],
        "path": "love/(file)-getfilename",
        "syntax": "filename = File:getFilename( )",
        "type": "love.filesystem"
    },
    "File):getMode": {
        "descr": "Gets the FileMode the file has been opened with.",
        "name": "File):getMode",
        "params": [
            {
                "descr": "The mode this file has been opened with.",
                "name": "FileMode mode"
            }
        ],
        "path": "love/(file)-getmode",
        "syntax": "mode = File:getMode( )",
        "type": "love.filesystem"
    },
    "File):getSize": {
        "descr": "Returns the file size.",
        "name": "File):getSize",
        "params": [
            {
                "descr": "The file size.",
                "name": "number size"
            }
        ],
        "path": "love/(file)-getsize",
        "syntax": "size = File:getSize( )",
        "type": "love.filesystem"
    },
    "File):isEOF": {
        "descr": "Gets whether end-of-file has been reached.",
        "name": "File):isEOF",
        "params": [
            {
                "descr": "Whether EOF has been reached.",
                "name": "boolean eof"
            }
        ],
        "path": "love/(file)-iseof",
        "syntax": "eof = File:isEOF( )",
        "type": "love.filesystem"
    },
    "File):isOpen": {
        "descr": "Gets whether the file is open.",
        "name": "File):isOpen",
        "params": [
            {
                "descr": "True if the file is currently open, false otherwise.",
                "name": "boolean open"
            }
        ],
        "path": "love/(file)-isopen",
        "syntax": "open = File:isOpen( )",
        "type": "love.filesystem"
    },
    "File):lines": {
        "descr": "Iterate over all the lines in a file.",
        "name": "File):lines",
        "params": [
            {
                "descr": "The iterator (can be used in for loops).",
                "name": "function iterator"
            }
        ],
        "path": "love/(file)-lines",
        "syntax": "iterator = File:lines( )",
        "type": "love.filesystem"
    },
    "File):open": {
        "descr": "Open the file for write, read or append.",
        "name": "File):open",
        "params": [
            {
                "descr": "The mode to open the file in.",
                "name": "FileMode mode"
            },
            {
                "descr": "True on success, false otherwise.",
                "name": "boolean ok"
            },
            {
                "descr": "The error string if an error occurred.",
                "name": "string err"
            }
        ],
        "path": "love/(file)-open",
        "syntax": "ok, err = File:open( mode )",
        "type": "love.filesystem"
    },
    "File):read": {
        "descr": "Read a number of bytes from a file",
        "name": "File):read",
        "params": [
            {
                "descr": "The number of bytes to read",
                "name": "number bytes (all)"
            },
            {
                "descr": "The contents of the read bytes",
                "name": "string contents"
            },
            {
                "descr": "How many bytes have been read",
                "name": "number size"
            }
        ],
        "path": "love/(file)-read",
        "syntax": "contents, size = File:read( bytes )",
        "type": "love.filesystem"
    },
    "File):seek": {
        "descr": "Seek to a position in a file",
        "name": "File):seek",
        "params": [
            {
                "descr": "The position to seek to",
                "name": "number pos"
            },
            {
                "descr": "Whether the operation was successful",
                "name": "boolean success"
            }
        ],
        "path": "love/(file)-seek",
        "syntax": "success = File:seek( pos )",
        "type": "love.filesystem"
    },
    "File):setBuffer": {
        "descr": "Sets the buffer mode for a file opened for writing or appending. Files with buffering enabled will not write data to the disk until the buffer size limit is reached, depending on the buffer mode.",
        "name": "File):setBuffer",
        "params": [
            {
                "descr": "The buffer mode to use.",
                "name": "BufferMode mode"
            },
            {
                "descr": "The maximum size in bytes of the file's buffer.",
                "name": "number size (0)"
            },
            {
                "descr": "Whether the buffer mode was successfully set.",
                "name": "boolean success"
            },
            {
                "descr": "The error string, if the buffer mode could not be set and an error occurred.",
                "name": "string errorstr (nil)"
            }
        ],
        "path": "love/(file)-setbuffer",
        "syntax": "success, errorstr = File:setBuffer( mode, size )",
        "type": "love.filesystem"
    },
    "File):tell": {
        "descr": "Returns the position in the file",
        "name": "File):tell",
        "params": [
            {
                "descr": "The current position",
                "name": "number pos"
            }
        ],
        "path": "love/(file)-tell",
        "syntax": "pos = File:tell( )",
        "type": "love.filesystem"
    },
    "File):write": {
        "descr": "Write data to a file.",
        "name": "File):write",
        "params": [
            {
                "descr": "The string data to write.",
                "name": "string data"
            },
            {
                "descr": "How many bytes to write.",
                "name": "number size (all)"
            },
            {
                "descr": "Whether the operation was successful.",
                "name": "boolean success"
            },
            {
                "descr": "The error string if an error occurred.",
                "name": "string err"
            }
        ],
        "path": "love/(file)-write",
        "syntax": "success, err = File:write( data, size )",
        "type": "love.filesystem"
    },
    "FileData:getExtension": {
        "descr": "Gets the extension of the FileData.",
        "name": "FileData:getExtension",
        "params": [
            {
                "descr": "The extension of the file the FileData represents.",
                "name": "string ext"
            }
        ],
        "path": "love/filedata-getextension",
        "syntax": "ext = FileData:getExtension( )",
        "type": "love.filesystem"
    },
    "FileData:getFilename": {
        "descr": "Gets the filename of the FileData.",
        "name": "FileData:getFilename",
        "params": [
            {
                "descr": "The name of the file the FileData represents.",
                "name": "string name"
            }
        ],
        "path": "love/filedata-getfilename",
        "syntax": "name = FileData:getFilename( )",
        "type": "love.filesystem"
    },
    "Fixture:destroy": {
        "descr": "Destroys the fixture.",
        "name": "Fixture:destroy",
        "params": [],
        "path": "love/fixture-destroy",
        "syntax": "Fixture:destroy( )",
        "type": "love.physics"
    },
    "Fixture:getBody": {
        "descr": "Returns the body to which the fixture is attached.",
        "name": "Fixture:getBody",
        "params": [
            {
                "descr": "The parent body.",
                "name": "Body body"
            }
        ],
        "path": "love/fixture-getbody",
        "syntax": "body = Fixture:getBody( )",
        "type": "love.physics"
    },
    "Fixture:getBoundingBox": {
        "descr": "Returns the points of the fixture bounding box. In case the fixture has multiple children a 1-based index can be specified. For example, a fixture will have multiple children with a chain shape.",
        "name": "Fixture:getBoundingBox",
        "params": [
            {
                "descr": "A bounding box of the fixture.",
                "name": "number index (1)"
            },
            {
                "descr": "The x position of the top-left point.",
                "name": "number topLeftX"
            },
            {
                "descr": "The y position of the top-left point.",
                "name": "number topLeftY"
            },
            {
                "descr": "The x position of the bottom-right point.",
                "name": "number bottomRightX"
            },
            {
                "descr": "The y position of the bottom-right point.",
                "name": "number bottomRightY"
            }
        ],
        "path": "love/fixture-getboundingbox",
        "syntax": "topLeftX, topLeftY, bottomRightX, bottomRightY = Fixture:getBoundingBox( index )",
        "type": "love.physics"
    },
    "Fixture:getCategory": {
        "descr": "Returns the categories the fixture belongs to.",
        "name": "Fixture:getCategory",
        "params": [
            {
                "descr": "The first category.",
                "name": "number category1"
            },
            {
                "descr": "The second category.",
                "name": "number category2"
            }
        ],
        "path": "love/fixture-getcategory",
        "syntax": "category1, category2, ... = Fixture:getCategory( )",
        "type": "love.physics"
    },
    "Fixture:getDensity": {
        "descr": "Returns the density of the fixture.",
        "name": "Fixture:getDensity",
        "params": [
            {
                "descr": "The fixture density in kilograms per square meter.",
                "name": "number density"
            }
        ],
        "path": "love/fixture-getdensity",
        "syntax": "density = Fixture:getDensity( )",
        "type": "love.physics"
    },
    "Fixture:getFilterData": {
        "descr": "Returns the filter data of the fixture. Categories and masks are encoded as the bits of a 16-bit integer.",
        "name": "Fixture:getFilterData",
        "params": [
            {
                "descr": "The categories as an integer from 0 to 65535.",
                "name": "number categories"
            },
            {
                "descr": "The mask as an integer from 0 to 65535.",
                "name": "number mask"
            },
            {
                "descr": "The group as an integer from -32768 to 32767.",
                "name": "number group"
            }
        ],
        "path": "love/fixture-getfilterdata",
        "syntax": "categories, mask, group = Fixture:getFilterData( )",
        "type": "love.physics"
    },
    "Fixture:getFriction": {
        "descr": "Returns the friction of the fixture.",
        "name": "Fixture:getFriction",
        "params": [
            {
                "descr": "The fixture friction.",
                "name": "number friction"
            }
        ],
        "path": "love/fixture-getfriction",
        "syntax": "friction = Fixture:getFriction( )",
        "type": "love.physics"
    },
    "Fixture:getGroupIndex": {
        "descr": "Returns the group the fixture belongs to. Fixtures with the same group will always collide if the group is positive or never collide if it's negative. The group zero means no group.",
        "name": "Fixture:getGroupIndex",
        "params": [
            {
                "descr": "The group of the fixture.",
                "name": "number group"
            }
        ],
        "path": "love/fixture-getgroupindex",
        "syntax": "group = Fixture:getGroupIndex( )",
        "type": "love.physics"
    },
    "Fixture:getMask": {
        "descr": "Returns which categories this fixture should NOT collide with.",
        "name": "Fixture:getMask",
        "params": [
            {
                "descr": "The first category selected by the mask.",
                "name": "number mask1"
            },
            {
                "descr": "The second category selected by the mask.",
                "name": "number mask2"
            }
        ],
        "path": "love/fixture-getmask",
        "syntax": "mask1, mask2, ... = Fixture:getMask( )",
        "type": "love.physics"
    },
    "Fixture:getMassData": {
        "descr": "Returns the mass, its center and the rotational inertia.",
        "name": "Fixture:getMassData",
        "params": [
            {
                "descr": "The x position of the center of mass.",
                "name": "number x"
            },
            {
                "descr": "The y position of the center of mass.",
                "name": "number y"
            },
            {
                "descr": "The mass of the fixture.",
                "name": "number mass"
            },
            {
                "descr": "The rotational inertia.",
                "name": "number inertia"
            }
        ],
        "path": "love/fixture-getmassdata",
        "syntax": "x, y, mass, inertia = Fixture:getMassData( )",
        "type": "love.physics"
    },
    "Fixture:getRestitution": {
        "descr": "Returns the restitution of the fixture.",
        "name": "Fixture:getRestitution",
        "params": [
            {
                "descr": "The fixture restitution.",
                "name": "number restitution"
            }
        ],
        "path": "love/fixture-getrestitution",
        "syntax": "restitution = Fixture:getRestitution( )",
        "type": "love.physics"
    },
    "Fixture:getShape": {
        "descr": "Returns the shape of the fixture. This shape is a reference to the actual data used in the simulation. It's possible to change its values between timesteps.",
        "name": "Fixture:getShape",
        "params": [
            {
                "descr": "The fixture's shape.",
                "name": "Shape shape"
            }
        ],
        "path": "love/fixture-getshape",
        "syntax": "shape = Fixture:getShape( )",
        "type": "love.physics"
    },
    "Fixture:getUserData": {
        "descr": "Returns the Lua value associated with this fixture.",
        "name": "Fixture:getUserData",
        "params": [
            {
                "descr": "The Lua value associated with the fixture.",
                "name": "mixed value"
            }
        ],
        "path": "love/fixture-getuserdata",
        "syntax": "value = Fixture:getUserData( )",
        "type": "love.physics"
    },
    "Fixture:isDestroyed": {
        "descr": "Gets whether the Fixture is destroyed. Destroyed fixtures cannot be used.",
        "name": "Fixture:isDestroyed",
        "params": [
            {
                "descr": "Whether the Fixture is destroyed.",
                "name": "boolean destroyed"
            }
        ],
        "path": "love/fixture-isdestroyed",
        "syntax": "destroyed = Fixture:isDestroyed( )",
        "type": "love.physics"
    },
    "Fixture:isSensor": {
        "descr": "Returns whether the fixture is a sensor.",
        "name": "Fixture:isSensor",
        "params": [
            {
                "descr": "If the fixture is a sensor.",
                "name": "boolean sensor"
            }
        ],
        "path": "love/fixture-issensor",
        "syntax": "sensor = Fixture:isSensor( )",
        "type": "love.physics"
    },
    "Fixture:rayCast": {
        "descr": "Casts a ray against the shape of the fixture and returns the surface normal vector and the line position where the ray hit. If the ray missed the shape, nil will be returned.",
        "name": "Fixture:rayCast",
        "params": [
            {
                "descr": "The x position of the input line starting point.",
                "name": "number x1"
            },
            {
                "descr": "The y position of the input line starting point.",
                "name": "number y1"
            },
            {
                "descr": "The x position of the input line end point.",
                "name": "number x2"
            },
            {
                "descr": "The y position of the input line end point.",
                "name": "number y2"
            },
            {
                "descr": "Ray length parameter.",
                "name": "number maxFraction"
            },
            {
                "descr": "The index of the child the ray gets cast against.",
                "name": "number childIndex (1)"
            },
            {
                "descr": "The x component of the normal vector of the edge where the ray hit the shape.",
                "name": "number xn"
            },
            {
                "descr": "The y component of the normal vector of the edge where the ray hit the shape.",
                "name": "number yn"
            },
            {
                "descr": "The position on the input line where the intersection happened as a factor of the line length.",
                "name": "number fraction"
            }
        ],
        "path": "love/fixture-raycast",
        "syntax": "xn, yn, fraction = Fixture:rayCast( x1, y1, x2, y2, maxFraction, childIndex )",
        "type": "love.physics"
    },
    "Fixture:setCategory": {
        "descr": "Sets the categories the fixture belongs to. There can be up to 16 categories represented as a number from 1 to 16.",
        "name": "Fixture:setCategory",
        "params": [
            {
                "descr": "The first category.",
                "name": "number category1"
            },
            {
                "descr": "The second category.",
                "name": "number category2"
            }
        ],
        "path": "love/fixture-setcategory",
        "syntax": "Fixture:setCategory( category1, category2, ... )",
        "type": "love.physics"
    },
    "Fixture:setDensity": {
        "descr": "Sets the density of the fixture. Call Body:resetMassData if this needs to take effect immediately.",
        "name": "Fixture:setDensity",
        "params": [
            {
                "descr": "The fixture density in kilograms per square meter.",
                "name": "number density"
            }
        ],
        "path": "love/fixture-setdensity",
        "syntax": "Fixture:setDensity( density )",
        "type": "love.physics"
    },
    "Fixture:setFilterData": {
        "descr": "Sets the filter data of the fixture.",
        "name": "Fixture:setFilterData",
        "params": [
            {
                "descr": "The categories as an integer from 0 to 65535.",
                "name": "number categories"
            },
            {
                "descr": "The mask as an integer from 0 to 65535.",
                "name": "number mask"
            },
            {
                "descr": "The group as an integer from -32768 to 32767.",
                "name": "number group"
            }
        ],
        "path": "love/fixture-setfilterdata",
        "syntax": "Fixture:setFilterData( categories, mask, group )",
        "type": "love.physics"
    },
    "Fixture:setFriction": {
        "descr": "Sets the friction of the fixture.",
        "name": "Fixture:setFriction",
        "params": [
            {
                "descr": "The fixture friction.",
                "name": "number friction"
            }
        ],
        "path": "love/fixture-setfriction",
        "syntax": "Fixture:setFriction( friction )",
        "type": "love.physics"
    },
    "Fixture:setGroupIndex": {
        "descr": "Sets the group the fixture belongs to. Fixtures with the same group will always collide if the group is positive or never collide if it's negative. The group zero means no group.",
        "name": "Fixture:setGroupIndex",
        "params": [
            {
                "descr": "The group as an integer from -32768 to 32767.",
                "name": "number group"
            }
        ],
        "path": "love/fixture-setgroupindex",
        "syntax": "Fixture:setGroupIndex( group )",
        "type": "love.physics"
    },
    "Fixture:setMask": {
        "descr": "",
        "name": "Fixture:setMask",
        "params": [
            {
                "descr": "The first category.",
                "name": "number mask1"
            },
            {
                "descr": "The second category.",
                "name": "number mask2"
            }
        ],
        "path": "love/fixture-setmask",
        "syntax": "Fixture:setMask( mask1, mask2, ... )",
        "type": "love.physics"
    },
    "Fixture:setRestitution": {
        "descr": "Sets the restitution of the fixture.",
        "name": "Fixture:setRestitution",
        "params": [
            {
                "descr": "The fixture restitution.",
                "name": "number restitution"
            }
        ],
        "path": "love/fixture-setrestitution",
        "syntax": "Fixture:setRestitution( restitution )",
        "type": "love.physics"
    },
    "Fixture:setSensor": {
        "descr": "Sets whether the fixture should act as a sensor.",
        "name": "Fixture:setSensor",
        "params": [
            {
                "descr": "The sensor status.",
                "name": "boolean sensor"
            }
        ],
        "path": "love/fixture-setsensor",
        "syntax": "Fixture:setSensor( sensor )",
        "type": "love.physics"
    },
    "Fixture:setUserData": {
        "descr": "Associates a Lua value with the fixture.",
        "name": "Fixture:setUserData",
        "params": [
            {
                "descr": "The Lua value to associate with the fixture.",
                "name": "mixed value"
            }
        ],
        "path": "love/fixture-setuserdata",
        "syntax": "Fixture:setUserData( value )",
        "type": "love.physics"
    },
    "Fixture:testPoint": {
        "descr": "Checks if a point is inside the shape of the fixture.",
        "name": "Fixture:testPoint",
        "params": [
            {
                "descr": "The x position of the point.",
                "name": "number x"
            },
            {
                "descr": "The y position of the point.",
                "name": "number y"
            },
            {
                "descr": "True if the point is inside or false if it is outside.",
                "name": "boolean isInside"
            }
        ],
        "path": "love/fixture-testpoint",
        "syntax": "isInside = Fixture:testPoint( x, y )",
        "type": "love.physics"
    },
    "Font:getAscent": {
        "descr": "Gets the ascent of the Font. The ascent spans the distance between the baseline and the top of the glyph that reaches farthest from the baseline.",
        "name": "Font:getAscent",
        "params": [
            {
                "descr": "The ascent of the Font in pixels.",
                "name": "number ascent"
            }
        ],
        "path": "love/font-getascent",
        "syntax": "ascent = Font:getAscent( )",
        "type": "love.graphics"
    },
    "Font:getBaseline": {
        "descr": "Gets the baseline of the Font. Most scripts share the notion of a baseline: an imaginary horizontal line on which characters rest. In some scripts, parts of glyphs lie below the baseline.",
        "name": "Font:getBaseline",
        "params": [
            {
                "descr": "The baseline of the Font in pixels.",
                "name": "number baseline"
            }
        ],
        "path": "love/font-getbaseline",
        "syntax": "baseline = Font:getBaseline( )",
        "type": "love.graphics"
    },
    "Font:getDescent": {
        "descr": "Gets the descent of the Font. The descent spans the distance between the baseline and the lowest descending glyph in a typeface.",
        "name": "Font:getDescent",
        "params": [
            {
                "descr": "The descent of the Font in pixels.",
                "name": "number descent"
            }
        ],
        "path": "love/font-getdescent",
        "syntax": "descent = Font:getDescent( )",
        "type": "love.graphics"
    },
    "Font:getFilter": {
        "descr": "Gets the filter mode for a font.",
        "name": "Font:getFilter",
        "params": [
            {
                "descr": "Filter mode used when minifying the font.",
                "name": "FilterMode min"
            },
            {
                "descr": "Filter mode used when magnifying the font.",
                "name": "FilterMode mag"
            },
            {
                "descr": "Maximum amount of anisotropic filtering used.",
                "name": "number anisotropy"
            }
        ],
        "path": "love/font-getfilter",
        "syntax": "min, mag, anisotropy = Font:getFilter( )",
        "type": "love.graphics"
    },
    "Font:getHeight": {
        "descr": "Gets the height of the Font. The height of the font is the size including any spacing; the height which it will need.",
        "name": "Font:getHeight",
        "params": [
            {
                "descr": "The height of the Font in pixels.",
                "name": "number height"
            }
        ],
        "path": "love/font-getheight",
        "syntax": "height = Font:getHeight( )",
        "type": "love.graphics"
    },
    "Font:getLineHeight": {
        "descr": "Gets the line height. This will be the value previously set by Font:setLineHeight, or 1.0 by default.",
        "name": "Font:getLineHeight",
        "params": [
            {
                "descr": "The current line height.",
                "name": "number height"
            }
        ],
        "path": "love/font-getlineheight",
        "syntax": "height = Font:getLineHeight( )",
        "type": "love.graphics"
    },
    "Font:getWidth": {
        "descr": "Determines the horizontal size a line of text needs. Does not support line-breaks.",
        "name": "Font:getWidth",
        "params": [
            {
                "descr": "A string.",
                "name": "string line"
            },
            {
                "descr": "The width of the line.",
                "name": "number width"
            }
        ],
        "path": "love/font-getwidth",
        "syntax": "width = Font:getWidth( line )",
        "type": "love.graphics"
    },
    "Font:getWrap": {
        "descr": "Gets formatting information for text, given a wrap limit.",
        "name": "Font:getWrap",
        "params": [
            {
                "descr": "The text that will be wrapped.",
                "name": "string text"
            },
            {
                "descr": "The maximum width in pixels of each line that text is allowed before wrapping.",
                "name": "number wraplimit"
            },
            {
                "descr": "The maximum width of the wrapped text.",
                "name": "number width"
            },
            {
                "descr": "A sequence containing each line of text that was wrapped.",
                "name": "table wrappedtext"
            }
        ],
        "path": "love/font-getwrap",
        "syntax": "width, wrappedtext = Font:getWrap( text, wraplimit )",
        "type": "love.graphics"
    },
    "Font:hasGlyphs": {
        "descr": "Gets whether the Font can render a character or string.",
        "name": "Font:hasGlyphs",
        "params": [
            {
                "descr": "A UTF-8 encoded unicode string.",
                "name": "string text"
            },
            {
                "descr": "Whether the font can render all the UTF-8 characters in the string.",
                "name": "boolean hasglyph"
            }
        ],
        "path": "love/font-hasglyphs",
        "syntax": "hasglyphs = Font:hasGlyphs( text )",
        "type": "love.graphics"
    },
    "Font:setFallbacks": {
        "descr": "Sets the fallback fonts. When the Font doesn't contain a glyph, it will substitute the glyph from the next subsequent fallback Fonts. This is akin to setting a \"font stack\" in Cascading Style Sheets (CSS).",
        "name": "Font:setFallbacks",
        "params": [
            {
                "descr": "The first fallback Font to use.",
                "name": "Font fallbackfont1"
            },
            {
                "descr": "Additional fallback Fonts.",
                "name": "Font ..."
            }
        ],
        "path": "love/font-setfallbacks",
        "syntax": "Font:setFallbacks( fallbackfont1, ... )",
        "type": "love.graphics"
    },
    "Font:setFilter": {
        "descr": "Sets the filter mode for a font.",
        "name": "Font:setFilter",
        "params": [
            {
                "descr": "How to scale a font down.",
                "name": "FilterMode min"
            },
            {
                "descr": "How to scale a font up.",
                "name": "FilterMode mag"
            },
            {
                "descr": "Maximum amount of anisotropic filtering used.",
                "name": "number anisotropy (1)"
            }
        ],
        "path": "love/font-setfilter",
        "syntax": "Font:setFilter( min, mag, anisotropy )",
        "type": "love.graphics"
    },
    "Font:setLineHeight": {
        "descr": "Sets the line height. When rendering the font in lines the actual height will be determined by the line height multiplied by the height of the font. The default is 1.0.",
        "name": "Font:setLineHeight",
        "params": [
            {
                "descr": "The new line height.",
                "name": "number height"
            }
        ],
        "path": "love/font-setlineheight",
        "syntax": "Font:setLineHeight( height )",
        "type": "love.graphics"
    },
    "Framebuffer:getImageData": {
        "descr": "Returns the image data stored in the Framebuffer. Think of it as a screenshot of the hidden screen that is the framebuffer.",
        "name": "Framebuffer:getImageData",
        "params": [
            {
                "descr": "The image data stored in the framebuffer.",
                "name": "ImageData data"
            }
        ],
        "path": "love/framebuffer-getimagedata",
        "syntax": "data = Framebuffer:getImageData( )",
        "type": "love.graphics"
    },
    "Framebuffer:getWrap": {
        "descr": "Gets the wrapping properties of a Framebuffer.",
        "name": "Framebuffer:getWrap",
        "params": [
            {
                "descr": "Horizontal wrapping mode of the Framebuffer.",
                "name": "WrapMode horiz"
            },
            {
                "descr": "Vertical wrapping mode of the Framebuffer.",
                "name": "WrapMode vert"
            }
        ],
        "path": "love/framebuffer-getwrap",
        "syntax": "horiz, vert = Framebuffer:getWrap( )",
        "type": "love.graphics"
    },
    "Framebuffer:renderTo": {
        "descr": "Render to the Framebuffer using a function.",
        "name": "Framebuffer:renderTo",
        "params": [
            {
                "descr": "A function performing drawing operations.",
                "name": "function func"
            }
        ],
        "path": "love/framebuffer-renderto",
        "syntax": "Framebuffer:renderTo( func )",
        "type": "love.graphics"
    },
    "Framebuffer:setWrap": {
        "descr": "Sets the wrapping properties of a Framebuffer.",
        "name": "Framebuffer:setWrap",
        "params": [
            {
                "descr": "Horizontal wrapping mode of the framebuffer.",
                "name": "WrapMode horiz"
            },
            {
                "descr": "Vertical wrapping mode of the framebuffer.",
                "name": "WrapMode vert"
            }
        ],
        "path": "love/framebuffer-setwrap",
        "syntax": "Framebuffer:setWrap( horiz, vert )",
        "type": "love.graphics"
    },
    "FrictionJoint:getMaxForce": {
        "descr": "Gets the maximum friction force in Newtons.",
        "name": "FrictionJoint:getMaxForce",
        "params": [
            {
                "descr": "Maximum force in Newtons.",
                "name": "number force"
            }
        ],
        "path": "love/frictionjoint-getmaxforce",
        "syntax": "force = FrictionJoint:getMaxForce( )",
        "type": "love.physics"
    },
    "FrictionJoint:getMaxTorque": {
        "descr": "Gets the maximum friction torque in Newton-meters.",
        "name": "FrictionJoint:getMaxTorque",
        "params": [
            {
                "descr": "Maximum torque in Newton-meters.",
                "name": "number torque"
            }
        ],
        "path": "love/frictionjoint-getmaxtorque",
        "syntax": "torque = FrictionJoint:getMaxTorque( )",
        "type": "love.physics"
    },
    "FrictionJoint:setMaxForce": {
        "descr": "Sets the maximum friction force in Newtons.",
        "name": "FrictionJoint:setMaxForce",
        "params": [
            {
                "descr": "Max force in Newtons.",
                "name": "number maxForce"
            }
        ],
        "path": "love/frictionjoint-setmaxforce",
        "syntax": "FrictionJoint:setMaxForce( force )",
        "type": "love.physics"
    },
    "FrictionJoint:setMaxTorque": {
        "descr": "Sets the maximum friction torque in Newton-meters.",
        "name": "FrictionJoint:setMaxTorque",
        "params": [
            {
                "descr": "Maximum torque in Newton-meters.",
                "name": "number torque"
            }
        ],
        "path": "love/frictionjoint-setmaxtorque",
        "syntax": "FrictionJoint:setMaxTorque( torque )",
        "type": "love.physics"
    },
    "GearJoint:getJoints": {
        "descr": "Get the Joints connected by this GearJoint.",
        "name": "GearJoint:getJoints",
        "params": [
            {
                "descr": "The first connected Joint.",
                "name": "Joint joint1"
            },
            {
                "descr": "The second connected Joint.",
                "name": "Joint joint2"
            }
        ],
        "path": "love/gearjoint-getjoints",
        "syntax": "joint1, joint2 = GearJoint:getJoints( )",
        "type": "love.physics"
    },
    "GearJoint:getRatio": {
        "descr": "Get the ratio of a gear joint.",
        "name": "GearJoint:getRatio",
        "params": [
            {
                "descr": "The ratio of the joint.",
                "name": "number ratio"
            }
        ],
        "path": "love/gearjoint-getratio",
        "syntax": "ratio = GearJoint:getRatio( )",
        "type": "love.physics"
    },
    "GearJoint:setRatio": {
        "descr": "Set the ratio of a gear joint.",
        "name": "GearJoint:setRatio",
        "params": [
            {
                "descr": "The new ratio of the joint.",
                "name": "number ratio"
            }
        ],
        "path": "love/gearjoint-setratio",
        "syntax": "GearJoint:setRatio( ratio )",
        "type": "love.physics"
    },
    "Image):getData": {
        "descr": "Gets the original ImageData or CompressedData used to create the Image.",
        "name": "Image):getData",
        "params": [
            {
                "descr": "The original ImageData used to create the Image, if the image is not compressed.",
                "name": "ImageData data"
            }
        ],
        "path": "love/(image)-getdata",
        "syntax": "data = Image:getData( )",
        "type": "love.graphics"
    },
    "Image):getDimensions": {
        "descr": "Gets the width and height of the Image.",
        "name": "Image):getDimensions",
        "params": [
            {
                "descr": "The width of the Image, in pixels.",
                "name": "number width"
            },
            {
                "descr": "The height of the Image, in pixels.",
                "name": "number height"
            }
        ],
        "path": "love/(image)-getdimensions",
        "syntax": "width, height = Image:getDimensions( )",
        "type": "love.graphics"
    },
    "Image):getFilter": {
        "descr": "Gets the filter mode for an image.",
        "name": "Image):getFilter",
        "params": [
            {
                "descr": "Filter mode used when minifying the image.",
                "name": "FilterMode min"
            },
            {
                "descr": "Filter mode used when magnifying the image.",
                "name": "FilterMode mag"
            }
        ],
        "path": "love/(image)-getfilter",
        "syntax": "min, mag = Image:getFilter( )",
        "type": "love.graphics"
    },
    "Image):getFlags": {
        "descr": "Gets the flags used when the image was created.",
        "name": "Image):getFlags",
        "params": [
            {
                "descr": "A table with ImageFlag keys.",
                "name": "table flags"
            }
        ],
        "path": "love/(image)-getflags",
        "syntax": "flags = Image:getFlags( )",
        "type": "love.graphics"
    },
    "Image):getHeight": {
        "descr": "Gets the height of the Image.",
        "name": "Image):getHeight",
        "params": [
            {
                "descr": "The height of the Image, in pixels.",
                "name": "number height"
            }
        ],
        "path": "love/(image)-getheight",
        "syntax": "height = Image:getHeight( )",
        "type": "love.graphics"
    },
    "Image):getMipmapFilter": {
        "descr": "Gets the mipmap filter mode for an Image.",
        "name": "Image):getMipmapFilter",
        "params": [
            {
                "descr": "The filter mode used in between mipmap levels. ",
                "name": "FilterMode mode"
            },
            {
                "descr": "Value used to determine whether the image should use more or less detailed mipmap levels than normal when drawing.",
                "name": "number sharpness"
            }
        ],
        "path": "love/(image)-getmipmapfilter",
        "syntax": "mode, sharpness = Image:getMipmapFilter( )",
        "type": "love.graphics"
    },
    "Image):getWidth": {
        "descr": "Gets the width of the Image.",
        "name": "Image):getWidth",
        "params": [
            {
                "descr": "The width of the Image, in pixels.",
                "name": "number width"
            }
        ],
        "path": "love/(image)-getwidth",
        "syntax": "width = Image:getWidth( )",
        "type": "love.graphics"
    },
    "Image):getWrap": {
        "descr": "Gets the wrapping properties of an Image.",
        "name": "Image):getWrap",
        "params": [
            {
                "descr": "Horizontal wrapping mode of the image.",
                "name": "WrapMode horiz"
            },
            {
                "descr": "Vertical wrapping mode of the image.",
                "name": "WrapMode vert"
            }
        ],
        "path": "love/(image)-getwrap",
        "syntax": "horiz, vert = Image:getWrap( )",
        "type": "love.graphics"
    },
    "Image):isCompressed": {
        "descr": "Gets whether the Image was created from CompressedData.",
        "name": "Image):isCompressed",
        "params": [
            {
                "descr": "Whether the Image is stored as a compressed texture on the GPU.",
                "name": "boolean compressed"
            }
        ],
        "path": "love/(image)-iscompressed",
        "syntax": "compressed = Image:isCompressed( )",
        "type": "love.graphics"
    },
    "Image):refresh": {
        "descr": "Reloads the Image's contents from the ImageData or CompressedData used to create the image.",
        "name": "Image):refresh",
        "params": [],
        "path": "love/(image)-refresh",
        "syntax": "Image:refresh( )",
        "type": "love.graphics"
    },
    "Image):setFilter": {
        "descr": "Sets the filter mode for an image.",
        "name": "Image):setFilter",
        "params": [
            {
                "descr": "How to scale an image down.",
                "name": "FilterMode min"
            },
            {
                "descr": "How to scale an image up.",
                "name": "FilterMode mag"
            }
        ],
        "path": "love/(image)-setfilter",
        "syntax": "Image:setFilter( min, mag )",
        "type": "love.graphics"
    },
    "Image):setMipmapFilter": {
        "descr": "Sets the mipmap filter mode for an Image.",
        "name": "Image):setMipmapFilter",
        "params": [
            {
                "descr": "The filter mode to use in between mipmap levels. ",
                "name": "FilterMode filtermode"
            },
            {
                "descr": "A positive sharpness value makes the image use a more detailed mipmap level when drawing, at the expense of performance. ",
                "name": "number sharpness (0)"
            }
        ],
        "path": "love/(image)-setmipmapfilter",
        "syntax": "Image:setMipmapFilter( filtermode, sharpness )",
        "type": "love.graphics"
    },
    "Image):setWrap": {
        "descr": "Sets the wrapping properties of an Image.",
        "name": "Image):setWrap",
        "params": [
            {
                "descr": "Horizontal wrapping mode of the image.",
                "name": "WrapMode horiz"
            },
            {
                "descr": "Vertical wrapping mode of the image.",
                "name": "WrapMode vert"
            }
        ],
        "path": "love/(image)-setwrap",
        "syntax": "Image:setWrap( horiz, vert )",
        "type": "love.graphics"
    },
    "ImageData:encode": {
        "descr": "Encodes the ImageData and optionally writes it to the save directory.",
        "name": "ImageData:encode",
        "params": [
            {
                "descr": "The format to encode the image as.",
                "name": "ImageFormat format"
            },
            {
                "descr": "The filename to write the file to. ",
                "name": "string filename (nil)"
            },
            {
                "descr": "The encoded image as a new FileData object.",
                "name": "FileData filedata"
            }
        ],
        "path": "love/imagedata-encode",
        "syntax": "filedata = ImageData:encode( format, filename )",
        "type": "love.image"
    },
    "ImageData:getDimensions": {
        "descr": "Gets the width and height of the ImageData in pixels.",
        "name": "ImageData:getDimensions",
        "params": [
            {
                "descr": "The width of the ImageData in pixels.",
                "name": "number width"
            },
            {
                "descr": "The height of the ImageData in pixels.",
                "name": "number height"
            }
        ],
        "path": "love/imagedata-getdimensions",
        "syntax": "width, height = ImageData:getDimensions( )",
        "type": "love.image"
    },
    "ImageData:getHeight": {
        "descr": "Gets the height of the ImageData in pixels.",
        "name": "ImageData:getHeight",
        "params": [
            {
                "descr": "The height of the ImageData in pixels.",
                "name": "number height"
            }
        ],
        "path": "love/imagedata-getheight",
        "syntax": "height = ImageData:getHeight( )",
        "type": "love.image"
    },
    "ImageData:getPixel": {
        "descr": "Gets the color of a pixel at a specific position in the image.",
        "name": "ImageData:getPixel",
        "params": [
            {
                "descr": "The position of the pixel on the x-axis.",
                "name": "number x"
            },
            {
                "descr": "The position of the pixel on the y-axis.",
                "name": "number y"
            },
            {
                "descr": "The red component (0-255).",
                "name": "number r"
            },
            {
                "descr": "The green component (0-255).",
                "name": "number g"
            },
            {
                "descr": "The blue component (0-255).",
                "name": "number b"
            },
            {
                "descr": "The alpha component (0-255).",
                "name": "number a"
            }
        ],
        "path": "love/imagedata-getpixel",
        "syntax": "r, g, b, a = ImageData:getPixel( x, y )",
        "type": "love.image"
    },
    "ImageData:getString": {
        "descr": "Gets the full ImageData as a string.",
        "name": "ImageData:getString",
        "params": [
            {
                "descr": "The raw data.",
                "name": "string pixels"
            }
        ],
        "path": "love/imagedata-getstring",
        "syntax": "pixels = ImageData:getString( )",
        "type": "love.image"
    },
    "ImageData:getWidth": {
        "descr": "Gets the width of the ImageData in pixels.",
        "name": "ImageData:getWidth",
        "params": [
            {
                "descr": "The width of the ImageData in pixels.",
                "name": "number width"
            }
        ],
        "path": "love/imagedata-getwidth",
        "syntax": "width = ImageData:getWidth( )",
        "type": "love.image"
    },
    "ImageData:mapPixel": {
        "descr": "Transform an image by applying a function to every pixel.",
        "name": "ImageData:mapPixel",
        "params": [
            {
                "descr": "Function to apply to every pixel.",
                "name": "function pixelFunction"
            }
        ],
        "path": "love/imagedata-mappixel",
        "syntax": "ImageData:mapPixel( pixelFunction )",
        "type": "love.image"
    },
    "ImageData:paste": {
        "descr": "Paste into ImageData from another source ImageData.",
        "name": "ImageData:paste",
        "params": [
            {
                "descr": "Source ImageData from which to copy.",
                "name": "ImageData source"
            },
            {
                "descr": "Destination top-left position on x-axis.",
                "name": "number dx"
            },
            {
                "descr": "Destination top-left position on y-axis.",
                "name": "number dy"
            },
            {
                "descr": "Source top-left position on x-axis.",
                "name": "number sx"
            },
            {
                "descr": "Source top-left position on y-axis.",
                "name": "number sy"
            },
            {
                "descr": "Source width.",
                "name": "number sw"
            },
            {
                "descr": "Source height.",
                "name": "number sh"
            }
        ],
        "path": "love/imagedata-paste",
        "syntax": "ImageData:paste( source, dx, dy, sx, sy, sw, sh )",
        "type": "love.image"
    },
    "ImageData:setPixel": {
        "descr": "Sets the color of a pixel at a specific position in the image.",
        "name": "ImageData:setPixel",
        "params": [
            {
                "descr": "The position of the pixel on the x-axis.",
                "name": "number x"
            },
            {
                "descr": "The position of the pixel on the y-axis.",
                "name": "number y"
            },
            {
                "descr": "The red component (0-255).",
                "name": "number r"
            },
            {
                "descr": "The green component (0-255).",
                "name": "number g"
            },
            {
                "descr": "The blue component (0-255).",
                "name": "number b"
            },
            {
                "descr": "The alpha component (0-255).",
                "name": "number a"
            }
        ],
        "path": "love/imagedata-setpixel",
        "syntax": "ImageData:setPixel( x, y, r, g, b, a )",
        "type": "love.image"
    },
    "Joint:destroy": {
        "descr": "Explicitly destroys the Joint. An error will occur if you attempt to use the object after calling this function.",
        "name": "Joint:destroy",
        "params": [],
        "path": "love/joint-destroy",
        "syntax": "Joint:destroy( )",
        "type": "love.physics"
    },
    "Joint:getAnchors": {
        "descr": "Get the anchor points of the joint.",
        "name": "Joint:getAnchors",
        "params": [
            {
                "descr": "The x-component of the anchor on Body 1.",
                "name": "number x1"
            },
            {
                "descr": "The y-component of the anchor on Body 1.",
                "name": "number y1"
            },
            {
                "descr": "The x-component of the anchor on Body 2.",
                "name": "number x2"
            },
            {
                "descr": "The y-component of the anchor on Body 2.",
                "name": "number y2"
            }
        ],
        "path": "love/joint-getanchors",
        "syntax": "x1, y1, x2, y2 = Joint:getAnchors( )",
        "type": "love.physics"
    },
    "Joint:getBodies": {
        "descr": "Gets the bodies that the Joint is attached to.",
        "name": "Joint:getBodies",
        "params": [
            {
                "descr": "The first Body.",
                "name": "Body bodyA (nil)"
            },
            {
                "descr": "The second Body.",
                "name": "Body bodyB (nil)"
            }
        ],
        "path": "love/joint-getbodies",
        "syntax": "bodyA, bodyB = Joint:getBodies( )",
        "type": "love.physics"
    },
    "Joint:getCollideConnected": {
        "descr": "Gets whether the connected Bodies collide.",
        "name": "Joint:getCollideConnected",
        "params": [
            {
                "descr": "True if they collide, false otherwise.",
                "name": "boolean c"
            }
        ],
        "path": "love/joint-getcollideconnected",
        "syntax": "c = Joint:getCollideConnected( )",
        "type": "love.physics"
    },
    "Joint:getReactionForce": {
        "descr": "Returns the reaction force in newtons on the second body",
        "name": "Joint:getReactionForce",
        "params": [
            {
                "descr": "How long the force applies. Usually the inverse time step or 1/dt.",
                "name": "number x"
            },
            {
                "descr": "The x-component of the force.",
                "name": "number x"
            },
            {
                "descr": "The y-component of the force.",
                "name": "number y"
            }
        ],
        "path": "love/joint-getreactionforce",
        "syntax": "x, y = Joint:getReactionForce( invdt )",
        "type": "love.physics"
    },
    "Joint:getReactionTorque": {
        "descr": "Returns the reaction torque on the second body.",
        "name": "Joint:getReactionTorque",
        "params": [
            {
                "descr": "How long the force applies. Usually the inverse time step or 1/dt.",
                "name": "number invdt"
            },
            {
                "descr": "The reaction torque on the second body.",
                "name": "number torque"
            }
        ],
        "path": "love/joint-getreactiontorque",
        "syntax": "torque = Joint:getReactionTorque( invdt )",
        "type": "love.physics"
    },
    "Joint:getType": {
        "descr": "Gets a string representing the type.",
        "name": "Joint:getType",
        "params": [
            {
                "descr": "A string with the name of the Joint type.",
                "name": "JointType type"
            }
        ],
        "path": "love/joint-gettype",
        "syntax": "type = Joint:getType( )",
        "type": "love.physics"
    },
    "Joint:getUserData": {
        "descr": "Returns the Lua value associated with this Joint.",
        "name": "Joint:getUserData",
        "params": [
            {
                "descr": "The Lua value associated with the Joint.",
                "name": "mixed value"
            }
        ],
        "path": "love/joint-getuserdata",
        "syntax": "value = Joint:getUserData( )",
        "type": "love.physics"
    },
    "Joint:isDestroyed": {
        "descr": "Gets whether the Joint is destroyed. Destroyed joints cannot be used.",
        "name": "Joint:isDestroyed",
        "params": [
            {
                "descr": "Whether the Joint is destroyed.",
                "name": "boolean destroyed"
            }
        ],
        "path": "love/joint-isdestroyed",
        "syntax": "destroyed = Joint:isDestroyed( )",
        "type": "love.physics"
    },
    "Joint:setCollideConnected": {
        "descr": "Sets whether the connected Bodies should collide with each other.",
        "name": "Joint:setCollideConnected",
        "params": [
            {
                "descr": "True for the Bodies to collide, false otherwise.",
                "name": "boolean collide"
            }
        ],
        "path": "love/joint-setcollideconnected",
        "syntax": "Joint:setCollideConnected( collide )",
        "type": "love.physics"
    },
    "Joint:setUserData": {
        "descr": "Associates a Lua value with the Joint.",
        "name": "Joint:setUserData",
        "params": [
            {
                "descr": "The Lua value to associate with the Joint.",
                "name": "mixed value"
            }
        ],
        "path": "love/joint-setuserdata",
        "syntax": "Joint:setUserData( value )",
        "type": "love.physics"
    },
    "Joystick:getAxes": {
        "descr": "Gets the direction of each axis.",
        "name": "Joystick:getAxes",
        "params": [
            {
                "descr": "Direction of axis1.",
                "name": "number axisDir1"
            },
            {
                "descr": "Direction of axis2.",
                "name": "number axisDir2"
            },
            {
                "descr": "Direction of axisN.",
                "name": "number axisDirN"
            }
        ],
        "path": "love/joystick-getaxes",
        "syntax": "axisDir1, axisDir2, ..., axisDirN = Joystick:getAxes( )",
        "type": "love.joystick"
    },
    "Joystick:getAxis": {
        "descr": "Gets the direction of an axis.",
        "name": "Joystick:getAxis",
        "params": [
            {
                "descr": "The index of the axis to be checked.",
                "name": "number axis"
            },
            {
                "descr": "Current value of the axis.",
                "name": "number direction"
            }
        ],
        "path": "love/joystick-getaxis",
        "syntax": "direction = Joystick:getAxis( axis )",
        "type": "love.joystick"
    },
    "Joystick:getAxisCount": {
        "descr": "Gets the number of axes on the joystick.",
        "name": "Joystick:getAxisCount",
        "params": [
            {
                "descr": "The number of axes available.",
                "name": "number axes"
            }
        ],
        "path": "love/joystick-getaxiscount",
        "syntax": "axes = Joystick:getAxisCount( )",
        "type": "love.joystick"
    },
    "Joystick:getButtonCount": {
        "descr": "Gets the number of buttons on the joystick.",
        "name": "Joystick:getButtonCount",
        "params": [
            {
                "descr": "The number of buttons available.",
                "name": "number buttons"
            }
        ],
        "path": "love/joystick-getbuttoncount",
        "syntax": "buttons = Joystick:getButtonCount( )",
        "type": "love.joystick"
    },
    "Joystick:getGUID": {
        "descr": "Gets a stable GUID unique to the type of the physical joystick which does not change over time. For example, all Sony Dualshock 3 controllers in OS X have the same GUID. The value is platform-dependent.",
        "name": "Joystick:getGUID",
        "params": [
            {
                "descr": "The Joystick type's OS-dependent unique identifier.",
                "name": "string guid"
            }
        ],
        "path": "love/joystick-getguid",
        "syntax": "guid = Joystick:getGUID( )",
        "type": "love.joystick"
    },
    "Joystick:getGamepadAxis": {
        "descr": "Gets the direction of a virtual gamepad axis. If the Joystick isn't recognized as a gamepad or isn't connected, this function will always return 0.",
        "name": "Joystick:getGamepadAxis",
        "params": [
            {
                "descr": "The virtual axis to be checked.",
                "name": "GamepadAxis axis"
            },
            {
                "descr": "Current value of the axis.",
                "name": "number direction"
            }
        ],
        "path": "love/joystick-getgamepadaxis",
        "syntax": "direction = Joystick:getGamepadAxis( axis )",
        "type": "love.joystick"
    },
    "Joystick:getGamepadMapping": {
        "descr": "Gets the button, axis or hat that a virtual gamepad input is bound to.",
        "name": "Joystick:getGamepadMapping",
        "params": [
            {
                "descr": "The virtual gamepad axis to get the binding for.",
                "name": "GamepadAxis axis"
            },
            {
                "descr": "The type of input the virtual gamepad axis is bound to.",
                "name": "JoystickInputType inputtype"
            },
            {
                "descr": "The index of the Joystick's button, axis or hat that the virtual gamepad axis is bound to.",
                "name": "number inputindex"
            },
            {
                "descr": "The direction of the hat, if the virtual gamepad axis is bound to a hat. ",
                "name": "JoystickHat hatdirection (nil)"
            }
        ],
        "path": "love/joystick-getgamepadmapping",
        "syntax": "inputtype, inputindex, hatdirection = Joystick:getGamepadMapping( axis )",
        "type": "love.joystick"
    },
    "Joystick:getHat": {
        "descr": "Gets the direction of the Joystick's hat.",
        "name": "Joystick:getHat",
        "params": [
            {
                "descr": "The index of the hat to be checked.",
                "name": "number hat"
            },
            {
                "descr": "The direction the hat is pushed.",
                "name": "JoystickHat direction"
            }
        ],
        "path": "love/joystick-gethat",
        "syntax": "direction = Joystick:getHat( hat )",
        "type": "love.joystick"
    },
    "Joystick:getHatCount": {
        "descr": "Gets the number of hats on the joystick.",
        "name": "Joystick:getHatCount",
        "params": [
            {
                "descr": "How many hats the joystick has.",
                "name": "number hats"
            }
        ],
        "path": "love/joystick-gethatcount",
        "syntax": "hats = Joystick:getHatCount( )",
        "type": "love.joystick"
    },
    "Joystick:getID": {
        "descr": "Gets the joystick's unique identifier. The identifier will remain the same for the life of the game, even when the Joystick is disconnected and reconnected, but it will change when the game is re-launched.",
        "name": "Joystick:getID",
        "params": [
            {
                "descr": "The Joystick's unique identifier. ",
                "name": "number id"
            },
            {
                "descr": "Unique instance identifier. Changes every time the Joystick is reconnected. ",
                "name": "number instanceid (nil)"
            }
        ],
        "path": "love/joystick-getid",
        "syntax": "id, instanceid = Joystick:getID( )",
        "type": "love.joystick"
    },
    "Joystick:getName": {
        "descr": "Gets the name of the joystick.",
        "name": "Joystick:getName",
        "params": [
            {
                "descr": "The name of the joystick.",
                "name": "string name"
            }
        ],
        "path": "love/joystick-getname",
        "syntax": "name = Joystick:getName( )",
        "type": "love.joystick"
    },
    "Joystick:getVibration": {
        "descr": "Gets the current vibration motor strengths on a Joystick with rumble support.",
        "name": "Joystick:getVibration",
        "params": [
            {
                "descr": "Current strength of the left vibration motor on the Joystick.",
                "name": "number left"
            },
            {
                "descr": "Current strength of the right vibration motor on the Joystick.",
                "name": "number right"
            }
        ],
        "path": "love/joystick-getvibration",
        "syntax": "left, right = Joystick:getVibration( )",
        "type": "love.joystick"
    },
    "Joystick:isConnected": {
        "descr": "Gets whether the Joystick is connected.",
        "name": "Joystick:isConnected",
        "params": [
            {
                "descr": "True if the Joystick is currently connected, false otherwise.",
                "name": "boolean connected"
            }
        ],
        "path": "love/joystick-isconnected",
        "syntax": "connected = Joystick:isConnected( )",
        "type": "love.joystick"
    },
    "Joystick:isDown": {
        "descr": "Checks if a button on the Joystick is pressed.",
        "name": "Joystick:isDown",
        "params": [
            {
                "descr": "The index of a button to check.",
                "name": "number buttonN"
            },
            {
                "descr": "True if any supplied button is down, false if not.",
                "name": "boolean anyDown"
            }
        ],
        "path": "love/joystick-isdown",
        "syntax": "anyDown = Joystick:isDown( buttonN, ... )",
        "type": "love.joystick"
    },
    "Joystick:isGamepad": {
        "descr": "Gets whether the Joystick is recognized as a gamepad. If this is the case, the Joystick's buttons and axes can be used in a standardized manner across different operating systems and joystick models via Joystick:getGamepadAxis, Joystick:isGamepadDown, love.gamepadpressed, and related functions.",
        "name": "Joystick:isGamepad",
        "params": [
            {
                "descr": "True if the Joystick is recognized as a gamepad, false otherwise.",
                "name": "boolean isgamepad"
            }
        ],
        "path": "love/joystick-isgamepad",
        "syntax": "isgamepad = Joystick:isGamepad( )",
        "type": "love.joystick"
    },
    "Joystick:isGamepadDown": {
        "descr": "Checks if a virtual gamepad button on the Joystick is pressed. If the Joystick is not recognized as a Gamepad or isn't connected, then this function will always return false.",
        "name": "Joystick:isGamepadDown",
        "params": [
            {
                "descr": "The gamepad button to check.",
                "name": "GamepadButton buttonN"
            },
            {
                "descr": "True if any supplied button is down, false if not.",
                "name": "boolean anyDown"
            }
        ],
        "path": "love/joystick-isgamepaddown",
        "syntax": "anyDown = Joystick:isGamepadDown( button1, button2, button3, ... )",
        "type": "love.joystick"
    },
    "Joystick:isVibrationSupported": {
        "descr": "Gets whether the Joystick supports vibration.",
        "name": "Joystick:isVibrationSupported",
        "params": [
            {
                "descr": "True if rumble / force feedback vibration is supported on this Joystick, false if not.",
                "name": "boolean supported"
            }
        ],
        "path": "love/joystick-isvibrationsupported",
        "syntax": "supported = Joystick:isVibrationSupported( )",
        "type": "love.joystick"
    },
    "Joystick:setVibration": {
        "descr": "Sets the vibration motor speeds on a Joystick with rumble support. Most common gamepads have this functionality, although not all drivers give proper support. Use Joystick:isVibrationSupported to check.",
        "name": "Joystick:setVibration",
        "params": [
            {
                "descr": "Strength of the left vibration motor on the Joystick. ",
                "name": "number left"
            },
            {
                "descr": "Strength of the right vibration motor on the Joystick. ",
                "name": "number right"
            },
            {
                "descr": "True if the vibration was successfully applied, false if not.",
                "name": "boolean success"
            }
        ],
        "path": "love/joystick-setvibration",
        "syntax": "success = Joystick:setVibration( left, right )",
        "type": "love.joystick"
    },
    "Mesh:attachAttribute": {
        "descr": "Attaches a vertex attribute from a different Mesh onto this Mesh, for use when drawing. This can be used to share vertex attribute data between several different Meshes.",
        "name": "Mesh:attachAttribute",
        "params": [
            {
                "descr": "The name of the vertex attribute to attach.",
                "name": "string name"
            },
            {
                "descr": "The Mesh to get the vertex attribute from.",
                "name": "Mesh mesh"
            }
        ],
        "path": "love/mesh-attachattribute",
        "syntax": "Mesh:attachAttribute( name, mesh )",
        "type": "love.graphics"
    },
    "Mesh:flush": {
        "descr": "Immediately sends all modified vertex data in the Mesh to the graphics card.",
        "name": "Mesh:flush",
        "params": [],
        "path": "love/mesh-flush",
        "syntax": "Mesh:flush( )",
        "type": "love.graphics"
    },
    "Mesh:getDrawMode": {
        "descr": "Gets the mode used when drawing the Mesh.",
        "name": "Mesh:getDrawMode",
        "params": [
            {
                "descr": "The mode used when drawing the Mesh.",
                "name": "MeshDrawMode mode"
            }
        ],
        "path": "love/mesh-getdrawmode",
        "syntax": "mode = Mesh:getDrawMode( )",
        "type": "love.graphics"
    },
    "Mesh:getDrawRange": {
        "descr": "Gets the range of vertices used when drawing the Mesh.",
        "name": "Mesh:getDrawRange",
        "params": [
            {
                "descr": "The index of the first vertex used when drawing, or the index of the first value in the vertex map used if one is set for this Mesh.",
                "name": "number min (nil)"
            },
            {
                "descr": "The index of the last vertex used when drawing, or the index of the last value in the vertex map used if one is set for this Mesh.",
                "name": "number max (nil)"
            }
        ],
        "path": "love/mesh-getdrawrange",
        "syntax": "min, max = Mesh:getDrawRange( )",
        "type": "love.graphics"
    },
    "Mesh:getImage": {
        "descr": "Gets the Image used when drawing the Mesh.",
        "name": "Mesh:getImage",
        "params": [
            {
                "descr": "The Image used to texture the Mesh when drawing. ",
                "name": "Image image (nil)"
            }
        ],
        "path": "love/mesh-getimage",
        "syntax": "image = Mesh:getImage( )",
        "type": "love.graphics"
    },
    "Mesh:getTexture": {
        "descr": "Gets the texture (Image or Canvas) used when drawing the Mesh.",
        "name": "Mesh:getTexture",
        "params": [
            {
                "descr": "The Image or Canvas to texture the Mesh with when drawing, or nil if none is set.",
                "name": "Texture texture (nil)"
            }
        ],
        "path": "love/mesh-gettexture",
        "syntax": "texture = Mesh:getTexture( )",
        "type": "love.graphics"
    },
    "Mesh:getVertex": {
        "descr": "Gets the properties of a vertex in the Mesh.",
        "name": "Mesh:getVertex",
        "params": [
            {
                "descr": "The index of the vertex you want to retrieve the information for.",
                "name": "number index"
            },
            {
                "descr": "The first component of the first vertex attribute in the specified vertex.",
                "name": "number attributecomponent"
            },
            {
                "descr": "Additional components of all vertex attributes in the specified vertex.",
                "name": "number ..."
            }
        ],
        "path": "love/mesh-getvertex",
        "syntax": "attributecomponent, ... = Mesh:getVertex( index )",
        "type": "love.graphics"
    },
    "Mesh:getVertexAttribute": {
        "descr": "Gets the properties of a specific attribute within a vertex in the Mesh.",
        "name": "Mesh:getVertexAttribute",
        "params": [
            {
                "descr": "The index of the the vertex to be modified.",
                "name": "number vertexindex"
            },
            {
                "descr": "The index of the attribute within the vertex to be modified.",
                "name": "number attributeindex"
            },
            {
                "descr": "The value of the first component of the attribute.",
                "name": "number value1"
            },
            {
                "descr": "The value of the second component of the attribute.",
                "name": "number value2"
            },
            {
                "descr": "Any additional vertex attribute components.",
                "name": "number ..."
            }
        ],
        "path": "love/mesh-getvertexattribute",
        "syntax": "value1, value2, ... = Mesh:getVertexAttribute( vertexindex, attributeindex )",
        "type": "love.graphics"
    },
    "Mesh:getVertexCount": {
        "descr": "Gets the total number of vertices in the Mesh.",
        "name": "Mesh:getVertexCount",
        "params": [
            {
                "descr": "The total number of vertices in the mesh.",
                "name": "number count"
            }
        ],
        "path": "love/mesh-getvertexcount",
        "syntax": "count = Mesh:getVertexCount( )",
        "type": "love.graphics"
    },
    "Mesh:getVertexFormat": {
        "descr": "Gets the vertex format that the Mesh was created with.",
        "name": "Mesh:getVertexFormat",
        "params": [
            {
                "descr": "The vertex format of the Mesh, which is a table containing tables for each vertex attribute the Mesh was created with, in the form of {attribute, ...}. ",
                "name": "table format"
            },
            {
                "descr": "Additional vertex attributes in the Mesh.",
                "name": "table ..."
            }
        ],
        "path": "love/mesh-getvertexformat",
        "syntax": "format = Mesh:getVertexFormat( )",
        "type": "love.graphics"
    },
    "Mesh:getVertexMap": {
        "descr": "Gets the vertex map for the Mesh. The vertex map describes the order in which the vertices are used when the Mesh is drawn. The vertices, vertex map, and mesh draw mode work together to determine what exactly is displayed on the screen.",
        "name": "Mesh:getVertexMap",
        "params": [
            {
                "descr": "A table containing the list of vertex indices used when drawing.",
                "name": "table map"
            }
        ],
        "path": "love/mesh-getvertexmap",
        "syntax": "map = Mesh:getVertexMap( )",
        "type": "love.graphics"
    },
    "Mesh:getVertices": {
        "descr": "Gets all the vertices in the Mesh.",
        "name": "Mesh:getVertices",
        "params": [
            {
                "descr": "The table filled with vertex information tables for each vertex as follows:  number [1]  The position of the vertex on the x-axis.",
                "name": "table vertices"
            },
            {
                "descr": "The position of the vertex on the y-axis.",
                "name": "number [2]"
            },
            {
                "descr": "The horizontal component of the texture coordinate. ",
                "name": "number [3]"
            },
            {
                "descr": "The vertical component of the texture coordinate. ",
                "name": "number [4]"
            },
            {
                "descr": "The red color component.",
                "name": "number [5] (255)"
            },
            {
                "descr": "The green color component.",
                "name": "number [6] (255)"
            },
            {
                "descr": "The blue color component.",
                "name": "number [7] (255)"
            },
            {
                "descr": "The alpha color component.",
                "name": "number [8] (255)"
            }
        ],
        "path": "love/mesh-getvertices",
        "syntax": "vertices = Mesh:getVertices( )",
        "type": "love.graphics"
    },
    "Mesh:hasVertexColors": {
        "descr": "Gets whether per-vertex colors are used instead of the constant color when drawing the Mesh (constant color being love.graphics.setColor.)",
        "name": "Mesh:hasVertexColors",
        "params": [
            {
                "descr": "True if per-vertex coloring is used, otherwise love.graphics.setColor is used when drawing the Mesh.",
                "name": "boolean vertexcolors"
            }
        ],
        "path": "love/mesh-hasvertexcolors",
        "syntax": "vertexcolors = Mesh:hasVertexColors( )",
        "type": "love.graphics"
    },
    "Mesh:isAttributeEnabled": {
        "descr": "Gets whether a specific vertex attribute in the Mesh is enabled. Vertex data from disabled attributes is not used when drawing the Mesh.",
        "name": "Mesh:isAttributeEnabled",
        "params": [
            {
                "descr": "The name of the vertex attribute to enable or disable.",
                "name": "string name"
            },
            {
                "descr": "Whether the vertex attribute is used when drawing this Mesh.",
                "name": "boolean enabled"
            }
        ],
        "path": "love/mesh-isattributeenabled",
        "syntax": "enabled = Mesh:isAttributeEnabled( name )",
        "type": "love.graphics"
    },
    "Mesh:setAttributeEnabled": {
        "descr": "Enables or disables a specific vertex attribute in the Mesh. Vertex data from disabled attributes is not used when drawing the Mesh.",
        "name": "Mesh:setAttributeEnabled",
        "params": [
            {
                "descr": "The name of the vertex attribute to enable or disable.",
                "name": "string name"
            },
            {
                "descr": "Whether the vertex attribute is used when drawing this Mesh.",
                "name": "boolean enable"
            }
        ],
        "path": "love/mesh-setattributeenabled",
        "syntax": "Mesh:setAttributeEnabled( name, enable )",
        "type": "love.graphics"
    },
    "Mesh:setDrawMode": {
        "descr": "Sets the mode used when drawing the Mesh.",
        "name": "Mesh:setDrawMode",
        "params": [
            {
                "descr": "The mode to use when drawing the Mesh.",
                "name": "MeshDrawMode mode"
            }
        ],
        "path": "love/mesh-setdrawmode",
        "syntax": "Mesh:setDrawMode( mode )",
        "type": "love.graphics"
    },
    "Mesh:setDrawRange": {
        "descr": "Restricts the drawn vertices of the Mesh to a subset of the total.",
        "name": "Mesh:setDrawRange",
        "params": [
            {
                "descr": "The index of the first vertex to use when drawing, or the index of the first value in the vertex map to use if one is set for this Mesh.",
                "name": "number min"
            },
            {
                "descr": "The index of the last vertex to use when drawing, or the index of the last value in the vertex map to use if one is set for this Mesh.",
                "name": "number max"
            }
        ],
        "path": "love/mesh-setdrawrange",
        "syntax": "Mesh:setDrawRange( min, max )",
        "type": "love.graphics"
    },
    "Mesh:setImage": {
        "descr": "",
        "name": "Mesh:setImage",
        "params": [
            {
                "descr": "The Image to texture the Mesh with when drawing.",
                "name": "Image image"
            }
        ],
        "path": "love/mesh-setimage",
        "syntax": "Mesh:setImage( image )",
        "type": "love.graphics"
    },
    "Mesh:setTexture": {
        "descr": "",
        "name": "Mesh:setTexture",
        "params": [
            {
                "descr": "The Image or Canvas to texture the Mesh with when drawing.",
                "name": "Texture texture"
            }
        ],
        "path": "love/mesh-settexture",
        "syntax": "Mesh:setTexture( texture )",
        "type": "love.graphics"
    },
    "Mesh:setVertex": {
        "descr": "Sets the properties of a vertex in the Mesh.",
        "name": "Mesh:setVertex",
        "params": [
            {
                "descr": "The index of the the vertex you want to modify.",
                "name": "number index"
            },
            {
                "descr": "The first component of the first vertex attribute in the specified vertex.",
                "name": "number attributecomponent"
            },
            {
                "descr": "Additional components of all vertex attributes in the specified vertex.",
                "name": "number ..."
            }
        ],
        "path": "love/mesh-setvertex",
        "syntax": "Mesh:setVertex( index, attributecomponent, ... )",
        "type": "love.graphics"
    },
    "Mesh:setVertexAttribute": {
        "descr": "Sets the properties of a specific attribute within a vertex in the Mesh.",
        "name": "Mesh:setVertexAttribute",
        "params": [
            {
                "descr": "The index of the the vertex to be modified.",
                "name": "number vertexindex"
            },
            {
                "descr": "The index of the attribute within the vertex to be modified.",
                "name": "number attributeindex"
            },
            {
                "descr": "The new value for the first component of the attribute.",
                "name": "number value1"
            },
            {
                "descr": "The new value for the second component of the attribute.",
                "name": "number value2"
            },
            {
                "descr": "Any additional vertex attribute components.",
                "name": "number ..."
            }
        ],
        "path": "love/mesh-setvertexattribute",
        "syntax": "Mesh:setVertexAttribute( vertexindex, attributeindex, value1, value2, ... )",
        "type": "love.graphics"
    },
    "Mesh:setVertexColors": {
        "descr": "Sets whether per-vertex colors are used instead of the constant color when drawing the Mesh (constant color being love.graphics.setColor.)",
        "name": "Mesh:setVertexColors",
        "params": [
            {
                "descr": "True to use per-vertex coloring, otherwise love.graphics.setColor is used when drawing.",
                "name": "boolean on"
            }
        ],
        "path": "love/mesh-setvertexcolors",
        "syntax": "Mesh:setVertexColors( on )",
        "type": "love.graphics"
    },
    "Mesh:setVertexMap": {
        "descr": "Sets the vertex map for the Mesh. The vertex map describes the order in which the vertices are used when the Mesh is drawn. The vertices, vertex map, and mesh draw mode work together to determine what exactly is displayed on the screen.",
        "name": "Mesh:setVertexMap",
        "params": [
            {
                "descr": "A table containing a list of vertex indices to use when drawing. ",
                "name": "table map"
            }
        ],
        "path": "love/mesh-setvertexmap",
        "syntax": "Mesh:setVertexMap( map )",
        "type": "love.graphics"
    },
    "Mesh:setVertices": {
        "descr": "Replaces a range of vertices in the Mesh with new ones. The total number of vertices in a Mesh cannot be changed after it has been created.",
        "name": "Mesh:setVertices",
        "params": [
            {
                "descr": "The table filled with vertex information tables for each vertex, in the form of {vertex, ...} where each vertex is a table in the form of {attributecomponent, ...}. ",
                "name": "table vertices"
            },
            {
                "descr": "Additional components of all vertex attributes in the vertex.",
                "name": "number ..."
            },
            {
                "descr": "The index of the first vertex to replace.",
                "name": "number startvertex (1)"
            }
        ],
        "path": "love/mesh-setvertices",
        "syntax": "Mesh:setVertices( vertices, startvertex )",
        "type": "love.graphics"
    },
    "MotorJoint:getAngularOffset": {
        "descr": "Gets the target angular offset between the two Bodies the Joint is attached to.",
        "name": "MotorJoint:getAngularOffset",
        "params": [
            {
                "descr": "The target angular offset in radians: the second body's angle minus the first body's angle.",
                "name": "number angleoffset"
            }
        ],
        "path": "love/motorjoint-getangularoffset",
        "syntax": "angleoffset = MotorJoint:getAngularOffset( )",
        "type": "love.physics"
    },
    "MotorJoint:getLinearOffset": {
        "descr": "Gets the target linear offset between the two Bodies the Joint is attached to.",
        "name": "MotorJoint:getLinearOffset",
        "params": [
            {
                "descr": "The x component of the target linear offset, relative to the first Body.",
                "name": "number x"
            },
            {
                "descr": "The y component of the target linear offset, relative to the first Body.",
                "name": "number y"
            }
        ],
        "path": "love/motorjoint-getlinearoffset",
        "syntax": "x, y = MotorJoint:getLinearOffset( )",
        "type": "love.physics"
    },
    "MotorJoint:setAngularOffset": {
        "descr": "Sets the target angluar offset between the two Bodies the Joint is attached to.",
        "name": "MotorJoint:setAngularOffset",
        "params": [
            {
                "descr": "The target angular offset in radians: the second body's angle minus the first body's angle.",
                "name": "number angleoffset"
            }
        ],
        "path": "love/motorjoint-setangularoffset",
        "syntax": "MotorJoint:setAngularOffset( angleoffset )",
        "type": "love.physics"
    },
    "MotorJoint:setLinearOffset": {
        "descr": "Sets the target linear offset between the two Bodies the Joint is attached to.",
        "name": "MotorJoint:setLinearOffset",
        "params": [
            {
                "descr": "The x component of the target linear offset, relative to the first Body.",
                "name": "number x"
            },
            {
                "descr": "The y component of the target linear offset, relative to the first Body.",
                "name": "number y"
            }
        ],
        "path": "love/motorjoint-setlinearoffset",
        "syntax": "MotorJoint:setLinearOffset( x, y )",
        "type": "love.physics"
    },
    "MouseJoint:getDampingRatio": {
        "descr": "Returns the damping ratio.",
        "name": "MouseJoint:getDampingRatio",
        "params": [
            {
                "descr": "The new damping ratio.",
                "name": "number ratio"
            }
        ],
        "path": "love/mousejoint-getdampingratio",
        "syntax": "ratio = MouseJoint:getDampingRatio( )",
        "type": "love.physics"
    },
    "MouseJoint:getFrequency": {
        "descr": "Returns the frequency.",
        "name": "MouseJoint:getFrequency",
        "params": [
            {
                "descr": "The frequency in hertz.",
                "name": "number freq"
            }
        ],
        "path": "love/mousejoint-getfrequency",
        "syntax": "freq = MouseJoint:getFrequency( )",
        "type": "love.physics"
    },
    "MouseJoint:getMaxForce": {
        "descr": "Gets the highest allowed force.",
        "name": "MouseJoint:getMaxForce",
        "params": [
            {
                "descr": "The max allowed force.",
                "name": "number f"
            }
        ],
        "path": "love/mousejoint-getmaxforce",
        "syntax": "f = MouseJoint:getMaxForce( )",
        "type": "love.physics"
    },
    "MouseJoint:getTarget": {
        "descr": "Gets the target point.",
        "name": "MouseJoint:getTarget",
        "params": [
            {
                "descr": "The x-component of the target.",
                "name": "number x"
            },
            {
                "descr": "The x-component of the target.",
                "name": "number y"
            }
        ],
        "path": "love/mousejoint-gettarget",
        "syntax": "x, y = MouseJoint:getTarget( )",
        "type": "love.physics"
    },
    "MouseJoint:setDampingRatio": {
        "descr": "Sets a new damping ratio.",
        "name": "MouseJoint:setDampingRatio",
        "params": [
            {
                "descr": "The new damping ratio.",
                "name": "number ratio"
            }
        ],
        "path": "love/mousejoint-setdampingratio",
        "syntax": "MouseJoint:setDampingRatio( ratio )",
        "type": "love.physics"
    },
    "MouseJoint:setFrequency": {
        "descr": "Sets a new frequency.",
        "name": "MouseJoint:setFrequency",
        "params": [
            {
                "descr": "The new frequency in hertz.",
                "name": "number freq"
            }
        ],
        "path": "love/mousejoint-setfrequency",
        "syntax": "MouseJoint:setFrequency( freq )",
        "type": "love.physics"
    },
    "MouseJoint:setMaxForce": {
        "descr": "Sets the highest allowed force.",
        "name": "MouseJoint:setMaxForce",
        "params": [
            {
                "descr": "The max allowed force.",
                "name": "number f"
            }
        ],
        "path": "love/mousejoint-setmaxforce",
        "syntax": "MouseJoint:setMaxForce( f )",
        "type": "love.physics"
    },
    "MouseJoint:setTarget": {
        "descr": "Sets the target point.",
        "name": "MouseJoint:setTarget",
        "params": [
            {
                "descr": "The x-component of the target.",
                "name": "number x"
            },
            {
                "descr": "The y-component of the target.",
                "name": "number y"
            }
        ],
        "path": "love/mousejoint-settarget",
        "syntax": "MouseJoint:setTarget( x, y )",
        "type": "love.physics"
    },
    "Object:type": {
        "descr": "Gets the type of the object as a string.",
        "name": "Object:type",
        "params": [
            {
                "descr": "The type as a string.",
                "name": "string type"
            }
        ],
        "path": "love/object-type",
        "syntax": "type = Object:type()",
        "type": "love"
    },
    "Object:typeOf": {
        "descr": "Checks whether an object is of a certain type. If the object has the type with the specified name in its hierarchy, this function will return true.",
        "name": "Object:typeOf",
        "params": [
            {
                "descr": "The name of the type to check for.",
                "name": "string name"
            },
            {
                "descr": "True if the object is of the specified type, false otherwise.",
                "name": "boolean b"
            }
        ],
        "path": "love/object-typeof",
        "syntax": "b = Object:typeOf( name )",
        "type": "love"
    },
    "ParticleSystem:clone": {
        "descr": "Creates an identical copy of the ParticleSystem in the stopped state.",
        "name": "ParticleSystem:clone",
        "params": [
            {
                "descr": "The new identical copy of this ParticleSystem.",
                "name": "ParticleSystem particlesystem"
            }
        ],
        "path": "love/particlesystem-clone",
        "syntax": "particlesystem = ParticleSystem:clone( )",
        "type": "love.graphics"
    },
    "ParticleSystem:count": {
        "descr": "Gets the amount of particles that are currently in the system.",
        "name": "ParticleSystem:count",
        "params": [
            {
                "descr": "The current number of live particles.",
                "name": "number count"
            }
        ],
        "path": "love/particlesystem-count",
        "syntax": "count = ParticleSystem:count( )",
        "type": "love.graphics"
    },
    "ParticleSystem:emit": {
        "descr": "Emits a burst of particles from the particle emitter.",
        "name": "ParticleSystem:emit",
        "params": [
            {
                "descr": "The amount of particles to emit. ",
                "name": "number numparticles"
            }
        ],
        "path": "love/particlesystem-emit",
        "syntax": "ParticleSystem:emit( numparticles )",
        "type": "love.graphics"
    },
    "ParticleSystem:getAreaSpread": {
        "descr": "Gets the area-based spawn parameters for the particles.",
        "name": "ParticleSystem:getAreaSpread",
        "params": [
            {
                "descr": "The type of distribution for new particles.",
                "name": "AreaSpreadDistribution distribution"
            },
            {
                "descr": "The maximum spawn distance from the emitter along the x-axis for uniform distribution, or the standard deviation along the x-axis for normal distribution.",
                "name": "number dx"
            },
            {
                "descr": "The maximum spawn distance from the emitter along the y-axis for uniform distribution, or the standard deviation along the y-axis for normal distribution.",
                "name": "number dy"
            }
        ],
        "path": "love/particlesystem-getareaspread",
        "syntax": "distribution, dx, dy = ParticleSystem:getAreaSpread( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getBufferSize": {
        "descr": "Gets the maximum number of particles the ParticleSystem can have at once.",
        "name": "ParticleSystem:getBufferSize",
        "params": [
            {
                "descr": "The maximum number of particles.",
                "name": "number size"
            }
        ],
        "path": "love/particlesystem-getbuffersize",
        "syntax": "size = ParticleSystem:getBufferSize( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getColors": {
        "descr": "Gets the series of colors applied to the particle sprite.",
        "name": "ParticleSystem:getColors",
        "params": [
            {
                "descr": "First color, red component (0-255).",
                "name": "number r1"
            },
            {
                "descr": "First color, green component (0-255).",
                "name": "number g1"
            },
            {
                "descr": "First color, blue component (0-255).",
                "name": "number b1"
            },
            {
                "descr": "First color, alpha component (0-255).",
                "name": "number a1"
            },
            {
                "descr": "Second color, red component (0-255).",
                "name": "number r2"
            },
            {
                "descr": "Second color, green component (0-255).",
                "name": "number g2"
            },
            {
                "descr": "Second color, blue component (0-255).",
                "name": "number b2"
            },
            {
                "descr": "Second color, alpha component (0-255).",
                "name": "number a2"
            },
            {
                "descr": "Eighth color, red component (0-255).",
                "name": "number r8"
            },
            {
                "descr": "Eighth color, green component (0-255).",
                "name": "number g8"
            },
            {
                "descr": "Eighth color, blue component (0-255).",
                "name": "number b8"
            },
            {
                "descr": "Eighth color, alpha component (0-255).",
                "name": "number a8"
            }
        ],
        "path": "love/particlesystem-getcolors",
        "syntax": "r1, g1, b1, a1, r2, g2, b2, a2, ..., r8, g8, b8, a8 = ParticleSystem:getColors( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getCount": {
        "descr": "Gets the number of particles that are currently in the system.",
        "name": "ParticleSystem:getCount",
        "params": [
            {
                "descr": "The current number of live particles.",
                "name": "number count"
            }
        ],
        "path": "love/particlesystem-getcount",
        "syntax": "count = ParticleSystem:getCount( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getDirection": {
        "descr": "Gets the direction of the particle emitter (in radians).",
        "name": "ParticleSystem:getDirection",
        "params": [
            {
                "descr": "The direction of the emitter (radians).",
                "name": "number direction"
            }
        ],
        "path": "love/particlesystem-getdirection",
        "syntax": "direction = ParticleSystem:getDirection( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getEmissionRate": {
        "descr": "Gets the amount of particles emitted per second.",
        "name": "ParticleSystem:getEmissionRate",
        "params": [
            {
                "descr": "The amount of particles per second.",
                "name": "number rate"
            }
        ],
        "path": "love/particlesystem-getemissionrate",
        "syntax": "rate = ParticleSystem:getEmissionRate( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getEmitterLifetime": {
        "descr": "Gets how long the particle system will emit particles (if -1 then it emits particles forever).",
        "name": "ParticleSystem:getEmitterLifetime",
        "params": [
            {
                "descr": "The lifetime of the emitter (in seconds).",
                "name": "number life"
            }
        ],
        "path": "love/particlesystem-getemitterlifetime",
        "syntax": "life = ParticleSystem:getEmitterLifetime( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getImage": {
        "descr": "Gets the image used for the particles.",
        "name": "ParticleSystem:getImage",
        "params": [
            {
                "descr": "An Image to use for the particles.",
                "name": "Image image"
            }
        ],
        "path": "love/particlesystem-getimage",
        "syntax": "image = ParticleSystem:getImage( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getInsertMode": {
        "descr": "Gets the mode used when the ParticleSystem adds new particles.",
        "name": "ParticleSystem:getInsertMode",
        "params": [
            {
                "descr": "The mode used when the ParticleSystem adds new particles.",
                "name": "ParticleInsertMode mode"
            }
        ],
        "path": "love/particlesystem-getinsertmode",
        "syntax": "mode = ParticleSystem:getInsertMode( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getLinearAcceleration": {
        "descr": "Gets the linear acceleration (acceleration along the x and y axes) for particles.",
        "name": "ParticleSystem:getLinearAcceleration",
        "params": [
            {
                "descr": "The minimum acceleration along the x axis.",
                "name": "number xmin"
            },
            {
                "descr": "The minimum acceleration along the y axis.",
                "name": "number ymin"
            },
            {
                "descr": "The maximum acceleration along the x axis.",
                "name": "number xmax (xmin)"
            },
            {
                "descr": "The maximum acceleration along the y axis.",
                "name": "number ymax (ymin)"
            }
        ],
        "path": "love/particlesystem-getlinearacceleration",
        "syntax": "xmin, ymin, xmax, ymax = ParticleSystem:getLinearAcceleration( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getLinearDamping": {
        "descr": "Gets the amount of linear damping (constant deceleration) for particles.",
        "name": "ParticleSystem:getLinearDamping",
        "params": [
            {
                "descr": "The minimum amount of linear damping applied to particles.",
                "name": "number min"
            },
            {
                "descr": "The maximum amount of linear damping applied to particles.",
                "name": "number max"
            }
        ],
        "path": "love/particlesystem-getlineardamping",
        "syntax": "min, max = ParticleSystem:getLinearDamping( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getOffset": {
        "descr": "Gets the particle image's draw offset.",
        "name": "ParticleSystem:getOffset",
        "params": [
            {
                "descr": "The x coordinate of the particle image's draw offset.",
                "name": "number ox"
            },
            {
                "descr": "The y coordinate of the particle image's draw offset.",
                "name": "number oy"
            }
        ],
        "path": "love/particlesystem-getoffset",
        "syntax": "ox, oy = ParticleSystem:getOffset( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getOffsetX": {
        "descr": "Get the x coordinate of the particle rotation offset.",
        "name": "ParticleSystem:getOffsetX",
        "params": [
            {
                "descr": "The x coordinate of the rotation offset.",
                "name": "number xOffset"
            }
        ],
        "path": "love/particlesystem-getoffsetx",
        "syntax": "xOffset = ParticleSystem:getOffsetX( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getOffsetY": {
        "descr": "Get the y coordinate of the particle rotation offset.",
        "name": "ParticleSystem:getOffsetY",
        "params": [
            {
                "descr": "The y coordinate of the rotation offset.",
                "name": "number yOffset"
            }
        ],
        "path": "love/particlesystem-getoffsety",
        "syntax": "yOffset = ParticleSystem:getOffsetY( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getParticleLifetime": {
        "descr": "Gets the lifetime of the particles.",
        "name": "ParticleSystem:getParticleLifetime",
        "params": [
            {
                "descr": "The minimum life of the particles (in seconds).",
                "name": "number min"
            },
            {
                "descr": "The maximum life of the particles (in seconds).",
                "name": "number max"
            }
        ],
        "path": "love/particlesystem-getparticlelifetime",
        "syntax": "min, max = ParticleSystem:getParticleLifetime( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getPosition": {
        "descr": "Gets the position of the emitter.",
        "name": "ParticleSystem:getPosition",
        "params": [
            {
                "descr": "Position along x-axis.",
                "name": "number x"
            },
            {
                "descr": "Position along y-axis.",
                "name": "number y"
            }
        ],
        "path": "love/particlesystem-getposition",
        "syntax": "x, y = ParticleSystem:getPosition( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getRadialAcceleration": {
        "descr": "Gets the radial acceleration (away from the emitter).",
        "name": "ParticleSystem:getRadialAcceleration",
        "params": [
            {
                "descr": "The minimum acceleration.",
                "name": "number min"
            },
            {
                "descr": "The maximum acceleration.",
                "name": "number max"
            }
        ],
        "path": "love/particlesystem-getradialacceleration",
        "syntax": "min, max = ParticleSystem:getRadialAcceleration( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getRotation": {
        "descr": "Gets the rotation of the image upon particle creation (in radians).",
        "name": "ParticleSystem:getRotation",
        "params": [
            {
                "descr": "The minimum initial angle (radians).",
                "name": "number min"
            },
            {
                "descr": "The maximum initial angle (radians).",
                "name": "number max"
            }
        ],
        "path": "love/particlesystem-getrotation",
        "syntax": "min, max = ParticleSystem:getRotation( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getSizeVariation": {
        "descr": "Gets the amount of size variation (0 meaning no variation and 1 meaning full variation between start and end).",
        "name": "ParticleSystem:getSizeVariation",
        "params": [
            {
                "descr": "The amount of variation (0 meaning no variation and 1 meaning full variation between start and end).",
                "name": "number variation"
            }
        ],
        "path": "love/particlesystem-getsizevariation",
        "syntax": "variation = ParticleSystem:getSizeVariation( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getSizes": {
        "descr": "Gets the series of sizes by which the sprite is scaled. 1.0 is normal size. The particle system will interpolate between each size evenly over the particle's lifetime.",
        "name": "ParticleSystem:getSizes",
        "params": [
            {
                "descr": "The first size.",
                "name": "number size1"
            },
            {
                "descr": "The second size.",
                "name": "number size2"
            },
            {
                "descr": "The eighth size.",
                "name": "number size8"
            }
        ],
        "path": "love/particlesystem-getsizes",
        "syntax": "size1, size1, ..., size8 = ParticleSystem:getSizes( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getSpeed": {
        "descr": "Gets the speed of the particles.",
        "name": "ParticleSystem:getSpeed",
        "params": [
            {
                "descr": "The minimum linear speed of the particles.",
                "name": "number min"
            },
            {
                "descr": "The maximum linear speed of the particles.",
                "name": "number max"
            }
        ],
        "path": "love/particlesystem-getspeed",
        "syntax": "min, max = ParticleSystem:getSpeed( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getSpin": {
        "descr": "Gets the spin of the sprite.",
        "name": "ParticleSystem:getSpin",
        "params": [
            {
                "descr": "The minimum spin (radians per second).",
                "name": "number min"
            },
            {
                "descr": "The maximum spin (radians per second).",
                "name": "number max (min)"
            },
            {
                "descr": "The degree of variation (0 meaning no variation and 1 meaning full variation between start and end).",
                "name": "number variation (0)"
            }
        ],
        "path": "love/particlesystem-getspin",
        "syntax": "min, max, variation = ParticleSystem:getSpin( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getSpinVariation": {
        "descr": "Gets the amount of spin variation (0 meaning no variation and 1 meaning full variation between start and end).",
        "name": "ParticleSystem:getSpinVariation",
        "params": [
            {
                "descr": "The amount of variation (0 meaning no variation and 1 meaning full variation between start and end).",
                "name": "number variation"
            }
        ],
        "path": "love/particlesystem-getspinvariation",
        "syntax": "variation = ParticleSystem:getSpinVariation( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getSpread": {
        "descr": "Gets the amount of directional spread of the particle emitter (in radians).",
        "name": "ParticleSystem:getSpread",
        "params": [
            {
                "descr": "The spread of the emitter (radians).",
                "name": "number spread"
            }
        ],
        "path": "love/particlesystem-getspread",
        "syntax": "spread = ParticleSystem:getSpread( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getTangentialAcceleration": {
        "descr": "Gets the tangential acceleration (acceleration perpendicular to the particle's direction).",
        "name": "ParticleSystem:getTangentialAcceleration",
        "params": [
            {
                "descr": "The minimum acceleration.",
                "name": "number min"
            },
            {
                "descr": "The maximum acceleration.",
                "name": "number max"
            }
        ],
        "path": "love/particlesystem-gettangentialacceleration",
        "syntax": "min, max = ParticleSystem:getTangentialAcceleration( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getTexture": {
        "descr": "Gets the texture (Image or Canvas) used for the particles.",
        "name": "ParticleSystem:getTexture",
        "params": [
            {
                "descr": "The Image or Canvas used for the particles.",
                "name": "Texture texture"
            }
        ],
        "path": "love/particlesystem-gettexture",
        "syntax": "texture = ParticleSystem:getTexture( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getX": {
        "descr": "Gets the x-coordinate of the particle emitter's position.",
        "name": "ParticleSystem:getX",
        "params": [
            {
                "descr": "Position along x-axis.",
                "name": "number x"
            }
        ],
        "path": "love/particlesystem-getx",
        "syntax": "x = ParticleSystem:getX( )",
        "type": "love.graphics"
    },
    "ParticleSystem:getY": {
        "descr": "Gets the y-coordinate of the particle emitter's position.",
        "name": "ParticleSystem:getY",
        "params": [
            {
                "descr": "Position along y-axis.",
                "name": "number y"
            }
        ],
        "path": "love/particlesystem-gety",
        "syntax": "y = ParticleSystem:getY( )",
        "type": "love.graphics"
    },
    "ParticleSystem:hasRelativeRotation": {
        "descr": "Gets whether particle angles and rotations are relative to their velocities. If enabled, particles are aligned to the angle of their velocities and rotate relative to that angle.",
        "name": "ParticleSystem:hasRelativeRotation",
        "params": [
            {
                "descr": "True if relative particle rotation is enabled, false if it's disabled.",
                "name": "boolean enable"
            }
        ],
        "path": "love/particlesystem-hasrelativerotation",
        "syntax": "relative = ParticleSystem:hasRelativeRotation( )",
        "type": "love.graphics"
    },
    "ParticleSystem:isActive": {
        "descr": "Checks whether the particle system is actively emitting particles.",
        "name": "ParticleSystem:isActive",
        "params": [
            {
                "descr": "True if system is active, false otherwise.",
                "name": "boolean active"
            }
        ],
        "path": "love/particlesystem-isactive",
        "syntax": "active = ParticleSystem:isActive( )",
        "type": "love.graphics"
    },
    "ParticleSystem:isEmpty": {
        "descr": "Checks whether the particle system is empty of particles.",
        "name": "ParticleSystem:isEmpty",
        "params": [
            {
                "descr": "True if there are no live particles, false otherwise.",
                "name": "boolean empty"
            }
        ],
        "path": "love/particlesystem-isempty",
        "syntax": "empty = ParticleSystem:isEmpty( )",
        "type": "love.graphics"
    },
    "ParticleSystem:isFull": {
        "descr": "Checks whether the particle system is full of particles.",
        "name": "ParticleSystem:isFull",
        "params": [
            {
                "descr": "True if no more particles can be added, false otherwise.",
                "name": "boolean full"
            }
        ],
        "path": "love/particlesystem-isfull",
        "syntax": "full = ParticleSystem:isFull( )",
        "type": "love.graphics"
    },
    "ParticleSystem:isPaused": {
        "descr": "Checks whether the particle system is paused.",
        "name": "ParticleSystem:isPaused",
        "params": [
            {
                "descr": "True if system is paused, false otherwise.",
                "name": "boolean paused"
            }
        ],
        "path": "love/particlesystem-ispaused",
        "syntax": "paused = ParticleSystem:isPaused( )",
        "type": "love.graphics"
    },
    "ParticleSystem:isStopped": {
        "descr": "Checks whether the particle system is stopped.",
        "name": "ParticleSystem:isStopped",
        "params": [
            {
                "descr": "True if system is stopped, false otherwise.",
                "name": "boolean stopped"
            }
        ],
        "path": "love/particlesystem-isstopped",
        "syntax": "stopped = ParticleSystem:isStopped( )",
        "type": "love.graphics"
    },
    "ParticleSystem:moveTo": {
        "descr": "Moves the position of the emitter. This results in smoother particle spawning behaviour than if ParticleSystem:setPosition is used every frame.",
        "name": "ParticleSystem:moveTo",
        "params": [
            {
                "descr": "Position along x-axis.",
                "name": "number x"
            },
            {
                "descr": "Position along y-axis.",
                "name": "number y"
            }
        ],
        "path": "love/particlesystem-moveto",
        "syntax": "ParticleSystem:moveTo( x, y )",
        "type": "love.graphics"
    },
    "ParticleSystem:pause": {
        "descr": "Pauses the particle emitter.",
        "name": "ParticleSystem:pause",
        "params": [],
        "path": "love/particlesystem-pause",
        "syntax": "ParticleSystem:pause( )",
        "type": "love.graphics"
    },
    "ParticleSystem:reset": {
        "descr": "Resets the particle emitter, removing any existing particles and resetting the lifetime counter.",
        "name": "ParticleSystem:reset",
        "params": [],
        "path": "love/particlesystem-reset",
        "syntax": "ParticleSystem:reset( )",
        "type": "love.graphics"
    },
    "ParticleSystem:setAreaSpread": {
        "descr": "Sets area-based spawn parameters for the particles. Newly created particles will spawn in an area around the emitter based on the parameters to this function.",
        "name": "ParticleSystem:setAreaSpread",
        "params": [
            {
                "descr": "The type of distribution for new particles.",
                "name": "AreaSpreadDistribution distribution"
            },
            {
                "descr": "The maximum spawn distance from the emitter along the x-axis for uniform distribution, or the standard deviation along the x-axis for normal distribution.",
                "name": "number dx"
            },
            {
                "descr": "The maximum spawn distance from the emitter along the y-axis for uniform distribution, or the standard deviation along the y-axis for normal distribution.",
                "name": "number dy"
            }
        ],
        "path": "love/particlesystem-setareaspread",
        "syntax": "ParticleSystem:setAreaSpread( distribution, dx, dy )",
        "type": "love.graphics"
    },
    "ParticleSystem:setBufferSize": {
        "descr": "Sets the size of the buffer (the max allowed amount of particles in the system).",
        "name": "ParticleSystem:setBufferSize",
        "params": [
            {
                "descr": "The buffer size.",
                "name": "number size"
            }
        ],
        "path": "love/particlesystem-setbuffersize",
        "syntax": "ParticleSystem:setBufferSize( size )",
        "type": "love.graphics"
    },
    "ParticleSystem:setColor": {
        "descr": "Sets the color of the image.",
        "name": "ParticleSystem:setColor",
        "params": [
            {
                "descr": "Start color, red component (0-255).",
                "name": "number r1"
            },
            {
                "descr": "Start color, green component (0-255).",
                "name": "number g1"
            },
            {
                "descr": "Start color, blue component (0-255).",
                "name": "number b1"
            },
            {
                "descr": "Start color, alpha component (0-255).",
                "name": "number a1"
            },
            {
                "descr": "End color, red component (0-255).",
                "name": "number r2 (r1)"
            },
            {
                "descr": "End color, green component (0-255).",
                "name": "number g2 (g1)"
            },
            {
                "descr": "End color, blue component (0-255).",
                "name": "number b2 (b1)"
            },
            {
                "descr": "End color, alpha component (0-255).",
                "name": "number a2 (a1)"
            }
        ],
        "path": "love/particlesystem-setcolor",
        "syntax": "ParticleSystem:setColor( r1, g1, b1, a1, r2, g2, b2, a2 )",
        "type": "love.graphics"
    },
    "ParticleSystem:setColors": {
        "descr": "Sets a series of colors to apply to the particle sprite. The particle system will interpolate between each color evenly over the particle's lifetime.",
        "name": "ParticleSystem:setColors",
        "params": [
            {
                "descr": "First color, red component (0-255).",
                "name": "number r1"
            },
            {
                "descr": "First color, green component (0-255).",
                "name": "number g1"
            },
            {
                "descr": "First color, blue component (0-255).",
                "name": "number b1"
            },
            {
                "descr": "First color, alpha component (0-255).",
                "name": "number a1"
            },
            {
                "descr": "Second color, red component (0-255).",
                "name": "number r2"
            },
            {
                "descr": "Second color, green component (0-255).",
                "name": "number g2"
            },
            {
                "descr": "Second color, blue component (0-255).",
                "name": "number b2"
            },
            {
                "descr": "Second color, alpha component (0-255).",
                "name": "number a2"
            },
            {
                "descr": "Eighth color, red component (0-255).",
                "name": "number r8"
            },
            {
                "descr": "Eighth color, green component (0-255).",
                "name": "number g8"
            },
            {
                "descr": "Eighth color, blue component (0-255).",
                "name": "number b8"
            },
            {
                "descr": "Eighth color, alpha component (0-255).",
                "name": "number a8"
            }
        ],
        "path": "love/particlesystem-setcolors",
        "syntax": "ParticleSystem:setColors( r1, g1, b1, a1, r2, g2, b2, a2, ..., r8, g8, b8, a8 )",
        "type": "love.graphics"
    },
    "ParticleSystem:setDirection": {
        "descr": "Sets the direction the particles will be emitted in.",
        "name": "ParticleSystem:setDirection",
        "params": [
            {
                "descr": "The direction of the particles (in radians).",
                "name": "number direction"
            }
        ],
        "path": "love/particlesystem-setdirection",
        "syntax": "ParticleSystem:setDirection( direction )",
        "type": "love.graphics"
    },
    "ParticleSystem:setEmissionRate": {
        "descr": "Sets the amount of particles emitted per second.",
        "name": "ParticleSystem:setEmissionRate",
        "params": [
            {
                "descr": "The amount of particles per second.",
                "name": "number rate"
            }
        ],
        "path": "love/particlesystem-setemissionrate",
        "syntax": "ParticleSystem:setEmissionRate( rate )",
        "type": "love.graphics"
    },
    "ParticleSystem:setEmitterLifetime": {
        "descr": "Sets how long the particle system should emit particles (if -1 then it emits particles forever).",
        "name": "ParticleSystem:setEmitterLifetime",
        "params": [
            {
                "descr": "The lifetime of the emitter (in seconds).",
                "name": "number life"
            }
        ],
        "path": "love/particlesystem-setemitterlifetime",
        "syntax": "ParticleSystem:setEmitterLifetime( life )",
        "type": "love.graphics"
    },
    "ParticleSystem:setGravity": {
        "descr": "Sets the gravity affecting the particles (acceleration along the y-axis). Every particle created will have a gravity between min and max.",
        "name": "ParticleSystem:setGravity",
        "params": [
            {
                "descr": "The minimum gravity.",
                "name": "number min"
            },
            {
                "descr": "The maximum gravity.",
                "name": "number max (min)"
            }
        ],
        "path": "love/particlesystem-setgravity",
        "syntax": "ParticleSystem:setGravity( min, max )",
        "type": "love.graphics"
    },
    "ParticleSystem:setImage": {
        "descr": "Sets the image to be used for the particles.",
        "name": "ParticleSystem:setImage",
        "params": [
            {
                "descr": "An Image to use for the particles.",
                "name": "Image image"
            }
        ],
        "path": "love/particlesystem-setimage",
        "syntax": "ParticleSystem:setImage( image )",
        "type": "love.graphics"
    },
    "ParticleSystem:setInsertMode": {
        "descr": "Sets the mode to use when the ParticleSystem adds new particles.",
        "name": "ParticleSystem:setInsertMode",
        "params": [
            {
                "descr": "The mode to use when the ParticleSystem adds new particles.",
                "name": "ParticleInsertMode mode"
            }
        ],
        "path": "love/particlesystem-setinsertmode",
        "syntax": "ParticleSystem:setInsertMode( mode )",
        "type": "love.graphics"
    },
    "ParticleSystem:setLifetime": {
        "descr": "Sets how long the particle system should emit particles (if -1 then it emits particles forever).",
        "name": "ParticleSystem:setLifetime",
        "params": [
            {
                "descr": "The lifetime of the emitter (in seconds).",
                "name": "number life"
            }
        ],
        "path": "love/particlesystem-setlifetime",
        "syntax": "ParticleSystem:setLifetime( life )",
        "type": "love.graphics"
    },
    "ParticleSystem:setLinearAcceleration": {
        "descr": "Sets the linear acceleration (acceleration along the x and y axes) for particles.",
        "name": "ParticleSystem:setLinearAcceleration",
        "params": [
            {
                "descr": "The minimum acceleration along the x axis.",
                "name": "number xmin"
            },
            {
                "descr": "The minimum acceleration along the y axis.",
                "name": "number ymin"
            },
            {
                "descr": "The maximum acceleration along the x axis.",
                "name": "number xmax (xmin)"
            },
            {
                "descr": "The maximum acceleration along the y axis.",
                "name": "number ymax (ymin)"
            }
        ],
        "path": "love/particlesystem-setlinearacceleration",
        "syntax": "ParticleSystem:setLinearAcceleration( xmin, ymin, xmax, ymax )",
        "type": "love.graphics"
    },
    "ParticleSystem:setLinearDamping": {
        "descr": "Sets the amount of linear damping (constant deceleration) for particles.",
        "name": "ParticleSystem:setLinearDamping",
        "params": [
            {
                "descr": "The minimum amount of linear damping applied to particles.",
                "name": "number min"
            },
            {
                "descr": "The maximum amount of linear damping applied to particles.",
                "name": "number max (min)"
            }
        ],
        "path": "love/particlesystem-setlineardamping",
        "syntax": "ParticleSystem:setLinearDamping( min, max )",
        "type": "love.graphics"
    },
    "ParticleSystem:setOffset": {
        "descr": "Set the offset position which the particle sprite is rotated around. If this function is not used, the particles rotate around their center.",
        "name": "ParticleSystem:setOffset",
        "params": [
            {
                "descr": "The x coordinate of the rotation offset.",
                "name": "number x"
            },
            {
                "descr": "The y coordinate of the rotation offset.",
                "name": "number y"
            }
        ],
        "path": "love/particlesystem-setoffset",
        "syntax": "ParticleSystem:setOffset( x, y )",
        "type": "love.graphics"
    },
    "ParticleSystem:setParticleLife": {
        "descr": "Sets the life of the particles.",
        "name": "ParticleSystem:setParticleLife",
        "params": [
            {
                "descr": "The minimum life of the particles (seconds).",
                "name": "number min"
            },
            {
                "descr": "The maximum life of the particles (seconds).",
                "name": "number max (min)"
            }
        ],
        "path": "love/particlesystem-setparticlelife",
        "syntax": "ParticleSystem:setParticleLife( min, max )",
        "type": "love.graphics"
    },
    "ParticleSystem:setParticleLifetime": {
        "descr": "Sets the lifetime of the particles.",
        "name": "ParticleSystem:setParticleLifetime",
        "params": [
            {
                "descr": "The minimum life of the particles (in seconds).",
                "name": "number min"
            },
            {
                "descr": "The maximum life of the particles (in seconds).",
                "name": "number max (min)"
            }
        ],
        "path": "love/particlesystem-setparticlelifetime",
        "syntax": "ParticleSystem:setParticleLifetime( min, max )",
        "type": "love.graphics"
    },
    "ParticleSystem:setPosition": {
        "descr": "Sets the position of the emitter.",
        "name": "ParticleSystem:setPosition",
        "params": [
            {
                "descr": "Position along x-axis.",
                "name": "number x"
            },
            {
                "descr": "Position along y-axis.",
                "name": "number y"
            }
        ],
        "path": "love/particlesystem-setposition",
        "syntax": "ParticleSystem:setPosition( x, y )",
        "type": "love.graphics"
    },
    "ParticleSystem:setQuads": {
        "descr": "Sets a series of Quads to use for the particle sprites. Particles will choose a Quad from the list based on the particle's current lifetime, allowing for the use of animated sprite sheets with ParticleSystems.",
        "name": "ParticleSystem:setQuads",
        "params": [
            {
                "descr": "The first Quad to use.",
                "name": "Quad quad1"
            },
            {
                "descr": "The second Quad to use.",
                "name": "Quad quad2"
            }
        ],
        "path": "love/particlesystem-setquads",
        "syntax": "ParticleSystem:setQuads( quad1, quad2, ... )",
        "type": "love.graphics"
    },
    "ParticleSystem:setRadialAcceleration": {
        "descr": "Set the radial acceleration (away from the emitter).",
        "name": "ParticleSystem:setRadialAcceleration",
        "params": [
            {
                "descr": "The minimum acceleration.",
                "name": "number min"
            },
            {
                "descr": "The maximum acceleration.",
                "name": "number max (min)"
            }
        ],
        "path": "love/particlesystem-setradialacceleration",
        "syntax": "ParticleSystem:setRadialAcceleration( min, max )",
        "type": "love.graphics"
    },
    "ParticleSystem:setRelativeRotation": {
        "descr": "Sets whether particle angles and rotations are relative to their velocities. If enabled, particles are aligned to the angle of their velocities and rotate relative to that angle.",
        "name": "ParticleSystem:setRelativeRotation",
        "params": [
            {
                "descr": "True to enable relative particle rotation, false to disable it.",
                "name": "boolean enable"
            }
        ],
        "path": "love/particlesystem-setrelativerotation",
        "syntax": "ParticleSystem:setRelativeRotation( enable )",
        "type": "love.graphics"
    },
    "ParticleSystem:setRotation": {
        "descr": "Sets the rotation of the image upon particle creation (in radians).",
        "name": "ParticleSystem:setRotation",
        "params": [
            {
                "descr": "The minimum initial angle (radians).",
                "name": "number min"
            },
            {
                "descr": "The maximum initial angle (radians).",
                "name": "number max (min)"
            }
        ],
        "path": "love/particlesystem-setrotation",
        "syntax": "ParticleSystem:setRotation( min, max )",
        "type": "love.graphics"
    },
    "ParticleSystem:setSize": {
        "descr": "Sets the size of the particle (1.0 being normal size). The particles will grow/shrink from the starting size to the ending size. The variation affects starting size only.",
        "name": "ParticleSystem:setSize",
        "params": [
            {
                "descr": "The minimum size (1.0 being normal size).",
                "name": "number min"
            },
            {
                "descr": "The maximum size (1.0 being normal size).",
                "name": "number max (min)"
            },
            {
                "descr": "The degree of variation (0 meaning no variation and 1 meaning full variation between start and end).",
                "name": "number variation (1)"
            }
        ],
        "path": "love/particlesystem-setsize",
        "syntax": "ParticleSystem:setSize( min, max, variation )",
        "type": "love.graphics"
    },
    "ParticleSystem:setSizeVariation": {
        "descr": "Sets the amount of size variation (0 meaning no variation and 1 meaning full variation between start and end).",
        "name": "ParticleSystem:setSizeVariation",
        "params": [
            {
                "descr": "The amount of variation (0 meaning no variation and 1 meaning full variation between start and end).",
                "name": "number variation"
            }
        ],
        "path": "love/particlesystem-setsizevariation",
        "syntax": "ParticleSystem:setSizeVariation( variation )",
        "type": "love.graphics"
    },
    "ParticleSystem:setSizes": {
        "descr": "Sets a series of sizes by which to scale a particle sprite. 1.0 is normal size. The particle system will interpolate between each size evenly over the particle's lifetime.",
        "name": "ParticleSystem:setSizes",
        "params": [
            {
                "descr": "The first size.",
                "name": "number size1"
            },
            {
                "descr": "The second size.",
                "name": "number size2"
            },
            {
                "descr": "The eighth size.",
                "name": "number size8"
            }
        ],
        "path": "love/particlesystem-setsizes",
        "syntax": "ParticleSystem:setSizes( size1, size2, ..., size8 )",
        "type": "love.graphics"
    },
    "ParticleSystem:setSpeed": {
        "descr": "Sets the speed of the particles.",
        "name": "ParticleSystem:setSpeed",
        "params": [
            {
                "descr": "The minimum linear speed of the particles.",
                "name": "number min"
            },
            {
                "descr": "The maximum linear speed of the particles.",
                "name": "number max (min)"
            }
        ],
        "path": "love/particlesystem-setspeed",
        "syntax": "ParticleSystem:setSpeed( min, max )",
        "type": "love.graphics"
    },
    "ParticleSystem:setSpin": {
        "descr": "Sets the spin of the sprite.",
        "name": "ParticleSystem:setSpin",
        "params": [
            {
                "descr": "The minimum spin (radians per second).",
                "name": "number min"
            },
            {
                "descr": "The maximum spin (radians per second).",
                "name": "number max (min)"
            }
        ],
        "path": "love/particlesystem-setspin",
        "syntax": "ParticleSystem:setSpin( min, max )",
        "type": "love.graphics"
    },
    "ParticleSystem:setSpinVariation": {
        "descr": "Sets the amount of spin variation (0 meaning no variation and 1 meaning full variation between start and end).",
        "name": "ParticleSystem:setSpinVariation",
        "params": [
            {
                "descr": "The amount of variation (0 meaning no variation and 1 meaning full variation between start and end).",
                "name": "number variation"
            }
        ],
        "path": "love/particlesystem-setspinvariation",
        "syntax": "ParticleSystem:setSpinVariation( variation )",
        "type": "love.graphics"
    },
    "ParticleSystem:setSpread": {
        "descr": "Sets the amount of spread for the system.",
        "name": "ParticleSystem:setSpread",
        "params": [
            {
                "descr": "The amount of spread (radians).",
                "name": "number spread"
            }
        ],
        "path": "love/particlesystem-setspread",
        "syntax": "ParticleSystem:setSpread( spread )",
        "type": "love.graphics"
    },
    "ParticleSystem:setSprite": {
        "descr": "Sets the image which is to be emitted.",
        "name": "ParticleSystem:setSprite",
        "params": [
            {
                "descr": "An Image to use for the particle.",
                "name": "Image sprite"
            }
        ],
        "path": "love/particlesystem-setsprite",
        "syntax": "ParticleSystem:setSprite( sprite )",
        "type": "love.graphics"
    },
    "ParticleSystem:setTangentialAcceleration": {
        "descr": "Sets the tangential acceleration (acceleration perpendicular to the particle's direction).",
        "name": "ParticleSystem:setTangentialAcceleration",
        "params": [
            {
                "descr": "The minimum acceleration.",
                "name": "number min"
            },
            {
                "descr": "The maximum acceleration.",
                "name": "number max (min)"
            }
        ],
        "path": "love/particlesystem-settangentialacceleration",
        "syntax": "ParticleSystem:setTangentialAcceleration( min, max )",
        "type": "love.graphics"
    },
    "ParticleSystem:setTexture": {
        "descr": "Sets the texture (Image or Canvas) to be used for the particles.",
        "name": "ParticleSystem:setTexture",
        "params": [
            {
                "descr": "An Image or Canvas to use for the particles.",
                "name": "Texture texture"
            }
        ],
        "path": "love/particlesystem-settexture",
        "syntax": "ParticleSystem:setTexture( texture )",
        "type": "love.graphics"
    },
    "ParticleSystem:start": {
        "descr": "Starts the particle emitter.",
        "name": "ParticleSystem:start",
        "params": [],
        "path": "love/particlesystem-start",
        "syntax": "ParticleSystem:start( )",
        "type": "love.graphics"
    },
    "ParticleSystem:stop": {
        "descr": "Stops the particle emitter, resetting the lifetime counter.",
        "name": "ParticleSystem:stop",
        "params": [],
        "path": "love/particlesystem-stop",
        "syntax": "ParticleSystem:stop( )",
        "type": "love.graphics"
    },
    "ParticleSystem:update": {
        "descr": "Updates the particle system; moving, creating and killing particles.",
        "name": "ParticleSystem:update",
        "params": [
            {
                "descr": "The time (seconds) since last frame.",
                "name": "number dt"
            }
        ],
        "path": "love/particlesystem-update",
        "syntax": "ParticleSystem:update( dt )",
        "type": "love.graphics"
    },
    "PixelEffect:getWarnings": {
        "descr": "Returns any warning messages from compiling the pixel effect code. This can be used for debugging your pixel effects if there's anything the graphics hardware doesn't like.",
        "name": "PixelEffect:getWarnings",
        "params": [
            {
                "descr": "Warning messages (if any).",
                "name": "string warnings"
            }
        ],
        "path": "love/pixeleffect-getwarnings",
        "syntax": "warnings = PixelEffect:getWarnings( )",
        "type": "love.graphics"
    },
    "PixelEffect:send": {
        "descr": "Sends one or more values to a special (extern) variable inside the pixel effect. Extern variables have to be marked using the extern keyword, e.g.",
        "name": "PixelEffect:send",
        "params": [
            {
                "descr": "Name of the number to send to the pixel effect.",
                "name": "string name"
            },
            {
                "descr": "Number to send to store in the extern.",
                "name": "number number"
            },
            {
                "descr": "Additional numbers to send in case the extern is an array.",
                "name": "number ..."
            }
        ],
        "path": "love/pixeleffect-send",
        "syntax": "PixelEffect:send( name, number, ... )",
        "type": "love.graphics"
    },
    "PolygonShape:getPoints": {
        "descr": "Get the local coordinates of the polygon's vertices.",
        "name": "PolygonShape:getPoints",
        "params": [
            {
                "descr": "The x-component of the first vertex.",
                "name": "number x1"
            },
            {
                "descr": "The y-component of the first vertex.",
                "name": "number y1"
            },
            {
                "descr": "The x-component of the second vertex.",
                "name": "number x2"
            },
            {
                "descr": "The y-component of the second vertex.",
                "name": "number y2"
            }
        ],
        "path": "love/polygonshape-getpoints",
        "syntax": "x1, y1, x2, y2, ... x8, y8 = PolygonShape:getPoints( )",
        "type": "love.physics"
    },
    "PolygonShape:validate": {
        "descr": "Validates whether the PolygonShape is convex. Concave PolygonShapes cannot be used in love.physics.",
        "name": "PolygonShape:validate",
        "params": [
            {
                "descr": "Whether the PolygonShape is convex.",
                "name": "boolean convex"
            }
        ],
        "path": "love/polygonshape-validate",
        "syntax": "convex = PolygonShape:validate()",
        "type": "love.physics"
    },
    "PrismaticJoint:enableLimit": {
        "descr": "Enables or disables the limits of the joint.",
        "name": "PrismaticJoint:enableLimit",
        "params": [
            {
                "descr": "True to enable, false to disable.",
                "name": "boolean enable"
            }
        ],
        "path": "love/prismaticjoint-enablelimit",
        "syntax": "PrismaticJoint:enableLimit( enable )",
        "type": "love.physics"
    },
    "PrismaticJoint:enableMotor": {
        "descr": "Starts or stops the joint motor.",
        "name": "PrismaticJoint:enableMotor",
        "params": [
            {
                "descr": "True to enable, false to disable.",
                "name": "boolean enable"
            }
        ],
        "path": "love/prismaticjoint-enablemotor",
        "syntax": "PrismaticJoint:enableMotor( enable )",
        "type": "love.physics"
    },
    "PrismaticJoint:getAxis": {
        "descr": "Gets the world-space axis vector of the Prismatic Joint.",
        "name": "PrismaticJoint:getAxis",
        "params": [
            {
                "descr": "The x-axis coordinate of the world-space axis vector.",
                "name": "number x"
            },
            {
                "descr": "The y-axis coordinate of the world-space axis vector.",
                "name": "number y"
            }
        ],
        "path": "love/prismaticjoint-getaxis",
        "syntax": "x, y = PrismaticJoint:getAxis( )",
        "type": "love.physics"
    },
    "PrismaticJoint:getJointSpeed": {
        "descr": "Get the current joint angle speed.",
        "name": "PrismaticJoint:getJointSpeed",
        "params": [
            {
                "descr": "Joint angle speed in meters/second.",
                "name": "number s"
            }
        ],
        "path": "love/prismaticjoint-getjointspeed",
        "syntax": "s = PrismaticJoint:getJointSpeed( )",
        "type": "love.physics"
    },
    "PrismaticJoint:getJointTranslation": {
        "descr": "Get the current joint translation.",
        "name": "PrismaticJoint:getJointTranslation",
        "params": [
            {
                "descr": "Joint translation, usually in meters..",
                "name": "number t"
            }
        ],
        "path": "love/prismaticjoint-getjointtranslation",
        "syntax": "t = PrismaticJoint:getJointTranslation( )",
        "type": "love.physics"
    },
    "PrismaticJoint:getLimits": {
        "descr": "Gets the joint limits.",
        "name": "PrismaticJoint:getLimits",
        "params": [
            {
                "descr": "The lower limit, usually in meters.",
                "name": "number lower"
            },
            {
                "descr": "The upper limit, usually in meters.",
                "name": "number upper"
            }
        ],
        "path": "love/prismaticjoint-getlimits",
        "syntax": "lower, upper = PrismaticJoint:getLimits( )",
        "type": "love.physics"
    },
    "PrismaticJoint:getLowerLimit": {
        "descr": "Gets the lower limit.",
        "name": "PrismaticJoint:getLowerLimit",
        "params": [
            {
                "descr": "The lower limit, usually in meters.",
                "name": "number lower"
            }
        ],
        "path": "love/prismaticjoint-getlowerlimit",
        "syntax": "lower = PrismaticJoint:getLowerLimit( )",
        "type": "love.physics"
    },
    "PrismaticJoint:getMaxMotorForce": {
        "descr": "Gets the maximum motor force.",
        "name": "PrismaticJoint:getMaxMotorForce",
        "params": [
            {
                "descr": "The maximum motor force, usually in N.",
                "name": "number f"
            }
        ],
        "path": "love/prismaticjoint-getmaxmotorforce",
        "syntax": "f = PrismaticJoint:getMaxMotorForce( )",
        "type": "love.physics"
    },
    "PrismaticJoint:getMotorForce": {
        "descr": "Returns the current motor force.",
        "name": "PrismaticJoint:getMotorForce",
        "params": [
            {
                "descr": "How long the force applies. Usually the inverse time step or 1/dt.",
                "name": "number invdt"
            },
            {
                "descr": "The force on the motor in newtons.",
                "name": "number force"
            }
        ],
        "path": "love/prismaticjoint-getmotorforce",
        "syntax": "force = PrismaticJoint:getMotorForce( invdt )",
        "type": "love.physics"
    },
    "PrismaticJoint:getMotorSpeed": {
        "descr": "Gets the motor speed.",
        "name": "PrismaticJoint:getMotorSpeed",
        "params": [
            {
                "descr": "The motor speed, usually in meters per second.",
                "name": "number s"
            }
        ],
        "path": "love/prismaticjoint-getmotorspeed",
        "syntax": "s = PrismaticJoint:getMotorSpeed( )",
        "type": "love.physics"
    },
    "PrismaticJoint:getUpperLimit": {
        "descr": "Gets the upper limit.",
        "name": "PrismaticJoint:getUpperLimit",
        "params": [
            {
                "descr": "The upper limit, usually in meters.",
                "name": "number upper"
            }
        ],
        "path": "love/prismaticjoint-getupperlimit",
        "syntax": "upper = PrismaticJoint:getUpperLimit( )",
        "type": "love.physics"
    },
    "PrismaticJoint:hasLimitsEnabled": {
        "descr": "Checks whether the limits are enabled.",
        "name": "PrismaticJoint:hasLimitsEnabled",
        "params": [
            {
                "descr": "True if enabled, false otherwise.",
                "name": "boolean enabled"
            }
        ],
        "path": "love/prismaticjoint-haslimitsenabled",
        "syntax": "enabled = PrismaticJoint:hasLimitsEnabled( )",
        "type": "love.physics"
    },
    "PrismaticJoint:isLimitEnabled": {
        "descr": "Checks whether the limits are enabled.",
        "name": "PrismaticJoint:isLimitEnabled",
        "params": [
            {
                "descr": "True if enabled, false otherwise.",
                "name": "boolean enabled"
            }
        ],
        "path": "love/prismaticjoint-islimitenabled",
        "syntax": "enabled = PrismaticJoint:isLimitEnabled( )",
        "type": "love.physics"
    },
    "PrismaticJoint:isLimitsEnabled": {
        "descr": "Checks whether limits are enabled.",
        "name": "PrismaticJoint:isLimitsEnabled",
        "params": [
            {
                "descr": "True if enabled, false otherwise.",
                "name": "boolean enabled"
            }
        ],
        "path": "love/prismaticjoint-islimitsenabled",
        "syntax": "enabled = PrismaticJoint:isLimitsEnabled( )",
        "type": "love.physics"
    },
    "PrismaticJoint:isMotorEnabled": {
        "descr": "Checks whether the motor is enabled.",
        "name": "PrismaticJoint:isMotorEnabled",
        "params": [
            {
                "descr": "True if enabled, false if disabled.",
                "name": "boolean enabled"
            }
        ],
        "path": "love/prismaticjoint-ismotorenabled",
        "syntax": "enabled = PrismaticJoint:isMotorEnabled( )",
        "type": "love.physics"
    },
    "PrismaticJoint:setLimits": {
        "descr": "Sets the limits.",
        "name": "PrismaticJoint:setLimits",
        "params": [
            {
                "descr": "The lower limit, usually in meters.",
                "name": "number lower"
            },
            {
                "descr": "The upper limit, usually in meters.",
                "name": "number upper"
            }
        ],
        "path": "love/prismaticjoint-setlimits",
        "syntax": "PrismaticJoint:setLimits( lower, upper )",
        "type": "love.physics"
    },
    "PrismaticJoint:setLimitsEnabled": {
        "descr": "Enables/disables the joint limit.",
        "name": "PrismaticJoint:setLimitsEnabled",
        "params": [
            {
                "descr": "True if enabled, false if disabled.",
                "name": "boolean enable"
            }
        ],
        "path": "love/prismaticjoint-setlimitsenabled",
        "syntax": "enable = PrismaticJoint:setLimitsEnabled( )",
        "type": "love.physics"
    },
    "PrismaticJoint:setLowerLimit": {
        "descr": "Sets the lower limit.",
        "name": "PrismaticJoint:setLowerLimit",
        "params": [
            {
                "descr": "The lower limit, usually in meters.",
                "name": "number lower"
            }
        ],
        "path": "love/prismaticjoint-setlowerlimit",
        "syntax": "PrismaticJoint:setLowerLimit( lower )",
        "type": "love.physics"
    },
    "PrismaticJoint:setMaxMotorForce": {
        "descr": "Set the maximum motor force.",
        "name": "PrismaticJoint:setMaxMotorForce",
        "params": [
            {
                "descr": "The maximum motor force, usually in N.",
                "name": "number f"
            }
        ],
        "path": "love/prismaticjoint-setmaxmotorforce",
        "syntax": "PrismaticJoint:setMaxMotorForce( f )",
        "type": "love.physics"
    },
    "PrismaticJoint:setMotorEnabled": {
        "descr": "Enables/disables the joint motor.",
        "name": "PrismaticJoint:setMotorEnabled",
        "params": [
            {
                "descr": "True to enable, false to disable.",
                "name": "boolean enable"
            }
        ],
        "path": "love/prismaticjoint-setmotorenabled",
        "syntax": "PrismaticJoint:setMotorEnabled( enable )",
        "type": "love.physics"
    },
    "PrismaticJoint:setMotorSpeed": {
        "descr": "Sets the motor speed.",
        "name": "PrismaticJoint:setMotorSpeed",
        "params": [
            {
                "descr": "The motor speed, usually in meters per second.",
                "name": "number s"
            }
        ],
        "path": "love/prismaticjoint-setmotorspeed",
        "syntax": "PrismaticJoint:setMotorSpeed( s )",
        "type": "love.physics"
    },
    "PrismaticJoint:setUpperLimit": {
        "descr": "Sets the upper limit.",
        "name": "PrismaticJoint:setUpperLimit",
        "params": [
            {
                "descr": "The upper limit, usually in meters.",
                "name": "number upper"
            }
        ],
        "path": "love/prismaticjoint-setupperlimit",
        "syntax": "PrismaticJoint:setUpperLimit( upper )",
        "type": "love.physics"
    },
    "PulleyJoint:getConstant": {
        "descr": "Get the total length of the rope.",
        "name": "PulleyJoint:getConstant",
        "params": [
            {
                "descr": "The length of the rope in the joint.",
                "name": "number length"
            }
        ],
        "path": "love/pulleyjoint-getconstant",
        "syntax": "length = PulleyJoint:getConstant( )",
        "type": "love.physics"
    },
    "PulleyJoint:getGroundAnchors": {
        "descr": "Get the ground anchor positions in world coordinates.",
        "name": "PulleyJoint:getGroundAnchors",
        "params": [
            {
                "descr": "The x coordinate of the first anchor.",
                "name": "number a1x"
            },
            {
                "descr": "The y coordinate of the first anchor.",
                "name": "number a1y"
            },
            {
                "descr": "The x coordinate of the second anchor.",
                "name": "number a2x"
            },
            {
                "descr": "The y coordinate of the second anchor.",
                "name": "number a2y"
            }
        ],
        "path": "love/pulleyjoint-getgroundanchors",
        "syntax": "a1x, a1y, a2x, a2y = PulleyJoint:getGroundAnchors( )",
        "type": "love.physics"
    },
    "PulleyJoint:getLength1": {
        "descr": "Get the current length of the rope segment attached to the first body.",
        "name": "PulleyJoint:getLength1",
        "params": [
            {
                "descr": "The length of the rope segment.",
                "name": "number length"
            }
        ],
        "path": "love/pulleyjoint-getlength1",
        "syntax": "length = PulleyJoint:getLength1( )",
        "type": "love.physics"
    },
    "PulleyJoint:getLength2": {
        "descr": "Get the current length of the rope segment attached to the second body.",
        "name": "PulleyJoint:getLength2",
        "params": [
            {
                "descr": "The length of the rope segment.",
                "name": "number length"
            }
        ],
        "path": "love/pulleyjoint-getlength2",
        "syntax": "length = PulleyJoint:getLength2( )",
        "type": "love.physics"
    },
    "PulleyJoint:getLengthA": {
        "descr": "Get the current length of the rope segment attached to the first body.",
        "name": "PulleyJoint:getLengthA",
        "params": [
            {
                "descr": "The length of the rope segment.",
                "name": "number length"
            }
        ],
        "path": "love/pulleyjoint-getlengtha",
        "syntax": "length = PulleyJoint:getLengthA( )",
        "type": "love.physics"
    },
    "PulleyJoint:getLengthB": {
        "descr": "Get the current length of the rope segment attached to the second body.",
        "name": "PulleyJoint:getLengthB",
        "params": [
            {
                "descr": "The length of the rope segment.",
                "name": "number length"
            }
        ],
        "path": "love/pulleyjoint-getlengthb",
        "syntax": "length = PulleyJoint:getLengthB( )",
        "type": "love.physics"
    },
    "PulleyJoint:getMaxLengths": {
        "descr": "Get the maximum lengths of the rope segments.",
        "name": "PulleyJoint:getMaxLengths",
        "params": [
            {
                "descr": "The maximum length of the first rope segment.",
                "name": "number len1"
            },
            {
                "descr": "The maximum length of the second rope segment.",
                "name": "number len2"
            }
        ],
        "path": "love/pulleyjoint-getmaxlengths",
        "syntax": "len1, len2 = PulleyJoint:getMaxLengths( )",
        "type": "love.physics"
    },
    "PulleyJoint:getRatio": {
        "descr": "Get the pulley ratio.",
        "name": "PulleyJoint:getRatio",
        "params": [
            {
                "descr": "The pulley ratio of the joint.",
                "name": "number ratio"
            }
        ],
        "path": "love/pulleyjoint-getratio",
        "syntax": "ratio = PulleyJoint:getRatio( )",
        "type": "love.physics"
    },
    "PulleyJoint:setConstant": {
        "descr": "Set the total length of the rope.",
        "name": "PulleyJoint:setConstant",
        "params": [
            {
                "descr": "The new length of the rope in the joint.",
                "name": "number length"
            }
        ],
        "path": "love/pulleyjoint-setconstant",
        "syntax": "PulleyJoint:setConstant( length )",
        "type": "love.physics"
    },
    "PulleyJoint:setMaxLengths": {
        "descr": "Set the maximum lengths of the rope segments.",
        "name": "PulleyJoint:setMaxLengths",
        "params": [
            {
                "descr": "The new maximum length of the first segment.",
                "name": "number max1"
            },
            {
                "descr": "The new maximum length of the second segment.",
                "name": "number max2"
            }
        ],
        "path": "love/pulleyjoint-setmaxlengths",
        "syntax": "PulleyJoint:setMaxLengths( max1, max2 )",
        "type": "love.physics"
    },
    "PulleyJoint:setRatio": {
        "descr": "Set the pulley ratio.",
        "name": "PulleyJoint:setRatio",
        "params": [
            {
                "descr": "The new pulley ratio of the joint.",
                "name": "number ratio"
            }
        ],
        "path": "love/pulleyjoint-setratio",
        "syntax": "PulleyJoint:setRatio( ratio )",
        "type": "love.physics"
    },
    "Quad:flip": {
        "descr": "Flips this quad horizontally, vertically, or both.",
        "name": "Quad:flip",
        "params": [
            {
                "descr": "True to flip horizontally, false to leave as-is.",
                "name": "boolean x"
            },
            {
                "descr": "True to flip vertically, false to leave as-is.",
                "name": "boolean y"
            }
        ],
        "path": "love/quad-flip",
        "syntax": "Quad:flip( x, y )",
        "type": "love.graphics"
    },
    "Quad:getTextureDimensions": {
        "descr": "Gets reference texture dimensions initially specified in love.graphics.newQuad.",
        "name": "Quad:getTextureDimensions",
        "params": [
            {
                "descr": "The Texture width used by the Quad.",
                "name": "number sw"
            },
            {
                "descr": "The Texture height used by the Quad.",
                "name": "number sh"
            }
        ],
        "path": "love/quad-gettexturedimensions",
        "syntax": "sw, sh = Quad:getTextureDimensions( )",
        "type": "love.graphics"
    },
    "Quad:getViewport": {
        "descr": "Gets the current viewport of this Quad.",
        "name": "Quad:getViewport",
        "params": [
            {
                "descr": "The top-left corner along the x-axis.",
                "name": "number x"
            },
            {
                "descr": "The top-right corner along the y-axis.",
                "name": "number y"
            },
            {
                "descr": "The width of the viewport.",
                "name": "number w"
            },
            {
                "descr": "The height of the viewport.",
                "name": "number h"
            }
        ],
        "path": "love/quad-getviewport",
        "syntax": "x, y, w, h = Quad:getViewport( )",
        "type": "love.graphics"
    },
    "Quad:setViewport": {
        "descr": "Sets the texture coordinates according to a viewport.",
        "name": "Quad:setViewport",
        "params": [
            {
                "descr": "The top-left corner along the x-axis.",
                "name": "number x"
            },
            {
                "descr": "The top-right corner along the y-axis.",
                "name": "number y"
            },
            {
                "descr": "The width of the viewport.",
                "name": "number w"
            },
            {
                "descr": "The height of the viewport.",
                "name": "number h"
            }
        ],
        "path": "love/quad-setviewport",
        "syntax": "Quad:setViewport( x, y, w, h )",
        "type": "love.graphics"
    },
    "RandomGenerator:getSeed": {
        "descr": "Gets the seed of the random number generator object.",
        "name": "RandomGenerator:getSeed",
        "params": [
            {
                "descr": "Integer number representing the lower 32 bits of the RandomGenerator's 64 bit seed value.",
                "name": "number low"
            },
            {
                "descr": "Integer number representing the higher 32 bits of the RandomGenerator's 64 bit seed value.",
                "name": "number high"
            }
        ],
        "path": "love/randomgenerator-getseed",
        "syntax": "low, high = RandomGenerator:getSeed( )",
        "type": "love.math"
    },
    "RandomGenerator:getState": {
        "descr": "Gets the current state of the random number generator. This returns an opaque implementation-dependent string which is only useful for later use with RandomGenerator:setState.",
        "name": "RandomGenerator:getState",
        "params": [
            {
                "descr": "The current state of the RandomGenerator object, represented as a string.",
                "name": "string state"
            }
        ],
        "path": "love/randomgenerator-getstate",
        "syntax": "state = RandomGenerator:getState( )",
        "type": "love.math"
    },
    "RandomGenerator:random": {
        "descr": "Generates a pseudo-random number in a platform independent manner.",
        "name": "RandomGenerator:random",
        "params": [
            {
                "descr": "The pseudo-random number.",
                "name": "number number"
            }
        ],
        "path": "love/randomgenerator-random",
        "syntax": "number = RandomGenerator:random( )",
        "type": "love.math"
    },
    "RandomGenerator:randomNormal": {
        "descr": "Get a normally distributed pseudo random number.",
        "name": "RandomGenerator:randomNormal",
        "params": [
            {
                "descr": "Standard deviation of the distribution.",
                "name": "number stddev (1)"
            },
            {
                "descr": "The mean of the distribution.",
                "name": "number mean (0)"
            },
            {
                "descr": "Normally distributed random number with variance (stddev)² and the specified mean.",
                "name": "number number"
            }
        ],
        "path": "love/randomgenerator-randomnormal",
        "syntax": "number = RandomGenerator:randomNormal( stddev, mean )",
        "type": "love.math"
    },
    "RandomGenerator:setSeed": {
        "descr": "Sets the seed of the random number generator using the specified integer number.",
        "name": "RandomGenerator:setSeed",
        "params": [
            {
                "descr": "The integer number with which you want to seed the randomization. ",
                "name": "number seed"
            }
        ],
        "path": "love/randomgenerator-setseed",
        "syntax": "RandomGenerator:setSeed( seed )",
        "type": "love.math"
    },
    "RandomGenerator:setState": {
        "descr": "Sets the current state of the random number generator. The value used as an argument for this function is an opaque implementation-dependent string and should only originate from a previous call to RandomGenerator:getState.",
        "name": "RandomGenerator:setState",
        "params": [
            {
                "descr": "The new state of the RandomGenerator object, represented as a string. ",
                "name": "string state"
            }
        ],
        "path": "love/randomgenerator-setstate",
        "syntax": "RandomGenerator:setState( state )",
        "type": "love.math"
    },
    "RevoluteJoint:enableLimit": {
        "descr": "Enables or disables the joint limits.",
        "name": "RevoluteJoint:enableLimit",
        "params": [
            {
                "descr": "True to enable, false to disable.",
                "name": "boolean enable"
            }
        ],
        "path": "love/revolutejoint-enablelimit",
        "syntax": "RevoluteJoint:enableLimit( enable )",
        "type": "love.physics"
    },
    "RevoluteJoint:enableLimits": {
        "descr": "Enables or disables the joint limits.",
        "name": "RevoluteJoint:enableLimits",
        "params": [
            {
                "descr": "True to enable, false to disable.",
                "name": "boolean enable"
            }
        ],
        "path": "love/revolutejoint-enablelimits",
        "syntax": "RevoluteJoint:enableLimit( enable )",
        "type": "love.physics"
    },
    "RevoluteJoint:enableMotor": {
        "descr": "Starts or stops the joint motor.",
        "name": "RevoluteJoint:enableMotor",
        "params": [
            {
                "descr": "True to enable, false to disable.",
                "name": "boolean enable"
            }
        ],
        "path": "love/revolutejoint-enablemotor",
        "syntax": "RevoluteJoint:enableMotor( enable )",
        "type": "love.physics"
    },
    "RevoluteJoint:getJointAngle": {
        "descr": "Get the current joint angle.",
        "name": "RevoluteJoint:getJointAngle",
        "params": [
            {
                "descr": "The joint angle in radians.",
                "name": "number angle"
            }
        ],
        "path": "love/revolutejoint-getjointangle",
        "syntax": "angle = RevoluteJoint:getJointAngle( )",
        "type": "love.physics"
    },
    "RevoluteJoint:getJointSpeed": {
        "descr": "Get the current joint angle speed.",
        "name": "RevoluteJoint:getJointSpeed",
        "params": [
            {
                "descr": "Joint angle speed in radians/second.",
                "name": "number s"
            }
        ],
        "path": "love/revolutejoint-getjointspeed",
        "syntax": "s = RevoluteJoint:getJointSpeed( )",
        "type": "love.physics"
    },
    "RevoluteJoint:getLimits": {
        "descr": "Gets the joint limits.",
        "name": "RevoluteJoint:getLimits",
        "params": [
            {
                "descr": "The lower limit, in radians.",
                "name": "number lower"
            },
            {
                "descr": "The upper limit, in radians.",
                "name": "number upper"
            }
        ],
        "path": "love/revolutejoint-getlimits",
        "syntax": "lower, upper = RevoluteJoint:getLimits( )",
        "type": "love.physics"
    },
    "RevoluteJoint:getLowerLimit": {
        "descr": "Gets the lower limit.",
        "name": "RevoluteJoint:getLowerLimit",
        "params": [
            {
                "descr": "The lower limit, in radians.",
                "name": "number lower"
            }
        ],
        "path": "love/revolutejoint-getlowerlimit",
        "syntax": "lower = RevoluteJoint:getLowerLimit( )",
        "type": "love.physics"
    },
    "RevoluteJoint:getMaxMotorTorque": {
        "descr": "Gets the maximum motor force.",
        "name": "RevoluteJoint:getMaxMotorTorque",
        "params": [
            {
                "descr": "The maximum motor force, in Nm.",
                "name": "number f"
            }
        ],
        "path": "love/revolutejoint-getmaxmotortorque",
        "syntax": "f = RevoluteJoint:getMaxMotorTorque( )",
        "type": "love.physics"
    },
    "RevoluteJoint:getMotorSpeed": {
        "descr": "Gets the motor speed.",
        "name": "RevoluteJoint:getMotorSpeed",
        "params": [
            {
                "descr": "The motor speed, radians per second.",
                "name": "number s"
            }
        ],
        "path": "love/revolutejoint-getmotorspeed",
        "syntax": "s = RevoluteJoint:getMotorSpeed( )",
        "type": "love.physics"
    },
    "RevoluteJoint:getMotorTorque": {
        "descr": "Get the current motor force.",
        "name": "RevoluteJoint:getMotorTorque",
        "params": [
            {
                "descr": "The current motor force, in Nm.",
                "name": "number f"
            }
        ],
        "path": "love/revolutejoint-getmotortorque",
        "syntax": "f = RevoluteJoint:getMotorTorque( )",
        "type": "love.physics"
    },
    "RevoluteJoint:getUpperLimit": {
        "descr": "Gets the upper limit.",
        "name": "RevoluteJoint:getUpperLimit",
        "params": [
            {
                "descr": "The upper limit, in radians.",
                "name": "number upper"
            }
        ],
        "path": "love/revolutejoint-getupperlimit",
        "syntax": "upper = RevoluteJoint:getUpperLimit( )",
        "type": "love.physics"
    },
    "RevoluteJoint:hasLimitsEnabled": {
        "descr": "Checks whether limits are enabled.",
        "name": "RevoluteJoint:hasLimitsEnabled",
        "params": [
            {
                "descr": "True if enabled, false otherwise.",
                "name": "boolean enabled"
            }
        ],
        "path": "love/revolutejoint-haslimitsenabled",
        "syntax": "enabled = RevoluteJoint:hasLimitsEnabled( )",
        "type": "love.physics"
    },
    "RevoluteJoint:isLimitsEnabled": {
        "descr": "Checks whether limits are enabled.",
        "name": "RevoluteJoint:isLimitsEnabled",
        "params": [
            {
                "descr": "True if enabled, false otherwise.",
                "name": "boolean enabled"
            }
        ],
        "path": "love/revolutejoint-islimitsenabled",
        "syntax": "enabled = RevoluteJoint:isLimitsEnabled( )",
        "type": "love.physics"
    },
    "RevoluteJoint:isMotorEnabled": {
        "descr": "Checks whether the motor is enabled.",
        "name": "RevoluteJoint:isMotorEnabled",
        "params": [
            {
                "descr": "True if enabled, false if disabled.",
                "name": "boolean enabled"
            }
        ],
        "path": "love/revolutejoint-ismotorenabled",
        "syntax": "enabled = RevoluteJoint:isMotorEnabled( )",
        "type": "love.physics"
    },
    "RevoluteJoint:setLimits": {
        "descr": "Sets the limits.",
        "name": "RevoluteJoint:setLimits",
        "params": [
            {
                "descr": "The lower limit, in radians.",
                "name": "number lower"
            },
            {
                "descr": "The upper limit, in radians.",
                "name": "number upper"
            }
        ],
        "path": "love/revolutejoint-setlimits",
        "syntax": "RevoluteJoint:setLimits( lower, upper )",
        "type": "love.physics"
    },
    "RevoluteJoint:setLimitsEnabled": {
        "descr": "Enables/disables the joint limit.",
        "name": "RevoluteJoint:setLimitsEnabled",
        "params": [
            {
                "descr": "True to enable, false to disable.",
                "name": "boolean enable"
            }
        ],
        "path": "love/revolutejoint-setlimitsenabled",
        "syntax": "RevoluteJoint:setLimitsEnabled( enable )",
        "type": "love.physics"
    },
    "RevoluteJoint:setLowerLimit": {
        "descr": "Sets the lower limit.",
        "name": "RevoluteJoint:setLowerLimit",
        "params": [
            {
                "descr": "The lower limit, in radians.",
                "name": "number lower"
            }
        ],
        "path": "love/revolutejoint-setlowerlimit",
        "syntax": "RevoluteJoint:setLowerLimit( lower )",
        "type": "love.physics"
    },
    "RevoluteJoint:setMaxMotorTorque": {
        "descr": "Set the maximum motor force.",
        "name": "RevoluteJoint:setMaxMotorTorque",
        "params": [
            {
                "descr": "The maximum motor force, in Nm.",
                "name": "number f"
            }
        ],
        "path": "love/revolutejoint-setmaxmotortorque",
        "syntax": "RevoluteJoint:setMaxMotorTorque( f )",
        "type": "love.physics"
    },
    "RevoluteJoint:setMotorEnabled": {
        "descr": "Enables/disables the joint motor.",
        "name": "RevoluteJoint:setMotorEnabled",
        "params": [
            {
                "descr": "True to enable, false to disable.",
                "name": "boolean enable"
            }
        ],
        "path": "love/revolutejoint-setmotorenabled",
        "syntax": "RevoluteJoint:setMotorEnabled( enable )",
        "type": "love.physics"
    },
    "RevoluteJoint:setMotorSpeed": {
        "descr": "Sets the motor speed.",
        "name": "RevoluteJoint:setMotorSpeed",
        "params": [
            {
                "descr": "The motor speed, radians per second.",
                "name": "number s"
            }
        ],
        "path": "love/revolutejoint-setmotorspeed",
        "syntax": "RevoluteJoint:setMotorSpeed( s )",
        "type": "love.physics"
    },
    "RopeJoint:getMaxLength": {
        "descr": "Gets the maximum length of a RopeJoint.",
        "name": "RopeJoint:getMaxLength",
        "params": [
            {
                "descr": "The maximum length of the RopeJoint.",
                "name": "number maxLength"
            }
        ],
        "path": "love/ropejoint-getmaxlength",
        "syntax": "maxLength = RopeJoint:getLength( )",
        "type": "love.physics"
    },
    "Shader:getExternVariable": {
        "descr": "Gets information about an 'extern' ('uniform') variable in the shader.",
        "name": "Shader:getExternVariable",
        "params": [
            {
                "descr": "The name of the extern variable.",
                "name": "string name"
            },
            {
                "descr": "The base type of the variable.",
                "name": "ShaderVariableType type (nil)"
            },
            {
                "descr": "The number of components in the variable (e.g. ",
                "name": "number components (nil)"
            },
            {
                "descr": "The number of elements in the array if the variable is an array, or 1 if not.",
                "name": "number arrayelements (nil)"
            }
        ],
        "path": "love/shader-getexternvariable",
        "syntax": "type, components, arrayelements = Shader:getExternVariable( name )",
        "type": "love.graphics"
    },
    "Shader:getWarnings": {
        "descr": "Returns any warning and error messages from compiling the shader code. This can be used for debugging your shaders if there's anything the graphics hardware doesn't like.",
        "name": "Shader:getWarnings",
        "params": [
            {
                "descr": "Warning and error messages (if any).",
                "name": "string warnings"
            }
        ],
        "path": "love/shader-getwarnings",
        "syntax": "warnings = Shader:getWarnings( )",
        "type": "love.graphics"
    },
    "Shader:send": {
        "descr": "Sends one or more values to a special (uniform) variable inside the shader. Uniform variables have to be marked using the uniform or extern keyword, e.g.",
        "name": "Shader:send",
        "params": [
            {
                "descr": "Name of the number to send to the shader.",
                "name": "string name"
            },
            {
                "descr": "Number to send to store in the uniform variable.",
                "name": "number number"
            },
            {
                "descr": "Additional numbers to send if the uniform variable is an array.",
                "name": "number ..."
            }
        ],
        "path": "love/shader-send",
        "syntax": "Shader:send( name, number, ... )",
        "type": "love.graphics"
    },
    "Shader:sendColor": {
        "descr": "Sends one or more colors to a special (extern / uniform) vec3 or vec4 variable inside the shader. The color components must be in the range of [0, 255], unlike Shader:send. The colors are gamma-corrected if global gamma-correction is enabled.",
        "name": "Shader:sendColor",
        "params": [
            {
                "descr": "The name of the color extern variable to send to in the shader.",
                "name": "string name"
            },
            {
                "descr": "A table with red, green, blue, and optional alpha color components in the range of [0, 255] to send to the extern as a vector.",
                "name": "table color"
            },
            {
                "descr": "Additional colors to send in case the extern is an array. ",
                "name": "table ..."
            }
        ],
        "path": "love/shader-sendcolor",
        "syntax": "Shader:sendColor( name, color, ... )",
        "type": "love.graphics"
    },
    "Shape:computeAABB": {
        "descr": "Returns the points of the bounding box for the transformed shape.",
        "name": "Shape:computeAABB",
        "params": [
            {
                "descr": "The translation of the shape on the x-axis.",
                "name": "number tx"
            },
            {
                "descr": "The translation of the shape on the y-axis.",
                "name": "number ty"
            },
            {
                "descr": "The shape rotation.",
                "name": "number tr"
            },
            {
                "descr": "The index of the child to compute the bounding box of.",
                "name": "number childIndex (1)"
            },
            {
                "descr": "The x position of the top-left point.",
                "name": "number topLeftX"
            },
            {
                "descr": "The y position of the top-left point.",
                "name": "number topLeftY"
            },
            {
                "descr": "The x position of the bottom-right point.",
                "name": "number bottomRightX"
            },
            {
                "descr": "The y position of the bottom-right point.",
                "name": "number bottomRightY"
            }
        ],
        "path": "love/shape-computeaabb",
        "syntax": "topLeftX, topLeftY, bottomRightX, bottomRightY = Shape:computeAABB( tx, ty, tr, childIndex )",
        "type": "love.physics"
    },
    "Shape:computeMass": {
        "descr": "Computes the mass properties for the shape with the specified density.",
        "name": "Shape:computeMass",
        "params": [
            {
                "descr": "The shape density.",
                "name": "number density"
            },
            {
                "descr": "The x postition of the center of mass.",
                "name": "number x"
            },
            {
                "descr": "The y postition of the center of mass.",
                "name": "number y"
            },
            {
                "descr": "The mass of the shape.",
                "name": "number mass"
            },
            {
                "descr": "The rotational inertia.",
                "name": "number inertia"
            }
        ],
        "path": "love/shape-computemass",
        "syntax": "x, y, mass, inertia = Shape:computeMass( density )",
        "type": "love.physics"
    },
    "Shape:destroy": {
        "descr": "Explicitly destroys the Shape. When you don't have time to wait for garbage collection, this function may be used to free the object immediately, but note that an error will occur if you attempt to use the object after calling this function.",
        "name": "Shape:destroy",
        "params": [],
        "path": "love/shape-destroy",
        "syntax": "Shape:destroy( )",
        "type": "love.physics"
    },
    "Shape:getBody": {
        "descr": "Get the Body the shape is attached to.",
        "name": "Shape:getBody",
        "params": [
            {
                "descr": "The body the shape is attached to.",
                "name": "Body body"
            }
        ],
        "path": "love/shape-getbody",
        "syntax": "body = Shape:getBody( )",
        "type": "love.physics"
    },
    "Shape:getCategory": {
        "descr": "Gets the categories this shape is a member of. The number of categories the shape is a member of is the number of return values. Categories are used for allowing/disallowing certain collision.",
        "name": "Shape:getCategory",
        "params": [
            {
                "descr": "Numbers from 1-16.",
                "name": "numbers ..."
            }
        ],
        "path": "love/shape-getcategory",
        "syntax": "... = Shape:getCategory( )",
        "type": "love.physics"
    },
    "Shape:getCategoryBits": {
        "descr": "Gets the categories as a 16-bit integer. A set bit indicates membership of that category.",
        "name": "Shape:getCategoryBits",
        "params": [
            {
                "descr": "Integer value representing the categories.",
                "name": "number An"
            }
        ],
        "path": "love/shape-getcategorybits",
        "syntax": "An = Shape:getCategoryBits( )",
        "type": "love.physics"
    },
    "Shape:getChildCount": {
        "descr": "Returns the number of children the shape has.",
        "name": "Shape:getChildCount",
        "params": [
            {
                "descr": "The number of children.",
                "name": "number count"
            }
        ],
        "path": "love/shape-getchildcount",
        "syntax": "count = Shape:getChildCount( )",
        "type": "love.physics"
    },
    "Shape:getData": {
        "descr": "Get the data set with setData.",
        "name": "Shape:getData",
        "params": [
            {
                "descr": "The data previously set, or nil if none.",
                "name": "any v"
            }
        ],
        "path": "love/shape-getdata",
        "syntax": "v = Shape:getData( )",
        "type": "love.physics"
    },
    "Shape:getDensity": {
        "descr": "Gets the density of the Shape.",
        "name": "Shape:getDensity",
        "params": [
            {
                "descr": "The density of the Shape.",
                "name": "number density"
            }
        ],
        "path": "love/shape-getdensity",
        "syntax": "density = Shape:getDensity( )",
        "type": "love.physics"
    },
    "Shape:getFilterData": {
        "descr": "Gets the filter data of the Shape.",
        "name": "Shape:getFilterData",
        "params": [
            {
                "descr": "A 16-bit integer representing category membership.",
                "name": "number categoryBits"
            },
            {
                "descr": "A 16-bit integer representing masked categories.",
                "name": "number maskBits"
            },
            {
                "descr": "An integer representing the group index.",
                "name": "number groupIndex"
            }
        ],
        "path": "love/shape-getfilterdata",
        "syntax": "categoryBits, maskBits, groupIndex = Shape:getFilterData( )",
        "type": "love.physics"
    },
    "Shape:getFriction": {
        "descr": "Gets the friction of this shape.",
        "name": "Shape:getFriction",
        "params": [
            {
                "descr": "The friction of this Shape.",
                "name": "number friction"
            }
        ],
        "path": "love/shape-getfriction",
        "syntax": "friction = Shape:getFriction( )",
        "type": "love.physics"
    },
    "Shape:getMask": {
        "descr": "Gets which categories this shape should NOT collide with. The number of masked categories is the number of return values.",
        "name": "Shape:getMask",
        "params": [
            {
                "descr": "Numbers from 1-16",
                "name": "number ..."
            }
        ],
        "path": "love/shape-getmask",
        "syntax": "... = Shape:getMask( )",
        "type": "love.physics"
    },
    "Shape:getRadius": {
        "descr": "Gets the radius of the shape.",
        "name": "Shape:getRadius",
        "params": [
            {
                "descr": "The radius of the shape.",
                "name": "number radius"
            }
        ],
        "path": "love/shape-getradius",
        "syntax": "radius = Shape:getRadius()",
        "type": "love.physics"
    },
    "Shape:getRestitution": {
        "descr": "Gets the restitution of this shape.",
        "name": "Shape:getRestitution",
        "params": [
            {
                "descr": "The restitution of this Shape.",
                "name": "number restitution"
            }
        ],
        "path": "love/shape-getrestitution",
        "syntax": "restitution = Shape:getRestitution( )",
        "type": "love.physics"
    },
    "Shape:getType": {
        "descr": "Gets a string representing the Shape. This function can be useful for conditional debug drawing.",
        "name": "Shape:getType",
        "params": [
            {
                "descr": "The type of the Shape.",
                "name": "ShapeType type"
            }
        ],
        "path": "love/shape-gettype",
        "syntax": "type = Shape:getType( )",
        "type": "love.physics"
    },
    "Shape:isSensor": {
        "descr": "Checks whether a Shape is a sensor or not.",
        "name": "Shape:isSensor",
        "params": [
            {
                "descr": "True if sensor, false otherwise.",
                "name": "boolean s"
            }
        ],
        "path": "love/shape-issensor",
        "syntax": "s = Shape:isSensor( )",
        "type": "love.physics"
    },
    "Shape:rayCast": {
        "descr": "Casts a ray against the shape and returns the surface normal vector and the line position where the ray hit. If the ray missed the shape, nil will be returned. The Shape can be transformed to get it into the desired position.",
        "name": "Shape:rayCast",
        "params": [
            {
                "descr": "The x position of the input line starting point.",
                "name": "number x1"
            },
            {
                "descr": "The y position of the input line starting point.",
                "name": "number y1"
            },
            {
                "descr": "The x position of the input line end point.",
                "name": "number x2"
            },
            {
                "descr": "The y position of the input line end point.",
                "name": "number y2"
            },
            {
                "descr": "Ray length parameter.",
                "name": "number maxFraction"
            },
            {
                "descr": "The translation of the shape on the x-axis.",
                "name": "number tx"
            },
            {
                "descr": "The translation of the shape on the y-axis.",
                "name": "number ty"
            },
            {
                "descr": "The shape rotation.",
                "name": "number tr"
            },
            {
                "descr": "The index of the child the ray gets cast against.",
                "name": "number childIndex (1)"
            },
            {
                "descr": "The x component of the normal vector of the edge where the ray hit the shape.",
                "name": "number xn"
            },
            {
                "descr": "The y component of the normal vector of the edge where the ray hit the shape.",
                "name": "number yn"
            },
            {
                "descr": "The position on the input line where the intersection happened as a factor of the line length.",
                "name": "number fraction"
            }
        ],
        "path": "love/shape-raycast",
        "syntax": "xn, yn, fraction = Shape:rayCast( x1, y1, x2, y2, maxFraction, tx, ty, tr, childIndex )",
        "type": "love.physics"
    },
    "Shape:setCategory": {
        "descr": "Sets the categories this shape is a member of. Sets the categories of this shape by specifying numbers from 1-16 as parameters. Categories can be used to prevent certain shapes from colliding.",
        "name": "Shape:setCategory",
        "params": [
            {
                "descr": "Numbers from 1-16",
                "name": "numbers ..."
            }
        ],
        "path": "love/shape-setcategory",
        "syntax": "Shape:setCategory( ... )",
        "type": "love.physics"
    },
    "Shape:setData": {
        "descr": "Set data to be passed to the collision callback.",
        "name": "Shape:setData",
        "params": [
            {
                "descr": "Any Lua value.",
                "name": "any v"
            }
        ],
        "path": "love/shape-setdata",
        "syntax": "Shape:setData( v )",
        "type": "love.physics"
    },
    "Shape:setDensity": {
        "descr": "Sets the density of a Shape. Do this before calling Body:setMassFromShapes.",
        "name": "Shape:setDensity",
        "params": [
            {
                "descr": "The new density of the Shape.",
                "name": "number density"
            }
        ],
        "path": "love/shape-setdensity",
        "syntax": "Shape:setDensity( density )",
        "type": "love.physics"
    },
    "Shape:setFilterData": {
        "descr": "Sets the filter data for a Shape. Info stolen from box2d.org:",
        "name": "Shape:setFilterData",
        "params": [
            {
                "descr": "A 16-bit integer representing category membership.",
                "name": "number categoryBits"
            },
            {
                "descr": "A 16-bit integer representing masked categories.",
                "name": "number maskBits"
            },
            {
                "descr": "An integer representing the group index.",
                "name": "number groupIndex"
            }
        ],
        "path": "love/shape-setfilterdata",
        "syntax": "Shape:setFilterData( categoryBits, maskBits, groupIndex )",
        "type": "love.physics"
    },
    "Shape:setFriction": {
        "descr": "Sets the friction of the shape. Friction determines how shapes react when they \"slide\" along other shapes. Low friction indicates a slippery surface, like ice, while high friction indicates a rough surface, like concrete. Range: 0.0 - 1.0.",
        "name": "Shape:setFriction",
        "params": [
            {
                "descr": "The friction of the shape.",
                "name": "number friction"
            }
        ],
        "path": "love/shape-setfriction",
        "syntax": "Shape:setFriction( friction )",
        "type": "love.physics"
    },
    "Shape:setMask": {
        "descr": "Sets which categories this shape should NOT collide with. With this function, you can exclude certain shape categories from collisions with this shape. The categories passed as parameters will be excluded from collisions - all others included.",
        "name": "Shape:setMask",
        "params": [
            {
                "descr": "Numbers from 1-16.",
                "name": "number ..."
            }
        ],
        "path": "love/shape-setmask",
        "syntax": "Shape:setMask( ... )",
        "type": "love.physics"
    },
    "Shape:setRestitution": {
        "descr": "Sets the restitution of the shape. Restitution indicates the \"bounciness\" of the shape. High restitution can be used to model stuff like a rubber ball, while low restitution can be used for \"dull\" objects, like a bag of sand.",
        "name": "Shape:setRestitution",
        "params": [
            {
                "descr": "The restitution of the shape.",
                "name": "number restitution"
            }
        ],
        "path": "love/shape-setrestitution",
        "syntax": "Shape:setRestitution( restitution )",
        "type": "love.physics"
    },
    "Shape:setSensor": {
        "descr": "Sets whether this shape should act as a sensor. Set the shape as a sensor if you want to be notified when collision between shapes occur, but don't want a physical response (for instance, maybe you want enemies to appear when the player \"touches\" a certain point).",
        "name": "Shape:setSensor",
        "params": [
            {
                "descr": "True for sensor, false otherwise.",
                "name": "boolean sensor"
            }
        ],
        "path": "love/shape-setsensor",
        "syntax": "Shape:setSensor( sensor )",
        "type": "love.physics"
    },
    "Shape:testPoint": {
        "descr": "This is particularly useful for mouse interaction with the shapes. By looping through all shapes and testing the mouse position with this function, we can find which shapes the mouse touches.",
        "name": "Shape:testPoint",
        "params": [
            {
                "descr": "Translates the shape along the x-axis.",
                "name": "number tx"
            },
            {
                "descr": "Translates the shape along the y-axis.",
                "name": "number ty"
            },
            {
                "descr": "Rotates the shape.",
                "name": "number tr"
            },
            {
                "descr": "The x-component of the point.",
                "name": "number x"
            },
            {
                "descr": "The y-component of the point.",
                "name": "number y"
            },
            {
                "descr": "True if inside, false if outside",
                "name": "boolean hit"
            }
        ],
        "path": "love/shape-testpoint",
        "syntax": "hit = Shape:testPoint( tx, ty, tr, x, y )",
        "type": "love.physics"
    },
    "Shape:testSegment": {
        "descr": "Checks whether a line segment intersects a shape. This function will either return the \"time\" of impact and the surface normal at the point of collision, or nil if the line does not intersect the shape. The \"time\" is a value between 0.0 and 1.0 and can be used to calculate where the collision occured.",
        "name": "Shape:testSegment",
        "params": [
            {
                "descr": "The x-component of the first endpoint.",
                "name": "number x1"
            },
            {
                "descr": "The y-component of the first endpoint.",
                "name": "number y1"
            },
            {
                "descr": "The x-component of the second endpoint.",
                "name": "number x2"
            },
            {
                "descr": "The y-component of the second endpoint.",
                "name": "number y2"
            },
            {
                "descr": "The time of impact, or nil if no impact.",
                "name": "number t"
            },
            {
                "descr": "The x-component of the surface normal.",
                "name": "number xn"
            },
            {
                "descr": "The y-component of the surface normal.",
                "name": "number yn"
            }
        ],
        "path": "love/shape-testsegment",
        "syntax": "t, xn, yn = Shape:testSegment( x1, y1, x2, y2 )",
        "type": "love.physics"
    },
    "SoundData:getBitDepth": {
        "descr": "Returns the number of bits per sample.",
        "name": "SoundData:getBitDepth",
        "params": [
            {
                "descr": "Either 8, or 16.",
                "name": "number bitdepth"
            }
        ],
        "path": "love/sounddata-getbitdepth",
        "syntax": "bitdepth = SoundData:getBitDepth( )",
        "type": "love.sound"
    },
    "SoundData:getBits": {
        "descr": "Returns the number of bits per sample.",
        "name": "SoundData:getBits",
        "params": [
            {
                "descr": "Either 8, or 16.",
                "name": "number bits"
            }
        ],
        "path": "love/sounddata-getbits",
        "syntax": "bits = SoundData:getBits( )",
        "type": "love.sound"
    },
    "SoundData:getChannels": {
        "descr": "Returns the number of channels in the stream.",
        "name": "SoundData:getChannels",
        "params": [
            {
                "descr": "1 for mono, 2 for stereo.",
                "name": "number channels"
            }
        ],
        "path": "love/sounddata-getchannels",
        "syntax": "channels = SoundData:getChannels( )",
        "type": "love.sound"
    },
    "SoundData:getDuration": {
        "descr": "Gets the duration of the sound data.",
        "name": "SoundData:getDuration",
        "params": [
            {
                "descr": "The duration of the sound data in seconds.",
                "name": "number duration"
            }
        ],
        "path": "love/sounddata-getduration",
        "syntax": "duration = SoundData:getDuration( )",
        "type": "love.sound"
    },
    "SoundData:getSample": {
        "descr": "Gets the sample at the specified position.",
        "name": "SoundData:getSample",
        "params": [
            {
                "descr": "The position of the sample (0 means first sample).",
                "name": "number i"
            },
            {
                "descr": "The normalized sample (range -1.0 to 1.0).",
                "name": "number sample"
            }
        ],
        "path": "love/sounddata-getsample",
        "syntax": "sample = SoundData:getSample( i )",
        "type": "love.sound"
    },
    "SoundData:getSampleCount": {
        "descr": "Returns the number of samples per channel of the SoundData.",
        "name": "SoundData:getSampleCount",
        "params": [
            {
                "descr": "Total number of samples.",
                "name": "number count"
            }
        ],
        "path": "love/sounddata-getsamplecount",
        "syntax": "count = SoundData:getSampleCount( )",
        "type": "love.sound"
    },
    "SoundData:getSampleRate": {
        "descr": "Returns the sample rate of the SoundData.",
        "name": "SoundData:getSampleRate",
        "params": [
            {
                "descr": "Number of samples per second.",
                "name": "number rate"
            }
        ],
        "path": "love/sounddata-getsamplerate",
        "syntax": "rate = SoundData:getSampleRate( )",
        "type": "love.sound"
    },
    "SoundData:setSample": {
        "descr": "Sets the sample at the specified position.",
        "name": "SoundData:setSample",
        "params": [
            {
                "descr": "The position of the sample (0 means first sample).",
                "name": "number i"
            },
            {
                "descr": "A normalized sample (range -1.0 to 1.0).",
                "name": "number sample"
            }
        ],
        "path": "love/sounddata-setsample",
        "syntax": "SoundData:setSample( i, sample )",
        "type": "love.sound"
    },
    "Source:clone": {
        "descr": "Creates an identical copy of the Source in the stopped state.",
        "name": "Source:clone",
        "params": [
            {
                "descr": "The new identical copy of this Source.",
                "name": "Source source"
            }
        ],
        "path": "love/source-clone",
        "syntax": "source = Source:clone( )",
        "type": "love.audio"
    },
    "Source:getAttenuationDistances": {
        "descr": "Gets the reference and maximum attenuation distances of the Source. The values, combined with the current DistanceModel, affect how the Source's volume attenuates based on distance from the listener.",
        "name": "Source:getAttenuationDistances",
        "params": [
            {
                "descr": "The current reference attenuation distance. ",
                "name": "number ref"
            },
            {
                "descr": "The current maximum attenuation distance.",
                "name": "number max"
            }
        ],
        "path": "love/source-getattenuationdistances",
        "syntax": "ref, max = Source:getAttenuationDistances( )",
        "type": "love.audio"
    },
    "Source:getChannels": {
        "descr": "Gets the number of channels in the Source. Only 1-channel (mono) Sources can use directional and positional effects.",
        "name": "Source:getChannels",
        "params": [
            {
                "descr": "1 for mono, 2 for stereo.",
                "name": "number channels"
            }
        ],
        "path": "love/source-getchannels",
        "syntax": "channels = Source:getChannels( )",
        "type": "love.audio"
    },
    "Source:getCone": {
        "descr": "Gets the Source's directional volume cones. Together with Source:setDirection, the cone angles allow for the Source's volume to vary depending on its direction.",
        "name": "Source:getCone",
        "params": [
            {
                "descr": "The inner angle from the Source's direction, in radians. ",
                "name": "number innerAngle"
            },
            {
                "descr": "The outer angle from the Source's direction, in radians. ",
                "name": "number outerAngle"
            },
            {
                "descr": "The Source's volume when the listener is outside both the inner and outer cone angles.",
                "name": "number outerVolume"
            }
        ],
        "path": "love/source-getcone",
        "syntax": "innerAngle, outerAngle, outerVolume = Source:getCone( )",
        "type": "love.audio"
    },
    "Source:getDirection": {
        "descr": "Gets the direction of the Source.",
        "name": "Source:getDirection",
        "params": [
            {
                "descr": "The X part of the direction vector.",
                "name": "number x"
            },
            {
                "descr": "The Y part of the direction vector.",
                "name": "number y"
            },
            {
                "descr": "The Z part of the direction vector.",
                "name": "number z"
            }
        ],
        "path": "love/source-getdirection",
        "syntax": "x, y, z = Source:getDirection( )",
        "type": "love.audio"
    },
    "Source:getDistance": {
        "descr": "Returns the reference and maximum distance of the source.",
        "name": "Source:getDistance",
        "params": [
            {
                "descr": "The reference distance.",
                "name": "number ref"
            },
            {
                "descr": "The maximum distance.",
                "name": "number max"
            }
        ],
        "path": "love/source-getdistance",
        "syntax": "ref, max = Source:getDistance( )",
        "type": "love.audio"
    },
    "Source:getDuration": {
        "descr": "Gets the duration of the Source. For streaming Sources it may not always be sample-accurate, and may return -1 if the duration cannot be determined at all.",
        "name": "Source:getDuration",
        "params": [
            {
                "descr": "The time unit for the return value.",
                "name": "TimeUnit unit (\"seconds\")"
            },
            {
                "descr": "The duration of the Source, or -1 if it cannot be determined.",
                "name": "number duration"
            }
        ],
        "path": "love/source-getduration",
        "syntax": "duration = Source:getDuration( unit )",
        "type": "love.audio"
    },
    "Source:getPitch": {
        "descr": "Gets the current pitch of the Source.",
        "name": "Source:getPitch",
        "params": [
            {
                "descr": "The pitch, where 1.0 is normal.",
                "name": "number pitch"
            }
        ],
        "path": "love/source-getpitch",
        "syntax": "pitch = Source:getPitch( )",
        "type": "love.audio"
    },
    "Source:getPosition": {
        "descr": "Gets the position of the Source.",
        "name": "Source:getPosition",
        "params": [
            {
                "descr": "The X position of the Source.",
                "name": "number x"
            },
            {
                "descr": "The Y position of the Source.",
                "name": "number y"
            },
            {
                "descr": "The Z position of the Source.",
                "name": "number z"
            }
        ],
        "path": "love/source-getposition",
        "syntax": "x, y, z = Source:getPosition( )",
        "type": "love.audio"
    },
    "Source:getRolloff": {
        "descr": "Returns the rolloff factor of the source.",
        "name": "Source:getRolloff",
        "params": [
            {
                "descr": "The rolloff factor.",
                "name": "number rolloff"
            }
        ],
        "path": "love/source-getrolloff",
        "syntax": "rolloff = Source:getRolloff( )",
        "type": "love.audio"
    },
    "Source:getType": {
        "descr": "Gets the type (static or stream) of the Source.",
        "name": "Source:getType",
        "params": [
            {
                "descr": "The type of the source.",
                "name": "SourceType sourcetype"
            }
        ],
        "path": "love/source-gettype",
        "syntax": "sourcetype = Source:getType( )",
        "type": "love.audio"
    },
    "Source:getVelocity": {
        "descr": "Gets the velocity of the Source.",
        "name": "Source:getVelocity",
        "params": [
            {
                "descr": "The X part of the velocity vector.",
                "name": "number x"
            },
            {
                "descr": "The Y part of the velocity vector.",
                "name": "number y"
            },
            {
                "descr": "The Z part of the velocity vector.",
                "name": "number z"
            }
        ],
        "path": "love/source-getvelocity",
        "syntax": "x, y, z = Source:getVelocity( )",
        "type": "love.audio"
    },
    "Source:getVolume": {
        "descr": "Gets the current volume of the Source.",
        "name": "Source:getVolume",
        "params": [
            {
                "descr": "The volume of the Source, where 1.0 is normal volume.",
                "name": "number volume"
            }
        ],
        "path": "love/source-getvolume",
        "syntax": "volume = Source:getVolume( )",
        "type": "love.audio"
    },
    "Source:getVolumeLimits": {
        "descr": "Returns the volume limits of the source.",
        "name": "Source:getVolumeLimits",
        "params": [
            {
                "descr": "The minimum volume.",
                "name": "number min"
            },
            {
                "descr": "The maximum volume.",
                "name": "number max"
            }
        ],
        "path": "love/source-getvolumelimits",
        "syntax": "min, max = Source:getVolumeLimits( )",
        "type": "love.audio"
    },
    "Source:isLooping": {
        "descr": "Returns whether the Source will loop.",
        "name": "Source:isLooping",
        "params": [
            {
                "descr": "True if the Source will loop, false otherwise.",
                "name": "boolean loop"
            }
        ],
        "path": "love/source-islooping",
        "syntax": "loop = Source:isLooping( )",
        "type": "love.audio"
    },
    "Source:isPaused": {
        "descr": "Returns whether the Source is paused.",
        "name": "Source:isPaused",
        "params": [
            {
                "descr": "True if the Source is paused, false otherwise.",
                "name": "boolean paused"
            }
        ],
        "path": "love/source-ispaused",
        "syntax": "paused = Source:isPaused( )",
        "type": "love.audio"
    },
    "Source:isPlaying": {
        "descr": "Returns whether the Source is playing.",
        "name": "Source:isPlaying",
        "params": [
            {
                "descr": "True if the Source is playing, false otherwise.",
                "name": "boolean playing"
            }
        ],
        "path": "love/source-isplaying",
        "syntax": "playing = Source:isPlaying( )",
        "type": "love.audio"
    },
    "Source:isRelative": {
        "descr": "Gets whether the Source's position, velocity, direction, and cone angles are relative to the listener.",
        "name": "Source:isRelative",
        "params": [
            {
                "descr": "True if the position, velocity, direction and cone angles are relative to the listener, false if they're absolute.",
                "name": "boolean relative"
            }
        ],
        "path": "love/source-isrelative",
        "syntax": "relative = Source:isRelative( )",
        "type": "love.audio"
    },
    "Source:isStatic": {
        "descr": "Returns whether the Source is static.",
        "name": "Source:isStatic",
        "params": [
            {
                "descr": "True if the Source is static, false otherwise.",
                "name": "boolean static"
            }
        ],
        "path": "love/source-isstatic",
        "syntax": "static = Source:isStatic( )",
        "type": "love.audio"
    },
    "Source:isStopped": {
        "descr": "Returns whether the Source is stopped.",
        "name": "Source:isStopped",
        "params": [
            {
                "descr": "True if the Source is stopped, false otherwise.",
                "name": "boolean stopped"
            }
        ],
        "path": "love/source-isstopped",
        "syntax": "stopped = Source:isStopped( )",
        "type": "love.audio"
    },
    "Source:pause": {
        "descr": "Pauses the Source.",
        "name": "Source:pause",
        "params": [],
        "path": "love/source-pause",
        "syntax": "Source:pause()",
        "type": "love.audio"
    },
    "Source:play": {
        "descr": "Starts playing the Source.",
        "name": "Source:play",
        "params": [
            {
                "descr": "Whether the Source was able to successfully start playing.",
                "name": "boolean success"
            }
        ],
        "path": "love/source-play",
        "syntax": "success = Source:play()",
        "type": "love.audio"
    },
    "Source:resume": {
        "descr": "Resumes a paused Source.",
        "name": "Source:resume",
        "params": [],
        "path": "love/source-resume",
        "syntax": "Source:resume()",
        "type": "love.audio"
    },
    "Source:rewind": {
        "descr": "Rewinds a Source.",
        "name": "Source:rewind",
        "params": [],
        "path": "love/source-rewind",
        "syntax": "Source:rewind()",
        "type": "love.audio"
    },
    "Source:seek": {
        "descr": "Sets the currently playing position of the Source.",
        "name": "Source:seek",
        "params": [
            {
                "descr": "The position to seek to.",
                "name": "number offset"
            },
            {
                "descr": "The unit of the position value.",
                "name": "TimeUnit unit (\"seconds\")"
            }
        ],
        "path": "love/source-seek",
        "syntax": "Source:seek( offset, unit )",
        "type": "love.audio"
    },
    "Source:setAttenuationDistances": {
        "descr": "Sets the reference and maximum attenuation distances of the Source. The parameters, combined with the current DistanceModel, affect how the Source's volume attenuates based on distance. Distance attenuation is only applicable to Sources based on mono (rather than stereo) audio.",
        "name": "Source:setAttenuationDistances",
        "params": [
            {
                "descr": "The new reference attenuation distance. ",
                "name": "number ref"
            },
            {
                "descr": "The new maximum attenuation distance.",
                "name": "number max"
            }
        ],
        "path": "love/source-setattenuationdistances",
        "syntax": "Source:setAttenuationDistances( ref, max )",
        "type": "love.audio"
    },
    "Source:setCone": {
        "descr": "Sets the Source's directional volume cones. Together with Source:setDirection, the cone angles allow for the Source's volume to vary depending on its direction.",
        "name": "Source:setCone",
        "params": [
            {
                "descr": "The inner angle from the Source's direction, in radians. ",
                "name": "number innerAngle"
            },
            {
                "descr": "The outer angle from the Source's direction, in radians. ",
                "name": "number outerAngle"
            },
            {
                "descr": "The Source's volume when the listener is outside both the inner and outer cone angles.",
                "name": "number outerVolume (0)"
            }
        ],
        "path": "love/source-setcone",
        "syntax": "Source:setCone( innerAngle, outerAngle, outerVolume )",
        "type": "love.audio"
    },
    "Source:setDirection": {
        "descr": "Sets the direction vector of the Source. A zero vector makes the source non-directional.",
        "name": "Source:setDirection",
        "params": [
            {
                "descr": "The X part of the direction vector.",
                "name": "number x"
            },
            {
                "descr": "The Y part of the direction vector.",
                "name": "number y"
            },
            {
                "descr": "The Z part of the direction vector.",
                "name": "number z"
            }
        ],
        "path": "love/source-setdirection",
        "syntax": "Source:setDirection( x, y, z )",
        "type": "love.audio"
    },
    "Source:setDistance": {
        "descr": "Sets the reference and maximum distance of the source.",
        "name": "Source:setDistance",
        "params": [
            {
                "descr": "The new reference distance.",
                "name": "number ref"
            },
            {
                "descr": "The new maximum distance.",
                "name": "number max"
            }
        ],
        "path": "love/source-setdistance",
        "syntax": "Source:setDistance( ref, max )",
        "type": "love.audio"
    },
    "Source:setLooping": {
        "descr": "Sets whether the Source should loop.",
        "name": "Source:setLooping",
        "params": [
            {
                "descr": "True if the source should loop, false otherwise.",
                "name": "boolean loop"
            }
        ],
        "path": "love/source-setlooping",
        "syntax": "Source:setLooping( loop )",
        "type": "love.audio"
    },
    "Source:setPitch": {
        "descr": "Sets the pitch of the Source.",
        "name": "Source:setPitch",
        "params": [
            {
                "descr": "Calculated with regard to 1 being the base pitch. ",
                "name": "number pitch"
            }
        ],
        "path": "love/source-setpitch",
        "syntax": "Source:setPitch( pitch )",
        "type": "love.audio"
    },
    "Source:setPosition": {
        "descr": "Sets the position of the Source. Please note that this only works for mono (i.e. non-stereo) sound files!",
        "name": "Source:setPosition",
        "params": [
            {
                "descr": "The X position of the Source.",
                "name": "number x"
            },
            {
                "descr": "The Y position of the Source.",
                "name": "number y"
            },
            {
                "descr": "The Z position of the Source.",
                "name": "number z"
            }
        ],
        "path": "love/source-setposition",
        "syntax": "Source:setPosition( x, y, z )",
        "type": "love.audio"
    },
    "Source:setRelative": {
        "descr": "Sets whether the Source's position, velocity, direction, and cone angles are relative to the listener, or absolute.",
        "name": "Source:setRelative",
        "params": [
            {
                "descr": "True to make the position, velocity, direction and cone angles relative to the listener, false to make them absolute.",
                "name": "boolean enable (\"false\")"
            }
        ],
        "path": "love/source-setrelative",
        "syntax": "Source:setRelative( enable )",
        "type": "love.audio"
    },
    "Source:setRolloff": {
        "descr": "Sets the rolloff factor which affects the strength of the used distance attenuation.",
        "name": "Source:setRolloff",
        "params": [
            {
                "descr": "The new rolloff factor.",
                "name": "number rolloff"
            }
        ],
        "path": "love/source-setrolloff",
        "syntax": "Source:setRolloff( rolloff )",
        "type": "love.audio"
    },
    "Source:setVelocity": {
        "descr": "Sets the velocity of the Source.",
        "name": "Source:setVelocity",
        "params": [
            {
                "descr": "The X part of the velocity vector.",
                "name": "number x"
            },
            {
                "descr": "The Y part of the velocity vector.",
                "name": "number y"
            },
            {
                "descr": "The Z part of the velocity vector.",
                "name": "number z"
            }
        ],
        "path": "love/source-setvelocity",
        "syntax": "Source:setVelocity( x, y, z )",
        "type": "love.audio"
    },
    "Source:setVolume": {
        "descr": "Sets the current volume of the Source.",
        "name": "Source:setVolume",
        "params": [
            {
                "descr": "The volume for a Source, where 1.0 is normal volume. ",
                "name": "number volume"
            }
        ],
        "path": "love/source-setvolume",
        "syntax": "Source:setVolume( volume )",
        "type": "love.audio"
    },
    "Source:setVolumeLimits": {
        "descr": "Sets the volume limits of the source. The limits have to be numbers from 0 to 1.",
        "name": "Source:setVolumeLimits",
        "params": [
            {
                "descr": "The minimum volume.",
                "name": "number min"
            },
            {
                "descr": "The maximum volume.",
                "name": "number max"
            }
        ],
        "path": "love/source-setvolumelimits",
        "syntax": "Source:setVolumeLimits( min, max )",
        "type": "love.audio"
    },
    "Source:stop": {
        "descr": "Stops a Source.",
        "name": "Source:stop",
        "params": [],
        "path": "love/source-stop",
        "syntax": "Source:stop()",
        "type": "love.audio"
    },
    "Source:tell": {
        "descr": "Gets the currently playing position of the Source.",
        "name": "Source:tell",
        "params": [
            {
                "descr": "The type of unit for the return value.",
                "name": "TimeUnit unit (\"seconds\")"
            },
            {
                "descr": "The currently playing position of the Source.",
                "name": "number position"
            }
        ],
        "path": "love/source-tell",
        "syntax": "position = Source:tell( unit )",
        "type": "love.audio"
    },
    "SpriteBatch:add": {
        "descr": "Adds a sprite to the batch. Sprites are drawn in the order they are added.",
        "name": "SpriteBatch:add",
        "params": [
            {
                "descr": "The position to draw the object (x-axis).",
                "name": "number x"
            },
            {
                "descr": "The position to draw the object (y-axis).",
                "name": "number y"
            },
            {
                "descr": "Orientation (radians).",
                "name": "number r (0)"
            },
            {
                "descr": "Scale factor (x-axis).",
                "name": "number sx (1)"
            },
            {
                "descr": "Scale factor (y-axis).",
                "name": "number sy (sx)"
            },
            {
                "descr": "Origin offset (x-axis).",
                "name": "number ox (0)"
            },
            {
                "descr": "Origin offset (y-axis).",
                "name": "number oy (0)"
            },
            {
                "descr": "Shear factor (x-axis).",
                "name": "number kx (0)"
            },
            {
                "descr": "Shear factor (y-axis).",
                "name": "number ky (0)"
            },
            {
                "descr": "An identifier for the added sprite.",
                "name": "number id"
            }
        ],
        "path": "love/spritebatch-add",
        "syntax": "id = SpriteBatch:add( x, y, r, sx, sy, ox, oy, kx, ky )",
        "type": "love.graphics"
    },
    "SpriteBatch:addq": {
        "descr": "Adds a Quad to the batch.",
        "name": "SpriteBatch:addq",
        "params": [
            {
                "descr": "The Quad to add.",
                "name": "Quad quad"
            },
            {
                "descr": "The position to draw the object (x-axis).",
                "name": "number x"
            },
            {
                "descr": "The position to draw the object (y-axis).",
                "name": "number y"
            },
            {
                "descr": "Orientation (radians).",
                "name": "number r (0)"
            },
            {
                "descr": "Scale factor (x-axis).",
                "name": "number sx (1)"
            },
            {
                "descr": "Scale factor (y-axis).",
                "name": "number sy (sx)"
            },
            {
                "descr": "Origin offset (x-axis).",
                "name": "number ox (0)"
            },
            {
                "descr": "Origin offset (y-axis).",
                "name": "number oy (0)"
            },
            {
                "descr": "Shear factor (x-axis).",
                "name": "number kx (0)"
            },
            {
                "descr": "Shear factor (y-axis).",
                "name": "number ky (0)"
            },
            {
                "descr": "An identifier for the added sprite.",
                "name": "number id"
            }
        ],
        "path": "love/spritebatch-addq",
        "syntax": "id = SpriteBatch:addq( quad, x, y, r, sx, sy, ox, oy, kx, ky )",
        "type": "love.graphics"
    },
    "SpriteBatch:attachAttribute": {
        "descr": "Attaches a per-vertex attribute from a Mesh onto this SpriteBatch, for use when drawing. This can be combined with a Shader to augment a SpriteBatch with per-vertex or additional per-sprite information instead of just having per-sprite colors.",
        "name": "SpriteBatch:attachAttribute",
        "params": [
            {
                "descr": "The name of the vertex attribute to attach.",
                "name": "string name"
            },
            {
                "descr": "The Mesh to get the vertex attribute from.",
                "name": "Mesh mesh"
            }
        ],
        "path": "love/spritebatch-attachattribute",
        "syntax": "SpriteBatch:attachAttribute( name, mesh )",
        "type": "love.graphics"
    },
    "SpriteBatch:bind": {
        "descr": "Binds the SpriteBatch to memory for more efficient updating.",
        "name": "SpriteBatch:bind",
        "params": [],
        "path": "love/spritebatch-bind",
        "syntax": "SpriteBatch:bind( )",
        "type": "love.graphics"
    },
    "SpriteBatch:clear": {
        "descr": "Removes all sprites from the buffer.",
        "name": "SpriteBatch:clear",
        "params": [],
        "path": "love/spritebatch-clear",
        "syntax": "SpriteBatch:clear( )",
        "type": "love.graphics"
    },
    "SpriteBatch:flush": {
        "descr": "Immediately sends all new and modified sprite data in the batch to the graphics card.",
        "name": "SpriteBatch:flush",
        "params": [],
        "path": "love/spritebatch-flush",
        "syntax": "SpriteBatch:flush( )",
        "type": "love.graphics"
    },
    "SpriteBatch:getBufferSize": {
        "descr": "Gets the maximum number of sprites the SpriteBatch can hold.",
        "name": "SpriteBatch:getBufferSize",
        "params": [
            {
                "descr": "The maximum number of sprites the batch can hold.",
                "name": "number size"
            }
        ],
        "path": "love/spritebatch-getbuffersize",
        "syntax": "size = SpriteBatch:getBufferSize( )",
        "type": "love.graphics"
    },
    "SpriteBatch:getColor": {
        "descr": "Gets the color that will be used for the next add and set operations.",
        "name": "SpriteBatch:getColor",
        "params": [
            {
                "descr": "The red component (0-255).",
                "name": "number r"
            },
            {
                "descr": "The green component (0-255).",
                "name": "number g"
            },
            {
                "descr": "The blue component (0-255).",
                "name": "number b"
            },
            {
                "descr": "The alpha component (0-255).",
                "name": "number a"
            }
        ],
        "path": "love/spritebatch-getcolor",
        "syntax": "r, g, b, a = SpriteBatch:getColor( )",
        "type": "love.graphics"
    },
    "SpriteBatch:getCount": {
        "descr": "Gets the number of sprites currently in the SpriteBatch.",
        "name": "SpriteBatch:getCount",
        "params": [
            {
                "descr": "The number of sprites currently in the batch.",
                "name": "number count"
            }
        ],
        "path": "love/spritebatch-getcount",
        "syntax": "count = SpriteBatch:getCount( )",
        "type": "love.graphics"
    },
    "SpriteBatch:getImage": {
        "descr": "Returns the image used by the SpriteBatch.",
        "name": "SpriteBatch:getImage",
        "params": [
            {
                "descr": "The image for the sprites.",
                "name": "Image image"
            }
        ],
        "path": "love/spritebatch-getimage",
        "syntax": "image = SpriteBatch:getImage( )",
        "type": "love.graphics"
    },
    "SpriteBatch:getTexture": {
        "descr": "Gets the texture (Image or Canvas) used by the SpriteBatch.",
        "name": "SpriteBatch:getTexture",
        "params": [
            {
                "descr": "The Image or Canvas used by the SpriteBatch.",
                "name": "Texture texture"
            }
        ],
        "path": "love/spritebatch-gettexture",
        "syntax": "texture = SpriteBatch:getTexture( )",
        "type": "love.graphics"
    },
    "SpriteBatch:set": {
        "descr": "Changes a sprite in the batch. This requires the identifier returned by add and addq.",
        "name": "SpriteBatch:set",
        "params": [
            {
                "descr": "The identifier of the sprite that will be changed.",
                "name": "number id"
            },
            {
                "descr": "The position to draw the object (x-axis).",
                "name": "number x"
            },
            {
                "descr": "The position to draw the object (y-axis).",
                "name": "number y"
            },
            {
                "descr": "Orientation (radians).",
                "name": "number r (0)"
            },
            {
                "descr": "Scale factor (x-axis).",
                "name": "number sx (1)"
            },
            {
                "descr": "Scale factor (y-axis).",
                "name": "number sy (sx)"
            },
            {
                "descr": "Origin offset (x-axis).",
                "name": "number ox (0)"
            },
            {
                "descr": "Origin offset (y-axis).",
                "name": "number oy (0)"
            },
            {
                "descr": "Shear factor (x-axis).",
                "name": "number kx (0)"
            },
            {
                "descr": "Shear factor (y-axis).",
                "name": "number ky (0)"
            }
        ],
        "path": "love/spritebatch-set",
        "syntax": "SpriteBatch:set( id, x, y, r, sx, sy, ox, oy, kx, ky )",
        "type": "love.graphics"
    },
    "SpriteBatch:setBufferSize": {
        "descr": "Sets the maximum number of sprites the SpriteBatch can hold. Existing sprites in the batch (up to the new maximum) will not be cleared when this function is called.",
        "name": "SpriteBatch:setBufferSize",
        "params": [
            {
                "descr": "The new maximum number of sprites the batch can hold.",
                "name": "number size"
            }
        ],
        "path": "love/spritebatch-setbuffersize",
        "syntax": "SpriteBatch:setBufferSize( size )",
        "type": "love.graphics"
    },
    "SpriteBatch:setColor": {
        "descr": "Sets the color that will be used for the next add and set operations. Calling the function without arguments will disable all per-sprite colors for the SpriteBatch.",
        "name": "SpriteBatch:setColor",
        "params": [
            {
                "descr": "The amount of red.",
                "name": "number r"
            },
            {
                "descr": "The amount of green.",
                "name": "number g"
            },
            {
                "descr": "The amount of blue.",
                "name": "number b"
            },
            {
                "descr": "The amount of alpha.",
                "name": "number a (255)"
            }
        ],
        "path": "love/spritebatch-setcolor",
        "syntax": "SpriteBatch:setColor( r, g, b, a )",
        "type": "love.graphics"
    },
    "SpriteBatch:setImage": {
        "descr": "Replaces the image used for the sprites.",
        "name": "SpriteBatch:setImage",
        "params": [
            {
                "descr": "The new Image to use for the sprites.",
                "name": "Image image"
            }
        ],
        "path": "love/spritebatch-setimage",
        "syntax": "SpriteBatch:setImage( image )",
        "type": "love.graphics"
    },
    "SpriteBatch:setTexture": {
        "descr": "Sets the texture (Image or Canvas) used for the sprites in the batch, when drawing.",
        "name": "SpriteBatch:setTexture",
        "params": [
            {
                "descr": "The new Image or Canvas to use for the sprites in the batch.",
                "name": "Texture texture"
            }
        ],
        "path": "love/spritebatch-settexture",
        "syntax": "SpriteBatch:setTexture( texture )",
        "type": "love.graphics"
    },
    "SpriteBatch:setq": {
        "descr": "Changes a sprite with a quad in the batch. This requires the identifier returned by add and addq.",
        "name": "SpriteBatch:setq",
        "params": [
            {
                "descr": "The identifier of the sprite that will be changed.",
                "name": "number id"
            },
            {
                "descr": "The quad used on the image of the batch.",
                "name": "Quad quad"
            },
            {
                "descr": "The position to draw the object (x-axis).",
                "name": "number x"
            },
            {
                "descr": "The position to draw the object (y-axis).",
                "name": "number y"
            },
            {
                "descr": "Orientation (radians).",
                "name": "number r (0)"
            },
            {
                "descr": "Scale factor (x-axis).",
                "name": "number sx (1)"
            },
            {
                "descr": "Scale factor (y-axis).",
                "name": "number sy (sx)"
            },
            {
                "descr": "Origin offset (x-axis).",
                "name": "number ox (0)"
            },
            {
                "descr": "Origin offset (y-axis).",
                "name": "number oy (0)"
            },
            {
                "descr": "Shear factor (x-axis).",
                "name": "number kx (0)"
            },
            {
                "descr": "Shear factor (y-axis).",
                "name": "number ky (0)"
            }
        ],
        "path": "love/spritebatch-setq",
        "syntax": "SpriteBatch:setq( id, quad, x, y, r, sx, sy, ox, oy, kx, ky )",
        "type": "love.graphics"
    },
    "SpriteBatch:unbind": {
        "descr": "Unbinds the SpriteBatch.",
        "name": "SpriteBatch:unbind",
        "params": [],
        "path": "love/spritebatch-unbind",
        "syntax": "SpriteBatch:unbind( )",
        "type": "love.graphics"
    },
    "Text:add": {
        "descr": "Adds additional colored text to the Text object at the specified position.",
        "name": "Text:add",
        "params": [
            {
                "descr": "The text to add to the object.",
                "name": "string textstring"
            },
            {
                "descr": "The position of the new text on the x-axis.",
                "name": "number x"
            },
            {
                "descr": "The position of the new text on the y-axis.",
                "name": "number y"
            },
            {
                "descr": "The orientation of the new text in radians.",
                "name": "number angle (0)"
            },
            {
                "descr": "Scale factor on the x-axis.",
                "name": "number sx (1)"
            },
            {
                "descr": "Scale factor on the y-axis.",
                "name": "number sy (sx)"
            },
            {
                "descr": "Origin offset on the x-axis.",
                "name": "number ox (0)"
            },
            {
                "descr": "Origin offset on the y-axis.",
                "name": "number oy (0)"
            },
            {
                "descr": "Shearing / skew factor on the x-axis.",
                "name": "number kx (0)"
            },
            {
                "descr": "Shearing / skew factor on the y-axis.",
                "name": "number ky (0)"
            },
            {
                "descr": "An index number that can be used with Text:getWidth or Text:getHeight.",
                "name": "number index"
            }
        ],
        "path": "love/text-add",
        "syntax": "index = Text:add( textstring, x, y, angle, sx, sy, ox, oy, kx, ky )",
        "type": "love.graphics"
    },
    "Text:addf": {
        "descr": "Adds additional formatted / colored text to the Text object at the specified position.",
        "name": "Text:addf",
        "params": [
            {
                "descr": "The text to add to the object.",
                "name": "string textstring"
            },
            {
                "descr": "The maximum width in pixels of the text before it gets automatically wrapped to a new line.",
                "name": "number wraplimit"
            },
            {
                "descr": "The alignment of the text.",
                "name": "AlignMode align"
            },
            {
                "descr": "The position of the new text (x-axis).",
                "name": "number x"
            },
            {
                "descr": "The position of the new text (y-axis).",
                "name": "number y"
            },
            {
                "descr": "Orientation (radians).",
                "name": "number angle (0)"
            },
            {
                "descr": "Scale factor (x-axis).",
                "name": "number sx (1)"
            },
            {
                "descr": "Scale factor (y-axis).",
                "name": "number sy (sx)"
            },
            {
                "descr": "Origin offset (x-axis).",
                "name": "number ox (0)"
            },
            {
                "descr": "Origin offset (y-axis).",
                "name": "number oy (0)"
            },
            {
                "descr": "Shearing / skew factor (x-axis).",
                "name": "number kx (0)"
            },
            {
                "descr": "Shearing / skew factor (y-axis).",
                "name": "number ky (0)"
            },
            {
                "descr": "An index number that can be used with Text:getWidth or Text:getHeight.",
                "name": "number index"
            }
        ],
        "path": "love/text-addf",
        "syntax": "index = Text:addf( textstring, wraplimit, alignmode, x, y, angle, sx, sy, ox, oy, kx, ky )",
        "type": "love.graphics"
    },
    "Text:clear": {
        "descr": "Clears the contents of the Text object.",
        "name": "Text:clear",
        "params": [],
        "path": "love/text-clear",
        "syntax": "Text:clear( )",
        "type": "love.graphics"
    },
    "Text:getDimensions": {
        "descr": "Gets the width and height of the text in pixels.",
        "name": "Text:getDimensions",
        "params": [
            {
                "descr": "The width of the text. If multiple sub-strings have been added with Text:add, the width of the last sub-string is returned.",
                "name": "number width"
            },
            {
                "descr": "The height of the text. If multiple sub-strings have been added with Text:add, the height of the last sub-string is returned.",
                "name": "number height"
            }
        ],
        "path": "love/text-getdimensions",
        "syntax": "width, height = Text:getDimensions( )",
        "type": "love.graphics"
    },
    "Text:getFont": {
        "descr": "Gets the Font used with the Text object.",
        "name": "Text:getFont",
        "params": [
            {
                "descr": "The font used with this Text object.",
                "name": "Font font"
            }
        ],
        "path": "love/text-getfont",
        "syntax": "font = Text:getFont( )",
        "type": "love.graphics"
    },
    "Text:getHeight": {
        "descr": "Gets the height of the text in pixels.",
        "name": "Text:getHeight",
        "params": [
            {
                "descr": "The height of the text. If multiple sub-strings have been added with Text:add, the height of the last sub-string is returned.",
                "name": "number height"
            }
        ],
        "path": "love/text-getheight",
        "syntax": "height = Text:getHeight( )",
        "type": "love.graphics"
    },
    "Text:getWidth": {
        "descr": "Gets the width of the text in pixels.",
        "name": "Text:getWidth",
        "params": [
            {
                "descr": "The width of the text. If multiple sub-strings have been added with Text:add, the width of the last sub-string is returned.",
                "name": "number width"
            }
        ],
        "path": "love/text-getwidth",
        "syntax": "width = Text:getWidth( )",
        "type": "love.graphics"
    },
    "Text:set": {
        "descr": "Replaces the contents of the Text object with a new unformatted string.",
        "name": "Text:set",
        "params": [
            {
                "descr": "The new string of text to use.",
                "name": "string textstring"
            }
        ],
        "path": "love/text-set",
        "syntax": "Text:set( textstring )",
        "type": "love.graphics"
    },
    "Text:setFont": {
        "descr": "Replaces the Font used with the text.",
        "name": "Text:setFont",
        "params": [
            {
                "descr": "The new font to use with this Text object.",
                "name": "Font font"
            }
        ],
        "path": "love/text-setfont",
        "syntax": "Text:setFont( font )",
        "type": "love.graphics"
    },
    "Text:setf": {
        "descr": "Replaces the contents of the Text object with a new formatted string.",
        "name": "Text:setf",
        "params": [
            {
                "descr": "The new string of text to use.",
                "name": "string textstring"
            },
            {
                "descr": "The maximum width in pixels of the text before it gets automatically wrapped to a new line.",
                "name": "number wraplimit"
            },
            {
                "descr": "The alignment of the text.",
                "name": "AlignMode align (\"left\")"
            }
        ],
        "path": "love/text-setf",
        "syntax": "Text:setf( textstring, wraplimit, alignmode )",
        "type": "love.graphics"
    },
    "Thread:demand": {
        "descr": "Receive a message from a thread. Wait for the message to exist before returning. (Can return nil in case of an error in the thread.)",
        "name": "Thread:demand",
        "params": [
            {
                "descr": "The name of the message.",
                "name": "string name"
            },
            {
                "descr": "The contents of the message.",
                "name": "value value"
            }
        ],
        "path": "love/thread-demand",
        "syntax": "value = Thread:demand( name )",
        "type": "love.thread"
    },
    "Thread:get": {
        "descr": "Retrieves the value of a message and removes it from the thread's message box.",
        "name": "Thread:get",
        "params": [
            {
                "descr": "The name of the message.",
                "name": "string name"
            },
            {
                "descr": "The contents of the message or nil when no message in message box.",
                "name": "value value"
            }
        ],
        "path": "love/thread-get",
        "syntax": "value = Thread:get( name )",
        "type": "love.thread"
    },
    "Thread:getError": {
        "descr": "Retrieves the error string from the thread if it produced an error.",
        "name": "Thread:getError",
        "params": [
            {
                "descr": "The error message.",
                "name": "string value"
            }
        ],
        "path": "love/thread-geterror",
        "syntax": "value = Thread:getError( )",
        "type": "love.thread"
    },
    "Thread:getKeys": {
        "descr": "Returns a table with the names of all messages in the message box.",
        "name": "Thread:getKeys",
        "params": [
            {
                "descr": "A sequence with all the message names.",
                "name": "table msgNames"
            }
        ],
        "path": "love/thread-getkeys",
        "syntax": "msgNames = Thread:getKeys()",
        "type": "love.thread"
    },
    "Thread:getName": {
        "descr": "Get the name of a thread.",
        "name": "Thread:getName",
        "params": [
            {
                "descr": "The name of the thread.",
                "name": "string name"
            }
        ],
        "path": "love/thread-getname",
        "syntax": "name = Thread:getName( )",
        "type": "love.thread"
    },
    "Thread:isRunning": {
        "descr": "Returns whether the thread is currently running.",
        "name": "Thread:isRunning",
        "params": [
            {
                "descr": "True if the thread is running, false otherwise.",
                "name": "boolean value"
            }
        ],
        "path": "love/thread-isrunning",
        "syntax": "running = Thread:isRunning( )",
        "type": "love.thread"
    },
    "Thread:kill": {
        "descr": "Forcefully terminate the thread.",
        "name": "Thread:kill",
        "params": [],
        "path": "love/thread-kill",
        "syntax": "Thread:kill( )",
        "type": "love.thread"
    },
    "Thread:peek": {
        "descr": "Retrieves the value of a message, but leaves it in the thread's message box. The name of the message can be any string. The value of the message can be a boolean, string, number or a LÖVE userdata. It returns nil, if there's no message with the given name.",
        "name": "Thread:peek",
        "params": [
            {
                "descr": "The name of the message.",
                "name": "string name"
            },
            {
                "descr": "The contents of the message.",
                "name": "boolean, number, string or LÖVE userdata value"
            }
        ],
        "path": "love/thread-peek",
        "syntax": "value = Thread:peek( name )",
        "type": "love.thread"
    },
    "Thread:receive": {
        "descr": "Receive a message from a thread. Returns nil when a message is not in the message box.",
        "name": "Thread:receive",
        "params": [
            {
                "descr": "The name of the message.",
                "name": "string name"
            },
            {
                "descr": "The contents of the message or nil when no message in message box.",
                "name": "value value"
            }
        ],
        "path": "love/thread-receive",
        "syntax": "value = Thread:receive(name)",
        "type": "love.thread"
    },
    "Thread:send": {
        "descr": "Send a message (put it in the message box).",
        "name": "Thread:send",
        "params": [
            {
                "descr": "The name of the message.",
                "name": "string name"
            },
            {
                "descr": "The contents of the message.",
                "name": "value value"
            }
        ],
        "path": "love/thread-send",
        "syntax": "Thread:send(name, value)",
        "type": "love.thread"
    },
    "Thread:set": {
        "descr": "Sets a value in the message box of the thread. The name of the message can be any string. The value of the message can be a boolean, string, number or a LÖVE userdata. Foreign userdata (Lua's files, LuaSocket, ...), functions or tables are not supported.",
        "name": "Thread:set",
        "params": [
            {
                "descr": "The name of the message.",
                "name": "string name"
            },
            {
                "descr": "The contents of the message.",
                "name": "boolean, string, number or LÖVE userdata value"
            }
        ],
        "path": "love/thread-set",
        "syntax": "Thread:set(name, value)",
        "type": "love.thread"
    },
    "Thread:start": {
        "descr": "Starts the thread.",
        "name": "Thread:start",
        "params": [],
        "path": "love/thread-start",
        "syntax": "Thread:start( )",
        "type": "love.thread"
    },
    "Thread:wait": {
        "descr": "Wait for a thread to finish. This call will block until the thread finishes.",
        "name": "Thread:wait",
        "params": [],
        "path": "love/thread-wait",
        "syntax": "Thread:wait( )",
        "type": "love.thread"
    },
    "Video:getDimensions": {
        "descr": "Gets the width and height of the Video in pixels.",
        "name": "Video:getDimensions",
        "params": [
            {
                "descr": "The width of the Video.",
                "name": "number width"
            },
            {
                "descr": "The height of the Video.",
                "name": "number height"
            }
        ],
        "path": "love/video-getdimensions",
        "syntax": "width, height = Video:getDimensions( )",
        "type": "love.graphics"
    },
    "Video:getFilter": {
        "descr": "Gets the scaling filters used when drawing the Video.",
        "name": "Video:getFilter",
        "params": [
            {
                "descr": "The filter mode used when scaling the Video down.",
                "name": "FilterMode min"
            },
            {
                "descr": "The filter mode used when scaling the Video up.",
                "name": "FilterMode mag"
            },
            {
                "descr": "Maximum amount of anisotropic filtering used.",
                "name": "number anisotropy (1)"
            }
        ],
        "path": "love/video-getfilter",
        "syntax": "min, mag, anisotropy = Video:getFilter( )",
        "type": "love.graphics"
    },
    "Video:getHeight": {
        "descr": "Gets the height of the Video in pixels.",
        "name": "Video:getHeight",
        "params": [
            {
                "descr": "The height of the Video.",
                "name": "number height"
            }
        ],
        "path": "love/video-getheight",
        "syntax": "height = Video:getHeight( )",
        "type": "love.graphics"
    },
    "Video:getSource": {
        "descr": "Gets the audio Source used for playing back the video's audio. May return nil if the video has no audio, or if Video:setSource is called with a nil argument.",
        "name": "Video:getSource",
        "params": [
            {
                "descr": "The audio Source used for audio playback, or nil if the video has no audio.",
                "name": "Source source"
            }
        ],
        "path": "love/video-getsource",
        "syntax": "source = Video:getSource( )",
        "type": "love.graphics"
    },
    "Video:getStream": {
        "descr": "Gets the VideoStream object used for decoding and controlling the video.",
        "name": "Video:getStream",
        "params": [
            {
                "descr": "The VideoStream used for decoding and controlling the video.",
                "name": "VideoStream stream"
            }
        ],
        "path": "love/video-getstream",
        "syntax": "stream = Video:getStream( )",
        "type": "love.graphics"
    },
    "Video:getWidth": {
        "descr": "Gets the width of the Video in pixels.",
        "name": "Video:getWidth",
        "params": [
            {
                "descr": "The width of the Video.",
                "name": "number width"
            }
        ],
        "path": "love/video-getwidth",
        "syntax": "width = Video:getWidth( )",
        "type": "love.graphics"
    },
    "Video:isPlaying": {
        "descr": "Gets whether the Video is currently playing.",
        "name": "Video:isPlaying",
        "params": [
            {
                "descr": "Whether the video is playing.",
                "name": "boolean playing"
            }
        ],
        "path": "love/video-isplaying",
        "syntax": "playing = Video:isPlaying( )",
        "type": "love.graphics"
    },
    "Video:pause": {
        "descr": "Pauses the Video.",
        "name": "Video:pause",
        "params": [],
        "path": "love/video-pause",
        "syntax": "Video:pause( )",
        "type": "love.graphics"
    },
    "Video:play": {
        "descr": "Starts playing the Video. In order for the video to appear onscreen it must be drawn with love.graphics.draw.",
        "name": "Video:play",
        "params": [],
        "path": "love/video-play",
        "syntax": "Video:play( )",
        "type": "love.graphics"
    },
    "Video:rewind": {
        "descr": "Rewinds the Video to the beginning.",
        "name": "Video:rewind",
        "params": [],
        "path": "love/video-rewind",
        "syntax": "Video:rewind( )",
        "type": "love.graphics"
    },
    "Video:seek": {
        "descr": "Sets the current playback position of the Video.",
        "name": "Video:seek",
        "params": [
            {
                "descr": "The time in seconds since the beginning of the Video.",
                "name": "number offset"
            }
        ],
        "path": "love/video-seek",
        "syntax": "Video:seek( offset )",
        "type": "love.graphics"
    },
    "Video:setFilter": {
        "descr": "Sets the scaling filters used when drawing the Video.",
        "name": "Video:setFilter",
        "params": [
            {
                "descr": "The filter mode used when scaling the Video down.",
                "name": "FilterMode min"
            },
            {
                "descr": "The filter mode used when scaling the Video up.",
                "name": "FilterMode mag"
            },
            {
                "descr": "Maximum amount of anisotropic filtering used.",
                "name": "number anisotropy (1)"
            }
        ],
        "path": "love/video-setfilter",
        "syntax": "Video:setFilter( min, mag, anisotropy )",
        "type": "love.graphics"
    },
    "Video:setSource": {
        "descr": "Sets the audio Source used for playing back the video's audio. The audio Source also controls playback speed and synchronization.",
        "name": "Video:setSource",
        "params": [
            {
                "descr": "The audio Source used for audio playback, or nil to disable audio synchronization.",
                "name": "Source source (nil)"
            }
        ],
        "path": "love/video-setsource",
        "syntax": "Video:setSource( source )",
        "type": "love.graphics"
    },
    "Video:tell": {
        "descr": "Gets the current playback position of the Video.",
        "name": "Video:tell",
        "params": [
            {
                "descr": "The time in seconds since the beginning of the Video.",
                "name": "number seconds"
            }
        ],
        "path": "love/video-tell",
        "syntax": "seconds = Video:tell( )",
        "type": "love.graphics"
    },
    "WeldJoint:getDampingRatio": {
        "descr": "Returns the damping ratio of the joint.",
        "name": "WeldJoint:getDampingRatio",
        "params": [
            {
                "descr": "The damping ratio.",
                "name": "number ratio"
            }
        ],
        "path": "love/weldjoint-getdampingratio",
        "syntax": "ratio = WeldJoint:getDampingRatio( )",
        "type": "love.physics"
    },
    "WeldJoint:getFrequency": {
        "descr": "Returns the frequency.",
        "name": "WeldJoint:getFrequency",
        "params": [
            {
                "descr": "The frequency in hertz.",
                "name": "number freq"
            }
        ],
        "path": "love/weldjoint-getfrequency",
        "syntax": "freq = WeldJoint:getFrequency( )",
        "type": "love.physics"
    },
    "WeldJoint:setDampingRatio": {
        "descr": "Sets a new damping ratio.",
        "name": "WeldJoint:setDampingRatio",
        "params": [
            {
                "descr": "The new damping ratio.",
                "name": "number ratio"
            }
        ],
        "path": "love/weldjoint-setdampingratio",
        "syntax": "WeldJoint:setDampingRatio( ratio )",
        "type": "love.physics"
    },
    "WeldJoint:setFrequency": {
        "descr": "Sets a new frequency.",
        "name": "WeldJoint:setFrequency",
        "params": [
            {
                "descr": "The new frequency in hertz.",
                "name": "number freq"
            }
        ],
        "path": "love/weldjoint-setfrequency",
        "syntax": "WeldJoint:setFrequency( freq )",
        "type": "love.physics"
    },
    "WheelJoint:enableMotor": {
        "descr": "Starts and stops the joint motor.",
        "name": "WheelJoint:enableMotor",
        "params": [
            {
                "descr": "True turns the motor on and false turns it off.",
                "name": "boolean on"
            }
        ],
        "path": "love/wheeljoint-enablemotor",
        "syntax": "WheelJoint:enableMotor( on )",
        "type": "love.physics"
    },
    "WheelJoint:getAxis": {
        "descr": "Gets the world-space axis vector of the Wheel Joint.",
        "name": "WheelJoint:getAxis",
        "params": [
            {
                "descr": "The x-axis coordinate of the world-space axis vector.",
                "name": "number x"
            },
            {
                "descr": "The y-axis coordinate of the world-space axis vector.",
                "name": "number y"
            }
        ],
        "path": "love/wheeljoint-getaxis",
        "syntax": "x, y = WheelJoint:getAxis( )",
        "type": "love.physics"
    },
    "WheelJoint:getJointSpeed": {
        "descr": "Returns the current joint translation speed.",
        "name": "WheelJoint:getJointSpeed",
        "params": [
            {
                "descr": "The translation speed of the joint in meters per second.",
                "name": "number speed"
            }
        ],
        "path": "love/wheeljoint-getjointspeed",
        "syntax": "speed = WheelJoint:getJointSpeed( )",
        "type": "love.physics"
    },
    "WheelJoint:getJointTranslation": {
        "descr": "Returns the current joint translation.",
        "name": "WheelJoint:getJointTranslation",
        "params": [
            {
                "descr": "The translation of the joint in meters.",
                "name": "number position"
            }
        ],
        "path": "love/wheeljoint-getjointtranslation",
        "syntax": "position = WheelJoint:getJointTranslation( )",
        "type": "love.physics"
    },
    "WheelJoint:getMaxMotorTorque": {
        "descr": "Returns the maximum motor torque.",
        "name": "WheelJoint:getMaxMotorTorque",
        "params": [
            {
                "descr": "The maximum torque of the joint motor in newton meters.",
                "name": "number maxTorque"
            }
        ],
        "path": "love/wheeljoint-getmaxmotortorque",
        "syntax": "maxTorque = WheelJoint:getMaxMotorTorque( )",
        "type": "love.physics"
    },
    "WheelJoint:getMotorSpeed": {
        "descr": "Returns the speed of the motor.",
        "name": "WheelJoint:getMotorSpeed",
        "params": [
            {
                "descr": "The speed of the joint motor in radians per second.",
                "name": "number speed"
            }
        ],
        "path": "love/wheeljoint-getmotorspeed",
        "syntax": "speed = WheelJoint:getMotorSpeed( )",
        "type": "love.physics"
    },
    "WheelJoint:getMotorTorque": {
        "descr": "Returns the current torque on the motor.",
        "name": "WheelJoint:getMotorTorque",
        "params": [
            {
                "descr": "How long the force applies. Usually the inverse time step or 1/dt.",
                "name": "number invdt"
            },
            {
                "descr": "The torque on the motor in newton meters.",
                "name": "number torque"
            }
        ],
        "path": "love/wheeljoint-getmotortorque",
        "syntax": "torque = WheelJoint:getMotorTorque( invdt )",
        "type": "love.physics"
    },
    "WheelJoint:getSpringDampingRatio": {
        "descr": "Returns the damping ratio.",
        "name": "WheelJoint:getSpringDampingRatio",
        "params": [
            {
                "descr": "The damping ratio.",
                "name": "number ratio"
            }
        ],
        "path": "love/wheeljoint-getspringdampingratio",
        "syntax": "ratio = WheelJoint:getSpringDampingRatio( )",
        "type": "love.physics"
    },
    "WheelJoint:getSpringFrequency": {
        "descr": "Returns the spring frequency.",
        "name": "WheelJoint:getSpringFrequency",
        "params": [
            {
                "descr": "The frequency in hertz.",
                "name": "number freq"
            }
        ],
        "path": "love/wheeljoint-getspringfrequency",
        "syntax": "freq = WheelJoint:getSpringFrequency( )",
        "type": "love.physics"
    },
    "WheelJoint:isMotorEnabled": {
        "descr": "Checks if the joint motor is running.",
        "name": "WheelJoint:isMotorEnabled",
        "params": [
            {
                "descr": "The status of the joint motor.",
                "name": "boolean on"
            }
        ],
        "path": "love/wheeljoint-ismotorenabled",
        "syntax": "on = WheelJoint:isMotorEnabled( )",
        "type": "love.physics"
    },
    "WheelJoint:setMaxMotorTorque": {
        "descr": "Sets a new maximum motor torque.",
        "name": "WheelJoint:setMaxMotorTorque",
        "params": [
            {
                "descr": "The new maximum torque for the joint motor in newton meters.",
                "name": "number maxTorque"
            }
        ],
        "path": "love/wheeljoint-setmaxmotortorque",
        "syntax": "WheelJoint:setMaxMotorTorque( maxTorque )",
        "type": "love.physics"
    },
    "WheelJoint:setMotorEnabled": {
        "descr": "Starts and stops the joint motor.",
        "name": "WheelJoint:setMotorEnabled",
        "params": [
            {
                "descr": "True turns the motor on and false turns it off.",
                "name": "boolean enable"
            }
        ],
        "path": "love/wheeljoint-setmotorenabled",
        "syntax": "WheelJoint:setMotorEnabled( enable )",
        "type": "love.physics"
    },
    "WheelJoint:setMotorSpeed": {
        "descr": "Sets a new speed for the motor.",
        "name": "WheelJoint:setMotorSpeed",
        "params": [
            {
                "descr": "The new speed for the joint motor in radians per second.",
                "name": "number speed"
            }
        ],
        "path": "love/wheeljoint-setmotorspeed",
        "syntax": "WheelJoint:setMotorSpeed( speed )",
        "type": "love.physics"
    },
    "WheelJoint:setSpringDampingRatio": {
        "descr": "Sets a new damping ratio.",
        "name": "WheelJoint:setSpringDampingRatio",
        "params": [
            {
                "descr": "The new damping ratio.",
                "name": "number ratio"
            }
        ],
        "path": "love/wheeljoint-setspringdampingratio",
        "syntax": "WheelJoint:setSpringDampingRatio( ratio )",
        "type": "love.physics"
    },
    "WheelJoint:setSpringFrequency": {
        "descr": "Sets a new spring frequency.",
        "name": "WheelJoint:setSpringFrequency",
        "params": [
            {
                "descr": "The new frequency in hertz.",
                "name": "number freq"
            }
        ],
        "path": "love/wheeljoint-setspringfrequency",
        "syntax": "WheelJoint:setSpringFrequency( freq )",
        "type": "love.physics"
    },
    "World:destroy": {
        "descr": "Destroys the world, taking all bodies, joints, fixtures and their shapes with it.",
        "name": "World:destroy",
        "params": [],
        "path": "love/world-destroy",
        "syntax": "World:destroy( )",
        "type": "love.physics"
    },
    "World:getAllowSleeping": {
        "descr": "Returns the sleep behaviour of the world.",
        "name": "World:getAllowSleeping",
        "params": [
            {
                "descr": "True if the bodies are allowed to sleep or false if not.",
                "name": "boolean allowSleep"
            }
        ],
        "path": "love/world-getallowsleeping",
        "syntax": "allowSleep = World:getAllowSleeping( )",
        "type": "love.physics"
    },
    "World:getBodyCount": {
        "descr": "Returns the number of bodies in the world.",
        "name": "World:getBodyCount",
        "params": [
            {
                "descr": "The number of bodies in the world.",
                "name": "number n"
            }
        ],
        "path": "love/world-getbodycount",
        "syntax": "n = World:getBodyCount( )",
        "type": "love.physics"
    },
    "World:getBodyList": {
        "descr": "Returns a table with all bodies.",
        "name": "World:getBodyList",
        "params": [
            {
                "descr": "A sequence with all bodies.",
                "name": "table bodies"
            }
        ],
        "path": "love/world-getbodylist",
        "syntax": "bodies = World:getBodyList( )",
        "type": "love.physics"
    },
    "World:getCallbacks": {
        "descr": "Returns functions for the callbacks during the world update.",
        "name": "World:getCallbacks",
        "params": [
            {
                "descr": "Gets called when two fixtures begin to overlap.",
                "name": "function beginContact"
            },
            {
                "descr": "Gets called when two fixtures cease to overlap.",
                "name": "function endContact"
            },
            {
                "descr": "Gets called before a collision gets resolved.",
                "name": "function preSolve"
            },
            {
                "descr": "Gets called after the collision has been resolved.",
                "name": "function postSolve"
            }
        ],
        "path": "love/world-getcallbacks",
        "syntax": "beginContact, endContact, preSolve, postSolve = World:getCallbacks( )",
        "type": "love.physics"
    },
    "World:getContactCount": {
        "descr": "Returns the number of contacts in the world.",
        "name": "World:getContactCount",
        "params": [
            {
                "descr": "The number of contacts in the world.",
                "name": "number n"
            }
        ],
        "path": "love/world-getcontactcount",
        "syntax": "n = World:getContactCount( )",
        "type": "love.physics"
    },
    "World:getContactFilter": {
        "descr": "Returns the function for collision filtering.",
        "name": "World:getContactFilter",
        "params": [
            {
                "descr": "The function that handles the contact filtering.",
                "name": "function contactFilter"
            }
        ],
        "path": "love/world-getcontactfilter",
        "syntax": "contactFilter = World:getContactFilter( )",
        "type": "love.physics"
    },
    "World:getContactList": {
        "descr": "Returns a table with all contacts.",
        "name": "World:getContactList",
        "params": [
            {
                "descr": "A sequence with all contacts.",
                "name": "table contacts"
            }
        ],
        "path": "love/world-getcontactlist",
        "syntax": "contacts = World:getContactList( )",
        "type": "love.physics"
    },
    "World:getGravity": {
        "descr": "Get the gravity of the world.",
        "name": "World:getGravity",
        "params": [
            {
                "descr": "The x component of gravity.",
                "name": "number x"
            },
            {
                "descr": "The y component of gravity.",
                "name": "number y"
            }
        ],
        "path": "love/world-getgravity",
        "syntax": "x, y = World:getGravity( )",
        "type": "love.physics"
    },
    "World:getJointCount": {
        "descr": "Returns the number of joints in the world.",
        "name": "World:getJointCount",
        "params": [
            {
                "descr": "The number of joints in the world.",
                "name": "number n"
            }
        ],
        "path": "love/world-getjointcount",
        "syntax": "n = World:getJointCount( )",
        "type": "love.physics"
    },
    "World:getJointList": {
        "descr": "Returns a table with all joints.",
        "name": "World:getJointList",
        "params": [
            {
                "descr": "A sequence with all joints.",
                "name": "table joints"
            }
        ],
        "path": "love/world-getjointlist",
        "syntax": "joints = World:getJointList( )",
        "type": "love.physics"
    },
    "World:isAllowSleep": {
        "descr": "Get the sleep behaviour of the world.",
        "name": "World:isAllowSleep",
        "params": [
            {
                "descr": "Permission for any body to sleep.",
                "name": "boolean permission"
            }
        ],
        "path": "love/world-isallowsleep",
        "syntax": "permission = World:isAllowSleep( )",
        "type": "love.physics"
    },
    "World:isDestroyed": {
        "descr": "Gets whether the World is destroyed. Destroyed worlds cannot be used.",
        "name": "World:isDestroyed",
        "params": [
            {
                "descr": "Whether the World is destroyed.",
                "name": "boolean destroyed"
            }
        ],
        "path": "love/world-isdestroyed",
        "syntax": "destroyed = World:isDestroyed( )",
        "type": "love.physics"
    },
    "World:isLocked": {
        "descr": "Returns if the world is updating its state.",
        "name": "World:isLocked",
        "params": [
            {
                "descr": "Will be true if the world is in the process of updating its state.",
                "name": "boolean locked"
            }
        ],
        "path": "love/world-islocked",
        "syntax": "locked = World:isLocked( )",
        "type": "love.physics"
    },
    "World:isSleepingAllowed": {
        "descr": "Gets the sleep behaviour of the world.",
        "name": "World:isSleepingAllowed",
        "params": [
            {
                "descr": "True if bodies in the world are allowed to sleep, or false if not.",
                "name": "boolean allow"
            }
        ],
        "path": "love/world-issleepingallowed",
        "syntax": "allow = World:isSleepingAllowed( )",
        "type": "love.physics"
    },
    "World:queryBoundingBox": {
        "descr": "Calls a function for each fixture inside the specified area by searching for any overlapping bounding box (Fixture:getBoundingBox).",
        "name": "World:queryBoundingBox",
        "params": [
            {
                "descr": "The x position of the top-left point.",
                "name": "number topLeftX"
            },
            {
                "descr": "The y position of the top-left point.",
                "name": "number topLeftY"
            },
            {
                "descr": "The x position of the bottom-right point.",
                "name": "number bottomRightX"
            },
            {
                "descr": "The y position of the bottom-right point.",
                "name": "number bottomRightY"
            },
            {
                "descr": "This function gets passed one argument, the fixture, and should return a boolean. ",
                "name": "function callback"
            }
        ],
        "path": "love/world-queryboundingbox",
        "syntax": "World:queryBoundingBox( topLeftX, topLeftY, bottomRightX, bottomRightY, callback )",
        "type": "love.physics"
    },
    "World:rayCast": {
        "descr": "Casts a ray and calls a function for each fixtures it intersects.",
        "name": "World:rayCast",
        "params": [
            {
                "descr": "The x position of the starting point of the ray.",
                "name": "number x1"
            },
            {
                "descr": "The y position of the starting point of the ray.",
                "name": "number y1"
            },
            {
                "descr": "The x position of the end point of the ray.",
                "name": "number x2"
            },
            {
                "descr": "The y position of the end point of the ray.",
                "name": "number y2"
            },
            {
                "descr": "A function called for each fixture intersected by the ray. ",
                "name": "function callback"
            },
            {
                "descr": "The fixture intersecting the ray.",
                "name": "Fixture fixture"
            },
            {
                "descr": "The x position of the intersection point.",
                "name": "number x"
            },
            {
                "descr": "The y position of the intersection point.",
                "name": "number y"
            },
            {
                "descr": "The x value of the surface normal vector of the shape edge.",
                "name": "number xn"
            },
            {
                "descr": "The y value of the surface normal vector of the shape edge.",
                "name": "number yn"
            },
            {
                "descr": "The position of the intersection on the ray as a number from 0 to 1 (or even higher if the ray length was changed with the return value).",
                "name": "number fraction"
            },
            {
                "descr": "The ray can be controlled with the return value. ",
                "name": "number control"
            }
        ],
        "path": "love/world-raycast",
        "syntax": "World:rayCast( x1, y1, x2, y2, callback )",
        "type": "love.physics"
    },
    "World:setAllowSleep": {
        "descr": "Set the sleep behaviour of the world.",
        "name": "World:setAllowSleep",
        "params": [
            {
                "descr": "Permission for any body to sleep.",
                "name": "boolean permission"
            }
        ],
        "path": "love/world-setallowsleep",
        "syntax": "World:setAllowSleep( permission )",
        "type": "love.physics"
    },
    "World:setAllowSleeping": {
        "descr": "Sets the sleep behaviour of the world.",
        "name": "World:setAllowSleeping",
        "params": [
            {
                "descr": "True if the bodies are allowed to sleep or false if not.",
                "name": "boolean allowSleep"
            }
        ],
        "path": "love/world-setallowsleeping",
        "syntax": "World:setAllowSleeping( allowSleep )",
        "type": "love.physics"
    },
    "World:setCallbacks": {
        "descr": "Sets functions for the collision callbacks during the world update.",
        "name": "World:setCallbacks",
        "params": [
            {
                "descr": "Gets called when two fixtures begin to overlap.",
                "name": "function beginContact"
            },
            {
                "descr": "Gets called when two fixtures cease to overlap. ",
                "name": "function endContact"
            },
            {
                "descr": "Gets called before a collision gets resolved.",
                "name": "function preSolve"
            },
            {
                "descr": "Gets called after the collision has been resolved.",
                "name": "function postSolve"
            }
        ],
        "path": "love/world-setcallbacks",
        "syntax": "World:setCallbacks( beginContact, endContact, preSolve, postSolve )",
        "type": "love.physics"
    },
    "World:setContactFilter": {
        "descr": "Sets a function for collision filtering.",
        "name": "World:setContactFilter",
        "params": [
            {
                "descr": "The function handling the contact filtering.",
                "name": "function filter"
            }
        ],
        "path": "love/world-setcontactfilter",
        "syntax": "World:setContactFilter( filter )",
        "type": "love.physics"
    },
    "World:setGravity": {
        "descr": "Set the gravity of the world.",
        "name": "World:setGravity",
        "params": [
            {
                "descr": "The x component of gravity.",
                "name": "number x"
            },
            {
                "descr": "The y component of gravity.",
                "name": "number y"
            }
        ],
        "path": "love/world-setgravity",
        "syntax": "World:setGravity( x, y )",
        "type": "love.physics"
    },
    "World:setMeter": {
        "descr": "Set the scale of the world.",
        "name": "World:setMeter",
        "params": [
            {
                "descr": "The size of 1 meter in pixels.",
                "name": "number scale"
            }
        ],
        "path": "love/world-setmeter",
        "syntax": "World:setMeter( scale )",
        "type": "love.physics"
    },
    "World:setSleepingAllowed": {
        "descr": "Sets the sleep behaviour of the world.",
        "name": "World:setSleepingAllowed",
        "params": [
            {
                "descr": "True if bodies in the world are allowed to sleep, or false if not.",
                "name": "boolean allow"
            }
        ],
        "path": "love/world-setsleepingallowed",
        "syntax": "World:setSleepingAllowed( allow )",
        "type": "love.physics"
    },
    "World:translateOrigin": {
        "descr": "Translates the World's origin. Useful in large worlds where floating point precision issues become noticeable at far distances from the origin.",
        "name": "World:translateOrigin",
        "params": [
            {
                "descr": "The x component of the new origin with respect to the old origin.",
                "name": "number x"
            },
            {
                "descr": "The y component of the new origin with respect to the old origin.",
                "name": "number y"
            }
        ],
        "path": "love/world-translateorigin",
        "syntax": "World:translateOrigin( x, y )",
        "type": "love.physics"
    },
    "World:update": {
        "descr": "Update the state of the world.",
        "name": "World:update",
        "params": [
            {
                "descr": "The time (in seconds) to advance the physics simulation.",
                "name": "number dt"
            }
        ],
        "path": "love/world-update",
        "syntax": "World:update( dt )",
        "type": "love.physics"
    },
    "append": {
        "descr": "Append data to an existing file.",
        "name": "love.filesystem.append",
        "params": [
            {
                "descr": "The name (and path) of the file.",
                "name": "string name"
            },
            {
                "descr": "The string data to append to the file.",
                "name": "string data"
            },
            {
                "descr": "How many bytes to write.",
                "name": "number size (all)"
            },
            {
                "descr": "True if the operation was successful, or nil if there was an error.",
                "name": "boolean success"
            },
            {
                "descr": "The error message on failure.",
                "name": "string errormsg"
            }
        ],
        "path": "love/love.filesystem.append",
        "syntax": "success, errormsg = love.filesystem.append( name, data, size )",
        "type": "love.filesystem"
    },
    "arc": {
        "descr": "Draws a filled or unfilled arc at position (x, y). The arc is drawn from angle1 to angle2 in radians. The segments parameter determines how many segments are used to draw the arc. The more segments, the smoother the edge.",
        "name": "love.graphics.arc",
        "params": [
            {
                "descr": "How to draw the arc.",
                "name": "DrawMode drawmode"
            },
            {
                "descr": "The position of the center along x-axis.",
                "name": "number x"
            },
            {
                "descr": "The position of the center along y-axis.",
                "name": "number y"
            },
            {
                "descr": "Radius of the arc.",
                "name": "number radius"
            },
            {
                "descr": "The angle at which the arc begins.",
                "name": "number angle1"
            },
            {
                "descr": "The angle at which the arc terminates.",
                "name": "number angle2"
            },
            {
                "descr": "The number of segments used for drawing the arc.",
                "name": "number segments (10)"
            }
        ],
        "path": "love/love.graphics.arc",
        "syntax": "love.graphics.arc( drawmode, x, y, radius, angle1, angle2, segments )",
        "type": "love.graphics"
    },
    "areSymlinksEnabled": {
        "descr": "Gets whether love.filesystem follows symbolic links.",
        "name": "love.filesystem.areSymlinksEnabled",
        "params": [
            {
                "descr": "Whether love.filesystem follows symbolic links.",
                "name": "boolean enable"
            }
        ],
        "path": "love/love.filesystem.aresymlinksenabled",
        "syntax": "enabled = love.filesystem.areSymlinksEnabled( )",
        "type": "love.filesystem"
    },
    "checkMode": {
        "descr": "Checks if a display mode is supported.",
        "name": "love.graphics.checkMode",
        "params": [
            {
                "descr": "The display width.",
                "name": "number width"
            },
            {
                "descr": "The display height.",
                "name": "number height"
            },
            {
                "descr": "True to check for fullscreen, false for windowed.",
                "name": "boolean fullscreen (false)"
            },
            {
                "descr": "True if supported, false if not.",
                "name": "boolean supported"
            }
        ],
        "path": "love/love.graphics.checkmode",
        "syntax": "supported = love.graphics.checkMode( width, height, fullscreen )",
        "type": "love.graphics"
    },
    "circle": {
        "descr": "Draws a circle.",
        "name": "love.graphics.circle",
        "params": [
            {
                "descr": "How to draw the circle.",
                "name": "DrawMode mode"
            },
            {
                "descr": "The position of the center along x-axis.",
                "name": "number x"
            },
            {
                "descr": "The position of the center along y-axis.",
                "name": "number y"
            },
            {
                "descr": "The radius of the circle.",
                "name": "number radius"
            }
        ],
        "path": "love/love.graphics.circle",
        "syntax": "love.graphics.circle( mode, x, y, radius )",
        "type": "love.graphics"
    },
    "clear": {
        "descr": "Clears the screen to the background color in LÖVE 0.9.2 and earlier, or to the specified color in 0.10.0 and newer.",
        "name": "love.graphics.clear",
        "params": [],
        "path": "love/love.graphics.clear",
        "syntax": "love.graphics.clear( )",
        "type": "love.graphics"
    },
    "close": {
        "descr": "Closes the window. It can be reopened with love.window.setMode.",
        "name": "love.window.close",
        "params": [],
        "path": "love/love.window.close",
        "syntax": "love.window.close( )",
        "type": "love.window"
    },
    "compress": {
        "descr": "Compresses a string or data using a specific compression algorithm.",
        "name": "love.math.compress",
        "params": [
            {
                "descr": "The raw (un-compressed) string to compress.",
                "name": "string rawstring"
            },
            {
                "descr": "The format to use when compressing the string.",
                "name": "CompressedDataFormat format (\"lz4\")"
            },
            {
                "descr": "The level of compression to use, between 0 and 9. ",
                "name": "number level (-1)"
            },
            {
                "descr": "A new Data object containing the compressed version of the string.",
                "name": "CompressedData compressedData"
            }
        ],
        "path": "love/love.math.compress",
        "syntax": "compressedData = love.math.compress( rawstring, format, level )",
        "type": "love.math"
    },
    "createDirectory": {
        "descr": "Recursively creates a directory.",
        "name": "love.filesystem.createDirectory",
        "params": [
            {
                "descr": "The directory to create.",
                "name": "string name"
            },
            {
                "descr": "True if the directory was created, false if not.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.filesystem.createdirectory",
        "syntax": "success = love.filesystem.createDirectory( name )",
        "type": "love.filesystem"
    },
    "decompress": {
        "descr": "Decompresses a CompressedData or previously compressed string or Data object.",
        "name": "love.math.decompress",
        "params": [
            {
                "descr": "The compressed data to decompress.",
                "name": "CompressedData compressedData"
            },
            {
                "descr": "A string containing the raw decompressed data.",
                "name": "string rawstring"
            }
        ],
        "path": "love/love.math.decompress",
        "syntax": "rawstring = love.math.decompress( compressedData )",
        "type": "love.math"
    },
    "directorydropped": {
        "descr": "Callback function triggered when a directory is dragged and dropped onto the window.",
        "name": "love.directorydropped",
        "params": [
            {
                "descr": "The full platform-dependent path to the directory. ",
                "name": "string path"
            }
        ],
        "path": "love/love.directorydropped",
        "syntax": "love.directorydropped( path )",
        "type": "love"
    },
    "discard": {
        "descr": "Discards (trashes) the contents of the screen or active Canvas. This is a performance optimization function with niche use cases.",
        "name": "love.graphics.discard",
        "params": [
            {
                "descr": "Whether to discard the texture(s) of the active Canvas(es) (the contents of the screen if no Canvas is active.)",
                "name": "boolean discardcolor (true)"
            },
            {
                "descr": "Whether to discard the contents of the stencil buffer of the screen / active Canvas.",
                "name": "boolean discardstencil (true)"
            }
        ],
        "path": "love/love.graphics.discard",
        "syntax": "love.graphics.discard( discardcolor, discardstencil )",
        "type": "love.graphics"
    },
    "draw": {
        "descr": "Draws a Drawable object (an Image, Canvas, SpriteBatch, ParticleSystem, Mesh, or Video) on the screen with optional rotation, scaling and shearing.",
        "name": "love.graphics.draw",
        "params": [
            {
                "descr": "A drawable object.",
                "name": "Drawable drawable"
            },
            {
                "descr": "The position to draw the object (x-axis).",
                "name": "number x (0)"
            },
            {
                "descr": "The position to draw the object (y-axis).",
                "name": "number y (0)"
            },
            {
                "descr": "Orientation (radians).",
                "name": "number r (0)"
            },
            {
                "descr": "Scale factor (x-axis).",
                "name": "number sx (1)"
            },
            {
                "descr": "Scale factor (y-axis).",
                "name": "number sy (sx)"
            },
            {
                "descr": "Origin offset (x-axis).",
                "name": "number ox (0)"
            },
            {
                "descr": "Origin offset (y-axis).",
                "name": "number oy (0)"
            },
            {
                "descr": "Shearing factor (x-axis).",
                "name": "number kx (0) Available since 0.8.0"
            },
            {
                "descr": "Shearing factor (y-axis).",
                "name": "number ky (0) Available since 0.8.0"
            }
        ],
        "path": "love/love.graphics.draw",
        "syntax": "love.graphics.draw( drawable, x, y, r, sx, sy, ox, oy, kx, ky )",
        "type": "love.graphics"
    },
    "drawq": {
        "descr": "Draw a Quad with the specified Image on screen.",
        "name": "love.graphics.drawq",
        "params": [
            {
                "descr": "An image to texture the quad with.",
                "name": "Image image"
            },
            {
                "descr": "The quad to draw on screen.",
                "name": "Quad quad"
            },
            {
                "descr": "The position to draw the object (x-axis).",
                "name": "number x"
            },
            {
                "descr": "The position to draw the object (y-axis).",
                "name": "number y"
            },
            {
                "descr": "Orientation (radians).",
                "name": "number r (0)"
            },
            {
                "descr": "Scale factor (x-axis).",
                "name": "number sx (1)"
            },
            {
                "descr": "Scale factor (y-axis).",
                "name": "number sy (sx)"
            },
            {
                "descr": "Origin offset (x-axis).",
                "name": "number ox (0)"
            },
            {
                "descr": "Origin offset (y-axis).",
                "name": "number oy (0)"
            },
            {
                "descr": "Shearing factor (x-axis).",
                "name": "number kx (0) Available since 0.8.0"
            },
            {
                "descr": "Shearing factor (y-axis).",
                "name": "number ky (0) Available since 0.8.0"
            }
        ],
        "path": "love/love.graphics.drawq",
        "syntax": "love.graphics.drawq( image, quad, x, y, r, sx, sy, ox, oy, kx, ky )",
        "type": "love.graphics"
    },
    "ellipse": {
        "descr": "Draws an ellipse.",
        "name": "love.graphics.ellipse",
        "params": [
            {
                "descr": "How to draw the ellipse.",
                "name": "DrawMode mode"
            },
            {
                "descr": "The position of the center along x-axis.",
                "name": "number x"
            },
            {
                "descr": "The position of the center along y-axis.",
                "name": "number y"
            },
            {
                "descr": "The radius of the ellipse along the x-axis (half the ellipse's width.)",
                "name": "number radiusx"
            },
            {
                "descr": "The radius of the ellipse along the y-axis (half the ellipse's height.)",
                "name": "number radiusy"
            }
        ],
        "path": "love/love.graphics.ellipse",
        "syntax": "love.graphics.ellipse( mode, x, y, radiusx, radiusy )",
        "type": "love.graphics"
    },
    "enet.host create": {
        "descr": "Returns a new  host. All arguments are optional.",
        "name": "enet.host create",
        "params": [
            {
                "descr": "The address to connect to in the format \"ip:port\".",
                "name": "string bind_address"
            },
            {
                "descr": "The max number of peers. Defaults to 64.",
                "name": "number peer_count"
            },
            {
                "descr": "Downstream bandwidth in bytes/sec. ",
                "name": "number in_bandwidth"
            },
            {
                "descr": "The max number of channels. Defaults to 1.",
                "name": "number channel_count"
            },
            {
                "descr": "Upstream bandwidth in bytes/sec. ",
                "name": "number out_bandwidth"
            },
            {
                "descr": "The requested  host.",
                "name": "enet.host host"
            }
        ],
        "path": "love/enet.host_create",
        "syntax": "host = enet.host_create(bind_address, peer_count, channel_count, in_bandwidth, out_bandwidth)",
        "type": "enet"
    },
    "enet.host:bandwidth limit": {
        "descr": "Sets the bandwidth limits of the  host in bytes/sec. Set to 0 for unlimited.",
        "name": "enet.host:bandwidth limit",
        "params": [
            {
                "descr": "Download speed limit in bytes/sec.",
                "name": "number incoming"
            },
            {
                "descr": "Upload speed limit in bytes/sec.",
                "name": "number outgoing"
            }
        ],
        "path": "love/enet.host-bandwidth_limit",
        "syntax": "host:bandwidth_limit(incoming, outgoing)",
        "type": "enet"
    },
    "enet.host:broadcast": {
        "descr": "Queues a packet to be sent to all connected  peers.",
        "name": "enet.host:broadcast",
        "params": [
            {
                "descr": "The data to send.",
                "name": "string data"
            },
            {
                "descr": "The channel to send the packet on. ",
                "name": "number channel"
            },
            {
                "descr": "flag is one of \"reliable\", \"unsequenced\", or \"unreliable\". ",
                "name": "string flag"
            }
        ],
        "path": "love/enet.host-broadcast",
        "syntax": "host:broadcast(data, channel, flag)",
        "type": "enet"
    },
    "enet.host:channel limit": {
        "descr": "Sets the maximum number of channels allowed. If it is 0 then the system maximum allowable value is used.",
        "name": "enet.host:channel limit",
        "params": [
            {
                "descr": "The maximum number of channels allowed.",
                "name": "number limit"
            }
        ],
        "path": "love/enet.host-channel_limit",
        "syntax": "host:channel_limit(limit)",
        "type": "enet"
    },
    "enet.host:check events": {
        "descr": "Checks for any queued events and dispatches one if available. Returns the associated  event if something was dispatched, otherwise nil.",
        "name": "enet.host:check events",
        "params": [
            {
                "descr": "An  event or nil if no events are available.",
                "name": "table event"
            }
        ],
        "path": "love/enet.host-check_events",
        "syntax": "event = host:check_events()",
        "type": "enet"
    },
    "enet.host:compress with range coder": {
        "descr": "Toggles an adaptive order-2 PPM range coder for the transmitted data of all peers.",
        "name": "enet.host:compress with range coder",
        "params": [
            {
                "descr": "True if the compression algorithm is active, false if not.",
                "name": "boolean state"
            }
        ],
        "path": "love/enet.host-compress_with_range_coder",
        "syntax": "host:compress_with_range_coder()",
        "type": "enet"
    },
    "enet.host:connect": {
        "descr": "Connects a  host to a remote  host. Returns  peer object associated with the remote  host. The actual connection will not take place until the next  host:service() is called, in which a \"connect\"  event will be generated.",
        "name": "enet.host:connect",
        "params": [
            {
                "descr": "The address to connect to in the format \"ip:port\".",
                "name": "string address"
            },
            {
                "descr": "The number of channels to allocate. ",
                "name": "number channel_count"
            },
            {
                "descr": "An integer value that can be associated with the connect  event. ",
                "name": "number data"
            },
            {
                "descr": "A  peer.",
                "name": "enet.peer peer"
            }
        ],
        "path": "love/enet.host-connect",
        "syntax": "peer = host:connect(address, channel_count, data)",
        "type": "enet"
    },
    "enet.host:destroy": {
        "descr": "Destroys the  host structure and closes all of its connections. This function is also ran automatically by lua's garbage collector, since it's an alias to host:__gc.",
        "name": "enet.host:destroy",
        "params": [],
        "path": "love/enet.host-destroy",
        "syntax": "host:destroy()",
        "type": "enet"
    },
    "enet.host:flush": {
        "descr": "Sends any queued packets. This is only required to send packets earlier than the next call to  host:service, or if  host:service will not be called again.",
        "name": "enet.host:flush",
        "params": [],
        "path": "love/enet.host-flush",
        "syntax": "host:flush()",
        "type": "enet"
    },
    "enet.host:get peer": {
        "descr": "Returns the connected  peer at the specified index (starting at 1). ENet stores all  peers in an array of the corresponding  host and re-uses unused peers for new connections. You can query the state of a peer using  peer:state().",
        "name": "enet.host:get peer",
        "params": [
            {
                "descr": "The index of the desired  peer.",
                "name": "number index"
            },
            {
                "descr": "The desired  peer structure.",
                "name": "enet.peer peer"
            }
        ],
        "path": "love/enet.host-get_peer",
        "syntax": "host:get_peer(index)",
        "type": "enet"
    },
    "enet.host:get socket address": {
        "descr": "Returns a string that describes the socket address of the given  host. The string is formatted as “a.b.c.d:port”, where “a.b.c.d” is the IP address of the used socket.",
        "name": "enet.host:get socket address",
        "params": [
            {
                "descr": "A string that describes the socket address.",
                "name": "string address"
            }
        ],
        "path": "love/enet.host-get_socket_address",
        "syntax": "host:get_socket_address()",
        "type": "enet"
    },
    "enet.host:peer count": {
        "descr": "Returns the number of  peers that are allocated for the given  host. This represents the maximum number of possible connections.",
        "name": "enet.host:peer count",
        "params": [
            {
                "descr": "The maximum number of peers allowed.",
                "name": "number limit"
            }
        ],
        "path": "love/enet.host-peer_count",
        "syntax": "host:peer_count()",
        "type": "enet"
    },
    "enet.host:service": {
        "descr": "Wait for  events, send and receive any ready packets. If an  event is in the queue it will be returned and dequeued. Generally you will want to dequeue all waiting  events every frame.",
        "name": "enet.host:service",
        "params": [
            {
                "descr": "The max number of milliseconds to be waited for an  event. ",
                "name": "number timeout"
            },
            {
                "descr": "An  event or nil if no events occured.",
                "name": "table event"
            }
        ],
        "path": "love/enet.host-service",
        "syntax": "event = host:service( timeout )",
        "type": "enet"
    },
    "enet.host:service time": {
        "descr": "Returns the time-stamp of the last call to  host:service() or  host:flush(). The time-stamp is in milliseconds of the current time of day.",
        "name": "enet.host:service time",
        "params": [
            {
                "descr": "A time-stamp in milliseconds.",
                "name": "number timestamp"
            }
        ],
        "path": "love/enet.host-service_time",
        "syntax": "host:channel_limit(limit)",
        "type": "enet"
    },
    "enet.host:total received data": {
        "descr": "Returns the number of bytes that were received by the given host.",
        "name": "enet.host:total received data",
        "params": [
            {
                "descr": "The total number of bytes received.",
                "name": "number bytes"
            }
        ],
        "path": "love/enet.host-total_received_data",
        "syntax": "host:total_received_data()",
        "type": "enet"
    },
    "enet.host:total sent data": {
        "descr": "Returns the number of bytes that were sent through the given  host.",
        "name": "enet.host:total sent data",
        "params": [
            {
                "descr": "The total number of bytes sent.",
                "name": "number bytes"
            }
        ],
        "path": "love/enet.host-total_sent_data",
        "syntax": "host:total_sent_data()",
        "type": "enet"
    },
    "enet.linked version": {
        "descr": "Returns the included ENet's version as a string.",
        "name": "enet.linked version",
        "params": [
            {
                "descr": "ENet's version.",
                "name": "string version"
            }
        ],
        "path": "love/enet.linked_version",
        "syntax": "version = enet.linked_version()",
        "type": "enet"
    },
    "enet.peer:connect id": {
        "descr": "Returns the field ENetPeer::connectID that is assigned for each connection.",
        "name": "enet.peer:connect id",
        "params": [
            {
                "descr": "Unique ID that was assigned to the connection.",
                "name": "number id"
            }
        ],
        "path": "love/enet.peer-connect_id",
        "syntax": "peer:connect_id()",
        "type": "enet"
    },
    "enet.peer:disconnect": {
        "descr": "Requests a disconnection from the  peer. The message is sent on the next  host:service() or  host:flush().",
        "name": "enet.peer:disconnect",
        "params": [
            {
                "descr": "An optional integer value to be associated with the disconnect.",
                "name": "number data"
            }
        ],
        "path": "love/enet.peer-disconnect",
        "syntax": "peer:disconnect(data)",
        "type": "enet"
    },
    "enet.peer:disconnect later": {
        "descr": "Request a disconnection from  peer, but only after all queued outgoing packets are sent.",
        "name": "enet.peer:disconnect later",
        "params": [
            {
                "descr": "Optional integer value to be associated with the disconnect.",
                "name": "number data"
            }
        ],
        "path": "love/enet.peer-disconnect_later",
        "syntax": "peer:disconnect_later(data)",
        "type": "enet"
    },
    "enet.peer:disconnect now": {
        "descr": "Force immediate disconnection from  peer. Foreign  peer not guaranteed to receive disconnect notification.",
        "name": "enet.peer:disconnect now",
        "params": [
            {
                "descr": "Optional integer value to be associated with the disconnect.",
                "name": "number data"
            }
        ],
        "path": "love/enet.peer-disconnect_now",
        "syntax": "peer:disconnect_now(data)",
        "type": "enet"
    },
    "enet.peer:index": {
        "descr": "Returns the index of the  peer. All  peers of an ENet  host are kept in an array. This function finds and returns the index of the  peer of its  host structure.",
        "name": "enet.peer:index",
        "params": [
            {
                "descr": "The index of the peer.",
                "name": "number index"
            }
        ],
        "path": "love/enet.peer-index",
        "syntax": "peer:index()",
        "type": "enet"
    },
    "enet.peer:last round trip time": {
        "descr": "Returns or sets the round trip time of the previous round trip time computation. If value is nil the current value of the  peer is returned. Otherwise the the previous round trip time computation is set to the specified value and returned.",
        "name": "enet.peer:last round trip time",
        "params": [
            {
                "descr": "The  peer's last round trip time computation in milliseconds.",
                "name": "number lastroundtriptime"
            },
            {
                "descr": "Integer value to be used as the last round trip time.",
                "name": "number value"
            }
        ],
        "path": "love/enet.peer-last_round_trip_time",
        "syntax": "peer:last_round_trip_time()",
        "type": "enet"
    },
    "enet.peer:ping": {
        "descr": "Send a ping request to  peer, updates  round_trip_time. This is called automatically at regular intervals.",
        "name": "enet.peer:ping",
        "params": [],
        "path": "love/enet.peer-ping",
        "syntax": "peer:ping()",
        "type": "enet"
    },
    "enet.peer:ping interval": {
        "descr": "Specifies the interval in milliseconds that pings are sent to the other end of the connection (defaults to 500).",
        "name": "enet.peer:ping interval",
        "params": [
            {
                "descr": "Time in milliseconds to wait before automatically calling  peer:ping().",
                "name": "number interval"
            }
        ],
        "path": "love/enet.peer-ping_interval",
        "syntax": "peer:ping_interval(interval)",
        "type": "enet"
    },
    "enet.peer:receive": {
        "descr": "Attempts to dequeue an incoming packet for this  peer. Returns nil if there are no packets waiting. Otherwise returns two values: The string representing the packet data, and the channel the packet came from.",
        "name": "enet.peer:receive",
        "params": [
            {
                "descr": "Data from the received packet in a string.",
                "name": "string data"
            },
            {
                "descr": "Channel the packet was received from.",
                "name": "number channel"
            }
        ],
        "path": "love/enet.peer-receive",
        "syntax": "peer:receive()",
        "type": "enet"
    },
    "enet.peer:reset": {
        "descr": "Forcefully disconnects  peer. The  peer is not notified of the disconnection.",
        "name": "enet.peer:reset",
        "params": [],
        "path": "love/enet.peer-reset",
        "syntax": "peer:reset()",
        "type": "enet"
    },
    "enet.peer:round trip time": {
        "descr": "Returns or sets the current round trip time (i.e. ping). If value is nil the current value of the  peer is returned. Otherwise the round trip time is set to the specified value and returned.",
        "name": "enet.peer:round trip time",
        "params": [
            {
                "descr": "The  peer's current round trip time in milliseconds.",
                "name": "number roundtriptime"
            },
            {
                "descr": "Integer value to be used as the new round trip time.",
                "name": "number value"
            }
        ],
        "path": "love/enet.peer-round_trip_time",
        "syntax": "peer:round_trip_time()",
        "type": "enet"
    },
    "enet.peer:send": {
        "descr": "Queues a packet to be sent to the  peer.",
        "name": "enet.peer:send",
        "params": [
            {
                "descr": "The contents of the packet, it must be a string.",
                "name": "string data"
            },
            {
                "descr": "The channel to send the packet on. ",
                "name": "number channel"
            },
            {
                "descr": "flag is one of \"reliable\", \"unsequenced\", or \"unreliable\". ",
                "name": "string flag"
            }
        ],
        "path": "love/enet.peer-send",
        "syntax": "peer:send(data, channel, flag)",
        "type": "enet"
    },
    "enet.peer:state": {
        "descr": "Returns the state of the  peer as a string.",
        "name": "enet.peer:state",
        "params": [
            {
                "descr": "The  peer's current state. It can be any of the following:",
                "name": "string state"
            }
        ],
        "path": "love/enet.peer-state",
        "syntax": "peer:state()",
        "type": "enet"
    },
    "enet.peer:throttle configure": {
        "descr": "Changes the probability at which unreliable packets should not be dropped.",
        "name": "enet.peer:throttle configure",
        "params": [
            {
                "descr": "Interval in milliseconds to measure lowest mean  RTT.",
                "name": "number interval"
            },
            {
                "descr": "Rate at which to increase throttle probability as mean  RTT declines.",
                "name": "number acceleration"
            },
            {
                "descr": "Rate at which to decrease throttle probability as mean  RTT increases.",
                "name": "number deceleration"
            }
        ],
        "path": "love/enet.peer-throttle_configure",
        "syntax": "peer:throttle_configure(interval, acceleration, deceleration)",
        "type": "enet"
    },
    "enet.peer:timeout": {
        "descr": "Returns or sets the parameters when a timeout is detected. This is happens either after a fixed timeout or a variable timeout of time that takes the round trip time into account. The former is specified with the maximum parameter.",
        "name": "enet.peer:timeout",
        "params": [
            {
                "descr": "A factor that is multiplied with a value that based on the average  round trip time to compute the timeout limit.",
                "name": "number limit"
            },
            {
                "descr": "Timeout value, in milliseconds, that a reliable packet has to be acknowledged if the variable timeout limit was exceeded before dropping the  peer.",
                "name": "number minimum"
            },
            {
                "descr": "Fixed timeout in milliseconds for which any packet has to be acknowledged before dropping the  peer.",
                "name": "number maximum"
            },
            {
                "descr": "A factor that is multiplied with a value that based on the average  round trip time to compute the timeout limit.",
                "name": "number limit"
            },
            {
                "descr": "Timeout value, in milliseconds, that a reliable packet has to be acknowledged if the variable timeout limit was exceeded before dropping the  peer.",
                "name": "number minimum"
            },
            {
                "descr": "Fixed timeout in milliseconds for which any packet has to be acknowledged before dropping the  peer.",
                "name": "number maximum"
            }
        ],
        "path": "love/enet.peer-timeout",
        "syntax": "peer:timeout(limit, minimum, maximum)",
        "type": "enet"
    },
    "enet:host create": {
        "descr": "Returns a new  host. All arguments are optional.",
        "name": "enet:host create",
        "params": [
            {
                "descr": "The address to connect to in the format \"ip:port\".",
                "name": "string bind_address"
            },
            {
                "descr": "The max number of peers. Defaults to 64.",
                "name": "number peer_count"
            },
            {
                "descr": "Downstream bandwidth in bytes/sec. ",
                "name": "number in_bandwidth"
            },
            {
                "descr": "The max number of channels. Defaults to 1.",
                "name": "number channel_count"
            },
            {
                "descr": "Upstream bandwidth in bytes/sec. ",
                "name": "number out_bandwidth"
            },
            {
                "descr": "The requested  host.",
                "name": "enet.host host"
            }
        ],
        "path": "love/enet-host_create",
        "syntax": "host = enet.host_create(bind_address, peer_count, channel_count, in_bandwidth, out_bandwidth)",
        "type": "enet"
    },
    "enumerate": {
        "descr": "Returns a table with the names of files and subdirectories in the specified path. The table is not sorted in any way; the order is undefined.",
        "name": "love.filesystem.enumerate",
        "params": [
            {
                "descr": "The directory.",
                "name": "string dir"
            },
            {
                "descr": "A sequence with the names of all files and subdirectories as strings.",
                "name": "table files"
            }
        ],
        "path": "love/love.filesystem.enumerate",
        "syntax": "files = love.filesystem.enumerate( dir )",
        "type": "love.filesystem"
    },
    "errhand": {
        "descr": "The error handler, used to display error messages.",
        "name": "love.errhand",
        "params": [
            {
                "descr": "The error message.",
                "name": "string msg"
            }
        ],
        "path": "love/love.errhand",
        "syntax": "love.errhand( msg )",
        "type": "love"
    },
    "exists": {
        "descr": "Check whether a file or directory exists.",
        "name": "love.filesystem.exists",
        "params": [
            {
                "descr": "The path to a potential file or directory.",
                "name": "string filename"
            },
            {
                "descr": "True if there is a file or directory with the specified name. ",
                "name": "boolean exists"
            }
        ],
        "path": "love/love.filesystem.exists",
        "syntax": "exists = love.filesystem.exists( filename )",
        "type": "love.filesystem"
    },
    "filedropped": {
        "descr": "Callback function triggered when a file is dragged and dropped onto the window.",
        "name": "love.filedropped",
        "params": [
            {
                "descr": "The unopened File object representing the file that was dropped.",
                "name": "File file"
            }
        ],
        "path": "love/love.filedropped",
        "syntax": "love.filedropped( file )",
        "type": "love"
    },
    "focus": {
        "descr": "Callback function triggered when window receives or loses focus.",
        "name": "love.focus",
        "params": [
            {
                "descr": "True if the window gains focus, false if it loses focus.",
                "name": "boolean focus"
            }
        ],
        "path": "love/love.focus",
        "syntax": "love.focus( focus )",
        "type": "love"
    },
    "fromPixels": {
        "descr": "Converts a number from pixels to density-independent units.",
        "name": "love.window.fromPixels",
        "params": [
            {
                "descr": "A number in pixels to convert to density-independent units.",
                "name": "number pixelvalue"
            },
            {
                "descr": "The converted number, in density-independent units.",
                "name": "number value"
            }
        ],
        "path": "love/love.window.frompixels",
        "syntax": "value = love.window.fromPixels( pixelvalue )",
        "type": "love.window"
    },
    "gamepadaxis": {
        "descr": "Called when a Joystick's virtual gamepad axis is moved.",
        "name": "love.gamepadaxis",
        "params": [
            {
                "descr": "The joystick object.",
                "name": "Joystick joystick"
            },
            {
                "descr": "The virtual gamepad axis.",
                "name": "GamepadAxis axis"
            },
            {
                "descr": "The new axis value.",
                "name": "number value"
            }
        ],
        "path": "love/love.gamepadaxis",
        "syntax": "love.gamepadaxis( joystick, axis, value )",
        "type": "love"
    },
    "gamepadpressed": {
        "descr": "Called when a Joystick's virtual gamepad button is pressed.",
        "name": "love.gamepadpressed",
        "params": [
            {
                "descr": "The joystick object.",
                "name": "Joystick joystick"
            },
            {
                "descr": "The virtual gamepad button.",
                "name": "GamepadButton button"
            }
        ],
        "path": "love/love.gamepadpressed",
        "syntax": "love.gamepadpressed( joystick, button )",
        "type": "love"
    },
    "gamepadreleased": {
        "descr": "Called when a Joystick's virtual gamepad button is released.",
        "name": "love.gamepadreleased",
        "params": [
            {
                "descr": "The joystick object.",
                "name": "Joystick joystick"
            },
            {
                "descr": "The virtual gamepad button.",
                "name": "GamepadButton button"
            }
        ],
        "path": "love/love.gamepadreleased",
        "syntax": "love.gamepadreleased( joystick, button )",
        "type": "love"
    },
    "gammaToLinear": {
        "descr": "Converts a color from gamma-space (sRGB) to linear-space (RGB). This is useful when doing gamma-correct rendering and you need to do math in linear RGB in the few cases where LÖVE doesn't handle conversions automatically.",
        "name": "love.math.gammaToLinear",
        "params": [
            {
                "descr": "The red channel of the sRGB color to convert.",
                "name": "number r"
            },
            {
                "descr": "The green channel of the sRGB color to convert.",
                "name": "number g"
            },
            {
                "descr": "The blue channel of the sRGB color to convert.",
                "name": "number b"
            },
            {
                "descr": "The red channel of the converted color in linear RGB space.",
                "name": "number lr"
            },
            {
                "descr": "The green channel of the converted color in linear RGB space.",
                "name": "number lg"
            },
            {
                "descr": "The blue channel of the converted color in linear RGB space.",
                "name": "number lb"
            }
        ],
        "path": "love/love.math.gammatolinear",
        "syntax": "lr, lg, lb = love.math.gammaToLinear( r, g, b )",
        "type": "love.math"
    },
    "getAppdataDirectory": {
        "descr": "Returns the application data directory (could be the same as getUserDirectory)",
        "name": "love.filesystem.getAppdataDirectory",
        "params": [
            {
                "descr": "The path of the application data directory",
                "name": "string path"
            }
        ],
        "path": "love/love.filesystem.getappdatadirectory",
        "syntax": "path = love.filesystem.getAppdataDirectory( )",
        "type": "love.filesystem"
    },
    "getAverageDelta": {
        "descr": "Returns the average delta time (seconds per frame) over the last second.",
        "name": "love.timer.getAverageDelta",
        "params": [
            {
                "descr": "The average delta time over the last second.",
                "name": "number delta"
            }
        ],
        "path": "love/love.timer.getaveragedelta",
        "syntax": "delta = love.timer.getAverageDelta( )",
        "type": "love.timer"
    },
    "getAxes": {
        "descr": "Returns the position of each axis.",
        "name": "love.joystick.getAxes",
        "params": [
            {
                "descr": "The joystick to be checked",
                "name": "number joystick"
            },
            {
                "descr": "Direction of axis1",
                "name": "number axisDir1"
            },
            {
                "descr": "Direction of axis2",
                "name": "number axisDir2"
            },
            {
                "descr": "Direction of axisN",
                "name": "number axisDirN"
            }
        ],
        "path": "love/love.joystick.getaxes",
        "syntax": "axisDir1, axisDir2, axisDirN = love.joystick.getAxes( joystick )",
        "type": "love.joystick"
    },
    "getAxis": {
        "descr": "Returns the direction of the axis.",
        "name": "love.joystick.getAxis",
        "params": [
            {
                "descr": "The joystick to be checked",
                "name": "number joystick"
            },
            {
                "descr": "The axis to be checked",
                "name": "number axis"
            },
            {
                "descr": "Current value of the axis",
                "name": "number direction"
            }
        ],
        "path": "love/love.joystick.getaxis",
        "syntax": "direction = love.joystick.getAxis( joystick, axis )",
        "type": "love.joystick"
    },
    "getBackgroundColor": {
        "descr": "Gets the current background color.",
        "name": "love.graphics.getBackgroundColor",
        "params": [
            {
                "descr": "The red component (0-255).",
                "name": "number r"
            },
            {
                "descr": "The green component (0-255).",
                "name": "number g"
            },
            {
                "descr": "The blue component (0-255).",
                "name": "number b"
            },
            {
                "descr": "The alpha component (0-255).",
                "name": "number a"
            }
        ],
        "path": "love/love.graphics.getbackgroundcolor",
        "syntax": "r, g, b, a = love.graphics.getBackgroundColor( )",
        "type": "love.graphics"
    },
    "getBall": {
        "descr": "Returns the change in ball position.",
        "name": "love.joystick.getBall",
        "params": [
            {
                "descr": "The joystick to be checked",
                "name": "number joystick"
            },
            {
                "descr": "The ball to be checked",
                "name": "number ball"
            },
            {
                "descr": "Change in x of the ball position.",
                "name": "number dx"
            },
            {
                "descr": "Change in y of the ball position.",
                "name": "number dy"
            }
        ],
        "path": "love/love.joystick.getball",
        "syntax": "dx, dy = love.joystick.getBall( joystick, ball )",
        "type": "love.joystick"
    },
    "getBlendMode": {
        "descr": "Gets the blending mode.",
        "name": "love.graphics.getBlendMode",
        "params": [
            {
                "descr": "The current blend mode.",
                "name": "BlendMode mode"
            },
            {
                "descr": "The current blend alpha mode – it determines how the alpha of drawn objects affects blending.",
                "name": "BlendAlphaMode alphamode"
            }
        ],
        "path": "love/love.graphics.getblendmode",
        "syntax": "mode, alphamode = love.graphics.getBlendMode( )",
        "type": "love.graphics"
    },
    "getCanvas": {
        "descr": "Gets the current target Canvas.",
        "name": "love.graphics.getCanvas",
        "params": [
            {
                "descr": "The Canvas set by setCanvas. Returns nil if drawing to the real screen.",
                "name": "Canvas canvas"
            }
        ],
        "path": "love/love.graphics.getcanvas",
        "syntax": "canvas = love.graphics.getCanvas( )",
        "type": "love.graphics"
    },
    "getCanvasFormats": {
        "descr": "Gets the available Canvas formats, and whether each is supported.",
        "name": "love.graphics.getCanvasFormats",
        "params": [
            {
                "descr": "A table containing CanvasFormats as keys, and a boolean indicating whether the format is supported as values. ",
                "name": "table formats"
            }
        ],
        "path": "love/love.graphics.getcanvasformats",
        "syntax": "formats = love.graphics.getCanvasFormats( )",
        "type": "love.graphics"
    },
    "getCaption": {
        "descr": "Gets the window caption.",
        "name": "love.graphics.getCaption",
        "params": [
            {
                "descr": "The current window caption.",
                "name": "string caption"
            }
        ],
        "path": "love/love.graphics.getcaption",
        "syntax": "caption = love.graphics.getCaption( )",
        "type": "love.graphics"
    },
    "getChannel": {
        "descr": "Creates or retrieves a named thread channel.",
        "name": "love.thread.getChannel",
        "params": [
            {
                "descr": "The name of the channel you want to create or retrieve.",
                "name": "string name"
            },
            {
                "descr": "The Channel object associated with the name.",
                "name": "Channel channel"
            }
        ],
        "path": "love/love.thread.getchannel",
        "syntax": "channel = love.thread.getChannel( name )",
        "type": "love.thread"
    },
    "getClipboardText": {
        "descr": "Gets text from the clipboard.",
        "name": "love.system.getClipboardText",
        "params": [
            {
                "descr": "The text currently held in the system's clipboard.",
                "name": "string text"
            }
        ],
        "path": "love/love.system.getclipboardtext",
        "syntax": "text = love.system.getClipboardText( )",
        "type": "love.system"
    },
    "getColor": {
        "descr": "Gets the current color.",
        "name": "love.graphics.getColor",
        "params": [
            {
                "descr": "The red component (0-255).",
                "name": "number r"
            },
            {
                "descr": "The green component (0-255).",
                "name": "number g"
            },
            {
                "descr": "The blue component (0-255).",
                "name": "number b"
            },
            {
                "descr": "The alpha component (0-255).",
                "name": "number a"
            }
        ],
        "path": "love/love.graphics.getcolor",
        "syntax": "r, g, b, a = love.graphics.getColor( )",
        "type": "love.graphics"
    },
    "getColorMask": {
        "descr": "Gets the active color components used when drawing. Normally all 4 components are active unless love.graphics.setColorMask has been used.",
        "name": "love.graphics.getColorMask",
        "params": [
            {
                "descr": "Whether the red color component is active when rendering.",
                "name": "boolean r"
            },
            {
                "descr": "Whether the green color component is active when rendering.",
                "name": "boolean g"
            },
            {
                "descr": "Whether the blue color component is active when rendering.",
                "name": "boolean b"
            },
            {
                "descr": "Whether the alpha color component is active when rendering.",
                "name": "boolean a"
            }
        ],
        "path": "love/love.graphics.getcolormask",
        "syntax": "r, g, b, a = love.graphics.getColorMask( )",
        "type": "love.graphics"
    },
    "getColorMode": {
        "descr": "Gets the color mode (which controls how images are affected by the current color).",
        "name": "love.graphics.getColorMode",
        "params": [
            {
                "descr": "The current color mode.",
                "name": "ColorMode mode"
            }
        ],
        "path": "love/love.graphics.getcolormode",
        "syntax": "mode = love.graphics.getColorMode( )",
        "type": "love.graphics"
    },
    "getCompressedImageFormats": {
        "descr": "Gets the available compressed image formats, and whether each is supported.",
        "name": "love.graphics.getCompressedImageFormats",
        "params": [
            {
                "descr": "A table containing CompressedImageFormats as keys, and a boolean indicating whether the format is supported as values. ",
                "name": "table formats"
            }
        ],
        "path": "love/love.graphics.getcompressedimageformats",
        "syntax": "formats = love.graphics.getCompressedImageFormats( )",
        "type": "love.graphics"
    },
    "getCursor": {
        "descr": "Gets the current Cursor.",
        "name": "love.mouse.getCursor",
        "params": [
            {
                "descr": "The current cursor, or nil if no cursor is set.",
                "name": "Cursor cursor (nil)"
            }
        ],
        "path": "love/love.mouse.getcursor",
        "syntax": "cursor = love.mouse.getCursor( )",
        "type": "love.mouse"
    },
    "getDefaultFilter": {
        "descr": "Returns the default scaling filters used with Images, Canvases, and Fonts.",
        "name": "love.graphics.getDefaultFilter",
        "params": [
            {
                "descr": "Filter mode used when scaling the image down.",
                "name": "FilterMode min"
            },
            {
                "descr": "Filter mode used when scaling the image up.",
                "name": "FilterMode mag"
            },
            {
                "descr": "Maximum amount of Anisotropic Filtering used.",
                "name": "number anisotropy"
            }
        ],
        "path": "love/love.graphics.getdefaultfilter",
        "syntax": "min, mag, anisotropy = love.graphics.getDefaultFilter( )",
        "type": "love.graphics"
    },
    "getDefaultImageFilter": {
        "descr": "Returns the default scaling filters.",
        "name": "love.graphics.getDefaultImageFilter",
        "params": [
            {
                "descr": "Filter mode used when scaling the image down.",
                "name": "FilterMode min"
            },
            {
                "descr": "Filter mode used when scaling the image up.",
                "name": "FilterMode mag"
            }
        ],
        "path": "love/love.graphics.getdefaultimagefilter",
        "syntax": "min, mag = love.graphics.getDefaultImageFilter( )",
        "type": "love.graphics"
    },
    "getDelta": {
        "descr": "Returns the time between the last two frames.",
        "name": "love.timer.getDelta",
        "params": [
            {
                "descr": "The time passed (in seconds).",
                "name": "number dt"
            }
        ],
        "path": "love/love.timer.getdelta",
        "syntax": "dt = love.timer.getDelta( )",
        "type": "love.timer"
    },
    "getDesktopDimensions": {
        "descr": "Gets the width and height of the desktop.",
        "name": "love.window.getDesktopDimensions",
        "params": [
            {
                "descr": "The index of the display, if multiple monitors are available.",
                "name": "number display (1)"
            },
            {
                "descr": "The width of the desktop.",
                "name": "number width"
            },
            {
                "descr": "The height of the desktop.",
                "name": "number height"
            }
        ],
        "path": "love/love.window.getdesktopdimensions",
        "syntax": "width, height = love.window.getDesktopDimensions( display )",
        "type": "love.window"
    },
    "getDimensions": {
        "descr": "Gets the width and height of the window.",
        "name": "love.window.getDimensions",
        "params": [
            {
                "descr": "The width of the window.",
                "name": "number width"
            },
            {
                "descr": "The height of the window.",
                "name": "number height"
            }
        ],
        "path": "love/love.window.getdimensions",
        "syntax": "width, height = love.window.getDimensions( )",
        "type": "love.window"
    },
    "getDirectoryItems": {
        "descr": "Returns a table with the names of files and subdirectories in the specified path. The table is not sorted in any way; the order is undefined.",
        "name": "love.filesystem.getDirectoryItems",
        "params": [
            {
                "descr": "The directory.",
                "name": "string dir"
            },
            {
                "descr": "A sequence with the names of all files and subdirectories as strings.",
                "name": "table files"
            }
        ],
        "path": "love/love.filesystem.getdirectoryitems",
        "syntax": "files = love.filesystem.getDirectoryItems( dir )",
        "type": "love.filesystem"
    },
    "getDisplayCount": {
        "descr": "Gets the number of connected monitors.",
        "name": "love.window.getDisplayCount",
        "params": [
            {
                "descr": "The number of currently connected displays.",
                "name": "number count"
            }
        ],
        "path": "love/love.window.getdisplaycount",
        "syntax": "count = love.window.getDisplayCount( )",
        "type": "love.window"
    },
    "getDisplayName": {
        "descr": "Gets the name of a display.",
        "name": "love.window.getDisplayName",
        "params": [
            {
                "descr": "The index of the display to get the name of.",
                "name": "number displayindex (1)"
            },
            {
                "descr": "The name of the specified display.",
                "name": "string name"
            }
        ],
        "path": "love/love.window.getdisplayname",
        "syntax": "name = love.window.getDisplayName( displayindex )",
        "type": "love.window"
    },
    "getDistance": {
        "descr": "Returns the two closest points between two fixtures and their distance.",
        "name": "love.physics.getDistance",
        "params": [
            {
                "descr": "The first fixture.",
                "name": "Fixture fixture1"
            },
            {
                "descr": "The second fixture.",
                "name": "Fixture fixture2"
            },
            {
                "descr": "The distance of the two points.",
                "name": "number distance"
            },
            {
                "descr": "The x-coordinate of the first point.",
                "name": "number x1"
            },
            {
                "descr": "The y-coordinate of the first point.",
                "name": "number y1"
            },
            {
                "descr": "The x-coordinate of the second point.",
                "name": "number x2"
            },
            {
                "descr": "The y-coordinate of the second point.",
                "name": "number y2"
            }
        ],
        "path": "love/love.physics.getdistance",
        "syntax": "distance, x1, y1, x2, y2 = love.physics.getDistance( fixture1, fixture2 )",
        "type": "love.physics"
    },
    "getDistanceModel": {
        "descr": "Returns the distance attenuation model.",
        "name": "love.audio.getDistanceModel",
        "params": [
            {
                "descr": "The current distance model. The default is 'inverseclamped'.",
                "name": "DistanceModel model"
            }
        ],
        "path": "love/love.audio.getdistancemodel",
        "syntax": "model = love.audio.getDistanceModel( )",
        "type": "love.audio"
    },
    "getDopplerScale": {
        "descr": "Gets the current global scale factor for velocity-based doppler effects.",
        "name": "love.audio.getDopplerScale",
        "params": [
            {
                "descr": "The current doppler scale factor.",
                "name": "number scale"
            }
        ],
        "path": "love/love.audio.getdopplerscale",
        "syntax": "scale = love.audio.getDopplerScale( )",
        "type": "love.audio"
    },
    "getFPS": {
        "descr": "Returns the current frames per second.",
        "name": "love.timer.getFPS",
        "params": [
            {
                "descr": "The current FPS.",
                "name": "number fps"
            }
        ],
        "path": "love/love.timer.getfps",
        "syntax": "fps = love.timer.getFPS( )",
        "type": "love.timer"
    },
    "getFont": {
        "descr": "Gets the current Font object.",
        "name": "love.graphics.getFont",
        "params": [
            {
                "descr": "The current Font. Automatically creates and sets the default font, if none is set yet.",
                "name": "Font font"
            }
        ],
        "path": "love/love.graphics.getfont",
        "syntax": "font = love.graphics.getFont( )",
        "type": "love.graphics"
    },
    "getFullscreen": {
        "descr": "Gets whether the window is fullscreen.",
        "name": "love.window.getFullscreen",
        "params": [
            {
                "descr": "True if the window is fullscreen, false otherwise.",
                "name": "boolean fullscreen"
            },
            {
                "descr": "The type of fullscreen mode used.",
                "name": "FullscreenType fstype"
            }
        ],
        "path": "love/love.window.getfullscreen",
        "syntax": "fullscreen, fstype = love.window.getFullscreen( )",
        "type": "love.window"
    },
    "getFullscreenModes": {
        "descr": "Gets a list of supported fullscreen modes.",
        "name": "love.window.getFullscreenModes",
        "params": [
            {
                "descr": "The index of the display, if multiple monitors are available.",
                "name": "number display (1)"
            },
            {
                "descr": "A table of width/height pairs. (Note that this may not be in order.)",
                "name": "table modes"
            }
        ],
        "path": "love/love.window.getfullscreenmodes",
        "syntax": "modes = love.window.getFullscreenModes( display )",
        "type": "love.window"
    },
    "getHat": {
        "descr": "Returns the direction of a hat.",
        "name": "love.joystick.getHat",
        "params": [
            {
                "descr": "The joystick to be checked",
                "name": "number joystick"
            },
            {
                "descr": "The hat to be checked",
                "name": "number hat"
            },
            {
                "descr": "The direction the hat is pushed",
                "name": "JoystickConstant direction"
            }
        ],
        "path": "love/love.joystick.gethat",
        "syntax": "direction = love.joystick.getHat( joystick, hat )",
        "type": "love.joystick"
    },
    "getHeight": {
        "descr": "Gets the height of the window.",
        "name": "love.window.getHeight",
        "params": [
            {
                "descr": "The height of the window.",
                "name": "number height"
            }
        ],
        "path": "love/love.window.getheight",
        "syntax": "height = love.window.getHeight( )",
        "type": "love.window"
    },
    "getIcon": {
        "descr": "Gets the window icon.",
        "name": "love.window.getIcon",
        "params": [
            {
                "descr": "The window icon imagedata, or nil if no icon has been set with love.window.setIcon.",
                "name": "ImageData imagedata"
            }
        ],
        "path": "love/love.window.geticon",
        "syntax": "imagedata = love.window.getIcon( )",
        "type": "love.window"
    },
    "getIdentity": {
        "descr": "Gets the write directory name for your game. Note that this only returns the name of the folder to store your files in, not the full path.",
        "name": "love.filesystem.getIdentity",
        "params": [
            {
                "descr": "The identity that is used as write directory.",
                "name": "string name"
            }
        ],
        "path": "love/love.filesystem.getidentity",
        "syntax": "name = love.filesystem.getIdentity( )",
        "type": "love.filesystem"
    },
    "getJoystickCount": {
        "descr": "Gets the number of connected joysticks.",
        "name": "love.joystick.getJoystickCount",
        "params": [
            {
                "descr": "The number of connected joysticks.",
                "name": "number joystickcount"
            }
        ],
        "path": "love/love.joystick.getjoystickcount",
        "syntax": "joystickcount = love.joystick.getJoystickCount( )",
        "type": "love.joystick"
    },
    "getJoysticks": {
        "descr": "Gets a list of connected Joysticks.",
        "name": "love.joystick.getJoysticks",
        "params": [
            {
                "descr": "The list of currently connected Joysticks.",
                "name": "table joysticks"
            }
        ],
        "path": "love/love.joystick.getjoysticks",
        "syntax": "joysticks = love.joystick.getJoysticks( )",
        "type": "love.joystick"
    },
    "getKeyFromScancode": {
        "descr": "Gets the key corresponding to the given hardware scancode.",
        "name": "love.keyboard.getKeyFromScancode",
        "params": [
            {
                "descr": "The scancode to get the key from.",
                "name": "Scancode scancode"
            },
            {
                "descr": "The key corresponding to the given scancode, or \"unknown\" if the scancode doesn't map to a KeyConstant on the current system.",
                "name": "KeyConstant key"
            }
        ],
        "path": "love/love.keyboard.getkeyfromscancode",
        "syntax": "key = love.keyboard.getKeyFromScancode( scancode )",
        "type": "love.keyboard"
    },
    "getKeyRepeat": {
        "descr": "Returns the delay and interval of key repeating.",
        "name": "love.keyboard.getKeyRepeat",
        "params": [
            {
                "descr": "The amount of time before repeating the key (in seconds)",
                "name": "number delay"
            },
            {
                "descr": "The amount of time between repeats (in seconds)",
                "name": "number interval"
            }
        ],
        "path": "love/love.keyboard.getkeyrepeat",
        "syntax": "delay, interval = love.keyboard.getKeyRepeat( )",
        "type": "love.keyboard"
    },
    "getLastModified": {
        "descr": "Gets the last modification time of a file.",
        "name": "love.filesystem.getLastModified",
        "params": [
            {
                "descr": "The path and name to a file.",
                "name": "string filename"
            },
            {
                "descr": "The last modification time in seconds since the unix epoch or nil on failure.",
                "name": "number modtime"
            },
            {
                "descr": "The error message on failure.",
                "name": "string errormsg"
            }
        ],
        "path": "love/love.filesystem.getlastmodified",
        "syntax": "modtime, errormsg = love.filesystem.getLastModified( filename )",
        "type": "love.filesystem"
    },
    "getLineJoin": {
        "descr": "Gets the line join style.",
        "name": "love.graphics.getLineJoin",
        "params": [
            {
                "descr": "The LineJoin style.",
                "name": "LineJoin join"
            }
        ],
        "path": "love/love.graphics.getlinejoin",
        "syntax": "join = love.graphics.getLineJoin( )",
        "type": "love.graphics"
    },
    "getLineStipple": {
        "descr": "Gets the current line stipple.",
        "name": "love.graphics.getLineStipple",
        "params": [
            {
                "descr": "The 16-bit stipple pattern.",
                "name": "number pattern"
            },
            {
                "descr": "The repeat factor.",
                "name": "number repeat"
            }
        ],
        "path": "love/love.graphics.getlinestipple",
        "syntax": "pattern, repeat = love.graphics.getLineStipple( )",
        "type": "love.graphics"
    },
    "getLineStyle": {
        "descr": "Gets the line style.",
        "name": "love.graphics.getLineStyle",
        "params": [
            {
                "descr": "The current line style.",
                "name": "LineStyle style"
            }
        ],
        "path": "love/love.graphics.getlinestyle",
        "syntax": "style = love.graphics.getLineStyle( )",
        "type": "love.graphics"
    },
    "getLineWidth": {
        "descr": "Gets the current line width.",
        "name": "love.graphics.getLineWidth",
        "params": [
            {
                "descr": "The current line width.",
                "name": "number width"
            }
        ],
        "path": "love/love.graphics.getlinewidth",
        "syntax": "width = love.graphics.getLineWidth( )",
        "type": "love.graphics"
    },
    "getMaxImageSize": {
        "descr": "Gets the max supported width or height of Images and Canvases.",
        "name": "love.graphics.getMaxImageSize",
        "params": [
            {
                "descr": "The max supported width or height of Images and Canvases.",
                "name": "number size"
            }
        ],
        "path": "love/love.graphics.getmaximagesize",
        "syntax": "size = love.graphics.getMaxImageSize( )",
        "type": "love.graphics"
    },
    "getMaxPointSize": {
        "descr": "Gets the max supported point size.",
        "name": "love.graphics.getMaxPointSize",
        "params": [
            {
                "descr": "The max supported point size.",
                "name": "number size"
            }
        ],
        "path": "love/love.graphics.getmaxpointsize",
        "syntax": "size = love.graphics.getMaxPointSize( )",
        "type": "love.graphics"
    },
    "getMeter": {
        "descr": "Returns the meter scale factor.",
        "name": "love.physics.getMeter",
        "params": [
            {
                "descr": "The scale factor as an integer.",
                "name": "number scale"
            }
        ],
        "path": "love/love.physics.getmeter",
        "syntax": "scale = love.physics.getMeter( )",
        "type": "love.physics"
    },
    "getMicroTime": {
        "descr": "Returns the value of a timer with an unspecified starting time. The time is accurate to the microsecond.",
        "name": "love.timer.getMicroTime",
        "params": [
            {
                "descr": "The time passed in seconds.",
                "name": "number t"
            }
        ],
        "path": "love/love.timer.getmicrotime",
        "syntax": "t = love.timer.getMicroTime( )",
        "type": "love.timer"
    },
    "getMode": {
        "descr": "Gets the display mode and properties of the window.",
        "name": "love.window.getMode",
        "params": [
            {
                "descr": "Window width.",
                "name": "number width"
            },
            {
                "descr": "Window height.",
                "name": "number height"
            },
            {
                "descr": "Table with the window properties:  boolean fullscreen  Fullscreen (true), or windowed (false).",
                "name": "table flags"
            },
            {
                "descr": "The type of fullscreen mode used.",
                "name": "FullscreenType fullscreentype"
            },
            {
                "descr": "True if the graphics framerate is synchronized with the monitor's refresh rate, false otherwise.",
                "name": "boolean vsync"
            },
            {
                "descr": "The number of antialiasing samples used (0 if MSAA is disabled).",
                "name": "number msaa"
            },
            {
                "descr": "True if the window is resizable in windowed mode, false otherwise.",
                "name": "boolean resizable"
            },
            {
                "descr": "True if the window is borderless in windowed mode, false otherwise.",
                "name": "boolean borderless"
            },
            {
                "descr": "True if the window is centered in windowed mode, false otherwise.",
                "name": "boolean centered"
            },
            {
                "descr": "The index of the display the window is currently in, if multiple monitors are available.",
                "name": "number display"
            },
            {
                "descr": "The minimum width of the window, if it's resizable.",
                "name": "number minwidth"
            },
            {
                "descr": "The minimum height of the window, if it's resizable.",
                "name": "number minheight"
            },
            {
                "descr": "True if high-dpi mode is allowed on Retina displays in OS X. ",
                "name": "boolean highdpi"
            },
            {
                "descr": "The refresh rate of the screen's current display mode, in Hz. ",
                "name": "number refreshrate"
            },
            {
                "descr": "The x-coordinate of the window's position in its current display. ",
                "name": "number x"
            },
            {
                "descr": "The y-coordinate of the window's position in its current display. ",
                "name": "number y"
            },
            {
                "descr": "Removed in 0.10.0 (use love.graphics.isGammaCorrect instead). ",
                "name": "boolean srgb"
            }
        ],
        "path": "love/love.window.getmode",
        "syntax": "width, height, flags = love.window.getMode( )",
        "type": "love.window"
    },
    "getModes": {
        "descr": "Gets a list of supported fullscreen modes.",
        "name": "love.graphics.getModes",
        "params": [
            {
                "descr": "A table of width/height pairs. (Note that this may not be in order.)",
                "name": "table modes"
            }
        ],
        "path": "love/love.graphics.getmodes",
        "syntax": "modes = love.graphics.getModes( )",
        "type": "love.graphics"
    },
    "getName": {
        "descr": "Returns the name of a joystick.",
        "name": "love.joystick.getName",
        "params": [
            {
                "descr": "The joystick to be checked",
                "name": "number joystick"
            },
            {
                "descr": "The name",
                "name": "string name"
            }
        ],
        "path": "love/love.joystick.getname",
        "syntax": "name = love.joystick.getName( joystick )",
        "type": "love.joystick"
    },
    "getNumAxes": {
        "descr": "Returns the number of axes on the joystick.",
        "name": "love.joystick.getNumAxes",
        "params": [
            {
                "descr": "The joystick to be checked",
                "name": "number joystick"
            },
            {
                "descr": "The number of axes available",
                "name": "number axes"
            }
        ],
        "path": "love/love.joystick.getnumaxes",
        "syntax": "axes = love.joystick.getNumAxes( joystick )",
        "type": "love.joystick"
    },
    "getNumBalls": {
        "descr": "Returns the number of balls on the joystick.",
        "name": "love.joystick.getNumBalls",
        "params": [
            {
                "descr": "The joystick to be checked",
                "name": "number joystick"
            },
            {
                "descr": "The number of balls available",
                "name": "number balls"
            }
        ],
        "path": "love/love.joystick.getnumballs",
        "syntax": "balls = love.joystick.getNumBalls( joystick )",
        "type": "love.joystick"
    },
    "getNumButtons": {
        "descr": "Returns the number of buttons on the joystick.",
        "name": "love.joystick.getNumButtons",
        "params": [
            {
                "descr": "The joystick to be checked",
                "name": "number joystick"
            },
            {
                "descr": "The number of buttons available",
                "name": "number buttons"
            }
        ],
        "path": "love/love.joystick.getnumbuttons",
        "syntax": "buttons = love.joystick.getNumButtons( joystick )",
        "type": "love.joystick"
    },
    "getNumHats": {
        "descr": "Returns the number of hats on the joystick.",
        "name": "love.joystick.getNumHats",
        "params": [
            {
                "descr": "The joystick to be checked",
                "name": "number joystick"
            },
            {
                "descr": "How many hats the joystick has",
                "name": "number hats"
            }
        ],
        "path": "love/love.joystick.getnumhats",
        "syntax": "hats = love.joystick.getNumHats( joystick )",
        "type": "love.joystick"
    },
    "getNumJoysticks": {
        "descr": "Returns how many joysticks are available.",
        "name": "love.joystick.getNumJoysticks",
        "params": [
            {
                "descr": "The number of joysticks available",
                "name": "number joysticks"
            }
        ],
        "path": "love/love.joystick.getnumjoysticks",
        "syntax": "joysticks = love.joystick.getNumJoysticks( )",
        "type": "love.joystick"
    },
    "getNumSources": {
        "descr": "Gets the current number of simultaneously playing sources.",
        "name": "love.audio.getNumSources",
        "params": [
            {
                "descr": "The current number of simultaneously playing sources.",
                "name": "number numSources"
            }
        ],
        "path": "love/love.audio.getnumsources",
        "syntax": "numSources = love.audio.getNumSources( )",
        "type": "love.audio"
    },
    "getOS": {
        "descr": "Gets the current operating system. In general, LÖVE abstracts away the need to know the current operating system, but there are a few cases where it can be useful (especially in combination with os.execute.)",
        "name": "love.system.getOS",
        "params": [
            {
                "descr": "The current operating system. \"OS X\", \"Windows\", \"Linux\", \"Android\" or \"iOS\".",
                "name": "string osString"
            }
        ],
        "path": "love/love.system.getos",
        "syntax": "osString = love.system.getOS( )",
        "type": "love.system"
    },
    "getOrientation": {
        "descr": "Returns the orientation of the listener.",
        "name": "love.audio.getOrientation",
        "params": [
            {
                "descr": "Forward vector of the listener orientation.",
                "name": "number fx, fy, fz"
            },
            {
                "descr": "Up vector of the listener orientation.",
                "name": "number ux, uy, uz"
            }
        ],
        "path": "love/love.audio.getorientation",
        "syntax": "fx, fy, fz, ux, uy, uz = love.audio.getOrientation( )",
        "type": "love.audio"
    },
    "getPixelEffect": {
        "descr": "Returns the current PixelEffect. Returns nil if none is set.",
        "name": "love.graphics.getPixelEffect",
        "params": [
            {
                "descr": "The current PixelEffect.",
                "name": "PixelEffect pe"
            }
        ],
        "path": "love/love.graphics.getpixeleffect",
        "syntax": "pe = love.graphics.getPixelEffect( )",
        "type": "love.graphics"
    },
    "getPixelScale": {
        "descr": "Gets the DPI scale factor associated with the window.",
        "name": "love.window.getPixelScale",
        "params": [
            {
                "descr": "The pixel scale factor associated with the window.",
                "name": "number scale"
            }
        ],
        "path": "love/love.window.getpixelscale",
        "syntax": "scale = love.window.getPixelScale( )",
        "type": "love.window"
    },
    "getPointSize": {
        "descr": "Gets the point size.",
        "name": "love.graphics.getPointSize",
        "params": [
            {
                "descr": "The current point size.",
                "name": "number size"
            }
        ],
        "path": "love/love.graphics.getpointsize",
        "syntax": "size = love.graphics.getPointSize( )",
        "type": "love.graphics"
    },
    "getPointStyle": {
        "descr": "Gets the current point style.",
        "name": "love.graphics.getPointStyle",
        "params": [
            {
                "descr": "The current point style.",
                "name": "PointStyle style"
            }
        ],
        "path": "love/love.graphics.getpointstyle",
        "syntax": "style = love.graphics.getPointStyle( )",
        "type": "love.graphics"
    },
    "getPosition": {
        "descr": "Gets the position of the window on the screen.",
        "name": "love.window.getPosition",
        "params": [
            {
                "descr": "The x-coordinate of the window's position.",
                "name": "number x"
            },
            {
                "descr": "The y-coordinate of the window's position.",
                "name": "number y"
            },
            {
                "descr": "The index of the display that the window is in.",
                "name": "number display"
            }
        ],
        "path": "love/love.window.getposition",
        "syntax": "x, y, display = love.window.getPosition( )",
        "type": "love.window"
    },
    "getPowerInfo": {
        "descr": "Gets information about the system's power supply.",
        "name": "love.system.getPowerInfo",
        "params": [
            {
                "descr": "The basic state of the power supply.",
                "name": "PowerState state"
            },
            {
                "descr": "Percentage of battery life left, between 0 and 100. ",
                "name": "number percent (nil)"
            },
            {
                "descr": "Seconds of battery life left. nil if the value can't be determined or there's no battery.",
                "name": "number seconds (nil)"
            }
        ],
        "path": "love/love.system.getpowerinfo",
        "syntax": "state, percent, seconds = love.system.getPowerInfo( )",
        "type": "love.system"
    },
    "getPressure": {
        "descr": "Gets the current pressure of the specified touch-press.",
        "name": "love.touch.getPressure",
        "params": [
            {
                "descr": "The identifier of the touch-press. ",
                "name": "light userdata id"
            },
            {
                "descr": "The pressure of the touch-press. ",
                "name": "number pressure"
            }
        ],
        "path": "love/love.touch.getpressure",
        "syntax": "pressure = love.touch.getPressure( id )",
        "type": "love.touch"
    },
    "getProcessorCount": {
        "descr": "Gets the number of CPU cores in the system.",
        "name": "love.system.getProcessorCount",
        "params": [
            {
                "descr": "The number of CPU cores.",
                "name": "number cores"
            }
        ],
        "path": "love/love.system.getprocessorcount",
        "syntax": "cores = love.system.getProcessorCount( )",
        "type": "love.system"
    },
    "getRandomSeed": {
        "descr": "Gets the seed of the random number generator.",
        "name": "love.math.getRandomSeed",
        "params": [
            {
                "descr": "Integer number representing the lower 32 bits of the random number generator's 64 bit seed value.",
                "name": "number low"
            },
            {
                "descr": "Integer number representing the higher 32 bits of the random number generator's 64 bit seed value.",
                "name": "number high"
            }
        ],
        "path": "love/love.math.getrandomseed",
        "syntax": "low, high = love.math.getRandomSeed( )",
        "type": "love.math"
    },
    "getRealDirectory": {
        "descr": "Gets the platform-specific absolute path of the directory containing a filepath.",
        "name": "love.filesystem.getRealDirectory",
        "params": [
            {
                "descr": "The filepath to get the directory of.",
                "name": "string filepath"
            },
            {
                "descr": "The platform-specific full path of the directory containing the filepath.",
                "name": "string realdir"
            }
        ],
        "path": "love/love.filesystem.getrealdirectory",
        "syntax": "realdir = love.filesystem.getRealDirectory( filepath )",
        "type": "love.filesystem"
    },
    "getRelativeMode": {
        "descr": "Gets whether relative mode is enabled for the mouse.",
        "name": "love.mouse.getRelativeMode",
        "params": [
            {
                "descr": "True if relative mode is enabled, false if it's disabled.",
                "name": "boolean enabled"
            }
        ],
        "path": "love/love.mouse.getrelativemode",
        "syntax": "enabled = love.mouse.getRelativeMode( )",
        "type": "love.mouse"
    },
    "getRendererInfo": {
        "descr": "Gets information about the system's video card and drivers.",
        "name": "love.graphics.getRendererInfo",
        "params": [
            {
                "descr": "The name of the renderer, e.g. \"OpenGL\" or \"OpenGL ES\".",
                "name": "string name"
            },
            {
                "descr": "The version of the renderer with some extra driver-dependent version info, e.g. ",
                "name": "string version"
            },
            {
                "descr": "The name of the graphics card vendor, e.g. ",
                "name": "string vendor"
            },
            {
                "descr": "The name of the graphics card, e.g. ",
                "name": "string device"
            }
        ],
        "path": "love/love.graphics.getrendererinfo",
        "syntax": "name, version, vendor, device = love.graphics.getRendererInfo( )",
        "type": "love.graphics"
    },
    "getRequirePath": {
        "descr": "Gets the filesystem paths that will be searched when require is called.",
        "name": "love.filesystem.getRequirePath",
        "params": [
            {
                "descr": "The paths that the require function will check in love's filesystem.",
                "name": "string paths"
            }
        ],
        "path": "love/love.filesystem.getrequirepath",
        "syntax": "paths = love.filesystem.getRequirePath( )",
        "type": "love.filesystem"
    },
    "getSaveDirectory": {
        "descr": "Gets the full path to the designated save directory. This can be useful if you want to use the standard io library (or something else) to read or write in the save directory.",
        "name": "love.filesystem.getSaveDirectory",
        "params": [
            {
                "descr": "The absolute path to the save directory.",
                "name": "string dir"
            }
        ],
        "path": "love/love.filesystem.getsavedirectory",
        "syntax": "dir = love.filesystem.getSaveDirectory( )",
        "type": "love.filesystem"
    },
    "getScancodeFromKey": {
        "descr": "Gets the hardware scancode corresponding to the given key.",
        "name": "love.keyboard.getScancodeFromKey",
        "params": [
            {
                "descr": "The key to get the scancode from.",
                "name": "KeyConstant key"
            },
            {
                "descr": "The scancode corresponding to the given key, or \"unknown\" if the given key has no known physical representation on the current system.",
                "name": "Scancode scancode"
            }
        ],
        "path": "love/love.keyboard.getscancodefromkey",
        "syntax": "scancode = love.keyboard.getScancodeFromKey( key )",
        "type": "love.keyboard"
    },
    "getScissor": {
        "descr": "Gets the current scissor box.",
        "name": "love.graphics.getScissor",
        "params": [
            {
                "descr": "The x-component of the top-left point of the box.",
                "name": "number x"
            },
            {
                "descr": "The y-component of the top-left point of the box.",
                "name": "number y"
            },
            {
                "descr": "The width of the box.",
                "name": "number width"
            },
            {
                "descr": "The height of the box.",
                "name": "number height"
            }
        ],
        "path": "love/love.graphics.getscissor",
        "syntax": "x, y, width, height = love.graphics.getScissor( )",
        "type": "love.graphics"
    },
    "getShader": {
        "descr": "Gets the current Shader. Returns nil if none is set.",
        "name": "love.graphics.getShader",
        "params": [
            {
                "descr": "The currently active Shader, or nil if none is set.",
                "name": "Shader shader"
            }
        ],
        "path": "love/love.graphics.getshader",
        "syntax": "shader = love.graphics.getShader( )",
        "type": "love.graphics"
    },
    "getSize": {
        "descr": "Gets the size in bytes of a file.",
        "name": "love.filesystem.getSize",
        "params": [
            {
                "descr": "The path and name to a file.",
                "name": "string filename"
            },
            {
                "descr": "The size in bytes of the file, or nil on failure.",
                "name": "number size"
            },
            {
                "descr": "The error message on failure.",
                "name": "string errormsg (nil)"
            }
        ],
        "path": "love/love.filesystem.getsize",
        "syntax": "size, errormsg = love.filesystem.getSize( filename )",
        "type": "love.filesystem"
    },
    "getSource": {
        "descr": "Returns the full path to the the .love file or directory. If the game is fused to the LÖVE executable, then the executable is returned.",
        "name": "love.filesystem.getSource",
        "params": [
            {
                "descr": "The full platform-dependent path of the .love file or directory.",
                "name": "string path"
            }
        ],
        "path": "love/love.filesystem.getsource",
        "syntax": "path = love.filesystem.getSource( )",
        "type": "love.filesystem"
    },
    "getSourceBaseDirectory": {
        "descr": "Returns the full path to the directory containing the .love file. If the game is fused to the LÖVE executable, then the directory containing the executable is returned.",
        "name": "love.filesystem.getSourceBaseDirectory",
        "params": [
            {
                "descr": "The full platform-dependent path of the directory containing the .love file.",
                "name": "string path"
            }
        ],
        "path": "love/love.filesystem.getsourcebasedirectory",
        "syntax": "path = love.filesystem.getSourceBaseDirectory( )",
        "type": "love.filesystem"
    },
    "getSourceCount": {
        "descr": "Gets the current number of simultaneously playing sources.",
        "name": "love.audio.getSourceCount",
        "params": [
            {
                "descr": "The current number of simultaneously playing sources.",
                "name": "number numSources"
            }
        ],
        "path": "love/love.audio.getsourcecount",
        "syntax": "numSources = love.audio.getSourceCount( )",
        "type": "love.audio"
    },
    "getStats": {
        "descr": "Gets performance-related rendering statistics.",
        "name": "love.graphics.getStats",
        "params": [
            {
                "descr": "A table with the following fields:  number drawcalls  The number of draw calls made so far during the current frame.",
                "name": "table stats"
            },
            {
                "descr": "The number of times the active Canvas has been switched so far during the current frame.",
                "name": "number canvasswitches"
            },
            {
                "descr": "The estimated total size in bytes of video memory used by all loaded Images, Canvases, and Fonts.",
                "name": "number texturememory"
            },
            {
                "descr": "The number of Image objects currently loaded.",
                "name": "number images"
            },
            {
                "descr": "The number of Canvas objects currently loaded.",
                "name": "number canvases"
            },
            {
                "descr": "The number of Font objects currently loaded.",
                "name": "number fonts"
            },
            {
                "descr": "The number of times the active Shader has been changed so far during the current frame.",
                "name": "number shaderswitches Available since 0.10.2"
            }
        ],
        "path": "love/love.graphics.getstats",
        "syntax": "stats = love.graphics.getStats( )",
        "type": "love.graphics"
    },
    "getStencilTest": {
        "descr": "Gets the current stencil test configuration.",
        "name": "love.graphics.getStencilTest",
        "params": [
            {
                "descr": "The type of comparison that is made for each pixel. ",
                "name": "CompareMode comparemode"
            },
            {
                "descr": "The value used when comparing with the stencil value of each pixel.",
                "name": "number comparevalue"
            }
        ],
        "path": "love/love.graphics.getstenciltest",
        "syntax": "comparemode, comparevalue = love.graphics.getStencilTest( )",
        "type": "love.graphics"
    },
    "getSupported": {
        "descr": "Gets the optional graphics features and whether they're supported on the system.",
        "name": "love.graphics.getSupported",
        "params": [
            {
                "descr": "A table containing GraphicsFeature keys, and boolean values indicating whether each feature is supported.",
                "name": "table features"
            }
        ],
        "path": "love/love.graphics.getsupported",
        "syntax": "features = love.graphics.getSupported( )",
        "type": "love.graphics"
    },
    "getSystemCursor": {
        "descr": "Gets a Cursor object representing a system-native hardware cursor.",
        "name": "love.mouse.getSystemCursor",
        "params": [
            {
                "descr": "The type of system cursor to get.",
                "name": "CursorType ctype"
            },
            {
                "descr": "The Cursor object representing the system cursor type.",
                "name": "Cursor cursor"
            }
        ],
        "path": "love/love.mouse.getsystemcursor",
        "syntax": "cursor = love.mouse.getSystemCursor( ctype )",
        "type": "love.mouse"
    },
    "getSystemLimit": {
        "descr": "Gets the system-dependent maximum value for a love.graphics feature.",
        "name": "love.graphics.getSystemLimit",
        "params": [
            {
                "descr": "The graphics feature to get the maximum value of.",
                "name": "GraphicsLimit limittype"
            },
            {
                "descr": "The system-dependent max value for the feature.",
                "name": "number limit"
            }
        ],
        "path": "love/love.graphics.getsystemlimit",
        "syntax": "limit = love.graphics.getSystemLimit( limittype )",
        "type": "love.graphics"
    },
    "getSystemLimits": {
        "descr": "Gets the system-dependent maximum values for love.graphics features.",
        "name": "love.graphics.getSystemLimits",
        "params": [
            {
                "descr": "A table containing GraphicsLimit keys, and number values.",
                "name": "table limits"
            }
        ],
        "path": "love/love.graphics.getsystemlimits",
        "syntax": "limits = love.graphics.getSystemLimits( )",
        "type": "love.graphics"
    },
    "getThread": {
        "descr": "Look for a thread and get its object.",
        "name": "love.thread.getThread",
        "params": [
            {
                "descr": "The name of the thread to return.",
                "name": "string name"
            },
            {
                "descr": "The thread with that name.",
                "name": "Thread thread"
            }
        ],
        "path": "love/love.thread.getthread",
        "syntax": "thread = love.thread.getThread( name )",
        "type": "love.thread"
    },
    "getThreads": {
        "descr": "Get all threads.",
        "name": "love.thread.getThreads",
        "params": [
            {
                "descr": "A table containing all threads indexed by their names.",
                "name": "table threads"
            }
        ],
        "path": "love/love.thread.getthreads",
        "syntax": "threads = love.thread.getThreads( )",
        "type": "love.thread"
    },
    "getTime": {
        "descr": "Returns the value of a timer with an unspecified starting time. This function should only be used to calculate differences between points in time, as the starting time of the timer is unknown.",
        "name": "love.timer.getTime",
        "params": [
            {
                "descr": "The time in seconds.",
                "name": "number time"
            }
        ],
        "path": "love/love.timer.gettime",
        "syntax": "time = love.timer.getTime( )",
        "type": "love.timer"
    },
    "getTitle": {
        "descr": "Gets the window title.",
        "name": "love.window.getTitle",
        "params": [
            {
                "descr": "The current window title.",
                "name": "string title"
            }
        ],
        "path": "love/love.window.gettitle",
        "syntax": "title = love.window.getTitle( )",
        "type": "love.window"
    },
    "getTouches": {
        "descr": "Gets a list of all active touch-presses.",
        "name": "love.touch.getTouches",
        "params": [
            {
                "descr": "A list of active touch-press id values, which can be used with love.touch.getPosition.",
                "name": "table touches"
            }
        ],
        "path": "love/love.touch.gettouches",
        "syntax": "touches = love.touch.getTouches( )",
        "type": "love.touch"
    },
    "getUserDirectory": {
        "descr": "Returns the path of the user's directory",
        "name": "love.filesystem.getUserDirectory",
        "params": [
            {
                "descr": "The path of the user's directory",
                "name": "string path"
            }
        ],
        "path": "love/love.filesystem.getuserdirectory",
        "syntax": "path = love.filesystem.getUserDirectory( )",
        "type": "love.filesystem"
    },
    "getVelocity": {
        "descr": "Returns the velocity of the listener.",
        "name": "love.audio.getVelocity",
        "params": [
            {
                "descr": "The X velocity of the listener.",
                "name": "number x"
            },
            {
                "descr": "The Y velocity of the listener.",
                "name": "number y"
            },
            {
                "descr": "The Z velocity of the listener.",
                "name": "number z"
            }
        ],
        "path": "love/love.audio.getvelocity",
        "syntax": "x, y, z = love.audio.getVelocity( )",
        "type": "love.audio"
    },
    "getVersion": {
        "descr": "Gets the current running version of LÖVE.",
        "name": "love.getVersion",
        "params": [
            {
                "descr": "The major version of LÖVE, i.e. ",
                "name": "number major"
            },
            {
                "descr": "The minor version of LÖVE, i.e. ",
                "name": "number minor"
            },
            {
                "descr": "The revision version of LÖVE, i.e. ",
                "name": "number revision"
            },
            {
                "descr": "The codename of the current version, i.e. ",
                "name": "string codename"
            }
        ],
        "path": "love/love.getversion",
        "syntax": "major, minor, revision, codename = love.getVersion( )",
        "type": "love"
    },
    "getVolume": {
        "descr": "Returns the master volume.",
        "name": "love.audio.getVolume",
        "params": [
            {
                "descr": "The current master volume",
                "name": "number volume"
            }
        ],
        "path": "love/love.audio.getvolume",
        "syntax": "volume = love.audio.getVolume( )",
        "type": "love.audio"
    },
    "getWidth": {
        "descr": "Gets the width of the window.",
        "name": "love.window.getWidth",
        "params": [
            {
                "descr": "The width of the window.",
                "name": "number width"
            }
        ],
        "path": "love/love.window.getwidth",
        "syntax": "width = love.window.getWidth( )",
        "type": "love.window"
    },
    "getWorkingDirectory": {
        "descr": "Gets the current working directory.",
        "name": "love.filesystem.getWorkingDirectory",
        "params": [
            {
                "descr": "The current working directory.",
                "name": "string cwd"
            }
        ],
        "path": "love/love.filesystem.getworkingdirectory",
        "syntax": "cwd = love.filesystem.getWorkingDirectory( )",
        "type": "love.filesystem"
    },
    "getX": {
        "descr": "Returns the current x-position of the mouse.",
        "name": "love.mouse.getX",
        "params": [
            {
                "descr": "The position of the mouse along the x-axis.",
                "name": "number x"
            }
        ],
        "path": "love/love.mouse.getx",
        "syntax": "x = love.mouse.getX( )",
        "type": "love.mouse"
    },
    "getY": {
        "descr": "Returns the current y-position of the mouse.",
        "name": "love.mouse.getY",
        "params": [
            {
                "descr": "The position of the mouse along the y-axis.",
                "name": "number y"
            }
        ],
        "path": "love/love.mouse.gety",
        "syntax": "y = love.mouse.getY( )",
        "type": "love.mouse"
    },
    "hasCursor": {
        "descr": "Gets whether cursor functionality is supported.",
        "name": "love.mouse.hasCursor",
        "params": [
            {
                "descr": "Whether the system has cursor functionality.",
                "name": "boolean hascursor"
            }
        ],
        "path": "love/love.mouse.hascursor",
        "syntax": "hascursor = love.mouse.hasCursor( )",
        "type": "love.mouse"
    },
    "hasFocus": {
        "descr": "Checks if the game window has keyboard focus.",
        "name": "love.window.hasFocus",
        "params": [
            {
                "descr": "True if the window has the focus or false if not.",
                "name": "boolean focus"
            }
        ],
        "path": "love/love.window.hasfocus",
        "syntax": "focus = love.window.hasFocus( )",
        "type": "love.window"
    },
    "hasKeyRepeat": {
        "descr": "Gets whether key repeat is enabled.",
        "name": "love.keyboard.hasKeyRepeat",
        "params": [
            {
                "descr": "Whether key repeat is enabled.",
                "name": "boolean enabled"
            }
        ],
        "path": "love/love.keyboard.haskeyrepeat",
        "syntax": "enabled = love.keyboard.hasKeyRepeat( )",
        "type": "love.keyboard"
    },
    "hasMouseFocus": {
        "descr": "Checks if the game window has mouse focus.",
        "name": "love.window.hasMouseFocus",
        "params": [
            {
                "descr": "True if the window has mouse focus or false if not.",
                "name": "boolean focus"
            }
        ],
        "path": "love/love.window.hasmousefocus",
        "syntax": "focus = love.window.hasMouseFocus( )",
        "type": "love.window"
    },
    "hasTextInput": {
        "descr": "Gets whether text input events are enabled.",
        "name": "love.keyboard.hasTextInput",
        "params": [
            {
                "descr": "Whether text input events are enabled.",
                "name": "boolean enabled"
            }
        ],
        "path": "love/love.keyboard.hastextinput",
        "syntax": "enabled = love.keyboard.hasTextInput( )",
        "type": "love.keyboard"
    },
    "host create": {
        "descr": "Returns a new  host. All arguments are optional.",
        "name": "enet.host create",
        "params": [
            {
                "descr": "The address to connect to in the format \"ip:port\".",
                "name": "string bind_address"
            },
            {
                "descr": "The max number of peers. Defaults to 64.",
                "name": "number peer_count"
            },
            {
                "descr": "Downstream bandwidth in bytes/sec. ",
                "name": "number in_bandwidth"
            },
            {
                "descr": "The max number of channels. Defaults to 1.",
                "name": "number channel_count"
            },
            {
                "descr": "Upstream bandwidth in bytes/sec. ",
                "name": "number out_bandwidth"
            },
            {
                "descr": "The requested  host.",
                "name": "enet.host host"
            }
        ],
        "path": "love/enet.host_create",
        "syntax": "host = enet.host_create(bind_address, peer_count, channel_count, in_bandwidth, out_bandwidth)",
        "type": "enet"
    },
    "host:bandwidth limit": {
        "descr": "Sets the bandwidth limits of the  host in bytes/sec. Set to 0 for unlimited.",
        "name": "enet.host:bandwidth limit",
        "params": [
            {
                "descr": "Download speed limit in bytes/sec.",
                "name": "number incoming"
            },
            {
                "descr": "Upload speed limit in bytes/sec.",
                "name": "number outgoing"
            }
        ],
        "path": "love/enet.host-bandwidth_limit",
        "syntax": "host:bandwidth_limit(incoming, outgoing)",
        "type": "enet"
    },
    "host:broadcast": {
        "descr": "Queues a packet to be sent to all connected  peers.",
        "name": "enet.host:broadcast",
        "params": [
            {
                "descr": "The data to send.",
                "name": "string data"
            },
            {
                "descr": "The channel to send the packet on. ",
                "name": "number channel"
            },
            {
                "descr": "flag is one of \"reliable\", \"unsequenced\", or \"unreliable\". ",
                "name": "string flag"
            }
        ],
        "path": "love/enet.host-broadcast",
        "syntax": "host:broadcast(data, channel, flag)",
        "type": "enet"
    },
    "host:channel limit": {
        "descr": "Sets the maximum number of channels allowed. If it is 0 then the system maximum allowable value is used.",
        "name": "enet.host:channel limit",
        "params": [
            {
                "descr": "The maximum number of channels allowed.",
                "name": "number limit"
            }
        ],
        "path": "love/enet.host-channel_limit",
        "syntax": "host:channel_limit(limit)",
        "type": "enet"
    },
    "host:check events": {
        "descr": "Checks for any queued events and dispatches one if available. Returns the associated  event if something was dispatched, otherwise nil.",
        "name": "enet.host:check events",
        "params": [
            {
                "descr": "An  event or nil if no events are available.",
                "name": "table event"
            }
        ],
        "path": "love/enet.host-check_events",
        "syntax": "event = host:check_events()",
        "type": "enet"
    },
    "host:compress with range coder": {
        "descr": "Toggles an adaptive order-2 PPM range coder for the transmitted data of all peers.",
        "name": "enet.host:compress with range coder",
        "params": [
            {
                "descr": "True if the compression algorithm is active, false if not.",
                "name": "boolean state"
            }
        ],
        "path": "love/enet.host-compress_with_range_coder",
        "syntax": "host:compress_with_range_coder()",
        "type": "enet"
    },
    "host:connect": {
        "descr": "Connects a  host to a remote  host. Returns  peer object associated with the remote  host. The actual connection will not take place until the next  host:service() is called, in which a \"connect\"  event will be generated.",
        "name": "enet.host:connect",
        "params": [
            {
                "descr": "The address to connect to in the format \"ip:port\".",
                "name": "string address"
            },
            {
                "descr": "The number of channels to allocate. ",
                "name": "number channel_count"
            },
            {
                "descr": "An integer value that can be associated with the connect  event. ",
                "name": "number data"
            },
            {
                "descr": "A  peer.",
                "name": "enet.peer peer"
            }
        ],
        "path": "love/enet.host-connect",
        "syntax": "peer = host:connect(address, channel_count, data)",
        "type": "enet"
    },
    "host:destroy": {
        "descr": "Destroys the  host structure and closes all of its connections. This function is also ran automatically by lua's garbage collector, since it's an alias to host:__gc.",
        "name": "enet.host:destroy",
        "params": [],
        "path": "love/enet.host-destroy",
        "syntax": "host:destroy()",
        "type": "enet"
    },
    "host:flush": {
        "descr": "Sends any queued packets. This is only required to send packets earlier than the next call to  host:service, or if  host:service will not be called again.",
        "name": "enet.host:flush",
        "params": [],
        "path": "love/enet.host-flush",
        "syntax": "host:flush()",
        "type": "enet"
    },
    "host:get peer": {
        "descr": "Returns the connected  peer at the specified index (starting at 1). ENet stores all  peers in an array of the corresponding  host and re-uses unused peers for new connections. You can query the state of a peer using  peer:state().",
        "name": "enet.host:get peer",
        "params": [
            {
                "descr": "The index of the desired  peer.",
                "name": "number index"
            },
            {
                "descr": "The desired  peer structure.",
                "name": "enet.peer peer"
            }
        ],
        "path": "love/enet.host-get_peer",
        "syntax": "host:get_peer(index)",
        "type": "enet"
    },
    "host:get socket address": {
        "descr": "Returns a string that describes the socket address of the given  host. The string is formatted as “a.b.c.d:port”, where “a.b.c.d” is the IP address of the used socket.",
        "name": "enet.host:get socket address",
        "params": [
            {
                "descr": "A string that describes the socket address.",
                "name": "string address"
            }
        ],
        "path": "love/enet.host-get_socket_address",
        "syntax": "host:get_socket_address()",
        "type": "enet"
    },
    "host:peer count": {
        "descr": "Returns the number of  peers that are allocated for the given  host. This represents the maximum number of possible connections.",
        "name": "enet.host:peer count",
        "params": [
            {
                "descr": "The maximum number of peers allowed.",
                "name": "number limit"
            }
        ],
        "path": "love/enet.host-peer_count",
        "syntax": "host:peer_count()",
        "type": "enet"
    },
    "host:service": {
        "descr": "Wait for  events, send and receive any ready packets. If an  event is in the queue it will be returned and dequeued. Generally you will want to dequeue all waiting  events every frame.",
        "name": "enet.host:service",
        "params": [
            {
                "descr": "The max number of milliseconds to be waited for an  event. ",
                "name": "number timeout"
            },
            {
                "descr": "An  event or nil if no events occured.",
                "name": "table event"
            }
        ],
        "path": "love/enet.host-service",
        "syntax": "event = host:service( timeout )",
        "type": "enet"
    },
    "host:service time": {
        "descr": "Returns the time-stamp of the last call to  host:service() or  host:flush(). The time-stamp is in milliseconds of the current time of day.",
        "name": "enet.host:service time",
        "params": [
            {
                "descr": "A time-stamp in milliseconds.",
                "name": "number timestamp"
            }
        ],
        "path": "love/enet.host-service_time",
        "syntax": "host:channel_limit(limit)",
        "type": "enet"
    },
    "host:total received data": {
        "descr": "Returns the number of bytes that were received by the given host.",
        "name": "enet.host:total received data",
        "params": [
            {
                "descr": "The total number of bytes received.",
                "name": "number bytes"
            }
        ],
        "path": "love/enet.host-total_received_data",
        "syntax": "host:total_received_data()",
        "type": "enet"
    },
    "host:total sent data": {
        "descr": "Returns the number of bytes that were sent through the given  host.",
        "name": "enet.host:total sent data",
        "params": [
            {
                "descr": "The total number of bytes sent.",
                "name": "number bytes"
            }
        ],
        "path": "love/enet.host-total_sent_data",
        "syntax": "host:total_sent_data()",
        "type": "enet"
    },
    "init": {
        "descr": "Initializes love.filesystem, will be called internally, so should not be used explicitly.",
        "name": "love.filesystem.init",
        "params": [
            {
                "descr": "The name of the application binary, typically love.",
                "name": "string appname"
            }
        ],
        "path": "love/love.filesystem.init",
        "syntax": "love.filesystem.init( appname )",
        "type": "love.filesystem"
    },
    "intersectScissor": {
        "descr": "Sets the scissor to the rectangle created by the intersection of the specified rectangle with the existing scissor. If no scissor is active yet, it behaves like love.graphics.setScissor.",
        "name": "love.graphics.intersectScissor",
        "params": [
            {
                "descr": "The x-coordinate of the upper left corner of the rectangle to intersect with the existing scissor rectangle.",
                "name": "number x"
            },
            {
                "descr": "The y-coordinate of the upper left corner of the rectangle to intersect with the existing scissor rectangle.",
                "name": "number y"
            },
            {
                "descr": "The width of the rectangle to intersect with the existing scissor rectangle.",
                "name": "number width"
            },
            {
                "descr": "The height of the rectangle to intersect with the existing scissor rectangle.",
                "name": "number height"
            }
        ],
        "path": "love/love.graphics.intersectscissor",
        "syntax": "love.graphics.intersectScissor( x, y, width, height )",
        "type": "love.graphics"
    },
    "isActive": {
        "descr": "Gets whether the graphics module is able to be used. If it is not active, love.graphics function and method calls will not work correctly and may cause the program to crash.",
        "name": "love.graphics.isActive",
        "params": [
            {
                "descr": "Whether the graphics module is active and able to be used.",
                "name": "boolean active"
            }
        ],
        "path": "love/love.graphics.isactive",
        "syntax": "active = love.graphics.isActive( )",
        "type": "love.graphics"
    },
    "isCompressed": {
        "descr": "Determines whether a file can be loaded as CompressedImageData.",
        "name": "love.image.isCompressed",
        "params": [
            {
                "descr": "The filename of the potentially compressed image file.",
                "name": "string filename"
            },
            {
                "descr": "Whether the file can be loaded as CompressedImageData or not.",
                "name": "boolean compressed"
            }
        ],
        "path": "love/love.image.iscompressed",
        "syntax": "compressed = love.image.isCompressed( filename )",
        "type": "love.image"
    },
    "isConvex": {
        "descr": "Checks whether a polygon is convex.",
        "name": "love.math.isConvex",
        "params": [
            {
                "descr": "The vertices of the polygon as a table in the form of {x1, y1, x2, y2, x3, y3, ...}.",
                "name": "table vertices"
            },
            {
                "descr": "Whether the given polygon is convex.",
                "name": "boolean convex"
            }
        ],
        "path": "love/love.math.isconvex",
        "syntax": "convex = love.math.isConvex( vertices )",
        "type": "love.math"
    },
    "isCreated": {
        "descr": "Checks if the window has been created.",
        "name": "love.window.isCreated",
        "params": [
            {
                "descr": "True if the window has been created, false otherwise.",
                "name": "boolean created"
            }
        ],
        "path": "love/love.window.iscreated",
        "syntax": "created = love.window.isCreated( )",
        "type": "love.window"
    },
    "isDirectory": {
        "descr": "Check whether something is a directory.",
        "name": "love.filesystem.isDirectory",
        "params": [
            {
                "descr": "The path to a potential directory.",
                "name": "string filename"
            },
            {
                "descr": "True if there is a directory with the specified name. ",
                "name": "boolean isDir"
            }
        ],
        "path": "love/love.filesystem.isdirectory",
        "syntax": "isDir = love.filesystem.isDirectory( filename )",
        "type": "love.filesystem"
    },
    "isDisplaySleepEnabled": {
        "descr": "Gets whether the display is allowed to sleep while the program is running.",
        "name": "love.window.isDisplaySleepEnabled",
        "params": [
            {
                "descr": "True if system display sleep is enabled / allowed, false otherwise.",
                "name": "boolean enabled"
            }
        ],
        "path": "love/love.window.isdisplaysleepenabled",
        "syntax": "enabled = love.window.isDisplaySleepEnabled( )",
        "type": "love.window"
    },
    "isDown": {
        "descr": "Checks whether a certain mouse button is down.",
        "name": "love.mouse.isDown",
        "params": [
            {
                "descr": "The index of a button to check. ",
                "name": "number button"
            },
            {
                "descr": "Additional button numbers to check.",
                "name": "number ..."
            },
            {
                "descr": "True if any specified button is down.",
                "name": "boolean down"
            }
        ],
        "path": "love/love.mouse.isdown",
        "syntax": "down = love.mouse.isDown( button, ... )",
        "type": "love.mouse"
    },
    "isFile": {
        "descr": "Check whether something is a file.",
        "name": "love.filesystem.isFile",
        "params": [
            {
                "descr": "The path to a potential file.",
                "name": "string filename"
            },
            {
                "descr": "True if there is a file with the specified name. ",
                "name": "boolean isFile"
            }
        ],
        "path": "love/love.filesystem.isfile",
        "syntax": "isFile = love.filesystem.isFile( filename )",
        "type": "love.filesystem"
    },
    "isFused": {
        "descr": "Gets whether the game is in fused mode or not.",
        "name": "love.filesystem.isFused",
        "params": [
            {
                "descr": "True if the game is in fused mode, false otherwise.",
                "name": "boolean fused"
            }
        ],
        "path": "love/love.filesystem.isfused",
        "syntax": "fused = love.filesystem.isFused( )",
        "type": "love.filesystem"
    },
    "isGammaCorrect": {
        "descr": "Gets whether gamma-correct rendering is supported and enabled. It can be enabled by setting t.gammacorrect = true in love.conf.",
        "name": "love.graphics.isGammaCorrect",
        "params": [
            {
                "descr": "True if gamma-correct rendering is supported and was enabled in love.conf, false otherwise.",
                "name": "boolean gammacorrect"
            }
        ],
        "path": "love/love.graphics.isgammacorrect",
        "syntax": "gammacorrect = love.graphics.isGammaCorrect( )",
        "type": "love.graphics"
    },
    "isGrabbed": {
        "descr": "Checks if the mouse is grabbed.",
        "name": "love.mouse.isGrabbed",
        "params": [
            {
                "descr": "True if the cursor is grabbed, false if it is not.",
                "name": "boolean grabbed"
            }
        ],
        "path": "love/love.mouse.isgrabbed",
        "syntax": "grabbed = love.mouse.isGrabbed( )",
        "type": "love.mouse"
    },
    "isMaximized": {
        "descr": "Gets whether the Window is currently maximized.",
        "name": "love.window.isMaximized",
        "params": [
            {
                "descr": "True if the window is currently maximized in windowed mode, false otherwise.",
                "name": "boolean maximized"
            }
        ],
        "path": "love/love.window.ismaximized",
        "syntax": "maximized = love.window.isMaximized( )",
        "type": "love.window"
    },
    "isOpen": {
        "descr": "Checks if the window is open.",
        "name": "love.window.isOpen",
        "params": [
            {
                "descr": "True if the window is open, false otherwise.",
                "name": "boolean open"
            }
        ],
        "path": "love/love.window.isopen",
        "syntax": "open = love.window.isOpen( )",
        "type": "love.window"
    },
    "isScancodeDown": {
        "descr": "Checks whether the specified Scancodes are pressed. Not to be confused with love.keypressed or love.keyreleased.",
        "name": "love.keyboard.isScancodeDown",
        "params": [
            {
                "descr": "A Scancode to check.",
                "name": "Scancode scancode"
            },
            {
                "descr": "Additional Scancodes to check.",
                "name": "Scancode ..."
            },
            {
                "descr": "True if any supplied Scancode is down, false if not.",
                "name": "boolean down"
            }
        ],
        "path": "love/love.keyboard.isscancodedown",
        "syntax": "down = love.keyboard.isScancodeDown( scancode, ... )",
        "type": "love.keyboard"
    },
    "isSupported": {
        "descr": "Checks if certain graphics functions can be used.",
        "name": "love.graphics.isSupported",
        "params": [
            {
                "descr": "The graphics feature to check for.",
                "name": "GraphicsFeature supportN"
            },
            {
                "descr": "True if everything is supported, false otherwise.",
                "name": "boolean isSupported"
            }
        ],
        "path": "love/love.graphics.issupported",
        "syntax": "isSupported = love.graphics.isSupported( support1, support2, support3, ... )",
        "type": "love.graphics"
    },
    "isSymlink": {
        "descr": "Gets whether a filepath is actually a symbolic link.",
        "name": "love.filesystem.isSymlink",
        "params": [
            {
                "descr": "The file or directory path to check.",
                "name": "string path"
            },
            {
                "descr": "True if the path is a symbolic link, false otherwise.",
                "name": "boolean symlink"
            }
        ],
        "path": "love/love.filesystem.issymlink",
        "syntax": "symlink = love.filesystem.isSymlink( path )",
        "type": "love.filesystem"
    },
    "isVisible": {
        "descr": "Checks if the game window is visible.",
        "name": "love.window.isVisible",
        "params": [
            {
                "descr": "True if the window is visible or false if not.",
                "name": "boolean visible"
            }
        ],
        "path": "love/love.window.isvisible",
        "syntax": "visible = love.window.isVisible( )",
        "type": "love.window"
    },
    "isWireframe": {
        "descr": "Gets whether wireframe mode is used when drawing.",
        "name": "love.graphics.isWireframe",
        "params": [
            {
                "descr": "True if wireframe lines are used when drawing, false if it's not.",
                "name": "boolean wireframe"
            }
        ],
        "path": "love/love.graphics.iswireframe",
        "syntax": "wireframe = love.graphics.isWireframe( )",
        "type": "love.graphics"
    },
    "joystickadded": {
        "descr": "Called when a Joystick is connected.",
        "name": "love.joystickadded",
        "params": [
            {
                "descr": "The newly connected Joystick object.",
                "name": "Joystick joystick"
            }
        ],
        "path": "love/love.joystickadded",
        "syntax": "love.joystickadded( joystick )",
        "type": "love"
    },
    "joystickaxis": {
        "descr": "Called when a joystick axis moves.",
        "name": "love.joystickaxis",
        "params": [
            {
                "descr": "The joystick object.",
                "name": "Joystick joystick"
            },
            {
                "descr": "The axis number.",
                "name": "number axis"
            },
            {
                "descr": "The new axis value.",
                "name": "number value"
            }
        ],
        "path": "love/love.joystickaxis",
        "syntax": "love.joystickaxis( joystick, axis, value )",
        "type": "love"
    },
    "joystickhat": {
        "descr": "Called when a joystick hat direction changes.",
        "name": "love.joystickhat",
        "params": [
            {
                "descr": "The joystick object.",
                "name": "Joystick joystick"
            },
            {
                "descr": "The hat number.",
                "name": "number hat"
            },
            {
                "descr": "The new hat direction.",
                "name": "JoystickHat direction"
            }
        ],
        "path": "love/love.joystickhat",
        "syntax": "love.joystickhat( joystick, hat, direction )",
        "type": "love"
    },
    "joystickpressed": {
        "descr": "Called when a joystick button is pressed.",
        "name": "love.joystickpressed",
        "params": [
            {
                "descr": "The joystick object.",
                "name": "Joystick joystick"
            },
            {
                "descr": "The button number.",
                "name": "number button"
            }
        ],
        "path": "love/love.joystickpressed",
        "syntax": "love.joystickpressed( joystick, button )",
        "type": "love"
    },
    "joystickreleased": {
        "descr": "Called when a joystick button is released.",
        "name": "love.joystickreleased",
        "params": [
            {
                "descr": "The joystick object.",
                "name": "Joystick joystick"
            },
            {
                "descr": "The button number.",
                "name": "number button"
            }
        ],
        "path": "love/love.joystickreleased",
        "syntax": "love.joystickreleased( joystick, button )",
        "type": "love"
    },
    "joystickremoved": {
        "descr": "Called when a Joystick is disconnected.",
        "name": "love.joystickremoved",
        "params": [
            {
                "descr": "The now-disconnected Joystick object.",
                "name": "Joystick joystick"
            }
        ],
        "path": "love/love.joystickremoved",
        "syntax": "love.joystickremoved( joystick )",
        "type": "love"
    },
    "keypressed": {
        "descr": "Callback function triggered when a key is pressed.",
        "name": "love.keypressed",
        "params": [
            {
                "descr": "Character of the pressed key.",
                "name": "KeyConstant key"
            },
            {
                "descr": "The scancode representing the pressed key.",
                "name": "Scancode scancode"
            },
            {
                "descr": "Whether this keypress event is a repeat. ",
                "name": "boolean isrepeat"
            }
        ],
        "path": "love/love.keypressed",
        "syntax": "love.keypressed( key, scancode, isrepeat )",
        "type": "love"
    },
    "keyreleased": {
        "descr": "Callback function triggered when a keyboard key is released.",
        "name": "love.keyreleased",
        "params": [
            {
                "descr": "Character of the released key.",
                "name": "KeyConstant key"
            }
        ],
        "path": "love/love.keyreleased",
        "syntax": "love.keyreleased( key )",
        "type": "love"
    },
    "line": {
        "descr": "Draws lines between points.",
        "name": "love.graphics.line",
        "params": [
            {
                "descr": "The position of first point on the x-axis.",
                "name": "number x1"
            },
            {
                "descr": "The position of first point on the y-axis.",
                "name": "number y1"
            },
            {
                "descr": "The position of second point on the x-axis.",
                "name": "number x2"
            },
            {
                "descr": "The position of second point on the y-axis.",
                "name": "number y2"
            },
            {
                "descr": "You can continue passing point positions to draw a polyline.",
                "name": "number ..."
            }
        ],
        "path": "love/love.graphics.line",
        "syntax": "love.graphics.line( x1, y1, x2, y2, ... )",
        "type": "love.graphics"
    },
    "linearToGamma": {
        "descr": "Converts a color from linear-space (RGB) to gamma-space (sRGB). This is useful when storing linear RGB color values in an image, because the linear RGB color space has less precision than sRGB for dark colors, which can result in noticeable color banding when drawing.",
        "name": "love.math.linearToGamma",
        "params": [
            {
                "descr": "The red channel of the linear RGB color to convert.",
                "name": "number lr"
            },
            {
                "descr": "The green channel of the linear RGB color to convert.",
                "name": "number lg"
            },
            {
                "descr": "The blue channel of the linear RGB color to convert.",
                "name": "number lb"
            },
            {
                "descr": "The red channel of the converted color in gamma sRGB space.",
                "name": "number cr"
            },
            {
                "descr": "The green channel of the converted color in gamma sRGB space.",
                "name": "number cg"
            },
            {
                "descr": "The blue channel of the converted color in gamma sRGB space.",
                "name": "number cb"
            }
        ],
        "path": "love/love.math.lineartogamma",
        "syntax": "cr, cg, cb = love.math.linearToGamma( lr, lg, lb )",
        "type": "love.math"
    },
    "lines": {
        "descr": "Iterate over the lines in a file.",
        "name": "love.filesystem.lines",
        "params": [
            {
                "descr": "The name (and path) of the file",
                "name": "string name"
            },
            {
                "descr": "A function that iterates over all the lines in the file",
                "name": "function iterator"
            }
        ],
        "path": "love/love.filesystem.lines",
        "syntax": "iterator = love.filesystem.lines( name )",
        "type": "love.filesystem"
    },
    "linked version": {
        "descr": "Returns the included ENet's version as a string.",
        "name": "enet.linked version",
        "params": [
            {
                "descr": "ENet's version.",
                "name": "string version"
            }
        ],
        "path": "love/enet.linked_version",
        "syntax": "version = enet.linked_version()",
        "type": "enet"
    },
    "load": {
        "descr": "This function is called exactly once at the beginning of the game.",
        "name": "love.load",
        "params": [
            {
                "descr": "Command line arguments given to the game.",
                "name": "table arg"
            }
        ],
        "path": "love/love.load",
        "syntax": "love.load( arg )",
        "type": "love"
    },
    "loadGamepadMappings": {
        "descr": "Loads a gamepad mappings string or file created with love.joystick.saveGamepadMappings.",
        "name": "love.joystick.loadGamepadMappings",
        "params": [
            {
                "descr": "The filename to load the mappings string from.",
                "name": "string filename"
            }
        ],
        "path": "love/love.joystick.loadgamepadmappings",
        "syntax": "love.joystick.loadGamepadMappings( filename )",
        "type": "love.joystick"
    },
    "love.audio.getDistanceModel": {
        "descr": "Returns the distance attenuation model.",
        "name": "love.audio.getDistanceModel",
        "params": [
            {
                "descr": "The current distance model. The default is 'inverseclamped'.",
                "name": "DistanceModel model"
            }
        ],
        "path": "love/love.audio.getdistancemodel",
        "syntax": "model = love.audio.getDistanceModel( )",
        "type": "love.audio"
    },
    "love.audio.getDopplerScale": {
        "descr": "Gets the current global scale factor for velocity-based doppler effects.",
        "name": "love.audio.getDopplerScale",
        "params": [
            {
                "descr": "The current doppler scale factor.",
                "name": "number scale"
            }
        ],
        "path": "love/love.audio.getdopplerscale",
        "syntax": "scale = love.audio.getDopplerScale( )",
        "type": "love.audio"
    },
    "love.audio.getNumSources": {
        "descr": "Gets the current number of simultaneously playing sources.",
        "name": "love.audio.getNumSources",
        "params": [
            {
                "descr": "The current number of simultaneously playing sources.",
                "name": "number numSources"
            }
        ],
        "path": "love/love.audio.getnumsources",
        "syntax": "numSources = love.audio.getNumSources( )",
        "type": "love.audio"
    },
    "love.audio.getOrientation": {
        "descr": "Returns the orientation of the listener.",
        "name": "love.audio.getOrientation",
        "params": [
            {
                "descr": "Forward vector of the listener orientation.",
                "name": "number fx, fy, fz"
            },
            {
                "descr": "Up vector of the listener orientation.",
                "name": "number ux, uy, uz"
            }
        ],
        "path": "love/love.audio.getorientation",
        "syntax": "fx, fy, fz, ux, uy, uz = love.audio.getOrientation( )",
        "type": "love.audio"
    },
    "love.audio.getPosition": {
        "descr": "Returns the position of the listener. Please note that positional audio only works for mono (i.e. non-stereo) sources.",
        "name": "love.audio.getPosition",
        "params": [
            {
                "descr": "The X position of the listener.",
                "name": "number x"
            },
            {
                "descr": "The Y position of the listener.",
                "name": "number y"
            },
            {
                "descr": "The Z position of the listener.",
                "name": "number z"
            }
        ],
        "path": "love/love.audio.getposition",
        "syntax": "x, y, z = love.audio.getPosition( )",
        "type": "love.audio"
    },
    "love.audio.getSourceCount": {
        "descr": "Gets the current number of simultaneously playing sources.",
        "name": "love.audio.getSourceCount",
        "params": [
            {
                "descr": "The current number of simultaneously playing sources.",
                "name": "number numSources"
            }
        ],
        "path": "love/love.audio.getsourcecount",
        "syntax": "numSources = love.audio.getSourceCount( )",
        "type": "love.audio"
    },
    "love.audio.getVelocity": {
        "descr": "Returns the velocity of the listener.",
        "name": "love.audio.getVelocity",
        "params": [
            {
                "descr": "The X velocity of the listener.",
                "name": "number x"
            },
            {
                "descr": "The Y velocity of the listener.",
                "name": "number y"
            },
            {
                "descr": "The Z velocity of the listener.",
                "name": "number z"
            }
        ],
        "path": "love/love.audio.getvelocity",
        "syntax": "x, y, z = love.audio.getVelocity( )",
        "type": "love.audio"
    },
    "love.audio.getVolume": {
        "descr": "Returns the master volume.",
        "name": "love.audio.getVolume",
        "params": [
            {
                "descr": "The current master volume",
                "name": "number volume"
            }
        ],
        "path": "love/love.audio.getvolume",
        "syntax": "volume = love.audio.getVolume( )",
        "type": "love.audio"
    },
    "love.audio.newSource": {
        "descr": "Creates a new Source from a filepath, File, Decoder or SoundData. Sources created from SoundData are always static.",
        "name": "love.audio.newSource",
        "params": [
            {
                "descr": "The filepath to the audio file.",
                "name": "string filename"
            },
            {
                "descr": "Streaming or static source.",
                "name": "SourceType type (\"stream\")"
            },
            {
                "descr": "A new Source that can play the specified audio.",
                "name": "Source source"
            }
        ],
        "path": "love/love.audio.newsource",
        "syntax": "source = love.audio.newSource( filename, type )",
        "type": "love.audio"
    },
    "love.audio.pause": {
        "descr": "Pauses currently played Sources.",
        "name": "love.audio.pause",
        "params": [],
        "path": "love/love.audio.pause",
        "syntax": "love.audio.pause( )",
        "type": "love.audio"
    },
    "love.audio.play": {
        "descr": "Plays the specified Source.",
        "name": "love.audio.play",
        "params": [
            {
                "descr": "The Source to play.",
                "name": "Source source"
            }
        ],
        "path": "love/love.audio.play",
        "syntax": "love.audio.play( source )",
        "type": "love.audio"
    },
    "love.audio.resume": {
        "descr": "Resumes all audio.",
        "name": "love.audio.resume",
        "params": [],
        "path": "love/love.audio.resume",
        "syntax": "love.audio.resume( )",
        "type": "love.audio"
    },
    "love.audio.rewind": {
        "descr": "Rewinds all playing audio.",
        "name": "love.audio.rewind",
        "params": [],
        "path": "love/love.audio.rewind",
        "syntax": "love.audio.rewind( )",
        "type": "love.audio"
    },
    "love.audio.setDistanceModel": {
        "descr": "Sets the distance attenuation model.",
        "name": "love.audio.setDistanceModel",
        "params": [
            {
                "descr": "The new distance model.",
                "name": "DistanceModel model"
            }
        ],
        "path": "love/love.audio.setdistancemodel",
        "syntax": "love.audio.setDistanceModel( model )",
        "type": "love.audio"
    },
    "love.audio.setDopplerScale": {
        "descr": "Sets a global scale factor for velocity-based doppler effects. The default scale value is 1.",
        "name": "love.audio.setDopplerScale",
        "params": [
            {
                "descr": "The new doppler scale factor. The scale must be greater than 0.",
                "name": "number scale"
            }
        ],
        "path": "love/love.audio.setdopplerscale",
        "syntax": "love.audio.setDopplerScale( scale )",
        "type": "love.audio"
    },
    "love.audio.setOrientation": {
        "descr": "Sets the orientation of the listener.",
        "name": "love.audio.setOrientation",
        "params": [
            {
                "descr": "Forward vector of the listener orientation.",
                "name": "number fx, fy, fz"
            },
            {
                "descr": "Up vector of the listener orientation.",
                "name": "number ux, uy, uz"
            }
        ],
        "path": "love/love.audio.setorientation",
        "syntax": "love.audio.setOrientation( fx, fy, fz, ux, uy, uz )",
        "type": "love.audio"
    },
    "love.audio.setPosition": {
        "descr": "Sets the position of the listener, which determines how sounds play.",
        "name": "love.audio.setPosition",
        "params": [
            {
                "descr": "The x position of the listener.",
                "name": "number x"
            },
            {
                "descr": "The y position of the listener.",
                "name": "number y"
            },
            {
                "descr": "The z position of the listener.",
                "name": "number z"
            }
        ],
        "path": "love/love.audio.setposition",
        "syntax": "love.audio.setPosition( x, y, z )",
        "type": "love.audio"
    },
    "love.audio.setVelocity": {
        "descr": "Sets the velocity of the listener.",
        "name": "love.audio.setVelocity",
        "params": [
            {
                "descr": "The X velocity of the listener.",
                "name": "number x"
            },
            {
                "descr": "The Y velocity of the listener.",
                "name": "number y"
            },
            {
                "descr": "The Z velocity of the listener.",
                "name": "number z"
            }
        ],
        "path": "love/love.audio.setvelocity",
        "syntax": "love.audio.setVelocity( x, y, z )",
        "type": "love.audio"
    },
    "love.audio.setVolume": {
        "descr": "Sets the master volume.",
        "name": "love.audio.setVolume",
        "params": [
            {
                "descr": "1.0 is max and 0.0 is off.",
                "name": "number volume"
            }
        ],
        "path": "love/love.audio.setvolume",
        "syntax": "love.audio.setVolume( volume )",
        "type": "love.audio"
    },
    "love.audio.stop": {
        "descr": "Stops currently played sources.",
        "name": "love.audio.stop",
        "params": [],
        "path": "love/love.audio.stop",
        "syntax": "love.audio.stop( )",
        "type": "love.audio"
    },
    "love.directorydropped": {
        "descr": "Callback function triggered when a directory is dragged and dropped onto the window.",
        "name": "love.directorydropped",
        "params": [
            {
                "descr": "The full platform-dependent path to the directory. ",
                "name": "string path"
            }
        ],
        "path": "love/love.directorydropped",
        "syntax": "love.directorydropped( path )",
        "type": "love"
    },
    "love.draw": {
        "descr": "Callback function used to draw on the screen every frame.",
        "name": "love.draw",
        "params": [],
        "path": "love/love.draw",
        "syntax": "love.draw( )",
        "type": "love"
    },
    "love.errhand": {
        "descr": "The error handler, used to display error messages.",
        "name": "love.errhand",
        "params": [
            {
                "descr": "The error message.",
                "name": "string msg"
            }
        ],
        "path": "love/love.errhand",
        "syntax": "love.errhand( msg )",
        "type": "love"
    },
    "love.event.clear": {
        "descr": "Clears the event queue.",
        "name": "love.event.clear",
        "params": [],
        "path": "love/love.event.clear",
        "syntax": "love.event.clear()",
        "type": "love.event"
    },
    "love.event.poll": {
        "descr": "Returns an iterator for messages in the event queue.",
        "name": "love.event.poll",
        "params": [
            {
                "descr": "Iterator function usable in a for loop.",
                "name": "function i"
            }
        ],
        "path": "love/love.event.poll",
        "syntax": "i = love.event.poll( )",
        "type": "love.event"
    },
    "love.event.pump": {
        "descr": "Pump events into the event queue. This is a low-level function, and is usually not called by the user, but by love.run. Note that this does need to be called for any OS to think you're still running, and if you want to handle OS-generated events at all (think callbacks).",
        "name": "love.event.pump",
        "params": [],
        "path": "love/love.event.pump",
        "syntax": "love.event.pump( )",
        "type": "love.event"
    },
    "love.event.push": {
        "descr": "Adds an event to the event queue.",
        "name": "love.event.push",
        "params": [
            {
                "descr": "The name of the event.",
                "name": "Event e"
            },
            {
                "descr": "First event argument.",
                "name": "mixed a (nil)"
            },
            {
                "descr": "Second event argument.",
                "name": "mixed b (nil)"
            },
            {
                "descr": "Third event argument.",
                "name": "mixed c (nil)"
            },
            {
                "descr": "Fourth event argument.",
                "name": "mixed d (nil) Available since 0.8.0"
            }
        ],
        "path": "love/love.event.push",
        "syntax": "love.event.push( e, a, b, c, d )",
        "type": "love.event"
    },
    "love.event.quit": {
        "descr": "Adds the quit event to the queue.",
        "name": "love.event.quit",
        "params": [],
        "path": "love/love.event.quit",
        "syntax": "love.event.quit( )",
        "type": "love.event"
    },
    "love.event.wait": {
        "descr": "Like love.event.poll(), but blocks until there is an event in the queue.",
        "name": "love.event.wait",
        "params": [
            {
                "descr": "The type of event.",
                "name": "Event e"
            },
            {
                "descr": "First event argument.",
                "name": "mixed a"
            },
            {
                "descr": "Second event argument.",
                "name": "mixed b"
            },
            {
                "descr": "Third event argument.",
                "name": "mixed c"
            },
            {
                "descr": "Fourth event argument.",
                "name": "mixed d"
            }
        ],
        "path": "love/love.event.wait",
        "syntax": "e, a, b, c, d = love.event.wait( )",
        "type": "love.event"
    },
    "love.filedropped": {
        "descr": "Callback function triggered when a file is dragged and dropped onto the window.",
        "name": "love.filedropped",
        "params": [
            {
                "descr": "The unopened File object representing the file that was dropped.",
                "name": "File file"
            }
        ],
        "path": "love/love.filedropped",
        "syntax": "love.filedropped( file )",
        "type": "love"
    },
    "love.filesystem.append": {
        "descr": "Append data to an existing file.",
        "name": "love.filesystem.append",
        "params": [
            {
                "descr": "The name (and path) of the file.",
                "name": "string name"
            },
            {
                "descr": "The string data to append to the file.",
                "name": "string data"
            },
            {
                "descr": "How many bytes to write.",
                "name": "number size (all)"
            },
            {
                "descr": "True if the operation was successful, or nil if there was an error.",
                "name": "boolean success"
            },
            {
                "descr": "The error message on failure.",
                "name": "string errormsg"
            }
        ],
        "path": "love/love.filesystem.append",
        "syntax": "success, errormsg = love.filesystem.append( name, data, size )",
        "type": "love.filesystem"
    },
    "love.filesystem.areSymlinksEnabled": {
        "descr": "Gets whether love.filesystem follows symbolic links.",
        "name": "love.filesystem.areSymlinksEnabled",
        "params": [
            {
                "descr": "Whether love.filesystem follows symbolic links.",
                "name": "boolean enable"
            }
        ],
        "path": "love/love.filesystem.aresymlinksenabled",
        "syntax": "enabled = love.filesystem.areSymlinksEnabled( )",
        "type": "love.filesystem"
    },
    "love.filesystem.createDirectory": {
        "descr": "Recursively creates a directory.",
        "name": "love.filesystem.createDirectory",
        "params": [
            {
                "descr": "The directory to create.",
                "name": "string name"
            },
            {
                "descr": "True if the directory was created, false if not.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.filesystem.createdirectory",
        "syntax": "success = love.filesystem.createDirectory( name )",
        "type": "love.filesystem"
    },
    "love.filesystem.enumerate": {
        "descr": "Returns a table with the names of files and subdirectories in the specified path. The table is not sorted in any way; the order is undefined.",
        "name": "love.filesystem.enumerate",
        "params": [
            {
                "descr": "The directory.",
                "name": "string dir"
            },
            {
                "descr": "A sequence with the names of all files and subdirectories as strings.",
                "name": "table files"
            }
        ],
        "path": "love/love.filesystem.enumerate",
        "syntax": "files = love.filesystem.enumerate( dir )",
        "type": "love.filesystem"
    },
    "love.filesystem.exists": {
        "descr": "Check whether a file or directory exists.",
        "name": "love.filesystem.exists",
        "params": [
            {
                "descr": "The path to a potential file or directory.",
                "name": "string filename"
            },
            {
                "descr": "True if there is a file or directory with the specified name. ",
                "name": "boolean exists"
            }
        ],
        "path": "love/love.filesystem.exists",
        "syntax": "exists = love.filesystem.exists( filename )",
        "type": "love.filesystem"
    },
    "love.filesystem.getAppdataDirectory": {
        "descr": "Returns the application data directory (could be the same as getUserDirectory)",
        "name": "love.filesystem.getAppdataDirectory",
        "params": [
            {
                "descr": "The path of the application data directory",
                "name": "string path"
            }
        ],
        "path": "love/love.filesystem.getappdatadirectory",
        "syntax": "path = love.filesystem.getAppdataDirectory( )",
        "type": "love.filesystem"
    },
    "love.filesystem.getDirectoryItems": {
        "descr": "Returns a table with the names of files and subdirectories in the specified path. The table is not sorted in any way; the order is undefined.",
        "name": "love.filesystem.getDirectoryItems",
        "params": [
            {
                "descr": "The directory.",
                "name": "string dir"
            },
            {
                "descr": "A sequence with the names of all files and subdirectories as strings.",
                "name": "table files"
            }
        ],
        "path": "love/love.filesystem.getdirectoryitems",
        "syntax": "files = love.filesystem.getDirectoryItems( dir )",
        "type": "love.filesystem"
    },
    "love.filesystem.getIdentity": {
        "descr": "Gets the write directory name for your game. Note that this only returns the name of the folder to store your files in, not the full path.",
        "name": "love.filesystem.getIdentity",
        "params": [
            {
                "descr": "The identity that is used as write directory.",
                "name": "string name"
            }
        ],
        "path": "love/love.filesystem.getidentity",
        "syntax": "name = love.filesystem.getIdentity( )",
        "type": "love.filesystem"
    },
    "love.filesystem.getLastModified": {
        "descr": "Gets the last modification time of a file.",
        "name": "love.filesystem.getLastModified",
        "params": [
            {
                "descr": "The path and name to a file.",
                "name": "string filename"
            },
            {
                "descr": "The last modification time in seconds since the unix epoch or nil on failure.",
                "name": "number modtime"
            },
            {
                "descr": "The error message on failure.",
                "name": "string errormsg"
            }
        ],
        "path": "love/love.filesystem.getlastmodified",
        "syntax": "modtime, errormsg = love.filesystem.getLastModified( filename )",
        "type": "love.filesystem"
    },
    "love.filesystem.getRealDirectory": {
        "descr": "Gets the platform-specific absolute path of the directory containing a filepath.",
        "name": "love.filesystem.getRealDirectory",
        "params": [
            {
                "descr": "The filepath to get the directory of.",
                "name": "string filepath"
            },
            {
                "descr": "The platform-specific full path of the directory containing the filepath.",
                "name": "string realdir"
            }
        ],
        "path": "love/love.filesystem.getrealdirectory",
        "syntax": "realdir = love.filesystem.getRealDirectory( filepath )",
        "type": "love.filesystem"
    },
    "love.filesystem.getRequirePath": {
        "descr": "Gets the filesystem paths that will be searched when require is called.",
        "name": "love.filesystem.getRequirePath",
        "params": [
            {
                "descr": "The paths that the require function will check in love's filesystem.",
                "name": "string paths"
            }
        ],
        "path": "love/love.filesystem.getrequirepath",
        "syntax": "paths = love.filesystem.getRequirePath( )",
        "type": "love.filesystem"
    },
    "love.filesystem.getSaveDirectory": {
        "descr": "Gets the full path to the designated save directory. This can be useful if you want to use the standard io library (or something else) to read or write in the save directory.",
        "name": "love.filesystem.getSaveDirectory",
        "params": [
            {
                "descr": "The absolute path to the save directory.",
                "name": "string dir"
            }
        ],
        "path": "love/love.filesystem.getsavedirectory",
        "syntax": "dir = love.filesystem.getSaveDirectory( )",
        "type": "love.filesystem"
    },
    "love.filesystem.getSize": {
        "descr": "Gets the size in bytes of a file.",
        "name": "love.filesystem.getSize",
        "params": [
            {
                "descr": "The path and name to a file.",
                "name": "string filename"
            },
            {
                "descr": "The size in bytes of the file, or nil on failure.",
                "name": "number size"
            },
            {
                "descr": "The error message on failure.",
                "name": "string errormsg (nil)"
            }
        ],
        "path": "love/love.filesystem.getsize",
        "syntax": "size, errormsg = love.filesystem.getSize( filename )",
        "type": "love.filesystem"
    },
    "love.filesystem.getSource": {
        "descr": "Returns the full path to the the .love file or directory. If the game is fused to the LÖVE executable, then the executable is returned.",
        "name": "love.filesystem.getSource",
        "params": [
            {
                "descr": "The full platform-dependent path of the .love file or directory.",
                "name": "string path"
            }
        ],
        "path": "love/love.filesystem.getsource",
        "syntax": "path = love.filesystem.getSource( )",
        "type": "love.filesystem"
    },
    "love.filesystem.getSourceBaseDirectory": {
        "descr": "Returns the full path to the directory containing the .love file. If the game is fused to the LÖVE executable, then the directory containing the executable is returned.",
        "name": "love.filesystem.getSourceBaseDirectory",
        "params": [
            {
                "descr": "The full platform-dependent path of the directory containing the .love file.",
                "name": "string path"
            }
        ],
        "path": "love/love.filesystem.getsourcebasedirectory",
        "syntax": "path = love.filesystem.getSourceBaseDirectory( )",
        "type": "love.filesystem"
    },
    "love.filesystem.getUserDirectory": {
        "descr": "Returns the path of the user's directory",
        "name": "love.filesystem.getUserDirectory",
        "params": [
            {
                "descr": "The path of the user's directory",
                "name": "string path"
            }
        ],
        "path": "love/love.filesystem.getuserdirectory",
        "syntax": "path = love.filesystem.getUserDirectory( )",
        "type": "love.filesystem"
    },
    "love.filesystem.getWorkingDirectory": {
        "descr": "Gets the current working directory.",
        "name": "love.filesystem.getWorkingDirectory",
        "params": [
            {
                "descr": "The current working directory.",
                "name": "string cwd"
            }
        ],
        "path": "love/love.filesystem.getworkingdirectory",
        "syntax": "cwd = love.filesystem.getWorkingDirectory( )",
        "type": "love.filesystem"
    },
    "love.filesystem.init": {
        "descr": "Initializes love.filesystem, will be called internally, so should not be used explicitly.",
        "name": "love.filesystem.init",
        "params": [
            {
                "descr": "The name of the application binary, typically love.",
                "name": "string appname"
            }
        ],
        "path": "love/love.filesystem.init",
        "syntax": "love.filesystem.init( appname )",
        "type": "love.filesystem"
    },
    "love.filesystem.isDirectory": {
        "descr": "Check whether something is a directory.",
        "name": "love.filesystem.isDirectory",
        "params": [
            {
                "descr": "The path to a potential directory.",
                "name": "string filename"
            },
            {
                "descr": "True if there is a directory with the specified name. ",
                "name": "boolean isDir"
            }
        ],
        "path": "love/love.filesystem.isdirectory",
        "syntax": "isDir = love.filesystem.isDirectory( filename )",
        "type": "love.filesystem"
    },
    "love.filesystem.isFile": {
        "descr": "Check whether something is a file.",
        "name": "love.filesystem.isFile",
        "params": [
            {
                "descr": "The path to a potential file.",
                "name": "string filename"
            },
            {
                "descr": "True if there is a file with the specified name. ",
                "name": "boolean isFile"
            }
        ],
        "path": "love/love.filesystem.isfile",
        "syntax": "isFile = love.filesystem.isFile( filename )",
        "type": "love.filesystem"
    },
    "love.filesystem.isFused": {
        "descr": "Gets whether the game is in fused mode or not.",
        "name": "love.filesystem.isFused",
        "params": [
            {
                "descr": "True if the game is in fused mode, false otherwise.",
                "name": "boolean fused"
            }
        ],
        "path": "love/love.filesystem.isfused",
        "syntax": "fused = love.filesystem.isFused( )",
        "type": "love.filesystem"
    },
    "love.filesystem.isSymlink": {
        "descr": "Gets whether a filepath is actually a symbolic link.",
        "name": "love.filesystem.isSymlink",
        "params": [
            {
                "descr": "The file or directory path to check.",
                "name": "string path"
            },
            {
                "descr": "True if the path is a symbolic link, false otherwise.",
                "name": "boolean symlink"
            }
        ],
        "path": "love/love.filesystem.issymlink",
        "syntax": "symlink = love.filesystem.isSymlink( path )",
        "type": "love.filesystem"
    },
    "love.filesystem.lines": {
        "descr": "Iterate over the lines in a file.",
        "name": "love.filesystem.lines",
        "params": [
            {
                "descr": "The name (and path) of the file",
                "name": "string name"
            },
            {
                "descr": "A function that iterates over all the lines in the file",
                "name": "function iterator"
            }
        ],
        "path": "love/love.filesystem.lines",
        "syntax": "iterator = love.filesystem.lines( name )",
        "type": "love.filesystem"
    },
    "love.filesystem.load": {
        "descr": "Loads a Lua file (but does not run it).",
        "name": "love.filesystem.load",
        "params": [
            {
                "descr": "The name (and path) of the file.",
                "name": "string name"
            },
            {
                "descr": "The loaded chunk.",
                "name": "function chunk"
            },
            {
                "descr": "The error message if file could not be opened.",
                "name": "string errormsg (nil)"
            }
        ],
        "path": "love/love.filesystem.load",
        "syntax": "chunk, errormsg = love.filesystem.load( name )",
        "type": "love.filesystem"
    },
    "love.filesystem.mkdir": {
        "descr": "Recursively creates a directory.",
        "name": "love.filesystem.mkdir",
        "params": [
            {
                "descr": "The directory to create.",
                "name": "string name"
            },
            {
                "descr": "True if the directory was created, false if not.",
                "name": "boolean ok"
            }
        ],
        "path": "love/love.filesystem.mkdir",
        "syntax": "ok = love.filesystem.mkdir( name )",
        "type": "love.filesystem"
    },
    "love.filesystem.mount": {
        "descr": "Mounts a zip file or folder in the game's save directory for reading.",
        "name": "love.filesystem.mount",
        "params": [
            {
                "descr": "The folder or zip file in the game's save directory to mount.",
                "name": "string archive"
            },
            {
                "descr": "The new path the archive will be mounted to.",
                "name": "string mountpoint"
            },
            {
                "descr": "True if the archive was successfully mounted, false otherwise.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.filesystem.mount",
        "syntax": "success = love.filesystem.mount( archive, mountpoint )",
        "type": "love.filesystem"
    },
    "love.filesystem.newFile": {
        "descr": "Creates a new File object. It needs to be opened before it can be accessed.",
        "name": "love.filesystem.newFile",
        "params": [
            {
                "descr": "The filename of the file.",
                "name": "string filename"
            },
            {
                "descr": "The new File object.",
                "name": "File file"
            }
        ],
        "path": "love/love.filesystem.newfile",
        "syntax": "file = love.filesystem.newFile( filename )",
        "type": "love.filesystem"
    },
    "love.filesystem.newFileData": {
        "descr": "Creates a new FileData object.",
        "name": "love.filesystem.newFileData",
        "params": [
            {
                "descr": "The contents of the file.",
                "name": "string contents"
            },
            {
                "descr": "The name of the file.",
                "name": "string name"
            },
            {
                "descr": "The method to use when decoding the contents.",
                "name": "FileDecoder decoder (\"file\")"
            },
            {
                "descr": "Your new FileData.",
                "name": "FileData data"
            }
        ],
        "path": "love/love.filesystem.newfiledata",
        "syntax": "data = love.filesystem.newFileData( contents, name, decoder )",
        "type": "love.filesystem"
    },
    "love.filesystem.read": {
        "descr": "Read the contents of a file",
        "name": "love.filesystem.read",
        "params": [
            {
                "descr": "The name (and path) of the file",
                "name": "string name"
            },
            {
                "descr": "How many bytes to read",
                "name": "number size (all)"
            },
            {
                "descr": "The file contents",
                "name": "string contents"
            },
            {
                "descr": "How many bytes have been read",
                "name": "number size"
            }
        ],
        "path": "love/love.filesystem.read",
        "syntax": "contents, size = love.filesystem.read( name, size )",
        "type": "love.filesystem"
    },
    "love.filesystem.remove": {
        "descr": "Removes a file or empty directory.",
        "name": "love.filesystem.remove",
        "params": [
            {
                "descr": "The file or directory to remove.",
                "name": "string name"
            },
            {
                "descr": "True if the file/directory was removed, false otherwise.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.filesystem.remove",
        "syntax": "success = love.filesystem.remove( name )",
        "type": "love.filesystem"
    },
    "love.filesystem.setIdentity": {
        "descr": "Sets the write directory for your game. Note that you can only set the name of the folder to store your files in, not the location.",
        "name": "love.filesystem.setIdentity",
        "params": [
            {
                "descr": "The new identity that will be used as write directory.",
                "name": "string name"
            }
        ],
        "path": "love/love.filesystem.setidentity",
        "syntax": "love.filesystem.setIdentity( name )",
        "type": "love.filesystem"
    },
    "love.filesystem.setRequirePath": {
        "descr": "Sets the filesystem paths that will be searched when require is called.",
        "name": "love.filesystem.setRequirePath",
        "params": [
            {
                "descr": "The paths that the require function will check in love's filesystem.",
                "name": "string paths"
            }
        ],
        "path": "love/love.filesystem.setrequirepath",
        "syntax": "love.filesystem.setRequirePath( paths )",
        "type": "love.filesystem"
    },
    "love.filesystem.setSource": {
        "descr": "Sets the source of the game, where the code is present. This function can only be called once, and is normally automatically done by LÖVE.",
        "name": "love.filesystem.setSource",
        "params": [
            {
                "descr": "Absolute path to the game's source folder.",
                "name": "string path"
            }
        ],
        "path": "love/love.filesystem.setsource",
        "syntax": "love.filesystem.setSource( path )",
        "type": "love.filesystem"
    },
    "love.filesystem.setSymlinksEnabled": {
        "descr": "Sets whether love.filesystem follows symbolic links. It is enabled by default in version 0.10.0 and newer, and disabled by default in 0.9.2.",
        "name": "love.filesystem.setSymlinksEnabled",
        "params": [
            {
                "descr": "Whether love.filesystem should follow symbolic links.",
                "name": "boolean enable"
            }
        ],
        "path": "love/love.filesystem.setsymlinksenabled",
        "syntax": "love.filesystem.setSymlinksEnabled( enable )",
        "type": "love.filesystem"
    },
    "love.filesystem.unmount": {
        "descr": "Unmounts a zip file or folder previously mounted for reading with love.filesystem.mount.",
        "name": "love.filesystem.unmount",
        "params": [
            {
                "descr": "The folder or zip file in the game's save directory which is currently mounted.",
                "name": "string archive"
            },
            {
                "descr": "True if the archive was successfully unmounted, false otherwise.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.filesystem.unmount",
        "syntax": "success = love.filesystem.unmount( archive )",
        "type": "love.filesystem"
    },
    "love.filesystem.write": {
        "descr": "Write data to a file in the save directory. If the file existed already, it will be completely replaced by the new contents.",
        "name": "love.filesystem.write",
        "params": [
            {
                "descr": "The name (and path) of the file.",
                "name": "string name"
            },
            {
                "descr": "The string data to write to the file.",
                "name": "string data"
            },
            {
                "descr": "How many bytes to write.",
                "name": "number size (all)"
            },
            {
                "descr": "If the operation was successful.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.filesystem.write",
        "syntax": "success = love.filesystem.write( name, data, size )",
        "type": "love.filesystem"
    },
    "love.focus": {
        "descr": "Callback function triggered when window receives or loses focus.",
        "name": "love.focus",
        "params": [
            {
                "descr": "True if the window gains focus, false if it loses focus.",
                "name": "boolean focus"
            }
        ],
        "path": "love/love.focus",
        "syntax": "love.focus( focus )",
        "type": "love"
    },
    "love.font.newFontData": {
        "descr": "Creates a new FontData.",
        "name": "love.font.newFontData",
        "params": [
            {
                "descr": "The Rasterizer containing the font.",
                "name": "Rasterizer rasterizer"
            },
            {
                "descr": "The FontData.",
                "name": "FontData fontData"
            }
        ],
        "path": "love/love.font.newfontdata",
        "syntax": "fontData = love.font.newFontData( rasterizer )",
        "type": "love.font"
    },
    "love.font.newGlyphData": {
        "descr": "Creates a new GlyphData.",
        "name": "love.font.newGlyphData",
        "params": [
            {
                "descr": "The Rasterizer containing the font.",
                "name": "Rasterizer rasterizer"
            },
            {
                "descr": "The character code of the glyph.",
                "name": "number glyph"
            },
            {
                "descr": "The GlyphData.",
                "name": "GlyphData glyphData"
            }
        ],
        "path": "love/love.font.newglyphdata",
        "syntax": "glyphData = love.font.newGlyphData( rasterizer, glyph )",
        "type": "love.font"
    },
    "love.font.newRasterizer": {
        "descr": "Creates a new Rasterizer.",
        "name": "love.font.newRasterizer",
        "params": [
            {
                "descr": "The image data containing the drawable pictures of font glyphs.",
                "name": "ImageData imageData"
            },
            {
                "descr": "The sequence of glyphs in the ImageData.",
                "name": "string glyphs"
            },
            {
                "descr": "The rasterizer.",
                "name": "Rasterizer rasterizer"
            }
        ],
        "path": "love/love.font.newrasterizer",
        "syntax": "rasterizer = love.font.newRasterizer( imageData, glyphs )",
        "type": "love.font"
    },
    "love.gamepadaxis": {
        "descr": "Called when a Joystick's virtual gamepad axis is moved.",
        "name": "love.gamepadaxis",
        "params": [
            {
                "descr": "The joystick object.",
                "name": "Joystick joystick"
            },
            {
                "descr": "The virtual gamepad axis.",
                "name": "GamepadAxis axis"
            },
            {
                "descr": "The new axis value.",
                "name": "number value"
            }
        ],
        "path": "love/love.gamepadaxis",
        "syntax": "love.gamepadaxis( joystick, axis, value )",
        "type": "love"
    },
    "love.gamepadpressed": {
        "descr": "Called when a Joystick's virtual gamepad button is pressed.",
        "name": "love.gamepadpressed",
        "params": [
            {
                "descr": "The joystick object.",
                "name": "Joystick joystick"
            },
            {
                "descr": "The virtual gamepad button.",
                "name": "GamepadButton button"
            }
        ],
        "path": "love/love.gamepadpressed",
        "syntax": "love.gamepadpressed( joystick, button )",
        "type": "love"
    },
    "love.gamepadreleased": {
        "descr": "Called when a Joystick's virtual gamepad button is released.",
        "name": "love.gamepadreleased",
        "params": [
            {
                "descr": "The joystick object.",
                "name": "Joystick joystick"
            },
            {
                "descr": "The virtual gamepad button.",
                "name": "GamepadButton button"
            }
        ],
        "path": "love/love.gamepadreleased",
        "syntax": "love.gamepadreleased( joystick, button )",
        "type": "love"
    },
    "love.getVersion": {
        "descr": "Gets the current running version of LÖVE.",
        "name": "love.getVersion",
        "params": [
            {
                "descr": "The major version of LÖVE, i.e. ",
                "name": "number major"
            },
            {
                "descr": "The minor version of LÖVE, i.e. ",
                "name": "number minor"
            },
            {
                "descr": "The revision version of LÖVE, i.e. ",
                "name": "number revision"
            },
            {
                "descr": "The codename of the current version, i.e. ",
                "name": "string codename"
            }
        ],
        "path": "love/love.getversion",
        "syntax": "major, minor, revision, codename = love.getVersion( )",
        "type": "love"
    },
    "love.graphics.arc": {
        "descr": "Draws a filled or unfilled arc at position (x, y). The arc is drawn from angle1 to angle2 in radians. The segments parameter determines how many segments are used to draw the arc. The more segments, the smoother the edge.",
        "name": "love.graphics.arc",
        "params": [
            {
                "descr": "How to draw the arc.",
                "name": "DrawMode drawmode"
            },
            {
                "descr": "The position of the center along x-axis.",
                "name": "number x"
            },
            {
                "descr": "The position of the center along y-axis.",
                "name": "number y"
            },
            {
                "descr": "Radius of the arc.",
                "name": "number radius"
            },
            {
                "descr": "The angle at which the arc begins.",
                "name": "number angle1"
            },
            {
                "descr": "The angle at which the arc terminates.",
                "name": "number angle2"
            },
            {
                "descr": "The number of segments used for drawing the arc.",
                "name": "number segments (10)"
            }
        ],
        "path": "love/love.graphics.arc",
        "syntax": "love.graphics.arc( drawmode, x, y, radius, angle1, angle2, segments )",
        "type": "love.graphics"
    },
    "love.graphics.checkMode": {
        "descr": "Checks if a display mode is supported.",
        "name": "love.graphics.checkMode",
        "params": [
            {
                "descr": "The display width.",
                "name": "number width"
            },
            {
                "descr": "The display height.",
                "name": "number height"
            },
            {
                "descr": "True to check for fullscreen, false for windowed.",
                "name": "boolean fullscreen (false)"
            },
            {
                "descr": "True if supported, false if not.",
                "name": "boolean supported"
            }
        ],
        "path": "love/love.graphics.checkmode",
        "syntax": "supported = love.graphics.checkMode( width, height, fullscreen )",
        "type": "love.graphics"
    },
    "love.graphics.circle": {
        "descr": "Draws a circle.",
        "name": "love.graphics.circle",
        "params": [
            {
                "descr": "How to draw the circle.",
                "name": "DrawMode mode"
            },
            {
                "descr": "The position of the center along x-axis.",
                "name": "number x"
            },
            {
                "descr": "The position of the center along y-axis.",
                "name": "number y"
            },
            {
                "descr": "The radius of the circle.",
                "name": "number radius"
            }
        ],
        "path": "love/love.graphics.circle",
        "syntax": "love.graphics.circle( mode, x, y, radius )",
        "type": "love.graphics"
    },
    "love.graphics.clear": {
        "descr": "Clears the screen to the background color in LÖVE 0.9.2 and earlier, or to the specified color in 0.10.0 and newer.",
        "name": "love.graphics.clear",
        "params": [],
        "path": "love/love.graphics.clear",
        "syntax": "love.graphics.clear( )",
        "type": "love.graphics"
    },
    "love.graphics.discard": {
        "descr": "Discards (trashes) the contents of the screen or active Canvas. This is a performance optimization function with niche use cases.",
        "name": "love.graphics.discard",
        "params": [
            {
                "descr": "Whether to discard the texture(s) of the active Canvas(es) (the contents of the screen if no Canvas is active.)",
                "name": "boolean discardcolor (true)"
            },
            {
                "descr": "Whether to discard the contents of the stencil buffer of the screen / active Canvas.",
                "name": "boolean discardstencil (true)"
            }
        ],
        "path": "love/love.graphics.discard",
        "syntax": "love.graphics.discard( discardcolor, discardstencil )",
        "type": "love.graphics"
    },
    "love.graphics.draw": {
        "descr": "Draws a Drawable object (an Image, Canvas, SpriteBatch, ParticleSystem, Mesh, or Video) on the screen with optional rotation, scaling and shearing.",
        "name": "love.graphics.draw",
        "params": [
            {
                "descr": "A drawable object.",
                "name": "Drawable drawable"
            },
            {
                "descr": "The position to draw the object (x-axis).",
                "name": "number x (0)"
            },
            {
                "descr": "The position to draw the object (y-axis).",
                "name": "number y (0)"
            },
            {
                "descr": "Orientation (radians).",
                "name": "number r (0)"
            },
            {
                "descr": "Scale factor (x-axis).",
                "name": "number sx (1)"
            },
            {
                "descr": "Scale factor (y-axis).",
                "name": "number sy (sx)"
            },
            {
                "descr": "Origin offset (x-axis).",
                "name": "number ox (0)"
            },
            {
                "descr": "Origin offset (y-axis).",
                "name": "number oy (0)"
            },
            {
                "descr": "Shearing factor (x-axis).",
                "name": "number kx (0) Available since 0.8.0"
            },
            {
                "descr": "Shearing factor (y-axis).",
                "name": "number ky (0) Available since 0.8.0"
            }
        ],
        "path": "love/love.graphics.draw",
        "syntax": "love.graphics.draw( drawable, x, y, r, sx, sy, ox, oy, kx, ky )",
        "type": "love.graphics"
    },
    "love.graphics.drawq": {
        "descr": "Draw a Quad with the specified Image on screen.",
        "name": "love.graphics.drawq",
        "params": [
            {
                "descr": "An image to texture the quad with.",
                "name": "Image image"
            },
            {
                "descr": "The quad to draw on screen.",
                "name": "Quad quad"
            },
            {
                "descr": "The position to draw the object (x-axis).",
                "name": "number x"
            },
            {
                "descr": "The position to draw the object (y-axis).",
                "name": "number y"
            },
            {
                "descr": "Orientation (radians).",
                "name": "number r (0)"
            },
            {
                "descr": "Scale factor (x-axis).",
                "name": "number sx (1)"
            },
            {
                "descr": "Scale factor (y-axis).",
                "name": "number sy (sx)"
            },
            {
                "descr": "Origin offset (x-axis).",
                "name": "number ox (0)"
            },
            {
                "descr": "Origin offset (y-axis).",
                "name": "number oy (0)"
            },
            {
                "descr": "Shearing factor (x-axis).",
                "name": "number kx (0) Available since 0.8.0"
            },
            {
                "descr": "Shearing factor (y-axis).",
                "name": "number ky (0) Available since 0.8.0"
            }
        ],
        "path": "love/love.graphics.drawq",
        "syntax": "love.graphics.drawq( image, quad, x, y, r, sx, sy, ox, oy, kx, ky )",
        "type": "love.graphics"
    },
    "love.graphics.ellipse": {
        "descr": "Draws an ellipse.",
        "name": "love.graphics.ellipse",
        "params": [
            {
                "descr": "How to draw the ellipse.",
                "name": "DrawMode mode"
            },
            {
                "descr": "The position of the center along x-axis.",
                "name": "number x"
            },
            {
                "descr": "The position of the center along y-axis.",
                "name": "number y"
            },
            {
                "descr": "The radius of the ellipse along the x-axis (half the ellipse's width.)",
                "name": "number radiusx"
            },
            {
                "descr": "The radius of the ellipse along the y-axis (half the ellipse's height.)",
                "name": "number radiusy"
            }
        ],
        "path": "love/love.graphics.ellipse",
        "syntax": "love.graphics.ellipse( mode, x, y, radiusx, radiusy )",
        "type": "love.graphics"
    },
    "love.graphics.getBackgroundColor": {
        "descr": "Gets the current background color.",
        "name": "love.graphics.getBackgroundColor",
        "params": [
            {
                "descr": "The red component (0-255).",
                "name": "number r"
            },
            {
                "descr": "The green component (0-255).",
                "name": "number g"
            },
            {
                "descr": "The blue component (0-255).",
                "name": "number b"
            },
            {
                "descr": "The alpha component (0-255).",
                "name": "number a"
            }
        ],
        "path": "love/love.graphics.getbackgroundcolor",
        "syntax": "r, g, b, a = love.graphics.getBackgroundColor( )",
        "type": "love.graphics"
    },
    "love.graphics.getBlendMode": {
        "descr": "Gets the blending mode.",
        "name": "love.graphics.getBlendMode",
        "params": [
            {
                "descr": "The current blend mode.",
                "name": "BlendMode mode"
            },
            {
                "descr": "The current blend alpha mode – it determines how the alpha of drawn objects affects blending.",
                "name": "BlendAlphaMode alphamode"
            }
        ],
        "path": "love/love.graphics.getblendmode",
        "syntax": "mode, alphamode = love.graphics.getBlendMode( )",
        "type": "love.graphics"
    },
    "love.graphics.getCanvas": {
        "descr": "Gets the current target Canvas.",
        "name": "love.graphics.getCanvas",
        "params": [
            {
                "descr": "The Canvas set by setCanvas. Returns nil if drawing to the real screen.",
                "name": "Canvas canvas"
            }
        ],
        "path": "love/love.graphics.getcanvas",
        "syntax": "canvas = love.graphics.getCanvas( )",
        "type": "love.graphics"
    },
    "love.graphics.getCanvasFormats": {
        "descr": "Gets the available Canvas formats, and whether each is supported.",
        "name": "love.graphics.getCanvasFormats",
        "params": [
            {
                "descr": "A table containing CanvasFormats as keys, and a boolean indicating whether the format is supported as values. ",
                "name": "table formats"
            }
        ],
        "path": "love/love.graphics.getcanvasformats",
        "syntax": "formats = love.graphics.getCanvasFormats( )",
        "type": "love.graphics"
    },
    "love.graphics.getCaption": {
        "descr": "Gets the window caption.",
        "name": "love.graphics.getCaption",
        "params": [
            {
                "descr": "The current window caption.",
                "name": "string caption"
            }
        ],
        "path": "love/love.graphics.getcaption",
        "syntax": "caption = love.graphics.getCaption( )",
        "type": "love.graphics"
    },
    "love.graphics.getColor": {
        "descr": "Gets the current color.",
        "name": "love.graphics.getColor",
        "params": [
            {
                "descr": "The red component (0-255).",
                "name": "number r"
            },
            {
                "descr": "The green component (0-255).",
                "name": "number g"
            },
            {
                "descr": "The blue component (0-255).",
                "name": "number b"
            },
            {
                "descr": "The alpha component (0-255).",
                "name": "number a"
            }
        ],
        "path": "love/love.graphics.getcolor",
        "syntax": "r, g, b, a = love.graphics.getColor( )",
        "type": "love.graphics"
    },
    "love.graphics.getColorMask": {
        "descr": "Gets the active color components used when drawing. Normally all 4 components are active unless love.graphics.setColorMask has been used.",
        "name": "love.graphics.getColorMask",
        "params": [
            {
                "descr": "Whether the red color component is active when rendering.",
                "name": "boolean r"
            },
            {
                "descr": "Whether the green color component is active when rendering.",
                "name": "boolean g"
            },
            {
                "descr": "Whether the blue color component is active when rendering.",
                "name": "boolean b"
            },
            {
                "descr": "Whether the alpha color component is active when rendering.",
                "name": "boolean a"
            }
        ],
        "path": "love/love.graphics.getcolormask",
        "syntax": "r, g, b, a = love.graphics.getColorMask( )",
        "type": "love.graphics"
    },
    "love.graphics.getColorMode": {
        "descr": "Gets the color mode (which controls how images are affected by the current color).",
        "name": "love.graphics.getColorMode",
        "params": [
            {
                "descr": "The current color mode.",
                "name": "ColorMode mode"
            }
        ],
        "path": "love/love.graphics.getcolormode",
        "syntax": "mode = love.graphics.getColorMode( )",
        "type": "love.graphics"
    },
    "love.graphics.getCompressedImageFormats": {
        "descr": "Gets the available compressed image formats, and whether each is supported.",
        "name": "love.graphics.getCompressedImageFormats",
        "params": [
            {
                "descr": "A table containing CompressedImageFormats as keys, and a boolean indicating whether the format is supported as values. ",
                "name": "table formats"
            }
        ],
        "path": "love/love.graphics.getcompressedimageformats",
        "syntax": "formats = love.graphics.getCompressedImageFormats( )",
        "type": "love.graphics"
    },
    "love.graphics.getDefaultFilter": {
        "descr": "Returns the default scaling filters used with Images, Canvases, and Fonts.",
        "name": "love.graphics.getDefaultFilter",
        "params": [
            {
                "descr": "Filter mode used when scaling the image down.",
                "name": "FilterMode min"
            },
            {
                "descr": "Filter mode used when scaling the image up.",
                "name": "FilterMode mag"
            },
            {
                "descr": "Maximum amount of Anisotropic Filtering used.",
                "name": "number anisotropy"
            }
        ],
        "path": "love/love.graphics.getdefaultfilter",
        "syntax": "min, mag, anisotropy = love.graphics.getDefaultFilter( )",
        "type": "love.graphics"
    },
    "love.graphics.getDefaultImageFilter": {
        "descr": "Returns the default scaling filters.",
        "name": "love.graphics.getDefaultImageFilter",
        "params": [
            {
                "descr": "Filter mode used when scaling the image down.",
                "name": "FilterMode min"
            },
            {
                "descr": "Filter mode used when scaling the image up.",
                "name": "FilterMode mag"
            }
        ],
        "path": "love/love.graphics.getdefaultimagefilter",
        "syntax": "min, mag = love.graphics.getDefaultImageFilter( )",
        "type": "love.graphics"
    },
    "love.graphics.getDimensions": {
        "descr": "Gets the width and height in pixels of the window.",
        "name": "love.graphics.getDimensions",
        "params": [
            {
                "descr": "The width of the window.",
                "name": "number width"
            },
            {
                "descr": "The height of the window.",
                "name": "number height"
            }
        ],
        "path": "love/love.graphics.getdimensions",
        "syntax": "width, height = love.graphics.getDimensions( )",
        "type": "love.graphics"
    },
    "love.graphics.getFont": {
        "descr": "Gets the current Font object.",
        "name": "love.graphics.getFont",
        "params": [
            {
                "descr": "The current Font. Automatically creates and sets the default font, if none is set yet.",
                "name": "Font font"
            }
        ],
        "path": "love/love.graphics.getfont",
        "syntax": "font = love.graphics.getFont( )",
        "type": "love.graphics"
    },
    "love.graphics.getHeight": {
        "descr": "Gets the height in pixels of the window.",
        "name": "love.graphics.getHeight",
        "params": [
            {
                "descr": "The height of the window.",
                "name": "number height"
            }
        ],
        "path": "love/love.graphics.getheight",
        "syntax": "height = love.graphics.getHeight( )",
        "type": "love.graphics"
    },
    "love.graphics.getLineJoin": {
        "descr": "Gets the line join style.",
        "name": "love.graphics.getLineJoin",
        "params": [
            {
                "descr": "The LineJoin style.",
                "name": "LineJoin join"
            }
        ],
        "path": "love/love.graphics.getlinejoin",
        "syntax": "join = love.graphics.getLineJoin( )",
        "type": "love.graphics"
    },
    "love.graphics.getLineStipple": {
        "descr": "Gets the current line stipple.",
        "name": "love.graphics.getLineStipple",
        "params": [
            {
                "descr": "The 16-bit stipple pattern.",
                "name": "number pattern"
            },
            {
                "descr": "The repeat factor.",
                "name": "number repeat"
            }
        ],
        "path": "love/love.graphics.getlinestipple",
        "syntax": "pattern, repeat = love.graphics.getLineStipple( )",
        "type": "love.graphics"
    },
    "love.graphics.getLineStyle": {
        "descr": "Gets the line style.",
        "name": "love.graphics.getLineStyle",
        "params": [
            {
                "descr": "The current line style.",
                "name": "LineStyle style"
            }
        ],
        "path": "love/love.graphics.getlinestyle",
        "syntax": "style = love.graphics.getLineStyle( )",
        "type": "love.graphics"
    },
    "love.graphics.getLineWidth": {
        "descr": "Gets the current line width.",
        "name": "love.graphics.getLineWidth",
        "params": [
            {
                "descr": "The current line width.",
                "name": "number width"
            }
        ],
        "path": "love/love.graphics.getlinewidth",
        "syntax": "width = love.graphics.getLineWidth( )",
        "type": "love.graphics"
    },
    "love.graphics.getMaxImageSize": {
        "descr": "Gets the max supported width or height of Images and Canvases.",
        "name": "love.graphics.getMaxImageSize",
        "params": [
            {
                "descr": "The max supported width or height of Images and Canvases.",
                "name": "number size"
            }
        ],
        "path": "love/love.graphics.getmaximagesize",
        "syntax": "size = love.graphics.getMaxImageSize( )",
        "type": "love.graphics"
    },
    "love.graphics.getMaxPointSize": {
        "descr": "Gets the max supported point size.",
        "name": "love.graphics.getMaxPointSize",
        "params": [
            {
                "descr": "The max supported point size.",
                "name": "number size"
            }
        ],
        "path": "love/love.graphics.getmaxpointsize",
        "syntax": "size = love.graphics.getMaxPointSize( )",
        "type": "love.graphics"
    },
    "love.graphics.getMode": {
        "descr": "Returns the current display mode.",
        "name": "love.graphics.getMode",
        "params": [
            {
                "descr": "Display width.",
                "name": "number width"
            },
            {
                "descr": "Display height.",
                "name": "number height"
            },
            {
                "descr": "Fullscreen (true) or windowed (false).",
                "name": "boolean fullscreen"
            },
            {
                "descr": "True if vertical sync is enabled or false if disabled.",
                "name": "boolean vsync"
            },
            {
                "descr": "The number of FSAA samples.",
                "name": "number fsaa"
            }
        ],
        "path": "love/love.graphics.getmode",
        "syntax": "width, height, fullscreen, vsync, fsaa = love.graphics.getMode( )",
        "type": "love.graphics"
    },
    "love.graphics.getModes": {
        "descr": "Gets a list of supported fullscreen modes.",
        "name": "love.graphics.getModes",
        "params": [
            {
                "descr": "A table of width/height pairs. (Note that this may not be in order.)",
                "name": "table modes"
            }
        ],
        "path": "love/love.graphics.getmodes",
        "syntax": "modes = love.graphics.getModes( )",
        "type": "love.graphics"
    },
    "love.graphics.getPixelEffect": {
        "descr": "Returns the current PixelEffect. Returns nil if none is set.",
        "name": "love.graphics.getPixelEffect",
        "params": [
            {
                "descr": "The current PixelEffect.",
                "name": "PixelEffect pe"
            }
        ],
        "path": "love/love.graphics.getpixeleffect",
        "syntax": "pe = love.graphics.getPixelEffect( )",
        "type": "love.graphics"
    },
    "love.graphics.getPointSize": {
        "descr": "Gets the point size.",
        "name": "love.graphics.getPointSize",
        "params": [
            {
                "descr": "The current point size.",
                "name": "number size"
            }
        ],
        "path": "love/love.graphics.getpointsize",
        "syntax": "size = love.graphics.getPointSize( )",
        "type": "love.graphics"
    },
    "love.graphics.getPointStyle": {
        "descr": "Gets the current point style.",
        "name": "love.graphics.getPointStyle",
        "params": [
            {
                "descr": "The current point style.",
                "name": "PointStyle style"
            }
        ],
        "path": "love/love.graphics.getpointstyle",
        "syntax": "style = love.graphics.getPointStyle( )",
        "type": "love.graphics"
    },
    "love.graphics.getRendererInfo": {
        "descr": "Gets information about the system's video card and drivers.",
        "name": "love.graphics.getRendererInfo",
        "params": [
            {
                "descr": "The name of the renderer, e.g. \"OpenGL\" or \"OpenGL ES\".",
                "name": "string name"
            },
            {
                "descr": "The version of the renderer with some extra driver-dependent version info, e.g. ",
                "name": "string version"
            },
            {
                "descr": "The name of the graphics card vendor, e.g. ",
                "name": "string vendor"
            },
            {
                "descr": "The name of the graphics card, e.g. ",
                "name": "string device"
            }
        ],
        "path": "love/love.graphics.getrendererinfo",
        "syntax": "name, version, vendor, device = love.graphics.getRendererInfo( )",
        "type": "love.graphics"
    },
    "love.graphics.getScissor": {
        "descr": "Gets the current scissor box.",
        "name": "love.graphics.getScissor",
        "params": [
            {
                "descr": "The x-component of the top-left point of the box.",
                "name": "number x"
            },
            {
                "descr": "The y-component of the top-left point of the box.",
                "name": "number y"
            },
            {
                "descr": "The width of the box.",
                "name": "number width"
            },
            {
                "descr": "The height of the box.",
                "name": "number height"
            }
        ],
        "path": "love/love.graphics.getscissor",
        "syntax": "x, y, width, height = love.graphics.getScissor( )",
        "type": "love.graphics"
    },
    "love.graphics.getShader": {
        "descr": "Gets the current Shader. Returns nil if none is set.",
        "name": "love.graphics.getShader",
        "params": [
            {
                "descr": "The currently active Shader, or nil if none is set.",
                "name": "Shader shader"
            }
        ],
        "path": "love/love.graphics.getshader",
        "syntax": "shader = love.graphics.getShader( )",
        "type": "love.graphics"
    },
    "love.graphics.getStats": {
        "descr": "Gets performance-related rendering statistics.",
        "name": "love.graphics.getStats",
        "params": [
            {
                "descr": "A table with the following fields:  number drawcalls  The number of draw calls made so far during the current frame.",
                "name": "table stats"
            },
            {
                "descr": "The number of times the active Canvas has been switched so far during the current frame.",
                "name": "number canvasswitches"
            },
            {
                "descr": "The estimated total size in bytes of video memory used by all loaded Images, Canvases, and Fonts.",
                "name": "number texturememory"
            },
            {
                "descr": "The number of Image objects currently loaded.",
                "name": "number images"
            },
            {
                "descr": "The number of Canvas objects currently loaded.",
                "name": "number canvases"
            },
            {
                "descr": "The number of Font objects currently loaded.",
                "name": "number fonts"
            },
            {
                "descr": "The number of times the active Shader has been changed so far during the current frame.",
                "name": "number shaderswitches Available since 0.10.2"
            }
        ],
        "path": "love/love.graphics.getstats",
        "syntax": "stats = love.graphics.getStats( )",
        "type": "love.graphics"
    },
    "love.graphics.getStencilTest": {
        "descr": "Gets the current stencil test configuration.",
        "name": "love.graphics.getStencilTest",
        "params": [
            {
                "descr": "The type of comparison that is made for each pixel. ",
                "name": "CompareMode comparemode"
            },
            {
                "descr": "The value used when comparing with the stencil value of each pixel.",
                "name": "number comparevalue"
            }
        ],
        "path": "love/love.graphics.getstenciltest",
        "syntax": "comparemode, comparevalue = love.graphics.getStencilTest( )",
        "type": "love.graphics"
    },
    "love.graphics.getSupported": {
        "descr": "Gets the optional graphics features and whether they're supported on the system.",
        "name": "love.graphics.getSupported",
        "params": [
            {
                "descr": "A table containing GraphicsFeature keys, and boolean values indicating whether each feature is supported.",
                "name": "table features"
            }
        ],
        "path": "love/love.graphics.getsupported",
        "syntax": "features = love.graphics.getSupported( )",
        "type": "love.graphics"
    },
    "love.graphics.getSystemLimit": {
        "descr": "Gets the system-dependent maximum value for a love.graphics feature.",
        "name": "love.graphics.getSystemLimit",
        "params": [
            {
                "descr": "The graphics feature to get the maximum value of.",
                "name": "GraphicsLimit limittype"
            },
            {
                "descr": "The system-dependent max value for the feature.",
                "name": "number limit"
            }
        ],
        "path": "love/love.graphics.getsystemlimit",
        "syntax": "limit = love.graphics.getSystemLimit( limittype )",
        "type": "love.graphics"
    },
    "love.graphics.getSystemLimits": {
        "descr": "Gets the system-dependent maximum values for love.graphics features.",
        "name": "love.graphics.getSystemLimits",
        "params": [
            {
                "descr": "A table containing GraphicsLimit keys, and number values.",
                "name": "table limits"
            }
        ],
        "path": "love/love.graphics.getsystemlimits",
        "syntax": "limits = love.graphics.getSystemLimits( )",
        "type": "love.graphics"
    },
    "love.graphics.getWidth": {
        "descr": "Gets the width in pixels of the window.",
        "name": "love.graphics.getWidth",
        "params": [
            {
                "descr": "The width of the window.",
                "name": "number width"
            }
        ],
        "path": "love/love.graphics.getwidth",
        "syntax": "width = love.graphics.getWidth( )",
        "type": "love.graphics"
    },
    "love.graphics.hasFocus": {
        "descr": "Checks if the game window has keyboard focus.",
        "name": "love.graphics.hasFocus",
        "params": [
            {
                "descr": "True if the window has the focus or false if not.",
                "name": "boolean focus"
            }
        ],
        "path": "love/love.graphics.hasfocus",
        "syntax": "focus = love.graphics.hasFocus( )",
        "type": "love.graphics"
    },
    "love.graphics.intersectScissor": {
        "descr": "Sets the scissor to the rectangle created by the intersection of the specified rectangle with the existing scissor. If no scissor is active yet, it behaves like love.graphics.setScissor.",
        "name": "love.graphics.intersectScissor",
        "params": [
            {
                "descr": "The x-coordinate of the upper left corner of the rectangle to intersect with the existing scissor rectangle.",
                "name": "number x"
            },
            {
                "descr": "The y-coordinate of the upper left corner of the rectangle to intersect with the existing scissor rectangle.",
                "name": "number y"
            },
            {
                "descr": "The width of the rectangle to intersect with the existing scissor rectangle.",
                "name": "number width"
            },
            {
                "descr": "The height of the rectangle to intersect with the existing scissor rectangle.",
                "name": "number height"
            }
        ],
        "path": "love/love.graphics.intersectscissor",
        "syntax": "love.graphics.intersectScissor( x, y, width, height )",
        "type": "love.graphics"
    },
    "love.graphics.isActive": {
        "descr": "Gets whether the graphics module is able to be used. If it is not active, love.graphics function and method calls will not work correctly and may cause the program to crash.",
        "name": "love.graphics.isActive",
        "params": [
            {
                "descr": "Whether the graphics module is active and able to be used.",
                "name": "boolean active"
            }
        ],
        "path": "love/love.graphics.isactive",
        "syntax": "active = love.graphics.isActive( )",
        "type": "love.graphics"
    },
    "love.graphics.isCreated": {
        "descr": "Checks if the window has been created.",
        "name": "love.graphics.isCreated",
        "params": [
            {
                "descr": "True if the window has been created, false otherwise.",
                "name": "boolean created"
            }
        ],
        "path": "love/love.graphics.iscreated",
        "syntax": "created = love.graphics.isCreated( )",
        "type": "love.graphics"
    },
    "love.graphics.isGammaCorrect": {
        "descr": "Gets whether gamma-correct rendering is supported and enabled. It can be enabled by setting t.gammacorrect = true in love.conf.",
        "name": "love.graphics.isGammaCorrect",
        "params": [
            {
                "descr": "True if gamma-correct rendering is supported and was enabled in love.conf, false otherwise.",
                "name": "boolean gammacorrect"
            }
        ],
        "path": "love/love.graphics.isgammacorrect",
        "syntax": "gammacorrect = love.graphics.isGammaCorrect( )",
        "type": "love.graphics"
    },
    "love.graphics.isSupported": {
        "descr": "Checks if certain graphics functions can be used.",
        "name": "love.graphics.isSupported",
        "params": [
            {
                "descr": "The graphics feature to check for.",
                "name": "GraphicsFeature supportN"
            },
            {
                "descr": "True if everything is supported, false otherwise.",
                "name": "boolean isSupported"
            }
        ],
        "path": "love/love.graphics.issupported",
        "syntax": "isSupported = love.graphics.isSupported( support1, support2, support3, ... )",
        "type": "love.graphics"
    },
    "love.graphics.isWireframe": {
        "descr": "Gets whether wireframe mode is used when drawing.",
        "name": "love.graphics.isWireframe",
        "params": [
            {
                "descr": "True if wireframe lines are used when drawing, false if it's not.",
                "name": "boolean wireframe"
            }
        ],
        "path": "love/love.graphics.iswireframe",
        "syntax": "wireframe = love.graphics.isWireframe( )",
        "type": "love.graphics"
    },
    "love.graphics.line": {
        "descr": "Draws lines between points.",
        "name": "love.graphics.line",
        "params": [
            {
                "descr": "The position of first point on the x-axis.",
                "name": "number x1"
            },
            {
                "descr": "The position of first point on the y-axis.",
                "name": "number y1"
            },
            {
                "descr": "The position of second point on the x-axis.",
                "name": "number x2"
            },
            {
                "descr": "The position of second point on the y-axis.",
                "name": "number y2"
            },
            {
                "descr": "You can continue passing point positions to draw a polyline.",
                "name": "number ..."
            }
        ],
        "path": "love/love.graphics.line",
        "syntax": "love.graphics.line( x1, y1, x2, y2, ... )",
        "type": "love.graphics"
    },
    "love.graphics.newCanvas": {
        "descr": "Creates a new Canvas object for offscreen rendering.",
        "name": "love.graphics.newCanvas",
        "params": [
            {
                "descr": "A new Canvas with dimensions equal to the window's size in pixels.",
                "name": "Canvas canvas"
            }
        ],
        "path": "love/love.graphics.newcanvas",
        "syntax": "canvas = love.graphics.newCanvas( )",
        "type": "love.graphics"
    },
    "love.graphics.newFont": {
        "descr": "Creates a new Font. Created fonts are not cached, in that calling this function with the same arguments will always create a new Font object.",
        "name": "love.graphics.newFont",
        "params": [
            {
                "descr": "The filepath to the font file.",
                "name": "string filename"
            },
            {
                "descr": "The size of the font in pixels.",
                "name": "number size (12)"
            },
            {
                "descr": "A Font object which can be used to draw text on screen.",
                "name": "Font font"
            }
        ],
        "path": "love/love.graphics.newfont",
        "syntax": "font = love.graphics.newFont( filename, size )",
        "type": "love.graphics"
    },
    "love.graphics.newFramebuffer": {
        "descr": "Creates a new framebuffer object for offscreen rendering.",
        "name": "love.graphics.newFramebuffer",
        "params": [
            {
                "descr": "A new framebuffer with width/height equal to the window width/height.",
                "name": "Framebuffer framebuffer"
            }
        ],
        "path": "love/love.graphics.newframebuffer",
        "syntax": "framebuffer = love.graphics.newFramebuffer( )",
        "type": "love.graphics"
    },
    "love.graphics.newImage": {
        "descr": "Creates a new Image from a filepath, FileData, an ImageData, or a CompressedImageData, and optionally generates or specifies mipmaps for the image.",
        "name": "love.graphics.newImage",
        "params": [
            {
                "descr": "The filepath to the image file.",
                "name": "string filename"
            },
            {
                "descr": "An Image object which can be drawn on screen.",
                "name": "Image image"
            }
        ],
        "path": "love/love.graphics.newimage",
        "syntax": "image = love.graphics.newImage( filename )",
        "type": "love.graphics"
    },
    "love.graphics.newImageFont": {
        "descr": "Creates a new Font by loading a specifically formatted image.",
        "name": "love.graphics.newImageFont",
        "params": [
            {
                "descr": "The filepath to the image file.",
                "name": "string filename"
            },
            {
                "descr": "A string of the characters in the image in order from left to right.",
                "name": "string glyphs"
            },
            {
                "descr": "A Font object which can be used to draw text on screen.",
                "name": "Font font"
            }
        ],
        "path": "love/love.graphics.newimagefont",
        "syntax": "font = love.graphics.newImageFont( filename, glyphs )",
        "type": "love.graphics"
    },
    "love.graphics.newMesh": {
        "descr": "Creates a new Mesh.",
        "name": "love.graphics.newMesh",
        "params": [
            {
                "descr": "The table filled with vertex information tables for each vertex as follows:  number [1]  The position of the vertex on the x-axis.",
                "name": "table vertices"
            },
            {
                "descr": "The position of the vertex on the y-axis.",
                "name": "number [2]"
            },
            {
                "descr": "The u texture coordinate of the vertex. ",
                "name": "number [3] (0)"
            },
            {
                "descr": "The v texture coordinate of the vertex. ",
                "name": "number [4] (0)"
            },
            {
                "descr": "The red component of the vertex color.",
                "name": "number [5] (255)"
            },
            {
                "descr": "The green component of the vertex color.",
                "name": "number [6] (255)"
            },
            {
                "descr": "The blue component of the vertex color.",
                "name": "number [7] (255)"
            },
            {
                "descr": "The alpha component of the vertex color.",
                "name": "number [8] (255)"
            },
            {
                "descr": "How the vertices are used when drawing. ",
                "name": "MeshDrawMode mode (\"fan\")"
            },
            {
                "descr": "The expected usage of the Mesh. ",
                "name": "SpriteBatchUsage usage (\"dynamic\")"
            },
            {
                "descr": "The new mesh.",
                "name": "Mesh mesh"
            }
        ],
        "path": "love/love.graphics.newmesh",
        "syntax": "mesh = love.graphics.newMesh( vertices, mode, usage )",
        "type": "love.graphics"
    },
    "love.graphics.newParticleSystem": {
        "descr": "Creates a new ParticleSystem.",
        "name": "love.graphics.newParticleSystem",
        "params": [
            {
                "descr": "The image to use.",
                "name": "Image image"
            },
            {
                "descr": "The max number of particles at the same time.",
                "name": "number buffer"
            },
            {
                "descr": "A new ParticleSystem.",
                "name": "ParticleSystem system"
            }
        ],
        "path": "love/love.graphics.newparticlesystem",
        "syntax": "system = love.graphics.newParticleSystem( image, buffer )",
        "type": "love.graphics"
    },
    "love.graphics.newPixelEffect": {
        "descr": "Creates a new PixelEffect object for hardware-accelerated pixel level effects.",
        "name": "love.graphics.newPixelEffect",
        "params": [
            {
                "descr": "The pixel effect code.",
                "name": "string code"
            },
            {
                "descr": "A PixelEffect object for use in drawing operations.",
                "name": "PixelEffect pixeleffect"
            },
            {
                "descr": "The drawing color set with love.graphics.setColor.",
                "name": "vec4 color"
            },
            {
                "descr": "The texture of the image or canvas being drawn.",
                "name": "Image texture"
            },
            {
                "descr": "Coordinates of the pixel relative to the texture. ",
                "name": "vec2 texture_coords"
            },
            {
                "descr": "Coordinates of the pixel on the screen. ",
                "name": "vec2 screen_coords"
            },
            {
                "descr": "The color of the pixel.",
                "name": "vec4 output_color"
            }
        ],
        "path": "love/love.graphics.newpixeleffect",
        "syntax": "pixeleffect = love.graphics.newPixelEffect( code )",
        "type": "love.graphics"
    },
    "love.graphics.newQuad": {
        "descr": "Creates a new Quad.",
        "name": "love.graphics.newQuad",
        "params": [
            {
                "descr": "The top-left position in the Image along the x-axis.",
                "name": "number x"
            },
            {
                "descr": "The top-left position in the Image along the y-axis.",
                "name": "number y"
            },
            {
                "descr": "The width of the Quad in the Image. ",
                "name": "number width"
            },
            {
                "descr": "The height of the Quad in the Image. ",
                "name": "number height"
            },
            {
                "descr": "The reference width, the width of the Image. ",
                "name": "number sw"
            },
            {
                "descr": "The reference height, the height of the Image. ",
                "name": "number sh"
            },
            {
                "descr": "The new Quad.",
                "name": "Quad quad"
            }
        ],
        "path": "love/love.graphics.newquad",
        "syntax": "quad = love.graphics.newQuad( x, y, width, height, sw, sh )",
        "type": "love.graphics"
    },
    "love.graphics.newScreenshot": {
        "descr": "Creates a screenshot and returns the image data.",
        "name": "love.graphics.newScreenshot",
        "params": [
            {
                "descr": "The image data of the screenshot.",
                "name": "ImageData screenshot"
            }
        ],
        "path": "love/love.graphics.newscreenshot",
        "syntax": "screenshot = love.graphics.newScreenshot( )",
        "type": "love.graphics"
    },
    "love.graphics.newShader": {
        "descr": "",
        "name": "love.graphics.newShader",
        "params": [
            {
                "descr": "The pixel shader or vertex shader code, or a filename pointing to a file with the code.",
                "name": "string code"
            },
            {
                "descr": "A Shader object for use in drawing operations.",
                "name": "Shader shader"
            }
        ],
        "path": "love/love.graphics.newshader",
        "syntax": "shader = love.graphics.newShader( code )",
        "type": "love.graphics"
    },
    "love.graphics.newSpriteBatch": {
        "descr": "Creates a new SpriteBatch object.",
        "name": "love.graphics.newSpriteBatch",
        "params": [
            {
                "descr": "The Image to use for the sprites.",
                "name": "Image image"
            },
            {
                "descr": "The maximum number of sprites that the SpriteBatch can contain at any given time.",
                "name": "number maxsprites (1000)"
            },
            {
                "descr": "The new SpriteBatch.",
                "name": "SpriteBatch spriteBatch"
            }
        ],
        "path": "love/love.graphics.newspritebatch",
        "syntax": "spriteBatch = love.graphics.newSpriteBatch( image, maxsprites )",
        "type": "love.graphics"
    },
    "love.graphics.newStencil": {
        "descr": "Creates a new stencil.",
        "name": "love.graphics.newStencil",
        "params": [
            {
                "descr": "Function that draws the stencil.",
                "name": "function stencilFunction"
            },
            {
                "descr": "Function that defines the new stencil.",
                "name": "function myStencil"
            }
        ],
        "path": "love/love.graphics.newstencil",
        "syntax": "myStencil = love.graphics.newStencil( stencilFunction )",
        "type": "love.graphics"
    },
    "love.graphics.newText": {
        "descr": "Creates a new drawable Text object.",
        "name": "love.graphics.newText",
        "params": [
            {
                "descr": "The font to use for the text.",
                "name": "Font font"
            },
            {
                "descr": "The initial string of text that the new Text object will contain. ",
                "name": "string textstring (nil)"
            },
            {
                "descr": "The new drawable Text object.",
                "name": "Text text"
            }
        ],
        "path": "love/love.graphics.newtext",
        "syntax": "text = love.graphics.newText( font, textstring )",
        "type": "love.graphics"
    },
    "love.graphics.newVideo": {
        "descr": "Creates a new drawable Video. Currently only Ogg Theora video files are supported.",
        "name": "love.graphics.newVideo",
        "params": [
            {
                "descr": "The file path to the Ogg Theora video file.",
                "name": "string filename"
            },
            {
                "descr": "Whether to try to load the video's audio into an audio Source. ",
                "name": "boolean loadaudio (nil)"
            },
            {
                "descr": "A new Video.",
                "name": "Video video"
            }
        ],
        "path": "love/love.graphics.newvideo",
        "syntax": "video = love.graphics.newVideo( filename, loadaudio )",
        "type": "love.graphics"
    },
    "love.graphics.origin": {
        "descr": "Resets the current coordinate transformation.",
        "name": "love.graphics.origin",
        "params": [],
        "path": "love/love.graphics.origin",
        "syntax": "love.graphics.origin()",
        "type": "love.graphics"
    },
    "love.graphics.point": {
        "descr": "Draws a point.",
        "name": "love.graphics.point",
        "params": [
            {
                "descr": "The position on the x-axis.",
                "name": "number x"
            },
            {
                "descr": "The position on the y-axis.",
                "name": "number y"
            }
        ],
        "path": "love/love.graphics.point",
        "syntax": "love.graphics.point( x, y )",
        "type": "love.graphics"
    },
    "love.graphics.points": {
        "descr": "Draws one or more points.",
        "name": "love.graphics.points",
        "params": [
            {
                "descr": "The position of the first point on the x-axis.",
                "name": "number x"
            },
            {
                "descr": "The position of the first point on the y-axis.",
                "name": "number y"
            },
            {
                "descr": "The x and y coordinates of additional points.",
                "name": "number ..."
            }
        ],
        "path": "love/love.graphics.points",
        "syntax": "love.graphics.points( x, y, ... )",
        "type": "love.graphics"
    },
    "love.graphics.polygon": {
        "descr": "Draw a polygon.",
        "name": "love.graphics.polygon",
        "params": [
            {
                "descr": "How to draw the polygon.",
                "name": "DrawMode mode"
            },
            {
                "descr": "The vertices of the polygon.",
                "name": "number ..."
            }
        ],
        "path": "love/love.graphics.polygon",
        "syntax": "love.graphics.polygon( mode, ... )",
        "type": "love.graphics"
    },
    "love.graphics.pop": {
        "descr": "Pops the current coordinate transformation from the transformation stack.",
        "name": "love.graphics.pop",
        "params": [],
        "path": "love/love.graphics.pop",
        "syntax": "love.graphics.pop()",
        "type": "love.graphics"
    },
    "love.graphics.present": {
        "descr": "Displays the results of drawing operations on the screen.",
        "name": "love.graphics.present",
        "params": [],
        "path": "love/love.graphics.present",
        "syntax": "love.graphics.present( )",
        "type": "love.graphics"
    },
    "love.graphics.print": {
        "descr": "Draws text on screen. If no Font is set, one will be created and set (once) if needed.",
        "name": "love.graphics.print",
        "params": [
            {
                "descr": "The text to draw.",
                "name": "string text"
            },
            {
                "descr": "The position to draw the object (x-axis).",
                "name": "number x"
            },
            {
                "descr": "The position to draw the object (y-axis).",
                "name": "number y"
            },
            {
                "descr": "Orientation (radians).",
                "name": "number r (0)"
            },
            {
                "descr": "Scale factor (x-axis).",
                "name": "number sx (1)"
            },
            {
                "descr": "Scale factor (y-axis).",
                "name": "number sy (sx)"
            },
            {
                "descr": "Origin offset (x-axis).",
                "name": "number ox (0)"
            },
            {
                "descr": "Origin offset (y-axis).",
                "name": "number oy (0)"
            },
            {
                "descr": "Shearing factor (x-axis).",
                "name": "number kx (0) Available since 0.8.0"
            },
            {
                "descr": "Shearing factor (y-axis).",
                "name": "number ky (0) Available since 0.8.0"
            }
        ],
        "path": "love/love.graphics.print",
        "syntax": "love.graphics.print( text, x, y, r, sx, sy, ox, oy, kx, ky )",
        "type": "love.graphics"
    },
    "love.graphics.printf": {
        "descr": "Draws formatted text, with word wrap and alignment.",
        "name": "love.graphics.printf",
        "params": [
            {
                "descr": "A text string.",
                "name": "string text"
            },
            {
                "descr": "The position on the x-axis.",
                "name": "number x"
            },
            {
                "descr": "The position on the y-axis.",
                "name": "number y"
            },
            {
                "descr": "Wrap the line after this many horizontal pixels.",
                "name": "number limit"
            },
            {
                "descr": "The alignment.",
                "name": "AlignMode align (\"left\")"
            }
        ],
        "path": "love/love.graphics.printf",
        "syntax": "love.graphics.printf( text, x, y, limit, align )",
        "type": "love.graphics"
    },
    "love.graphics.push": {
        "descr": "Copies and pushes the current coordinate transformation to the transformation stack.",
        "name": "love.graphics.push",
        "params": [],
        "path": "love/love.graphics.push",
        "syntax": "love.graphics.push( )",
        "type": "love.graphics"
    },
    "love.graphics.quad": {
        "descr": "Draws a quadrilateral shape.",
        "name": "love.graphics.quad",
        "params": [
            {
                "descr": "How to draw the quad.",
                "name": "DrawMode mode"
            },
            {
                "descr": "The position of the top left corner along x-axis.",
                "name": "number x1"
            },
            {
                "descr": "The position of the top left corner along y-axis.",
                "name": "number y1"
            },
            {
                "descr": "The position of the top right corner along x-axis.",
                "name": "number x2"
            },
            {
                "descr": "The position of the top right corner along y-axis.",
                "name": "number y2"
            },
            {
                "descr": "The position of the bottom right corner along x-axis.",
                "name": "number x3"
            },
            {
                "descr": "The position of the bottom right corner along y-axis.",
                "name": "number y3"
            },
            {
                "descr": "The position of the bottom left corner along x-axis.",
                "name": "number x4"
            },
            {
                "descr": "The position of the bottom left corner along y-axis.",
                "name": "number y4"
            }
        ],
        "path": "love/love.graphics.quad",
        "syntax": "love.graphics.quad( mode, x1, y1, x2, y2, x3, y3, x4, y4 )",
        "type": "love.graphics"
    },
    "love.graphics.rectangle": {
        "descr": "Draws a rectangle.",
        "name": "love.graphics.rectangle",
        "params": [
            {
                "descr": "How to draw the rectangle.",
                "name": "DrawMode mode"
            },
            {
                "descr": "The position of top-left corner along the x-axis.",
                "name": "number x"
            },
            {
                "descr": "The position of top-left corner along the y-axis.",
                "name": "number y"
            },
            {
                "descr": "Width of the rectangle.",
                "name": "number width"
            },
            {
                "descr": "Height of the rectangle.",
                "name": "number height"
            }
        ],
        "path": "love/love.graphics.rectangle",
        "syntax": "love.graphics.rectangle( mode, x, y, width, height )",
        "type": "love.graphics"
    },
    "love.graphics.reset": {
        "descr": "Resets the current graphics settings.",
        "name": "love.graphics.reset",
        "params": [],
        "path": "love/love.graphics.reset",
        "syntax": "love.graphics.reset( )",
        "type": "love.graphics"
    },
    "love.graphics.rotate": {
        "descr": "Rotates the coordinate system in two dimensions.",
        "name": "love.graphics.rotate",
        "params": [
            {
                "descr": "The amount to rotate the coordinate system in radians.",
                "name": "number angle"
            }
        ],
        "path": "love/love.graphics.rotate",
        "syntax": "love.graphics.rotate( angle )",
        "type": "love.graphics"
    },
    "love.graphics.scale": {
        "descr": "Scales the coordinate system in two dimensions.",
        "name": "love.graphics.scale",
        "params": [
            {
                "descr": "The scaling in the direction of the x-axis.",
                "name": "number sx"
            },
            {
                "descr": "The scaling in the direction of the y-axis. ",
                "name": "number sy (sx)"
            }
        ],
        "path": "love/love.graphics.scale",
        "syntax": "love.graphics.scale( sx, sy )",
        "type": "love.graphics"
    },
    "love.graphics.setBackgroundColor": {
        "descr": "Sets the background color.",
        "name": "love.graphics.setBackgroundColor",
        "params": [
            {
                "descr": "The red component (0-255).",
                "name": "number red"
            },
            {
                "descr": "The green component (0-255).",
                "name": "number green"
            },
            {
                "descr": "The blue component (0-255).",
                "name": "number blue"
            }
        ],
        "path": "love/love.graphics.setbackgroundcolor",
        "syntax": "love.graphics.setBackgroundColor( red, green, blue )",
        "type": "love.graphics"
    },
    "love.graphics.setBlendMode": {
        "descr": "Sets the blending mode.",
        "name": "love.graphics.setBlendMode",
        "params": [
            {
                "descr": "The blend mode to use.",
                "name": "BlendMode mode"
            }
        ],
        "path": "love/love.graphics.setblendmode",
        "syntax": "love.graphics.setBlendMode( mode )",
        "type": "love.graphics"
    },
    "love.graphics.setCanvas": {
        "descr": "Captures drawing operations to a Canvas.",
        "name": "love.graphics.setCanvas",
        "params": [
            {
                "descr": "The new target.",
                "name": "Canvas canvas"
            }
        ],
        "path": "love/love.graphics.setcanvas",
        "syntax": "love.graphics.setCanvas( canvas )",
        "type": "love.graphics"
    },
    "love.graphics.setCaption": {
        "descr": "Sets the window caption.",
        "name": "love.graphics.setCaption",
        "params": [
            {
                "descr": "The new window caption.",
                "name": "string caption"
            }
        ],
        "path": "love/love.graphics.setcaption",
        "syntax": "love.graphics.setCaption( caption )",
        "type": "love.graphics"
    },
    "love.graphics.setColor": {
        "descr": "Sets the color used for drawing.",
        "name": "love.graphics.setColor",
        "params": [
            {
                "descr": "The amount of red.",
                "name": "number red"
            },
            {
                "descr": "The amount of green.",
                "name": "number green"
            },
            {
                "descr": "The amount of blue.",
                "name": "number blue"
            },
            {
                "descr": "The amount of alpha. The alpha value will be applied to all subsequent draw operations, even the drawing of an image.",
                "name": "number alpha (255)"
            }
        ],
        "path": "love/love.graphics.setcolor",
        "syntax": "love.graphics.setColor( red, green, blue, alpha )",
        "type": "love.graphics"
    },
    "love.graphics.setColorMask": {
        "descr": "Sets the color mask. Enables or disables specific color components when rendering and clearing the screen. For example, if red is set to false, no further changes will be made to the red component of any pixels.",
        "name": "love.graphics.setColorMask",
        "params": [
            {
                "descr": "Render red component.",
                "name": "boolean red"
            },
            {
                "descr": "Render green component.",
                "name": "boolean green"
            },
            {
                "descr": "Render blue component.",
                "name": "boolean blue"
            },
            {
                "descr": "Render alpha component.",
                "name": "boolean alpha"
            }
        ],
        "path": "love/love.graphics.setcolormask",
        "syntax": "love.graphics.setColorMask( red, green, blue, alpha )",
        "type": "love.graphics"
    },
    "love.graphics.setColorMode": {
        "descr": "Sets the color mode (which controls how images are affected by the current color).",
        "name": "love.graphics.setColorMode",
        "params": [
            {
                "descr": "The color mode to use.",
                "name": "ColorMode mode"
            }
        ],
        "path": "love/love.graphics.setcolormode",
        "syntax": "love.graphics.setColorMode( mode )",
        "type": "love.graphics"
    },
    "love.graphics.setDefaultFilter": {
        "descr": "Sets the default scaling filters used with Images, Canvases, and Fonts.",
        "name": "love.graphics.setDefaultFilter",
        "params": [
            {
                "descr": "Filter mode used when scaling the image down.",
                "name": "FilterMode min"
            },
            {
                "descr": "Filter mode used when scaling the image up.",
                "name": "FilterMode mag"
            },
            {
                "descr": "Maximum amount of Anisotropic Filtering used.",
                "name": "number anisotropy (1)"
            }
        ],
        "path": "love/love.graphics.setdefaultfilter",
        "syntax": "love.graphics.setDefaultFilter( min, mag, anisotropy )",
        "type": "love.graphics"
    },
    "love.graphics.setDefaultImageFilter": {
        "descr": "Sets the default scaling filters.",
        "name": "love.graphics.setDefaultImageFilter",
        "params": [
            {
                "descr": "Filter mode used when scaling the image down.",
                "name": "FilterMode min"
            },
            {
                "descr": "Filter mode used when scaling the image up.",
                "name": "FilterMode mag"
            }
        ],
        "path": "love/love.graphics.setdefaultimagefilter",
        "syntax": "love.graphics.setDefaultImageFilter( min, mag )",
        "type": "love.graphics"
    },
    "love.graphics.setFont": {
        "descr": "Set an already-loaded Font as the current font or create and load a new one from the file and size.",
        "name": "love.graphics.setFont",
        "params": [
            {
                "descr": "The Font object to use.",
                "name": "Font font"
            }
        ],
        "path": "love/love.graphics.setfont",
        "syntax": "love.graphics.setFont( font )",
        "type": "love.graphics"
    },
    "love.graphics.setIcon": {
        "descr": "Set window icon. This feature is not completely supported on Windows (apparently an SDL bug, not a LOVE bug: [1]).",
        "name": "love.graphics.setIcon",
        "params": [
            {
                "descr": "The window icon.",
                "name": "Image image"
            }
        ],
        "path": "love/love.graphics.seticon",
        "syntax": "love.graphics.setIcon( image )",
        "type": "love.graphics"
    },
    "love.graphics.setInvertedStencil": {
        "descr": "Defines an inverted stencil for the drawing operations or releases the active one.",
        "name": "love.graphics.setInvertedStencil",
        "params": [
            {
                "descr": "Function that draws the stencil.",
                "name": "function stencilFunction"
            }
        ],
        "path": "love/love.graphics.setinvertedstencil",
        "syntax": "love.graphics.setInvertedStencil( stencilFunction )",
        "type": "love.graphics"
    },
    "love.graphics.setLine": {
        "descr": "Sets the line width and style.",
        "name": "love.graphics.setLine",
        "params": [
            {
                "descr": "The width of the line.",
                "name": "number width"
            },
            {
                "descr": "The LineStyle to use.",
                "name": "LineStyle style (\"smooth\")"
            }
        ],
        "path": "love/love.graphics.setline",
        "syntax": "love.graphics.setLine( width, style )",
        "type": "love.graphics"
    },
    "love.graphics.setLineJoin": {
        "descr": "Sets the line join style. See LineJoin for the possible options.",
        "name": "love.graphics.setLineJoin",
        "params": [
            {
                "descr": "The LineJoin to use.",
                "name": "LineJoin join"
            }
        ],
        "path": "love/love.graphics.setlinejoin",
        "syntax": "love.graphics.setLineJoin( join )",
        "type": "love.graphics"
    },
    "love.graphics.setLineStipple": {
        "descr": "Sets the line stipple pattern.",
        "name": "love.graphics.setLineStipple",
        "params": [
            {
                "descr": "A 16-bit pattern.",
                "name": "number pattern"
            },
            {
                "descr": "Repeat factor.",
                "name": "number repeat (1)"
            }
        ],
        "path": "love/love.graphics.setlinestipple",
        "syntax": "love.graphics.setLineStipple( pattern, repeat )",
        "type": "love.graphics"
    },
    "love.graphics.setLineStyle": {
        "descr": "Sets the line style.",
        "name": "love.graphics.setLineStyle",
        "params": [
            {
                "descr": "The LineStyle to use. Line styles include smooth and rough.",
                "name": "LineStyle style"
            }
        ],
        "path": "love/love.graphics.setlinestyle",
        "syntax": "love.graphics.setLineStyle( style )",
        "type": "love.graphics"
    },
    "love.graphics.setLineWidth": {
        "descr": "Sets the line width.",
        "name": "love.graphics.setLineWidth",
        "params": [
            {
                "descr": "The width of the line.",
                "name": "number width"
            }
        ],
        "path": "love/love.graphics.setlinewidth",
        "syntax": "love.graphics.setLineWidth( width )",
        "type": "love.graphics"
    },
    "love.graphics.setMode": {
        "descr": "Changes the window size, or the display mode if fullscreen.",
        "name": "love.graphics.setMode",
        "params": [
            {
                "descr": "Display width.",
                "name": "number width"
            },
            {
                "descr": "Display height.",
                "name": "number height"
            },
            {
                "descr": "Fullscreen (true), or windowed (false).",
                "name": "boolean fullscreen (false)"
            },
            {
                "descr": "True if LÖVE should wait for vsync, false otherwise.",
                "name": "boolean vsync (true)"
            },
            {
                "descr": "The number of MSAA samples.",
                "name": "number fsaa (0)"
            },
            {
                "descr": "True if successful, false otherwise.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.graphics.setmode",
        "syntax": "success = love.graphics.setMode( width, height, fullscreen, vsync, fsaa )",
        "type": "love.graphics"
    },
    "love.graphics.setNewFont": {
        "descr": "Creates and sets a new Font.",
        "name": "love.graphics.setNewFont",
        "params": [
            {
                "descr": "The size of the font.",
                "name": "number size (12)"
            },
            {
                "descr": "The new font.",
                "name": "Font font"
            }
        ],
        "path": "love/love.graphics.setnewfont",
        "syntax": "font = love.graphics.setNewFont( size )",
        "type": "love.graphics"
    },
    "love.graphics.setPixelEffect": {
        "descr": "Sets or resets a PixelEffect as the current pixel effect. All drawing operations until the next love.graphics.setPixelEffect will be drawn using the PixelEffect object specified.",
        "name": "love.graphics.setPixelEffect",
        "params": [
            {
                "descr": "The new pixel effect.",
                "name": "PixelEffect pixeleffect"
            }
        ],
        "path": "love/love.graphics.setpixeleffect",
        "syntax": "love.graphics.setPixelEffect( pixeleffect )",
        "type": "love.graphics"
    },
    "love.graphics.setPoint": {
        "descr": "Sets the point size and style.",
        "name": "love.graphics.setPoint",
        "params": [
            {
                "descr": "The new point size.",
                "name": "number size"
            },
            {
                "descr": "The new point style.",
                "name": "PointStyle style"
            }
        ],
        "path": "love/love.graphics.setpoint",
        "syntax": "love.graphics.setPoint( size, style )",
        "type": "love.graphics"
    },
    "love.graphics.setPointSize": {
        "descr": "Sets the point size.",
        "name": "love.graphics.setPointSize",
        "params": [
            {
                "descr": "The new point size.",
                "name": "number size"
            }
        ],
        "path": "love/love.graphics.setpointsize",
        "syntax": "love.graphics.setPointSize( size )",
        "type": "love.graphics"
    },
    "love.graphics.setPointStyle": {
        "descr": "Sets the point style.",
        "name": "love.graphics.setPointStyle",
        "params": [
            {
                "descr": "The new point style.",
                "name": "PointStyle style"
            }
        ],
        "path": "love/love.graphics.setpointstyle",
        "syntax": "love.graphics.setPointStyle( style )",
        "type": "love.graphics"
    },
    "love.graphics.setRenderTarget": {
        "descr": "Sets or resets a Framebuffer as render target. All drawing operations until the next love.graphics.setRenderTarget will be directed to the Framebuffer object specified.",
        "name": "love.graphics.setRenderTarget",
        "params": [
            {
                "descr": "The new render target.",
                "name": "Framebuffer framebuffer"
            }
        ],
        "path": "love/love.graphics.setrendertarget",
        "syntax": "love.graphics.setRenderTarget( framebuffer )",
        "type": "love.graphics"
    },
    "love.graphics.setScissor": {
        "descr": "Sets or disables scissor.",
        "name": "love.graphics.setScissor",
        "params": [
            {
                "descr": "x coordinate of upper left corner.",
                "name": "number x"
            },
            {
                "descr": "y coordinate of upper left corner.",
                "name": "number y"
            },
            {
                "descr": "width of clipping rectangle.",
                "name": "number width"
            },
            {
                "descr": "height of clipping rectangle.",
                "name": "number height"
            }
        ],
        "path": "love/love.graphics.setscissor",
        "syntax": "love.graphics.setScissor( x, y, width, height )",
        "type": "love.graphics"
    },
    "love.graphics.setShader": {
        "descr": "Sets or resets a Shader as the current pixel effect or vertex shaders. All drawing operations until the next love.graphics.setShader will be drawn using the Shader object specified.",
        "name": "love.graphics.setShader",
        "params": [
            {
                "descr": "The new shader.",
                "name": "Shader shader"
            }
        ],
        "path": "love/love.graphics.setshader",
        "syntax": "love.graphics.setShader( shader )",
        "type": "love.graphics"
    },
    "love.graphics.setStencil": {
        "descr": "Defines or releases a stencil for the drawing operations.",
        "name": "love.graphics.setStencil",
        "params": [
            {
                "descr": "Function that draws the stencil.",
                "name": "function stencilFunction"
            }
        ],
        "path": "love/love.graphics.setstencil",
        "syntax": "love.graphics.setStencil( stencilFunction )",
        "type": "love.graphics"
    },
    "love.graphics.setStencilTest": {
        "descr": "Configures or disables stencil testing.",
        "name": "love.graphics.setStencilTest",
        "params": [
            {
                "descr": "The type of comparison to make for each pixel.",
                "name": "CompareMode comparemode"
            },
            {
                "descr": "The value to use when comparing with the stencil value of each pixel. ",
                "name": "number comparevalue"
            }
        ],
        "path": "love/love.graphics.setstenciltest",
        "syntax": "love.graphics.setStencilTest( comparemode, comparevalue )",
        "type": "love.graphics"
    },
    "love.graphics.setWireframe": {
        "descr": "Sets whether wireframe lines will be used when drawing.",
        "name": "love.graphics.setWireframe",
        "params": [
            {
                "descr": "True to enable wireframe mode when drawing, false to disable it.",
                "name": "boolean enable"
            }
        ],
        "path": "love/love.graphics.setwireframe",
        "syntax": "love.graphics.setWireframe( enable )",
        "type": "love.graphics"
    },
    "love.graphics.shear": {
        "descr": "Shears the coordinate system.",
        "name": "love.graphics.shear",
        "params": [
            {
                "descr": "The shear factor on the x-axis.",
                "name": "number kx"
            },
            {
                "descr": "The shear factor on the y-axis.",
                "name": "number ky"
            }
        ],
        "path": "love/love.graphics.shear",
        "syntax": "love.graphics.shear( kx, ky )",
        "type": "love.graphics"
    },
    "love.graphics.stencil": {
        "descr": "Draws geometry as a stencil.",
        "name": "love.graphics.stencil",
        "params": [
            {
                "descr": "Function which draws geometry. The stencil values of pixels, rather than the color of each pixel, will be affected by the geometry.",
                "name": "function stencilfunction"
            },
            {
                "descr": "How to modify any stencil values of pixels that are touched by what's drawn in the stencil function.",
                "name": "StencilAction action (\"replace\")"
            },
            {
                "descr": "The new stencil value to use for pixels if the \"replace\" stencil action is used. ",
                "name": "number value (1)"
            },
            {
                "descr": "True to preserve old stencil values of pixels, false to re-set every pixel's stencil value to 0 before executing the stencil function. ",
                "name": "boolean keepvalues (false)"
            }
        ],
        "path": "love/love.graphics.stencil",
        "syntax": "love.graphics.stencil( stencilfunction, action, value, keepvalues )",
        "type": "love.graphics"
    },
    "love.graphics.toggleFullscreen": {
        "descr": "Toggles fullscreen.",
        "name": "love.graphics.toggleFullscreen",
        "params": [
            {
                "descr": "True if successful, false otherwise.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.graphics.togglefullscreen",
        "syntax": "success = love.graphics.toggleFullscreen( )",
        "type": "love.graphics"
    },
    "love.graphics.translate": {
        "descr": "Translates the coordinate system in two dimensions.",
        "name": "love.graphics.translate",
        "params": [
            {
                "descr": "The translation relative to the x-axis.",
                "name": "number dx"
            },
            {
                "descr": "The translation relative to the y-axis.",
                "name": "number dy"
            }
        ],
        "path": "love/love.graphics.translate",
        "syntax": "love.graphics.translate( dx, dy )",
        "type": "love.graphics"
    },
    "love.graphics.triangle": {
        "descr": "Draws a triangle.",
        "name": "love.graphics.triangle",
        "params": [
            {
                "descr": "How to draw the triangle.",
                "name": "DrawMode mode"
            },
            {
                "descr": "The position of first point on the x-axis.",
                "name": "number x1"
            },
            {
                "descr": "The position of first point on the y-axis.",
                "name": "number y1"
            },
            {
                "descr": "The position of second point on the x-axis.",
                "name": "number x2"
            },
            {
                "descr": "The position of second point on the y-axis.",
                "name": "number y2"
            },
            {
                "descr": "The position of third point on the x-axis.",
                "name": "number x3"
            },
            {
                "descr": "The position of third point on the y-axis.",
                "name": "number y3"
            }
        ],
        "path": "love/love.graphics.triangle",
        "syntax": "love.graphics.triangle( mode, x1, y1, x2, y2, x3, y3 )",
        "type": "love.graphics"
    },
    "love.image.isCompressed": {
        "descr": "Determines whether a file can be loaded as CompressedImageData.",
        "name": "love.image.isCompressed",
        "params": [
            {
                "descr": "The filename of the potentially compressed image file.",
                "name": "string filename"
            },
            {
                "descr": "Whether the file can be loaded as CompressedImageData or not.",
                "name": "boolean compressed"
            }
        ],
        "path": "love/love.image.iscompressed",
        "syntax": "compressed = love.image.isCompressed( filename )",
        "type": "love.image"
    },
    "love.image.newCompressedData": {
        "descr": "Create a new CompressedImageData object from a compressed image file. LÖVE supports several compressed texture formats, enumerated in the CompressedImageFormat page.",
        "name": "love.image.newCompressedData",
        "params": [
            {
                "descr": "The filename of the compressed image file.",
                "name": "string filename"
            },
            {
                "descr": "The new CompressedImageData object.",
                "name": "CompressedImageData compressedImageData"
            }
        ],
        "path": "love/love.image.newcompresseddata",
        "syntax": "compressedImageData = love.image.newCompressedData( filename )",
        "type": "love.image"
    },
    "love.image.newEncodedImageData": {
        "descr": "Encodes ImageData.",
        "name": "love.image.newEncodedImageData",
        "params": [
            {
                "descr": "The raw ImageData to encode.",
                "name": "ImageData imageData"
            },
            {
                "descr": "The format to encode the image in.",
                "name": "ImageFormat format"
            },
            {
                "descr": "The encoded image data.",
                "name": "Data data"
            }
        ],
        "path": "love/love.image.newencodedimagedata",
        "syntax": "data = love.image.newEncodedImageData( imageData, format )",
        "type": "love.image"
    },
    "love.image.newImageData": {
        "descr": "Creates a new ImageData object.",
        "name": "love.image.newImageData",
        "params": [
            {
                "descr": "The width of the ImageData.",
                "name": "number width"
            },
            {
                "descr": "The height of the ImageData.",
                "name": "number height"
            },
            {
                "descr": "The new blank ImageData object. ",
                "name": "ImageData imageData"
            }
        ],
        "path": "love/love.image.newimagedata",
        "syntax": "imageData = love.image.newImageData( width, height )",
        "type": "love.image"
    },
    "love.joystick.close": {
        "descr": "Closes a joystick, i.e. stop using it for generating events and in query functions.",
        "name": "love.joystick.close",
        "params": [
            {
                "descr": "The joystick to be closed",
                "name": "number joystick"
            }
        ],
        "path": "love/love.joystick.close",
        "syntax": "love.joystick.close( joystick )",
        "type": "love.joystick"
    },
    "love.joystick.getAxes": {
        "descr": "Returns the position of each axis.",
        "name": "love.joystick.getAxes",
        "params": [
            {
                "descr": "The joystick to be checked",
                "name": "number joystick"
            },
            {
                "descr": "Direction of axis1",
                "name": "number axisDir1"
            },
            {
                "descr": "Direction of axis2",
                "name": "number axisDir2"
            },
            {
                "descr": "Direction of axisN",
                "name": "number axisDirN"
            }
        ],
        "path": "love/love.joystick.getaxes",
        "syntax": "axisDir1, axisDir2, axisDirN = love.joystick.getAxes( joystick )",
        "type": "love.joystick"
    },
    "love.joystick.getAxis": {
        "descr": "Returns the direction of the axis.",
        "name": "love.joystick.getAxis",
        "params": [
            {
                "descr": "The joystick to be checked",
                "name": "number joystick"
            },
            {
                "descr": "The axis to be checked",
                "name": "number axis"
            },
            {
                "descr": "Current value of the axis",
                "name": "number direction"
            }
        ],
        "path": "love/love.joystick.getaxis",
        "syntax": "direction = love.joystick.getAxis( joystick, axis )",
        "type": "love.joystick"
    },
    "love.joystick.getBall": {
        "descr": "Returns the change in ball position.",
        "name": "love.joystick.getBall",
        "params": [
            {
                "descr": "The joystick to be checked",
                "name": "number joystick"
            },
            {
                "descr": "The ball to be checked",
                "name": "number ball"
            },
            {
                "descr": "Change in x of the ball position.",
                "name": "number dx"
            },
            {
                "descr": "Change in y of the ball position.",
                "name": "number dy"
            }
        ],
        "path": "love/love.joystick.getball",
        "syntax": "dx, dy = love.joystick.getBall( joystick, ball )",
        "type": "love.joystick"
    },
    "love.joystick.getHat": {
        "descr": "Returns the direction of a hat.",
        "name": "love.joystick.getHat",
        "params": [
            {
                "descr": "The joystick to be checked",
                "name": "number joystick"
            },
            {
                "descr": "The hat to be checked",
                "name": "number hat"
            },
            {
                "descr": "The direction the hat is pushed",
                "name": "JoystickConstant direction"
            }
        ],
        "path": "love/love.joystick.gethat",
        "syntax": "direction = love.joystick.getHat( joystick, hat )",
        "type": "love.joystick"
    },
    "love.joystick.getJoystickCount": {
        "descr": "Gets the number of connected joysticks.",
        "name": "love.joystick.getJoystickCount",
        "params": [
            {
                "descr": "The number of connected joysticks.",
                "name": "number joystickcount"
            }
        ],
        "path": "love/love.joystick.getjoystickcount",
        "syntax": "joystickcount = love.joystick.getJoystickCount( )",
        "type": "love.joystick"
    },
    "love.joystick.getJoysticks": {
        "descr": "Gets a list of connected Joysticks.",
        "name": "love.joystick.getJoysticks",
        "params": [
            {
                "descr": "The list of currently connected Joysticks.",
                "name": "table joysticks"
            }
        ],
        "path": "love/love.joystick.getjoysticks",
        "syntax": "joysticks = love.joystick.getJoysticks( )",
        "type": "love.joystick"
    },
    "love.joystick.getName": {
        "descr": "Returns the name of a joystick.",
        "name": "love.joystick.getName",
        "params": [
            {
                "descr": "The joystick to be checked",
                "name": "number joystick"
            },
            {
                "descr": "The name",
                "name": "string name"
            }
        ],
        "path": "love/love.joystick.getname",
        "syntax": "name = love.joystick.getName( joystick )",
        "type": "love.joystick"
    },
    "love.joystick.getNumAxes": {
        "descr": "Returns the number of axes on the joystick.",
        "name": "love.joystick.getNumAxes",
        "params": [
            {
                "descr": "The joystick to be checked",
                "name": "number joystick"
            },
            {
                "descr": "The number of axes available",
                "name": "number axes"
            }
        ],
        "path": "love/love.joystick.getnumaxes",
        "syntax": "axes = love.joystick.getNumAxes( joystick )",
        "type": "love.joystick"
    },
    "love.joystick.getNumBalls": {
        "descr": "Returns the number of balls on the joystick.",
        "name": "love.joystick.getNumBalls",
        "params": [
            {
                "descr": "The joystick to be checked",
                "name": "number joystick"
            },
            {
                "descr": "The number of balls available",
                "name": "number balls"
            }
        ],
        "path": "love/love.joystick.getnumballs",
        "syntax": "balls = love.joystick.getNumBalls( joystick )",
        "type": "love.joystick"
    },
    "love.joystick.getNumButtons": {
        "descr": "Returns the number of buttons on the joystick.",
        "name": "love.joystick.getNumButtons",
        "params": [
            {
                "descr": "The joystick to be checked",
                "name": "number joystick"
            },
            {
                "descr": "The number of buttons available",
                "name": "number buttons"
            }
        ],
        "path": "love/love.joystick.getnumbuttons",
        "syntax": "buttons = love.joystick.getNumButtons( joystick )",
        "type": "love.joystick"
    },
    "love.joystick.getNumHats": {
        "descr": "Returns the number of hats on the joystick.",
        "name": "love.joystick.getNumHats",
        "params": [
            {
                "descr": "The joystick to be checked",
                "name": "number joystick"
            },
            {
                "descr": "How many hats the joystick has",
                "name": "number hats"
            }
        ],
        "path": "love/love.joystick.getnumhats",
        "syntax": "hats = love.joystick.getNumHats( joystick )",
        "type": "love.joystick"
    },
    "love.joystick.getNumJoysticks": {
        "descr": "Returns how many joysticks are available.",
        "name": "love.joystick.getNumJoysticks",
        "params": [
            {
                "descr": "The number of joysticks available",
                "name": "number joysticks"
            }
        ],
        "path": "love/love.joystick.getnumjoysticks",
        "syntax": "joysticks = love.joystick.getNumJoysticks( )",
        "type": "love.joystick"
    },
    "love.joystick.isDown": {
        "descr": "Checks if a button on a joystick is pressed.",
        "name": "love.joystick.isDown",
        "params": [
            {
                "descr": "The joystick to be checked",
                "name": "number joystick"
            },
            {
                "descr": "The button to be checked",
                "name": "number button"
            },
            {
                "descr": "True if the button is down, false if it is not",
                "name": "boolean down"
            }
        ],
        "path": "love/love.joystick.isdown",
        "syntax": "down = love.joystick.isDown( joystick, button )",
        "type": "love.joystick"
    },
    "love.joystick.isOpen": {
        "descr": "Checks if the joystick is open.",
        "name": "love.joystick.isOpen",
        "params": [
            {
                "descr": "The joystick to be checked",
                "name": "number joystick"
            },
            {
                "descr": "True if the joystick is open, false if it is closed.",
                "name": "boolean open"
            }
        ],
        "path": "love/love.joystick.isopen",
        "syntax": "open = love.joystick.isOpen( joystick )",
        "type": "love.joystick"
    },
    "love.joystick.loadGamepadMappings": {
        "descr": "Loads a gamepad mappings string or file created with love.joystick.saveGamepadMappings.",
        "name": "love.joystick.loadGamepadMappings",
        "params": [
            {
                "descr": "The filename to load the mappings string from.",
                "name": "string filename"
            }
        ],
        "path": "love/love.joystick.loadgamepadmappings",
        "syntax": "love.joystick.loadGamepadMappings( filename )",
        "type": "love.joystick"
    },
    "love.joystick.open": {
        "descr": "Opens up a joystick to be used, i.e. makes it ready to use. By default joysticks that are available at the start of your game will be opened.  NOTE: Unlike conventional Lua indexes, joysticks begin counting from 0 in LÖVE 0.7.2 and below. To to open the first joystick, you would use love.joystick.open(0). This is not the case in LÖVE 0.8.0 and later.",
        "name": "love.joystick.open",
        "params": [
            {
                "descr": "The joystick to be opened",
                "name": "number joystick"
            },
            {
                "descr": "True if the joystick has been successfully opened or false on failure.",
                "name": "boolean open"
            }
        ],
        "path": "love/love.joystick.open",
        "syntax": "open = love.joystick.open( joystick )",
        "type": "love.joystick"
    },
    "love.joystick.saveGamepadMappings": {
        "descr": "Saves the virtual gamepad mappings of all Joysticks that are recognized as gamepads and have either been recently used or their gamepad bindings have been modified.",
        "name": "love.joystick.saveGamepadMappings",
        "params": [
            {
                "descr": "The filename to save the mappings string to.",
                "name": "string filename"
            },
            {
                "descr": "The mappings string that was written to the file.",
                "name": "string mappings"
            }
        ],
        "path": "love/love.joystick.savegamepadmappings",
        "syntax": "mappings = love.joystick.saveGamepadMappings( filename )",
        "type": "love.joystick"
    },
    "love.joystick.setGamepadMapping": {
        "descr": "Binds a virtual gamepad input to a button, axis or hat for all Joysticks of a certain type. For example, if this function is used with a GUID returned by a Dualshock 3 controller in OS X, the binding will affect Joystick:getGamepadAxis and Joystick:isGamepadDown for all Dualshock 3 controllers used with the game when run in OS X.",
        "name": "love.joystick.setGamepadMapping",
        "params": [
            {
                "descr": "The OS-dependent GUID for the type of Joystick the binding will affect.",
                "name": "string guid"
            },
            {
                "descr": "The virtual gamepad button to bind.",
                "name": "GamepadButton button"
            },
            {
                "descr": "The type of input to bind the virtual gamepad button to.",
                "name": "JoystickInputType inputtype"
            },
            {
                "descr": "The index of the axis, button, or hat to bind the virtual gamepad button to.",
                "name": "number inputindex"
            },
            {
                "descr": "The direction of the hat, if the virtual gamepad button will be bound to a hat. ",
                "name": "JoystickHat hatdir (nil)"
            },
            {
                "descr": "Whether the virtual gamepad button was successfully bound.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.joystick.setgamepadmapping",
        "syntax": "success = love.joystick.setGamepadMapping( guid, button, inputtype, inputindex, hatdir )",
        "type": "love.joystick"
    },
    "love.joystickadded": {
        "descr": "Called when a Joystick is connected.",
        "name": "love.joystickadded",
        "params": [
            {
                "descr": "The newly connected Joystick object.",
                "name": "Joystick joystick"
            }
        ],
        "path": "love/love.joystickadded",
        "syntax": "love.joystickadded( joystick )",
        "type": "love"
    },
    "love.joystickaxis": {
        "descr": "Called when a joystick axis moves.",
        "name": "love.joystickaxis",
        "params": [
            {
                "descr": "The joystick object.",
                "name": "Joystick joystick"
            },
            {
                "descr": "The axis number.",
                "name": "number axis"
            },
            {
                "descr": "The new axis value.",
                "name": "number value"
            }
        ],
        "path": "love/love.joystickaxis",
        "syntax": "love.joystickaxis( joystick, axis, value )",
        "type": "love"
    },
    "love.joystickhat": {
        "descr": "Called when a joystick hat direction changes.",
        "name": "love.joystickhat",
        "params": [
            {
                "descr": "The joystick object.",
                "name": "Joystick joystick"
            },
            {
                "descr": "The hat number.",
                "name": "number hat"
            },
            {
                "descr": "The new hat direction.",
                "name": "JoystickHat direction"
            }
        ],
        "path": "love/love.joystickhat",
        "syntax": "love.joystickhat( joystick, hat, direction )",
        "type": "love"
    },
    "love.joystickpressed": {
        "descr": "Called when a joystick button is pressed.",
        "name": "love.joystickpressed",
        "params": [
            {
                "descr": "The joystick object.",
                "name": "Joystick joystick"
            },
            {
                "descr": "The button number.",
                "name": "number button"
            }
        ],
        "path": "love/love.joystickpressed",
        "syntax": "love.joystickpressed( joystick, button )",
        "type": "love"
    },
    "love.joystickreleased": {
        "descr": "Called when a joystick button is released.",
        "name": "love.joystickreleased",
        "params": [
            {
                "descr": "The joystick object.",
                "name": "Joystick joystick"
            },
            {
                "descr": "The button number.",
                "name": "number button"
            }
        ],
        "path": "love/love.joystickreleased",
        "syntax": "love.joystickreleased( joystick, button )",
        "type": "love"
    },
    "love.joystickremoved": {
        "descr": "Called when a Joystick is disconnected.",
        "name": "love.joystickremoved",
        "params": [
            {
                "descr": "The now-disconnected Joystick object.",
                "name": "Joystick joystick"
            }
        ],
        "path": "love/love.joystickremoved",
        "syntax": "love.joystickremoved( joystick )",
        "type": "love"
    },
    "love.keyboard.getKeyFromScancode": {
        "descr": "Gets the key corresponding to the given hardware scancode.",
        "name": "love.keyboard.getKeyFromScancode",
        "params": [
            {
                "descr": "The scancode to get the key from.",
                "name": "Scancode scancode"
            },
            {
                "descr": "The key corresponding to the given scancode, or \"unknown\" if the scancode doesn't map to a KeyConstant on the current system.",
                "name": "KeyConstant key"
            }
        ],
        "path": "love/love.keyboard.getkeyfromscancode",
        "syntax": "key = love.keyboard.getKeyFromScancode( scancode )",
        "type": "love.keyboard"
    },
    "love.keyboard.getKeyRepeat": {
        "descr": "Returns the delay and interval of key repeating.",
        "name": "love.keyboard.getKeyRepeat",
        "params": [
            {
                "descr": "The amount of time before repeating the key (in seconds)",
                "name": "number delay"
            },
            {
                "descr": "The amount of time between repeats (in seconds)",
                "name": "number interval"
            }
        ],
        "path": "love/love.keyboard.getkeyrepeat",
        "syntax": "delay, interval = love.keyboard.getKeyRepeat( )",
        "type": "love.keyboard"
    },
    "love.keyboard.getScancodeFromKey": {
        "descr": "Gets the hardware scancode corresponding to the given key.",
        "name": "love.keyboard.getScancodeFromKey",
        "params": [
            {
                "descr": "The key to get the scancode from.",
                "name": "KeyConstant key"
            },
            {
                "descr": "The scancode corresponding to the given key, or \"unknown\" if the given key has no known physical representation on the current system.",
                "name": "Scancode scancode"
            }
        ],
        "path": "love/love.keyboard.getscancodefromkey",
        "syntax": "scancode = love.keyboard.getScancodeFromKey( key )",
        "type": "love.keyboard"
    },
    "love.keyboard.hasKeyRepeat": {
        "descr": "Gets whether key repeat is enabled.",
        "name": "love.keyboard.hasKeyRepeat",
        "params": [
            {
                "descr": "Whether key repeat is enabled.",
                "name": "boolean enabled"
            }
        ],
        "path": "love/love.keyboard.haskeyrepeat",
        "syntax": "enabled = love.keyboard.hasKeyRepeat( )",
        "type": "love.keyboard"
    },
    "love.keyboard.hasTextInput": {
        "descr": "Gets whether text input events are enabled.",
        "name": "love.keyboard.hasTextInput",
        "params": [
            {
                "descr": "Whether text input events are enabled.",
                "name": "boolean enabled"
            }
        ],
        "path": "love/love.keyboard.hastextinput",
        "syntax": "enabled = love.keyboard.hasTextInput( )",
        "type": "love.keyboard"
    },
    "love.keyboard.isDown": {
        "descr": "Checks whether a certain key is down. Not to be confused with love.keypressed or love.keyreleased.",
        "name": "love.keyboard.isDown",
        "params": [
            {
                "descr": "The key to check.",
                "name": "KeyConstant key"
            },
            {
                "descr": "True if the key is down, false if not.",
                "name": "boolean down"
            }
        ],
        "path": "love/love.keyboard.isdown",
        "syntax": "down = love.keyboard.isDown( key )",
        "type": "love.keyboard"
    },
    "love.keyboard.isScancodeDown": {
        "descr": "Checks whether the specified Scancodes are pressed. Not to be confused with love.keypressed or love.keyreleased.",
        "name": "love.keyboard.isScancodeDown",
        "params": [
            {
                "descr": "A Scancode to check.",
                "name": "Scancode scancode"
            },
            {
                "descr": "Additional Scancodes to check.",
                "name": "Scancode ..."
            },
            {
                "descr": "True if any supplied Scancode is down, false if not.",
                "name": "boolean down"
            }
        ],
        "path": "love/love.keyboard.isscancodedown",
        "syntax": "down = love.keyboard.isScancodeDown( scancode, ... )",
        "type": "love.keyboard"
    },
    "love.keyboard.setKeyRepeat": {
        "descr": "Enables or disables key repeat for love.keypressed. It is disabled by default.",
        "name": "love.keyboard.setKeyRepeat",
        "params": [
            {
                "descr": "Whether repeat keypress events should be enabled when a key is held down.",
                "name": "boolean enable"
            }
        ],
        "path": "love/love.keyboard.setkeyrepeat",
        "syntax": "love.keyboard.setKeyRepeat( enable )",
        "type": "love.keyboard"
    },
    "love.keyboard.setTextInput": {
        "descr": "Enables or disables text input events. It is enabled by default on Windows, Mac, and Linux, and disabled by default on iOS and Android.",
        "name": "love.keyboard.setTextInput",
        "params": [
            {
                "descr": "Whether text input events should be enabled.",
                "name": "boolean enable"
            }
        ],
        "path": "love/love.keyboard.settextinput",
        "syntax": "love.keyboard.setTextInput( enable )",
        "type": "love.keyboard"
    },
    "love.keypressed": {
        "descr": "Callback function triggered when a key is pressed.",
        "name": "love.keypressed",
        "params": [
            {
                "descr": "Character of the pressed key.",
                "name": "KeyConstant key"
            },
            {
                "descr": "The scancode representing the pressed key.",
                "name": "Scancode scancode"
            },
            {
                "descr": "Whether this keypress event is a repeat. ",
                "name": "boolean isrepeat"
            }
        ],
        "path": "love/love.keypressed",
        "syntax": "love.keypressed( key, scancode, isrepeat )",
        "type": "love"
    },
    "love.keyreleased": {
        "descr": "Callback function triggered when a keyboard key is released.",
        "name": "love.keyreleased",
        "params": [
            {
                "descr": "Character of the released key.",
                "name": "KeyConstant key"
            }
        ],
        "path": "love/love.keyreleased",
        "syntax": "love.keyreleased( key )",
        "type": "love"
    },
    "love.load": {
        "descr": "This function is called exactly once at the beginning of the game.",
        "name": "love.load",
        "params": [
            {
                "descr": "Command line arguments given to the game.",
                "name": "table arg"
            }
        ],
        "path": "love/love.load",
        "syntax": "love.load( arg )",
        "type": "love"
    },
    "love.lowmemory": {
        "descr": "Callback function triggered when the system is running out of memory on mobile devices.",
        "name": "love.lowmemory",
        "params": [],
        "path": "love/love.lowmemory",
        "syntax": "love.lowmemory( )",
        "type": "love"
    },
    "love.math.compress": {
        "descr": "Compresses a string or data using a specific compression algorithm.",
        "name": "love.math.compress",
        "params": [
            {
                "descr": "The raw (un-compressed) string to compress.",
                "name": "string rawstring"
            },
            {
                "descr": "The format to use when compressing the string.",
                "name": "CompressedDataFormat format (\"lz4\")"
            },
            {
                "descr": "The level of compression to use, between 0 and 9. ",
                "name": "number level (-1)"
            },
            {
                "descr": "A new Data object containing the compressed version of the string.",
                "name": "CompressedData compressedData"
            }
        ],
        "path": "love/love.math.compress",
        "syntax": "compressedData = love.math.compress( rawstring, format, level )",
        "type": "love.math"
    },
    "love.math.decompress": {
        "descr": "Decompresses a CompressedData or previously compressed string or Data object.",
        "name": "love.math.decompress",
        "params": [
            {
                "descr": "The compressed data to decompress.",
                "name": "CompressedData compressedData"
            },
            {
                "descr": "A string containing the raw decompressed data.",
                "name": "string rawstring"
            }
        ],
        "path": "love/love.math.decompress",
        "syntax": "rawstring = love.math.decompress( compressedData )",
        "type": "love.math"
    },
    "love.math.gammaToLinear": {
        "descr": "Converts a color from gamma-space (sRGB) to linear-space (RGB). This is useful when doing gamma-correct rendering and you need to do math in linear RGB in the few cases where LÖVE doesn't handle conversions automatically.",
        "name": "love.math.gammaToLinear",
        "params": [
            {
                "descr": "The red channel of the sRGB color to convert.",
                "name": "number r"
            },
            {
                "descr": "The green channel of the sRGB color to convert.",
                "name": "number g"
            },
            {
                "descr": "The blue channel of the sRGB color to convert.",
                "name": "number b"
            },
            {
                "descr": "The red channel of the converted color in linear RGB space.",
                "name": "number lr"
            },
            {
                "descr": "The green channel of the converted color in linear RGB space.",
                "name": "number lg"
            },
            {
                "descr": "The blue channel of the converted color in linear RGB space.",
                "name": "number lb"
            }
        ],
        "path": "love/love.math.gammatolinear",
        "syntax": "lr, lg, lb = love.math.gammaToLinear( r, g, b )",
        "type": "love.math"
    },
    "love.math.getRandomSeed": {
        "descr": "Gets the seed of the random number generator.",
        "name": "love.math.getRandomSeed",
        "params": [
            {
                "descr": "Integer number representing the lower 32 bits of the random number generator's 64 bit seed value.",
                "name": "number low"
            },
            {
                "descr": "Integer number representing the higher 32 bits of the random number generator's 64 bit seed value.",
                "name": "number high"
            }
        ],
        "path": "love/love.math.getrandomseed",
        "syntax": "low, high = love.math.getRandomSeed( )",
        "type": "love.math"
    },
    "love.math.isConvex": {
        "descr": "Checks whether a polygon is convex.",
        "name": "love.math.isConvex",
        "params": [
            {
                "descr": "The vertices of the polygon as a table in the form of {x1, y1, x2, y2, x3, y3, ...}.",
                "name": "table vertices"
            },
            {
                "descr": "Whether the given polygon is convex.",
                "name": "boolean convex"
            }
        ],
        "path": "love/love.math.isconvex",
        "syntax": "convex = love.math.isConvex( vertices )",
        "type": "love.math"
    },
    "love.math.linearToGamma": {
        "descr": "Converts a color from linear-space (RGB) to gamma-space (sRGB). This is useful when storing linear RGB color values in an image, because the linear RGB color space has less precision than sRGB for dark colors, which can result in noticeable color banding when drawing.",
        "name": "love.math.linearToGamma",
        "params": [
            {
                "descr": "The red channel of the linear RGB color to convert.",
                "name": "number lr"
            },
            {
                "descr": "The green channel of the linear RGB color to convert.",
                "name": "number lg"
            },
            {
                "descr": "The blue channel of the linear RGB color to convert.",
                "name": "number lb"
            },
            {
                "descr": "The red channel of the converted color in gamma sRGB space.",
                "name": "number cr"
            },
            {
                "descr": "The green channel of the converted color in gamma sRGB space.",
                "name": "number cg"
            },
            {
                "descr": "The blue channel of the converted color in gamma sRGB space.",
                "name": "number cb"
            }
        ],
        "path": "love/love.math.lineartogamma",
        "syntax": "cr, cg, cb = love.math.linearToGamma( lr, lg, lb )",
        "type": "love.math"
    },
    "love.math.newBezierCurve": {
        "descr": "Creates a new BezierCurve object.",
        "name": "love.math.newBezierCurve",
        "params": [
            {
                "descr": "The vertices of the control polygon as a table in the form of {x1, y1, x2, y2, x3, y3, ...}.",
                "name": "table vertices"
            },
            {
                "descr": "A Bézier curve object.",
                "name": "BezierCurve curve"
            }
        ],
        "path": "love/love.math.newbeziercurve",
        "syntax": "curve = love.math.newBezierCurve( vertices )",
        "type": "love.math"
    },
    "love.math.newRandomGenerator": {
        "descr": "Creates a new RandomGenerator object which is completely independent of other RandomGenerator objects and random functions.",
        "name": "love.math.newRandomGenerator",
        "params": [
            {
                "descr": "The new Random Number Generator object.",
                "name": "RandomGenerator rng"
            }
        ],
        "path": "love/love.math.newrandomgenerator",
        "syntax": "rng = love.math.newRandomGenerator( )",
        "type": "love.math"
    },
    "love.math.noise": {
        "descr": "Generates a Simplex or Perlin noise value in 1-4 dimensions. The return value will always be the same, given the same arguments.",
        "name": "love.math.noise",
        "params": [
            {
                "descr": "The number used to generate the noise value.",
                "name": "number x"
            },
            {
                "descr": "The noise value in the range of [0, 1].",
                "name": "number value"
            }
        ],
        "path": "love/love.math.noise",
        "syntax": "value = love.math.noise( x )",
        "type": "love.math"
    },
    "love.math.random": {
        "descr": "Generates a pseudo-random number in a platform independent manner.",
        "name": "love.math.random",
        "params": [
            {
                "descr": "The pseudo-random number.",
                "name": "number number"
            }
        ],
        "path": "love/love.math.random",
        "syntax": "number = love.math.random( )",
        "type": "love.math"
    },
    "love.math.randomNormal": {
        "descr": "Get a normally distributed pseudo random number.",
        "name": "love.math.randomNormal",
        "params": [
            {
                "descr": "Standard deviation of the distribution.",
                "name": "number stddev (1)"
            },
            {
                "descr": "The mean of the distribution.",
                "name": "number mean (0)"
            },
            {
                "descr": "Normally distributed random number with variance (stddev)² and the specified mean.",
                "name": "number number"
            }
        ],
        "path": "love/love.math.randomnormal",
        "syntax": "number = love.math.randomNormal( stddev, mean )",
        "type": "love.math"
    },
    "love.math.setRandomSeed": {
        "descr": "Sets the seed of the random number generator using the specified integer number.",
        "name": "love.math.setRandomSeed",
        "params": [
            {
                "descr": "The integer number with which you want to seed the randomization. ",
                "name": "number seed"
            }
        ],
        "path": "love/love.math.setrandomseed",
        "syntax": "love.math.setRandomSeed( seed )",
        "type": "love.math"
    },
    "love.math.triangulate": {
        "descr": "Decomposes a simple convex or concave polygon into triangles.",
        "name": "love.math.triangulate",
        "params": [
            {
                "descr": "Polygon to triangulate. Must not intersect itself.",
                "name": "table polygon"
            },
            {
                "descr": "List of triangles the polygon is composed of, in the form of {{x1, y1, x2, y2, x3, y3}, {x1, y1, x2, y2, x3, y3}, ...}.",
                "name": "table triangles"
            }
        ],
        "path": "love/love.math.triangulate",
        "syntax": "triangles = love.math.triangulate( polygon )",
        "type": "love.math"
    },
    "love.mouse.getCursor": {
        "descr": "Gets the current Cursor.",
        "name": "love.mouse.getCursor",
        "params": [
            {
                "descr": "The current cursor, or nil if no cursor is set.",
                "name": "Cursor cursor (nil)"
            }
        ],
        "path": "love/love.mouse.getcursor",
        "syntax": "cursor = love.mouse.getCursor( )",
        "type": "love.mouse"
    },
    "love.mouse.getPosition": {
        "descr": "Returns the current position of the mouse.",
        "name": "love.mouse.getPosition",
        "params": [
            {
                "descr": "The position of the mouse along the x-axis.",
                "name": "number x"
            },
            {
                "descr": "The position of the mouse along the y-axis.",
                "name": "number y"
            }
        ],
        "path": "love/love.mouse.getposition",
        "syntax": "x, y = love.mouse.getPosition( )",
        "type": "love.mouse"
    },
    "love.mouse.getRelativeMode": {
        "descr": "Gets whether relative mode is enabled for the mouse.",
        "name": "love.mouse.getRelativeMode",
        "params": [
            {
                "descr": "True if relative mode is enabled, false if it's disabled.",
                "name": "boolean enabled"
            }
        ],
        "path": "love/love.mouse.getrelativemode",
        "syntax": "enabled = love.mouse.getRelativeMode( )",
        "type": "love.mouse"
    },
    "love.mouse.getSystemCursor": {
        "descr": "Gets a Cursor object representing a system-native hardware cursor.",
        "name": "love.mouse.getSystemCursor",
        "params": [
            {
                "descr": "The type of system cursor to get.",
                "name": "CursorType ctype"
            },
            {
                "descr": "The Cursor object representing the system cursor type.",
                "name": "Cursor cursor"
            }
        ],
        "path": "love/love.mouse.getsystemcursor",
        "syntax": "cursor = love.mouse.getSystemCursor( ctype )",
        "type": "love.mouse"
    },
    "love.mouse.getX": {
        "descr": "Returns the current x-position of the mouse.",
        "name": "love.mouse.getX",
        "params": [
            {
                "descr": "The position of the mouse along the x-axis.",
                "name": "number x"
            }
        ],
        "path": "love/love.mouse.getx",
        "syntax": "x = love.mouse.getX( )",
        "type": "love.mouse"
    },
    "love.mouse.getY": {
        "descr": "Returns the current y-position of the mouse.",
        "name": "love.mouse.getY",
        "params": [
            {
                "descr": "The position of the mouse along the y-axis.",
                "name": "number y"
            }
        ],
        "path": "love/love.mouse.gety",
        "syntax": "y = love.mouse.getY( )",
        "type": "love.mouse"
    },
    "love.mouse.hasCursor": {
        "descr": "Gets whether cursor functionality is supported.",
        "name": "love.mouse.hasCursor",
        "params": [
            {
                "descr": "Whether the system has cursor functionality.",
                "name": "boolean hascursor"
            }
        ],
        "path": "love/love.mouse.hascursor",
        "syntax": "hascursor = love.mouse.hasCursor( )",
        "type": "love.mouse"
    },
    "love.mouse.isDown": {
        "descr": "Checks whether a certain mouse button is down.",
        "name": "love.mouse.isDown",
        "params": [
            {
                "descr": "The index of a button to check. ",
                "name": "number button"
            },
            {
                "descr": "Additional button numbers to check.",
                "name": "number ..."
            },
            {
                "descr": "True if any specified button is down.",
                "name": "boolean down"
            }
        ],
        "path": "love/love.mouse.isdown",
        "syntax": "down = love.mouse.isDown( button, ... )",
        "type": "love.mouse"
    },
    "love.mouse.isGrabbed": {
        "descr": "Checks if the mouse is grabbed.",
        "name": "love.mouse.isGrabbed",
        "params": [
            {
                "descr": "True if the cursor is grabbed, false if it is not.",
                "name": "boolean grabbed"
            }
        ],
        "path": "love/love.mouse.isgrabbed",
        "syntax": "grabbed = love.mouse.isGrabbed( )",
        "type": "love.mouse"
    },
    "love.mouse.isVisible": {
        "descr": "Checks if the cursor is visible.",
        "name": "love.mouse.isVisible",
        "params": [
            {
                "descr": "True if the cursor to visible, false if the cursor is hidden.",
                "name": "boolean visible"
            }
        ],
        "path": "love/love.mouse.isvisible",
        "syntax": "visible = love.mouse.isVisible( )",
        "type": "love.mouse"
    },
    "love.mouse.newCursor": {
        "descr": "Creates a new hardware Cursor object from an image file or ImageData.",
        "name": "love.mouse.newCursor",
        "params": [
            {
                "descr": "The ImageData to use for the new Cursor.",
                "name": "ImageData imageData"
            },
            {
                "descr": "The x-coordinate in the ImageData of the cursor's hot spot.",
                "name": "number hotx (0)"
            },
            {
                "descr": "The y-coordinate in the ImageData of the cursor's hot spot.",
                "name": "number hoty (0)"
            },
            {
                "descr": "The new Cursor object.",
                "name": "Cursor cursor"
            }
        ],
        "path": "love/love.mouse.newcursor",
        "syntax": "cursor = love.mouse.newCursor( imageData, hotx, hoty )",
        "type": "love.mouse"
    },
    "love.mouse.setCursor": {
        "descr": "Sets the current mouse cursor.",
        "name": "love.mouse.setCursor",
        "params": [
            {
                "descr": "The Cursor object to use as the current mouse cursor.",
                "name": "Cursor cursor"
            }
        ],
        "path": "love/love.mouse.setcursor",
        "syntax": "love.mouse.setCursor( cursor )",
        "type": "love.mouse"
    },
    "love.mouse.setGrab": {
        "descr": "Grabs the mouse and confines it to the window.",
        "name": "love.mouse.setGrab",
        "params": [
            {
                "descr": "True to confine the mouse, false to let it leave the window.",
                "name": "boolean grab"
            }
        ],
        "path": "love/love.mouse.setgrab",
        "syntax": "love.mouse.setGrab( grab )",
        "type": "love.mouse"
    },
    "love.mouse.setGrabbed": {
        "descr": "Grabs the mouse and confines it to the window.",
        "name": "love.mouse.setGrabbed",
        "params": [
            {
                "descr": "True to confine the mouse, false to let it leave the window.",
                "name": "boolean grab"
            }
        ],
        "path": "love/love.mouse.setgrabbed",
        "syntax": "love.mouse.setGrabbed( grab )",
        "type": "love.mouse"
    },
    "love.mouse.setPosition": {
        "descr": "Sets the current position of the mouse.",
        "name": "love.mouse.setPosition",
        "params": [
            {
                "descr": "The new position of the mouse along the x-axis.",
                "name": "number x"
            },
            {
                "descr": "The new position of the mouse along the y-axis.",
                "name": "number y"
            }
        ],
        "path": "love/love.mouse.setposition",
        "syntax": "love.mouse.setPosition( x, y )",
        "type": "love.mouse"
    },
    "love.mouse.setRelativeMode": {
        "descr": "Sets whether relative mode is enabled for the mouse.",
        "name": "love.mouse.setRelativeMode",
        "params": [
            {
                "descr": "True to enable relative mode, false to disable it.",
                "name": "boolean enable"
            }
        ],
        "path": "love/love.mouse.setrelativemode",
        "syntax": "love.mouse.setRelativeMode( enable )",
        "type": "love.mouse"
    },
    "love.mouse.setVisible": {
        "descr": "Sets the current visibility of the cursor.",
        "name": "love.mouse.setVisible",
        "params": [
            {
                "descr": "True to set the cursor to visible, false to hide the cursor.",
                "name": "boolean visible"
            }
        ],
        "path": "love/love.mouse.setvisible",
        "syntax": "love.mouse.setVisible( visible )",
        "type": "love.mouse"
    },
    "love.mouse.setX": {
        "descr": "Sets the current X position of the mouse.",
        "name": "love.mouse.setX",
        "params": [
            {
                "descr": "The new position of the mouse along the x-axis.",
                "name": "number x"
            }
        ],
        "path": "love/love.mouse.setx",
        "syntax": "love.mouse.setX( x )",
        "type": "love.mouse"
    },
    "love.mouse.setY": {
        "descr": "Sets the current Y position of the mouse.",
        "name": "love.mouse.setY",
        "params": [
            {
                "descr": "The new position of the mouse along the y-axis.",
                "name": "number y"
            }
        ],
        "path": "love/love.mouse.sety",
        "syntax": "love.mouse.setY( y )",
        "type": "love.mouse"
    },
    "love.mousefocus": {
        "descr": "Callback function triggered when window receives or loses mouse focus.",
        "name": "love.mousefocus",
        "params": [
            {
                "descr": "Wether the window has mouse focus or not.",
                "name": "boolean focus"
            }
        ],
        "path": "love/love.mousefocus",
        "syntax": "love.mousefocus( focus )",
        "type": "love"
    },
    "love.mousemoved": {
        "descr": "Callback function triggered when the mouse is moved.",
        "name": "love.mousemoved",
        "params": [
            {
                "descr": "The mouse position on the x-axis.",
                "name": "number x"
            },
            {
                "descr": "The mouse position on the y-axis.",
                "name": "number y"
            },
            {
                "descr": "The amount moved along the x-axis since the last time love.mousemoved was called.",
                "name": "number dx"
            },
            {
                "descr": "The amount moved along the y-axis since the last time love.mousemoved was called.",
                "name": "number dy"
            },
            {
                "descr": "True if the mouse button press originated from a touchscreen touch-press.",
                "name": "boolean istouch"
            }
        ],
        "path": "love/love.mousemoved",
        "syntax": "love.mousemoved( x, y, dx, dy, istouch )",
        "type": "love"
    },
    "love.mousepressed": {
        "descr": "Callback function triggered when a mouse button is pressed.",
        "name": "love.mousepressed",
        "params": [
            {
                "descr": "Mouse x position, in pixels.",
                "name": "number x"
            },
            {
                "descr": "Mouse y position, in pixels.",
                "name": "number y"
            },
            {
                "descr": "The button index that was pressed. ",
                "name": "number button"
            },
            {
                "descr": "True if the mouse button press originated from a touchscreen touch-press.",
                "name": "boolean istouch"
            }
        ],
        "path": "love/love.mousepressed",
        "syntax": "love.mousepressed( x, y, button, istouch )",
        "type": "love"
    },
    "love.mousereleased": {
        "descr": "Callback function triggered when a mouse button is released.",
        "name": "love.mousereleased",
        "params": [
            {
                "descr": "Mouse x position, in pixels.",
                "name": "number x"
            },
            {
                "descr": "Mouse y position, in pixels.",
                "name": "number y"
            },
            {
                "descr": "The button index that was released. ",
                "name": "number button"
            },
            {
                "descr": "True if the mouse button release originated from a touchscreen touch-release.",
                "name": "boolean istouch"
            }
        ],
        "path": "love/love.mousereleased",
        "syntax": "love.mousereleased( x, y, button, istouch )",
        "type": "love"
    },
    "love.physics.getDistance": {
        "descr": "Returns the two closest points between two fixtures and their distance.",
        "name": "love.physics.getDistance",
        "params": [
            {
                "descr": "The first fixture.",
                "name": "Fixture fixture1"
            },
            {
                "descr": "The second fixture.",
                "name": "Fixture fixture2"
            },
            {
                "descr": "The distance of the two points.",
                "name": "number distance"
            },
            {
                "descr": "The x-coordinate of the first point.",
                "name": "number x1"
            },
            {
                "descr": "The y-coordinate of the first point.",
                "name": "number y1"
            },
            {
                "descr": "The x-coordinate of the second point.",
                "name": "number x2"
            },
            {
                "descr": "The y-coordinate of the second point.",
                "name": "number y2"
            }
        ],
        "path": "love/love.physics.getdistance",
        "syntax": "distance, x1, y1, x2, y2 = love.physics.getDistance( fixture1, fixture2 )",
        "type": "love.physics"
    },
    "love.physics.getMeter": {
        "descr": "Returns the meter scale factor.",
        "name": "love.physics.getMeter",
        "params": [
            {
                "descr": "The scale factor as an integer.",
                "name": "number scale"
            }
        ],
        "path": "love/love.physics.getmeter",
        "syntax": "scale = love.physics.getMeter( )",
        "type": "love.physics"
    },
    "love.physics.newBody": {
        "descr": "Creates a new body.",
        "name": "love.physics.newBody",
        "params": [
            {
                "descr": "The world to create the body in.",
                "name": "World world"
            },
            {
                "descr": "The x position of the body.",
                "name": "number x (0)"
            },
            {
                "descr": "The y position of the body.",
                "name": "number y (0)"
            },
            {
                "descr": "The type of the body.",
                "name": "BodyType type (\"static\")"
            },
            {
                "descr": "A new body.",
                "name": "Body body"
            }
        ],
        "path": "love/love.physics.newbody",
        "syntax": "body = love.physics.newBody( world, x, y, type )",
        "type": "love.physics"
    },
    "love.physics.newChainShape": {
        "descr": "Creates a new ChainShape.",
        "name": "love.physics.newChainShape",
        "params": [
            {
                "descr": "If the chain should loop back to the first point.",
                "name": "boolean loop"
            },
            {
                "descr": "The x position of the first point.",
                "name": "number x1"
            },
            {
                "descr": "The y position of the first point.",
                "name": "number y1"
            },
            {
                "descr": "The x position of the second point.",
                "name": "number x2"
            },
            {
                "descr": "The y position of the second point.",
                "name": "number y2"
            },
            {
                "descr": "Additional point positions.",
                "name": "number ..."
            },
            {
                "descr": "The new shape.",
                "name": "ChainShape shape"
            }
        ],
        "path": "love/love.physics.newchainshape",
        "syntax": "shape = love.physics.newChainShape( loop, x1, y1, x2, y2, ... )",
        "type": "love.physics"
    },
    "love.physics.newCircleShape": {
        "descr": "love.physics.newCircleShape needs a script example, help out by writing one.",
        "name": "love.physics.newCircleShape",
        "params": [
            {
                "descr": "The radius of the circle.",
                "name": "number radius"
            },
            {
                "descr": "The new shape.",
                "name": "CircleShape shape"
            }
        ],
        "path": "love/love.physics.newcircleshape",
        "syntax": "shape = love.physics.newCircleShape( radius )",
        "type": "love.physics"
    },
    "love.physics.newDistanceJoint": {
        "descr": "Creates a DistanceJoint between two bodies.",
        "name": "love.physics.newDistanceJoint",
        "params": [
            {
                "descr": "The first body to attach to the joint.",
                "name": "Body body1"
            },
            {
                "descr": "The second body to attach to the joint.",
                "name": "Body body2"
            },
            {
                "descr": "The x position of the first anchor point.",
                "name": "number x1"
            },
            {
                "descr": "The y position of the first anchor point.",
                "name": "number y1"
            },
            {
                "descr": "The x position of the second anchor point.",
                "name": "number x2"
            },
            {
                "descr": "The y position of the second anchor point.",
                "name": "number y2"
            },
            {
                "descr": "Specifies whether the two bodies should collide with each other.",
                "name": "boolean collideConnected (false)"
            },
            {
                "descr": "The new distance joint.",
                "name": "DistanceJoint joint"
            }
        ],
        "path": "love/love.physics.newdistancejoint",
        "syntax": "joint = love.physics.newDistanceJoint( body1, body2, x1, y1, x2, y2, collideConnected )",
        "type": "love.physics"
    },
    "love.physics.newEdgeShape": {
        "descr": "Creates a new EdgeShape.",
        "name": "love.physics.newEdgeShape",
        "params": [
            {
                "descr": "The x position of the first point.",
                "name": "number x1"
            },
            {
                "descr": "The y position of the first point.",
                "name": "number y1"
            },
            {
                "descr": "The x position of the second point.",
                "name": "number x2"
            },
            {
                "descr": "The y position of the second point.",
                "name": "number y2"
            },
            {
                "descr": "The new shape.",
                "name": "EdgeShape shape"
            }
        ],
        "path": "love/love.physics.newedgeshape",
        "syntax": "shape = love.physics.newEdgeShape( x1, y1, x2, y2 )",
        "type": "love.physics"
    },
    "love.physics.newFixture": {
        "descr": "Creates and attaches a Fixture to a body.",
        "name": "love.physics.newFixture",
        "params": [
            {
                "descr": "The body which gets the fixture attached.",
                "name": "Body body"
            },
            {
                "descr": "The shape to be copied to the fixture.",
                "name": "Shape shape"
            },
            {
                "descr": "The density of the fixture.",
                "name": "number density (1)"
            },
            {
                "descr": "The new fixture.",
                "name": "Fixture fixture"
            }
        ],
        "path": "love/love.physics.newfixture",
        "syntax": "fixture = love.physics.newFixture( body, shape, density )",
        "type": "love.physics"
    },
    "love.physics.newFrictionJoint": {
        "descr": "Create a friction joint between two bodies. A FrictionJoint applies friction to a body.",
        "name": "love.physics.newFrictionJoint",
        "params": [
            {
                "descr": "The first body to attach to the joint.",
                "name": "Body body1"
            },
            {
                "descr": "The second body to attach to the joint.",
                "name": "Body body2"
            },
            {
                "descr": "The x position of the anchor point.",
                "name": "number x"
            },
            {
                "descr": "The y position of the anchor point.",
                "name": "number y"
            },
            {
                "descr": "Specifies whether the two bodies should collide with each other.",
                "name": "boolean collideConnected (false)"
            },
            {
                "descr": "The new FrictionJoint.",
                "name": "FrictionJoint joint"
            }
        ],
        "path": "love/love.physics.newfrictionjoint",
        "syntax": "joint = love.physics.newFrictionJoint( body1, body2, x, y, collideConnected )",
        "type": "love.physics"
    },
    "love.physics.newGearJoint": {
        "descr": "Create a GearJoint connecting two Joints.",
        "name": "love.physics.newGearJoint",
        "params": [
            {
                "descr": "The first joint to connect with a gear joint.",
                "name": "Joint joint1"
            },
            {
                "descr": "The second joint to connect with a gear joint.",
                "name": "Joint joint2"
            },
            {
                "descr": "The gear ratio.",
                "name": "number ratio (1)"
            },
            {
                "descr": "Specifies whether the two bodies should collide with each other.",
                "name": "boolean collideConnected (false)"
            },
            {
                "descr": "The new gear joint.",
                "name": "GearJoint joint"
            }
        ],
        "path": "love/love.physics.newgearjoint",
        "syntax": "joint = love.physics.newGearJoint( joint1, joint2, ratio, collideConnected )",
        "type": "love.physics"
    },
    "love.physics.newMotorJoint": {
        "descr": "Creates a joint between two bodies which controls the relative motion between them.",
        "name": "love.physics.newMotorJoint",
        "params": [
            {
                "descr": "The first body to attach to the joint.",
                "name": "Body body1"
            },
            {
                "descr": "The second body to attach to the joint.",
                "name": "Body body2"
            },
            {
                "descr": "The joint's initial position correction factor, in the range of [0, 1].",
                "name": "number correctionFactor (0.3)"
            },
            {
                "descr": "The new MotorJoint.",
                "name": "MotorJoint joint"
            }
        ],
        "path": "love/love.physics.newmotorjoint",
        "syntax": "joint = love.physics.newMotorJoint( body1, body2, correctionFactor )",
        "type": "love.physics"
    },
    "love.physics.newMouseJoint": {
        "descr": "Create a joint between a body and the mouse.",
        "name": "love.physics.newMouseJoint",
        "params": [
            {
                "descr": "The body to attach to the mouse.",
                "name": "Body body"
            },
            {
                "descr": "The x position of the connecting point.",
                "name": "number x"
            },
            {
                "descr": "The y position of the connecting point.",
                "name": "number y"
            },
            {
                "descr": "The new mouse joint.",
                "name": "Joint joint"
            }
        ],
        "path": "love/love.physics.newmousejoint",
        "syntax": "joint = love.physics.newMouseJoint( body, x, y )",
        "type": "love.physics"
    },
    "love.physics.newPolygonShape": {
        "descr": "Creates a new PolygonShape.",
        "name": "love.physics.newPolygonShape",
        "params": [
            {
                "descr": "The x position of the first point.",
                "name": "number x1"
            },
            {
                "descr": "The y position of the first point.",
                "name": "number y1"
            },
            {
                "descr": "The x position of the second point.",
                "name": "number x2"
            },
            {
                "descr": "The y position of the second point.",
                "name": "number y2"
            },
            {
                "descr": "The x position of the third point.",
                "name": "number x3"
            },
            {
                "descr": "The y position of the third point.",
                "name": "number y3"
            },
            {
                "descr": "You can continue passing more point positions to create the PolygonShape.",
                "name": "number ..."
            },
            {
                "descr": "A new PolygonShape.",
                "name": "PolygonShape shape"
            }
        ],
        "path": "love/love.physics.newpolygonshape",
        "syntax": "shape = love.physics.newPolygonShape( x1, y1, x2, y2, x3, y3, ... )",
        "type": "love.physics"
    },
    "love.physics.newPrismaticJoint": {
        "descr": "Creates a PrismaticJoint between two bodies.",
        "name": "love.physics.newPrismaticJoint",
        "params": [
            {
                "descr": "The first body to connect with a prismatic joint.",
                "name": "Body body1"
            },
            {
                "descr": "The second body to connect with a prismatic joint.",
                "name": "Body body2"
            },
            {
                "descr": "The x coordinate of the anchor point.",
                "name": "number x"
            },
            {
                "descr": "The y coordinate of the anchor point.",
                "name": "number y"
            },
            {
                "descr": "The x coordinate of the axis vector.",
                "name": "number ax"
            },
            {
                "descr": "The y coordinate of the axis vector.",
                "name": "number ay"
            },
            {
                "descr": "Specifies whether the two bodies should collide with each other.",
                "name": "boolean collideConnected (false)"
            },
            {
                "descr": "The new prismatic joint.",
                "name": "PrismaticJoint joint"
            }
        ],
        "path": "love/love.physics.newprismaticjoint",
        "syntax": "joint = love.physics.newPrismaticJoint( body1, body2, x, y, ax, ay, collideConnected )",
        "type": "love.physics"
    },
    "love.physics.newPulleyJoint": {
        "descr": "Creates a PulleyJoint to join two bodies to each other and the ground.",
        "name": "love.physics.newPulleyJoint",
        "params": [
            {
                "descr": "The first body to connect with a pulley joint.",
                "name": "Body body1"
            },
            {
                "descr": "The second body to connect with a pulley joint.",
                "name": "Body body2"
            },
            {
                "descr": "The x coordinate of the first body's ground anchor.",
                "name": "number gx1"
            },
            {
                "descr": "The y coordinate of the first body's ground anchor.",
                "name": "number gy1"
            },
            {
                "descr": "The x coordinate of the second body's ground anchor.",
                "name": "number gx2"
            },
            {
                "descr": "The y coordinate of the second body's ground anchor.",
                "name": "number gy2"
            },
            {
                "descr": "The x coordinate of the pulley joint anchor in the first body.",
                "name": "number x1"
            },
            {
                "descr": "The y coordinate of the pulley joint anchor in the first body.",
                "name": "number y1"
            },
            {
                "descr": "The x coordinate of the pulley joint anchor in the second body.",
                "name": "number x2"
            },
            {
                "descr": "The y coordinate of the pulley joint anchor in the second body.",
                "name": "number y2"
            },
            {
                "descr": "The joint ratio.",
                "name": "number ratio (1)"
            },
            {
                "descr": "Specifies whether the two bodies should collide with each other.",
                "name": "boolean collideConnected (true)"
            },
            {
                "descr": "The new pulley joint.",
                "name": "PulleyJoint joint"
            }
        ],
        "path": "love/love.physics.newpulleyjoint",
        "syntax": "joint = love.physics.newPulleyJoint( body1, body2, gx1, gy1, gx2, gy2, x1, y1, x2, y2, ratio, collideConnected )",
        "type": "love.physics"
    },
    "love.physics.newRectangleShape": {
        "descr": "Shorthand for creating rectanglar PolygonShapes.",
        "name": "love.physics.newRectangleShape",
        "params": [
            {
                "descr": "The width of the rectangle.",
                "name": "number width"
            },
            {
                "descr": "The height of the rectangle.",
                "name": "number height"
            },
            {
                "descr": "A new PolygonShape.",
                "name": "PolygonShape shape"
            }
        ],
        "path": "love/love.physics.newrectangleshape",
        "syntax": "shape = love.physics.newRectangleShape( width, height )",
        "type": "love.physics"
    },
    "love.physics.newRevoluteJoint": {
        "descr": "Creates a pivot joint between two bodies.",
        "name": "love.physics.newRevoluteJoint",
        "params": [
            {
                "descr": "The first body.",
                "name": "Body body1"
            },
            {
                "descr": "The second body.",
                "name": "Body body2"
            },
            {
                "descr": "The x position of the connecting point.",
                "name": "number x"
            },
            {
                "descr": "The y position of the connecting point.",
                "name": "number y"
            },
            {
                "descr": "Specifies whether the two bodies should collide with each other.",
                "name": "boolean collideConnected (false)"
            },
            {
                "descr": "The new revolute joint.",
                "name": "Joint joint"
            }
        ],
        "path": "love/love.physics.newrevolutejoint",
        "syntax": "joint = love.physics.newRevoluteJoint( body1, body2, x, y, collideConnected )",
        "type": "love.physics"
    },
    "love.physics.newRopeJoint": {
        "descr": "Creates a joint between two bodies. Its only function is enforcing a max distance between these bodies.",
        "name": "love.physics.newRopeJoint",
        "params": [
            {
                "descr": "The first body to attach to the joint.",
                "name": "Body body1"
            },
            {
                "descr": "The second body to attach to the joint.",
                "name": "Body body2"
            },
            {
                "descr": "The x position of the first anchor point.",
                "name": "number x1"
            },
            {
                "descr": "The y position of the first anchor point.",
                "name": "number y1"
            },
            {
                "descr": "The x position of the second anchor point.",
                "name": "number x2"
            },
            {
                "descr": "The y position of the second anchor point.",
                "name": "number y2"
            },
            {
                "descr": "The maximum distance for the bodies.",
                "name": "number maxLength"
            },
            {
                "descr": "Specifies whether the two bodies should collide with each other.",
                "name": "boolean collideConnected (false)"
            },
            {
                "descr": "The new RopeJoint.",
                "name": "RopeJoint joint"
            }
        ],
        "path": "love/love.physics.newropejoint",
        "syntax": "joint = love.physics.newRopeJoint( body1, body2, x1, y1, x2, y2, maxLength, collideConnected )",
        "type": "love.physics"
    },
    "love.physics.newWeldJoint": {
        "descr": "Creates a constraint joint between two bodies. A WeldJoint essentially glues two bodies together. The constraint is a bit soft, however, due to Box2D's iterative solver.",
        "name": "love.physics.newWeldJoint",
        "params": [
            {
                "descr": "The first body to attach to the joint.",
                "name": "Body body1"
            },
            {
                "descr": "The second body to attach to the joint.",
                "name": "Body body2"
            },
            {
                "descr": "The x position of the anchor point (world space).",
                "name": "number x"
            },
            {
                "descr": "The y position of the anchor point (world space).",
                "name": "number y"
            },
            {
                "descr": "Specifies whether the two bodies should collide with each other.",
                "name": "boolean collideConnected (false)"
            },
            {
                "descr": "The new WeldJoint.",
                "name": "WeldJoint joint"
            }
        ],
        "path": "love/love.physics.newweldjoint",
        "syntax": "joint = love.physics.newWeldJoint( body1, body2, x, y, collideConnected )",
        "type": "love.physics"
    },
    "love.physics.newWheelJoint": {
        "descr": "Creates a wheel joint.",
        "name": "love.physics.newWheelJoint",
        "params": [
            {
                "descr": "The first body.",
                "name": "Body body1"
            },
            {
                "descr": "The second body.",
                "name": "Body body2"
            },
            {
                "descr": "The x position of the anchor point.",
                "name": "number x"
            },
            {
                "descr": "The y position of the anchor point.",
                "name": "number y"
            },
            {
                "descr": "The x position of the axis unit vector.",
                "name": "number ax"
            },
            {
                "descr": "The y position of the axis unit vector.",
                "name": "number ay"
            },
            {
                "descr": "Specifies whether the two bodies should collide with each other.",
                "name": "boolean collideConnected (false)"
            },
            {
                "descr": "The new WheelJoint.",
                "name": "WheelJoint joint"
            }
        ],
        "path": "love/love.physics.newwheeljoint",
        "syntax": "joint = love.physics.newWheelJoint( body1, body2, x, y, ax, ay, collideConnected )",
        "type": "love.physics"
    },
    "love.physics.newWorld": {
        "descr": "Creates a new World.",
        "name": "love.physics.newWorld",
        "params": [
            {
                "descr": "The x component of gravity.",
                "name": "number xg (0)"
            },
            {
                "descr": "The y component of gravity.",
                "name": "number yg (0)"
            },
            {
                "descr": "Whether the bodies in this world are allowed to sleep.",
                "name": "boolean sleep (true)"
            },
            {
                "descr": "A brave new World.",
                "name": "World world"
            }
        ],
        "path": "love/love.physics.newworld",
        "syntax": "world = love.physics.newWorld( xg, yg, sleep )",
        "type": "love.physics"
    },
    "love.physics.setMeter": {
        "descr": "Sets the pixels to meter scale factor.",
        "name": "love.physics.setMeter",
        "params": [
            {
                "descr": "The scale factor as an integer.",
                "name": "number scale"
            }
        ],
        "path": "love/love.physics.setmeter",
        "syntax": "love.physics.setMeter( scale )",
        "type": "love.physics"
    },
    "love.quit": {
        "descr": "Callback function triggered when the game is closed.",
        "name": "love.quit",
        "params": [
            {
                "descr": "Abort quitting. If true, do not close the game.",
                "name": "boolean r"
            }
        ],
        "path": "love/love.quit",
        "syntax": "r = love.quit( )",
        "type": "love"
    },
    "love.releaseerrhand": {
        "descr": "Nothing.",
        "name": "love.releaseerrhand",
        "params": [
            {
                "descr": "The error message.",
                "name": "string msg"
            }
        ],
        "path": "love/love.releaseerrhand",
        "syntax": "love.releaseerrhand( msg )",
        "type": "love"
    },
    "love.resize": {
        "descr": "Called when the window is resized, for example if the user resizes the window, or if love.window.setMode is called with an unsupported width or height in fullscreen and the window chooses the closest appropriate size.",
        "name": "love.resize",
        "params": [
            {
                "descr": "The new width, in pixels.",
                "name": "number w"
            },
            {
                "descr": "The new height, in pixels.",
                "name": "number h"
            }
        ],
        "path": "love/love.resize",
        "syntax": "love.resize( w, h )",
        "type": "love"
    },
    "love.run": {
        "descr": "The main function, containing the main loop. A sensible default is used when left out.",
        "name": "love.run",
        "params": [],
        "path": "love/love.run",
        "syntax": "love.run( )",
        "type": "love"
    },
    "love.sound.newDecoder": {
        "descr": "Attempts to find a decoder for the encoded sound data in the specified file.",
        "name": "love.sound.newDecoder",
        "params": [
            {
                "descr": "The file with encoded sound data.",
                "name": "File file"
            },
            {
                "descr": "The size of each decoded chunk, in bytes.",
                "name": "number buffer (2048)"
            },
            {
                "descr": "A new Decoder object.",
                "name": "Decoder decoder"
            }
        ],
        "path": "love/love.sound.newdecoder",
        "syntax": "decoder = love.sound.newDecoder( file, buffer )",
        "type": "love.sound"
    },
    "love.sound.newSoundData": {
        "descr": "Creates new SoundData from a filepath, File, or Decoder. It's also possible to create SoundData with a custom sample rate, channel and bit depth.",
        "name": "love.sound.newSoundData",
        "params": [
            {
                "descr": "The file name of the file to load.",
                "name": "string filename"
            },
            {
                "descr": "A new SoundData object.",
                "name": "SoundData soundData"
            }
        ],
        "path": "love/love.sound.newsounddata",
        "syntax": "soundData = love.sound.newSoundData( filename )",
        "type": "love.sound"
    },
    "love.system.getClipboardText": {
        "descr": "Gets text from the clipboard.",
        "name": "love.system.getClipboardText",
        "params": [
            {
                "descr": "The text currently held in the system's clipboard.",
                "name": "string text"
            }
        ],
        "path": "love/love.system.getclipboardtext",
        "syntax": "text = love.system.getClipboardText( )",
        "type": "love.system"
    },
    "love.system.getOS": {
        "descr": "Gets the current operating system. In general, LÖVE abstracts away the need to know the current operating system, but there are a few cases where it can be useful (especially in combination with os.execute.)",
        "name": "love.system.getOS",
        "params": [
            {
                "descr": "The current operating system. \"OS X\", \"Windows\", \"Linux\", \"Android\" or \"iOS\".",
                "name": "string osString"
            }
        ],
        "path": "love/love.system.getos",
        "syntax": "osString = love.system.getOS( )",
        "type": "love.system"
    },
    "love.system.getPowerInfo": {
        "descr": "Gets information about the system's power supply.",
        "name": "love.system.getPowerInfo",
        "params": [
            {
                "descr": "The basic state of the power supply.",
                "name": "PowerState state"
            },
            {
                "descr": "Percentage of battery life left, between 0 and 100. ",
                "name": "number percent (nil)"
            },
            {
                "descr": "Seconds of battery life left. nil if the value can't be determined or there's no battery.",
                "name": "number seconds (nil)"
            }
        ],
        "path": "love/love.system.getpowerinfo",
        "syntax": "state, percent, seconds = love.system.getPowerInfo( )",
        "type": "love.system"
    },
    "love.system.getProcessorCount": {
        "descr": "Gets the number of CPU cores in the system.",
        "name": "love.system.getProcessorCount",
        "params": [
            {
                "descr": "The number of CPU cores.",
                "name": "number cores"
            }
        ],
        "path": "love/love.system.getprocessorcount",
        "syntax": "cores = love.system.getProcessorCount( )",
        "type": "love.system"
    },
    "love.system.openURL": {
        "descr": "Opens a URL with the user's web or file browser.",
        "name": "love.system.openURL",
        "params": [
            {
                "descr": "The URL to open. Must be formatted as a proper URL.",
                "name": "string url"
            },
            {
                "descr": "Whether the URL was opened successfully.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.system.openurl",
        "syntax": "success = love.system.openURL( url )",
        "type": "love.system"
    },
    "love.system.setClipboardText": {
        "descr": "Puts text in the clipboard.",
        "name": "love.system.setClipboardText",
        "params": [
            {
                "descr": "The new text to hold in the system's clipboard.",
                "name": "string text"
            }
        ],
        "path": "love/love.system.setclipboardtext",
        "syntax": "love.system.setClipboardText( text )",
        "type": "love.system"
    },
    "love.system.vibrate": {
        "descr": "Causes the device to vibrate, if possible. Currently this will only work on Android and iOS devices that have a built-in vibration motor.",
        "name": "love.system.vibrate",
        "params": [
            {
                "descr": "The duration to vibrate for. If called on an iOS device, it will always vibrate for 0.5 seconds due to limitations in the iOS system APIs.",
                "name": "number seconds (0.5)"
            }
        ],
        "path": "love/love.system.vibrate",
        "syntax": "love.system.vibrate( seconds )",
        "type": "love.system"
    },
    "love.textedited": {
        "descr": "Called when the candidate text for an IME (Input Method Editor) has changed.",
        "name": "love.textedited",
        "params": [
            {
                "descr": "The UTF-8 encoded unicode candidate text.",
                "name": "string text"
            },
            {
                "descr": "The start cursor of the selected candidate text.",
                "name": "number start"
            },
            {
                "descr": "The length of the selected candidate text. ",
                "name": "number length"
            }
        ],
        "path": "love/love.textedited",
        "syntax": "love.textedited( text, start, length )",
        "type": "love"
    },
    "love.textinput": {
        "descr": "Called when text has been entered by the user. For example if shift-2 is pressed on an American keyboard layout, the text \"@\" will be generated.",
        "name": "love.textinput",
        "params": [
            {
                "descr": "The UTF-8 encoded unicode text.",
                "name": "string text"
            }
        ],
        "path": "love/love.textinput",
        "syntax": "love.textinput( text )",
        "type": "love"
    },
    "love.thread.getChannel": {
        "descr": "Creates or retrieves a named thread channel.",
        "name": "love.thread.getChannel",
        "params": [
            {
                "descr": "The name of the channel you want to create or retrieve.",
                "name": "string name"
            },
            {
                "descr": "The Channel object associated with the name.",
                "name": "Channel channel"
            }
        ],
        "path": "love/love.thread.getchannel",
        "syntax": "channel = love.thread.getChannel( name )",
        "type": "love.thread"
    },
    "love.thread.getThread": {
        "descr": "Look for a thread and get its object.",
        "name": "love.thread.getThread",
        "params": [
            {
                "descr": "The name of the thread to return.",
                "name": "string name"
            },
            {
                "descr": "The thread with that name.",
                "name": "Thread thread"
            }
        ],
        "path": "love/love.thread.getthread",
        "syntax": "thread = love.thread.getThread( name )",
        "type": "love.thread"
    },
    "love.thread.getThreads": {
        "descr": "Get all threads.",
        "name": "love.thread.getThreads",
        "params": [
            {
                "descr": "A table containing all threads indexed by their names.",
                "name": "table threads"
            }
        ],
        "path": "love/love.thread.getthreads",
        "syntax": "threads = love.thread.getThreads( )",
        "type": "love.thread"
    },
    "love.thread.newChannel": {
        "descr": "Create a new unnamed thread channel.",
        "name": "love.thread.newChannel",
        "params": [
            {
                "descr": "The new Channel object.",
                "name": "Channel channel"
            }
        ],
        "path": "love/love.thread.newchannel",
        "syntax": "channel = love.thread.newChannel( )",
        "type": "love.thread"
    },
    "love.thread.newThread": {
        "descr": "Creates a new Thread from a Lua file or FileData object.",
        "name": "love.thread.newThread",
        "params": [
            {
                "descr": "The name of the Lua file to use as the source.",
                "name": "string filename"
            },
            {
                "descr": "A new Thread that has yet to be started.",
                "name": "Thread thread"
            }
        ],
        "path": "love/love.thread.newthread",
        "syntax": "thread = love.thread.newThread( filename )",
        "type": "love.thread"
    },
    "love.threaderror": {
        "descr": "Callback function triggered when a Thread encounters an error.",
        "name": "love.threaderror",
        "params": [
            {
                "descr": "The thread which produced the error.",
                "name": "Thread thread"
            },
            {
                "descr": "The error message.",
                "name": "string errorstr"
            }
        ],
        "path": "love/love.threaderror",
        "syntax": "love.threaderror( thread, errorstr )",
        "type": "love"
    },
    "love.timer.getAverageDelta": {
        "descr": "Returns the average delta time (seconds per frame) over the last second.",
        "name": "love.timer.getAverageDelta",
        "params": [
            {
                "descr": "The average delta time over the last second.",
                "name": "number delta"
            }
        ],
        "path": "love/love.timer.getaveragedelta",
        "syntax": "delta = love.timer.getAverageDelta( )",
        "type": "love.timer"
    },
    "love.timer.getDelta": {
        "descr": "Returns the time between the last two frames.",
        "name": "love.timer.getDelta",
        "params": [
            {
                "descr": "The time passed (in seconds).",
                "name": "number dt"
            }
        ],
        "path": "love/love.timer.getdelta",
        "syntax": "dt = love.timer.getDelta( )",
        "type": "love.timer"
    },
    "love.timer.getFPS": {
        "descr": "Returns the current frames per second.",
        "name": "love.timer.getFPS",
        "params": [
            {
                "descr": "The current FPS.",
                "name": "number fps"
            }
        ],
        "path": "love/love.timer.getfps",
        "syntax": "fps = love.timer.getFPS( )",
        "type": "love.timer"
    },
    "love.timer.getMicroTime": {
        "descr": "Returns the value of a timer with an unspecified starting time. The time is accurate to the microsecond.",
        "name": "love.timer.getMicroTime",
        "params": [
            {
                "descr": "The time passed in seconds.",
                "name": "number t"
            }
        ],
        "path": "love/love.timer.getmicrotime",
        "syntax": "t = love.timer.getMicroTime( )",
        "type": "love.timer"
    },
    "love.timer.getTime": {
        "descr": "Returns the value of a timer with an unspecified starting time. This function should only be used to calculate differences between points in time, as the starting time of the timer is unknown.",
        "name": "love.timer.getTime",
        "params": [
            {
                "descr": "The time in seconds.",
                "name": "number time"
            }
        ],
        "path": "love/love.timer.gettime",
        "syntax": "time = love.timer.getTime( )",
        "type": "love.timer"
    },
    "love.timer.sleep": {
        "descr": "Pauses the current thread for the specified amount of time.",
        "name": "love.timer.sleep",
        "params": [
            {
                "descr": "Seconds to sleep for.",
                "name": "number s"
            }
        ],
        "path": "love/love.timer.sleep",
        "syntax": "love.timer.sleep( s )",
        "type": "love.timer"
    },
    "love.timer.step": {
        "descr": "Measures the time between two frames. Calling this changes the return value of love.timer.getDelta.",
        "name": "love.timer.step",
        "params": [],
        "path": "love/love.timer.step",
        "syntax": "love.timer.step( )",
        "type": "love.timer"
    },
    "love.touch.getPosition": {
        "descr": "Gets the current position of the specified touch-press, in pixels.",
        "name": "love.touch.getPosition",
        "params": [
            {
                "descr": "The identifier of the touch-press. ",
                "name": "light userdata id"
            },
            {
                "descr": "The position along the x-axis of the touch-press inside the window, in pixels.",
                "name": "number x"
            },
            {
                "descr": "The position along the y-axis of the touch-press inside the window, in pixels.",
                "name": "number y"
            }
        ],
        "path": "love/love.touch.getposition",
        "syntax": "x, y = love.touch.getPosition( id )",
        "type": "love.touch"
    },
    "love.touch.getPressure": {
        "descr": "Gets the current pressure of the specified touch-press.",
        "name": "love.touch.getPressure",
        "params": [
            {
                "descr": "The identifier of the touch-press. ",
                "name": "light userdata id"
            },
            {
                "descr": "The pressure of the touch-press. ",
                "name": "number pressure"
            }
        ],
        "path": "love/love.touch.getpressure",
        "syntax": "pressure = love.touch.getPressure( id )",
        "type": "love.touch"
    },
    "love.touch.getTouches": {
        "descr": "Gets a list of all active touch-presses.",
        "name": "love.touch.getTouches",
        "params": [
            {
                "descr": "A list of active touch-press id values, which can be used with love.touch.getPosition.",
                "name": "table touches"
            }
        ],
        "path": "love/love.touch.gettouches",
        "syntax": "touches = love.touch.getTouches( )",
        "type": "love.touch"
    },
    "love.touchmoved": {
        "descr": "Callback function triggered when a touch press moves inside the touch screen.",
        "name": "love.touchmoved",
        "params": [
            {
                "descr": "The identifier for the touch press.",
                "name": "light userdata id"
            },
            {
                "descr": "The x-axis position of the touch inside the window, in pixels.",
                "name": "number x"
            },
            {
                "descr": "The y-axis position of the touch inside the window, in pixels.",
                "name": "number y"
            },
            {
                "descr": "The x-axis movement of the touch inside the window, in pixels.",
                "name": "number dx"
            },
            {
                "descr": "The y-axis movement of the touch inside the window, in pixels.",
                "name": "number dy"
            },
            {
                "descr": "The amount of pressure being applied. ",
                "name": "number pressure"
            }
        ],
        "path": "love/love.touchmoved",
        "syntax": "love.touchmoved( id, x, y, dx, dy, pressure )",
        "type": "love"
    },
    "love.touchpressed": {
        "descr": "Callback function triggered when the touch screen is touched.",
        "name": "love.touchpressed",
        "params": [
            {
                "descr": "The identifier for the touch press.",
                "name": "light userdata id"
            },
            {
                "descr": "The x-axis position of the touch press inside the window, in pixels.",
                "name": "number x"
            },
            {
                "descr": "The y-axis position of the touch press inside the window, in pixels.",
                "name": "number y"
            },
            {
                "descr": "The x-axis movement of the touch press inside the window, in pixels. ",
                "name": "number dx"
            },
            {
                "descr": "The y-axis movement of the touch press inside the window, in pixels. ",
                "name": "number dy"
            },
            {
                "descr": "The amount of pressure being applied. ",
                "name": "number pressure"
            }
        ],
        "path": "love/love.touchpressed",
        "syntax": "love.touchpressed( id, x, y, dx, dy, pressure )",
        "type": "love"
    },
    "love.touchreleased": {
        "descr": "Callback function triggered when the touch screen stops being touched.",
        "name": "love.touchreleased",
        "params": [
            {
                "descr": "The identifier for the touch press.",
                "name": "light userdata id"
            },
            {
                "descr": "The x-axis position of the touch inside the window, in pixels.",
                "name": "number x"
            },
            {
                "descr": "The y-axis position of the touch inside the window, in pixels.",
                "name": "number y"
            },
            {
                "descr": "The x-axis movement of the touch inside the window, in pixels.",
                "name": "number dx"
            },
            {
                "descr": "The y-axis movement of the touch inside the window, in pixels.",
                "name": "number dy"
            },
            {
                "descr": "The amount of pressure being applied. ",
                "name": "number pressure"
            }
        ],
        "path": "love/love.touchreleased",
        "syntax": "love.touchreleased( id, x, y, dx, dy, pressure )",
        "type": "love"
    },
    "love.update": {
        "descr": "Callback function used to update the state of the game every frame.",
        "name": "love.update",
        "params": [
            {
                "descr": "Time since the last update in seconds.",
                "name": "number dt"
            }
        ],
        "path": "love/love.update",
        "syntax": "love.update( dt )",
        "type": "love"
    },
    "love.video.newVideoStream": {
        "descr": "Creates a new VideoStream. Currently only Ogg Theora video files are supported. VideoStreams can't draw videos, see love.graphics.newVideo for that.",
        "name": "love.video.newVideoStream",
        "params": [
            {
                "descr": "The file path to the Ogg Theora video file.",
                "name": "string filename"
            },
            {
                "descr": "A new VideoStream.",
                "name": "VideoStream videostream"
            }
        ],
        "path": "love/love.video.newvideostream",
        "syntax": "videostream = love.video.newVideoStream( filename )",
        "type": "love.video"
    },
    "love.visible": {
        "descr": "Callback function triggered when window is minimized/hidden or unminimized by the user.",
        "name": "love.visible",
        "params": [
            {
                "descr": "True if the window is visible, false if it isn't.",
                "name": "boolean visible"
            }
        ],
        "path": "love/love.visible",
        "syntax": "love.visible( visible )",
        "type": "love"
    },
    "love.wheelmoved": {
        "descr": "Callback function triggered when the mouse wheel is moved.",
        "name": "love.wheelmoved",
        "params": [
            {
                "descr": "Amount of horizontal mouse wheel movement. ",
                "name": "number x"
            },
            {
                "descr": "Amount of vertical mouse wheel movement. ",
                "name": "number y"
            }
        ],
        "path": "love/love.wheelmoved",
        "syntax": "love.wheelmoved( x, y )",
        "type": "love"
    },
    "love.window.close": {
        "descr": "Closes the window. It can be reopened with love.window.setMode.",
        "name": "love.window.close",
        "params": [],
        "path": "love/love.window.close",
        "syntax": "love.window.close( )",
        "type": "love.window"
    },
    "love.window.fromPixels": {
        "descr": "Converts a number from pixels to density-independent units.",
        "name": "love.window.fromPixels",
        "params": [
            {
                "descr": "A number in pixels to convert to density-independent units.",
                "name": "number pixelvalue"
            },
            {
                "descr": "The converted number, in density-independent units.",
                "name": "number value"
            }
        ],
        "path": "love/love.window.frompixels",
        "syntax": "value = love.window.fromPixels( pixelvalue )",
        "type": "love.window"
    },
    "love.window.getDesktopDimensions": {
        "descr": "Gets the width and height of the desktop.",
        "name": "love.window.getDesktopDimensions",
        "params": [
            {
                "descr": "The index of the display, if multiple monitors are available.",
                "name": "number display (1)"
            },
            {
                "descr": "The width of the desktop.",
                "name": "number width"
            },
            {
                "descr": "The height of the desktop.",
                "name": "number height"
            }
        ],
        "path": "love/love.window.getdesktopdimensions",
        "syntax": "width, height = love.window.getDesktopDimensions( display )",
        "type": "love.window"
    },
    "love.window.getDimensions": {
        "descr": "Gets the width and height of the window.",
        "name": "love.window.getDimensions",
        "params": [
            {
                "descr": "The width of the window.",
                "name": "number width"
            },
            {
                "descr": "The height of the window.",
                "name": "number height"
            }
        ],
        "path": "love/love.window.getdimensions",
        "syntax": "width, height = love.window.getDimensions( )",
        "type": "love.window"
    },
    "love.window.getDisplayCount": {
        "descr": "Gets the number of connected monitors.",
        "name": "love.window.getDisplayCount",
        "params": [
            {
                "descr": "The number of currently connected displays.",
                "name": "number count"
            }
        ],
        "path": "love/love.window.getdisplaycount",
        "syntax": "count = love.window.getDisplayCount( )",
        "type": "love.window"
    },
    "love.window.getDisplayName": {
        "descr": "Gets the name of a display.",
        "name": "love.window.getDisplayName",
        "params": [
            {
                "descr": "The index of the display to get the name of.",
                "name": "number displayindex (1)"
            },
            {
                "descr": "The name of the specified display.",
                "name": "string name"
            }
        ],
        "path": "love/love.window.getdisplayname",
        "syntax": "name = love.window.getDisplayName( displayindex )",
        "type": "love.window"
    },
    "love.window.getFullscreen": {
        "descr": "Gets whether the window is fullscreen.",
        "name": "love.window.getFullscreen",
        "params": [
            {
                "descr": "True if the window is fullscreen, false otherwise.",
                "name": "boolean fullscreen"
            },
            {
                "descr": "The type of fullscreen mode used.",
                "name": "FullscreenType fstype"
            }
        ],
        "path": "love/love.window.getfullscreen",
        "syntax": "fullscreen, fstype = love.window.getFullscreen( )",
        "type": "love.window"
    },
    "love.window.getFullscreenModes": {
        "descr": "Gets a list of supported fullscreen modes.",
        "name": "love.window.getFullscreenModes",
        "params": [
            {
                "descr": "The index of the display, if multiple monitors are available.",
                "name": "number display (1)"
            },
            {
                "descr": "A table of width/height pairs. (Note that this may not be in order.)",
                "name": "table modes"
            }
        ],
        "path": "love/love.window.getfullscreenmodes",
        "syntax": "modes = love.window.getFullscreenModes( display )",
        "type": "love.window"
    },
    "love.window.getHeight": {
        "descr": "Gets the height of the window.",
        "name": "love.window.getHeight",
        "params": [
            {
                "descr": "The height of the window.",
                "name": "number height"
            }
        ],
        "path": "love/love.window.getheight",
        "syntax": "height = love.window.getHeight( )",
        "type": "love.window"
    },
    "love.window.getIcon": {
        "descr": "Gets the window icon.",
        "name": "love.window.getIcon",
        "params": [
            {
                "descr": "The window icon imagedata, or nil if no icon has been set with love.window.setIcon.",
                "name": "ImageData imagedata"
            }
        ],
        "path": "love/love.window.geticon",
        "syntax": "imagedata = love.window.getIcon( )",
        "type": "love.window"
    },
    "love.window.getMode": {
        "descr": "Gets the display mode and properties of the window.",
        "name": "love.window.getMode",
        "params": [
            {
                "descr": "Window width.",
                "name": "number width"
            },
            {
                "descr": "Window height.",
                "name": "number height"
            },
            {
                "descr": "Table with the window properties:  boolean fullscreen  Fullscreen (true), or windowed (false).",
                "name": "table flags"
            },
            {
                "descr": "The type of fullscreen mode used.",
                "name": "FullscreenType fullscreentype"
            },
            {
                "descr": "True if the graphics framerate is synchronized with the monitor's refresh rate, false otherwise.",
                "name": "boolean vsync"
            },
            {
                "descr": "The number of antialiasing samples used (0 if MSAA is disabled).",
                "name": "number msaa"
            },
            {
                "descr": "True if the window is resizable in windowed mode, false otherwise.",
                "name": "boolean resizable"
            },
            {
                "descr": "True if the window is borderless in windowed mode, false otherwise.",
                "name": "boolean borderless"
            },
            {
                "descr": "True if the window is centered in windowed mode, false otherwise.",
                "name": "boolean centered"
            },
            {
                "descr": "The index of the display the window is currently in, if multiple monitors are available.",
                "name": "number display"
            },
            {
                "descr": "The minimum width of the window, if it's resizable.",
                "name": "number minwidth"
            },
            {
                "descr": "The minimum height of the window, if it's resizable.",
                "name": "number minheight"
            },
            {
                "descr": "True if high-dpi mode is allowed on Retina displays in OS X. ",
                "name": "boolean highdpi"
            },
            {
                "descr": "The refresh rate of the screen's current display mode, in Hz. ",
                "name": "number refreshrate"
            },
            {
                "descr": "The x-coordinate of the window's position in its current display. ",
                "name": "number x"
            },
            {
                "descr": "The y-coordinate of the window's position in its current display. ",
                "name": "number y"
            },
            {
                "descr": "Removed in 0.10.0 (use love.graphics.isGammaCorrect instead). ",
                "name": "boolean srgb"
            }
        ],
        "path": "love/love.window.getmode",
        "syntax": "width, height, flags = love.window.getMode( )",
        "type": "love.window"
    },
    "love.window.getPixelScale": {
        "descr": "Gets the DPI scale factor associated with the window.",
        "name": "love.window.getPixelScale",
        "params": [
            {
                "descr": "The pixel scale factor associated with the window.",
                "name": "number scale"
            }
        ],
        "path": "love/love.window.getpixelscale",
        "syntax": "scale = love.window.getPixelScale( )",
        "type": "love.window"
    },
    "love.window.getPosition": {
        "descr": "Gets the position of the window on the screen.",
        "name": "love.window.getPosition",
        "params": [
            {
                "descr": "The x-coordinate of the window's position.",
                "name": "number x"
            },
            {
                "descr": "The y-coordinate of the window's position.",
                "name": "number y"
            },
            {
                "descr": "The index of the display that the window is in.",
                "name": "number display"
            }
        ],
        "path": "love/love.window.getposition",
        "syntax": "x, y, display = love.window.getPosition( )",
        "type": "love.window"
    },
    "love.window.getTitle": {
        "descr": "Gets the window title.",
        "name": "love.window.getTitle",
        "params": [
            {
                "descr": "The current window title.",
                "name": "string title"
            }
        ],
        "path": "love/love.window.gettitle",
        "syntax": "title = love.window.getTitle( )",
        "type": "love.window"
    },
    "love.window.getWidth": {
        "descr": "Gets the width of the window.",
        "name": "love.window.getWidth",
        "params": [
            {
                "descr": "The width of the window.",
                "name": "number width"
            }
        ],
        "path": "love/love.window.getwidth",
        "syntax": "width = love.window.getWidth( )",
        "type": "love.window"
    },
    "love.window.hasFocus": {
        "descr": "Checks if the game window has keyboard focus.",
        "name": "love.window.hasFocus",
        "params": [
            {
                "descr": "True if the window has the focus or false if not.",
                "name": "boolean focus"
            }
        ],
        "path": "love/love.window.hasfocus",
        "syntax": "focus = love.window.hasFocus( )",
        "type": "love.window"
    },
    "love.window.hasMouseFocus": {
        "descr": "Checks if the game window has mouse focus.",
        "name": "love.window.hasMouseFocus",
        "params": [
            {
                "descr": "True if the window has mouse focus or false if not.",
                "name": "boolean focus"
            }
        ],
        "path": "love/love.window.hasmousefocus",
        "syntax": "focus = love.window.hasMouseFocus( )",
        "type": "love.window"
    },
    "love.window.isCreated": {
        "descr": "Checks if the window has been created.",
        "name": "love.window.isCreated",
        "params": [
            {
                "descr": "True if the window has been created, false otherwise.",
                "name": "boolean created"
            }
        ],
        "path": "love/love.window.iscreated",
        "syntax": "created = love.window.isCreated( )",
        "type": "love.window"
    },
    "love.window.isDisplaySleepEnabled": {
        "descr": "Gets whether the display is allowed to sleep while the program is running.",
        "name": "love.window.isDisplaySleepEnabled",
        "params": [
            {
                "descr": "True if system display sleep is enabled / allowed, false otherwise.",
                "name": "boolean enabled"
            }
        ],
        "path": "love/love.window.isdisplaysleepenabled",
        "syntax": "enabled = love.window.isDisplaySleepEnabled( )",
        "type": "love.window"
    },
    "love.window.isMaximized": {
        "descr": "Gets whether the Window is currently maximized.",
        "name": "love.window.isMaximized",
        "params": [
            {
                "descr": "True if the window is currently maximized in windowed mode, false otherwise.",
                "name": "boolean maximized"
            }
        ],
        "path": "love/love.window.ismaximized",
        "syntax": "maximized = love.window.isMaximized( )",
        "type": "love.window"
    },
    "love.window.isOpen": {
        "descr": "Checks if the window is open.",
        "name": "love.window.isOpen",
        "params": [
            {
                "descr": "True if the window is open, false otherwise.",
                "name": "boolean open"
            }
        ],
        "path": "love/love.window.isopen",
        "syntax": "open = love.window.isOpen( )",
        "type": "love.window"
    },
    "love.window.isVisible": {
        "descr": "Checks if the game window is visible.",
        "name": "love.window.isVisible",
        "params": [
            {
                "descr": "True if the window is visible or false if not.",
                "name": "boolean visible"
            }
        ],
        "path": "love/love.window.isvisible",
        "syntax": "visible = love.window.isVisible( )",
        "type": "love.window"
    },
    "love.window.maximize": {
        "descr": "Makes the window as large as possible.",
        "name": "love.window.maximize",
        "params": [],
        "path": "love/love.window.maximize",
        "syntax": "love.window.maximize( )",
        "type": "love.window"
    },
    "love.window.minimize": {
        "descr": "Minimizes the window to the system's task bar / dock.",
        "name": "love.window.minimize",
        "params": [],
        "path": "love/love.window.minimize",
        "syntax": "love.window.minimize( )",
        "type": "love.window"
    },
    "love.window.requestAttention": {
        "descr": "Causes the window to request the attention of the user if it is not in the foreground.",
        "name": "love.window.requestAttention",
        "params": [
            {
                "descr": "Whether to continuously request attention until the window becomes active, or to do it only once.",
                "name": "boolean continuous (false)"
            }
        ],
        "path": "love/love.window.requestattention",
        "syntax": "love.window.requestAttention( continuous )",
        "type": "love.window"
    },
    "love.window.setDisplaySleepEnabled": {
        "descr": "Sets whether the display is allowed to sleep while the program is running.",
        "name": "love.window.setDisplaySleepEnabled",
        "params": [
            {
                "descr": "True to enable system display sleep, false to disable it.",
                "name": "boolean enable"
            }
        ],
        "path": "love/love.window.setdisplaysleepenabled",
        "syntax": "love.window.setDisplaySleepEnabled( enable )",
        "type": "love.window"
    },
    "love.window.setFullscreen": {
        "descr": "Enters or exits fullscreen. The display to use when entering fullscreen is chosen based on which display the window is currently in, if multiple monitors are connected.",
        "name": "love.window.setFullscreen",
        "params": [
            {
                "descr": "Whether to enter or exit fullscreen mode.",
                "name": "boolean fullscreen"
            },
            {
                "descr": "True if successful, false otherwise.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.window.setfullscreen",
        "syntax": "success = love.window.setFullscreen( fullscreen )",
        "type": "love.window"
    },
    "love.window.setIcon": {
        "descr": "Sets the window icon until the game is quit. Not all operating systems support very large icon images.",
        "name": "love.window.setIcon",
        "params": [
            {
                "descr": "The window icon image.",
                "name": "ImageData imagedata"
            },
            {
                "descr": "Whether the icon has been set successfully.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.window.seticon",
        "syntax": "success = love.window.setIcon( imagedata )",
        "type": "love.window"
    },
    "love.window.setMode": {
        "descr": "Sets the display mode and properties of the window.",
        "name": "love.window.setMode",
        "params": [
            {
                "descr": "Display width.",
                "name": "number width"
            },
            {
                "descr": "Display height.",
                "name": "number height"
            },
            {
                "descr": "The flags table with the options:  boolean fullscreen (false)  Fullscreen (true), or windowed (false).",
                "name": "table flags"
            },
            {
                "descr": "The type of fullscreen to use. This defaults to \"normal\" in 0.9.2 and older.",
                "name": "FullscreenType fullscreentype (\"desktop\")"
            },
            {
                "descr": "True if LÖVE should wait for vsync, false otherwise.",
                "name": "boolean vsync (true)"
            },
            {
                "descr": "The number of antialiasing samples.",
                "name": "number msaa (0)"
            },
            {
                "descr": "True if the window should be resizable in windowed mode, false otherwise.",
                "name": "boolean resizable (false)"
            },
            {
                "descr": "True if the window should be borderless in windowed mode, false otherwise.",
                "name": "boolean borderless (false)"
            },
            {
                "descr": "True if the window should be centered in windowed mode, false otherwise.",
                "name": "boolean centered (true)"
            },
            {
                "descr": "The index of the display to show the window in, if multiple monitors are available.",
                "name": "number display (1)"
            },
            {
                "descr": "The minimum width of the window, if it's resizable. ",
                "name": "number minwidth (1)"
            },
            {
                "descr": "The minimum height of the window, if it's resizable. ",
                "name": "number minheight (1)"
            },
            {
                "descr": "True if high-dpi mode should be used on Retina displays in OS X and iOS. ",
                "name": "boolean highdpi (false)"
            },
            {
                "descr": "The x-coordinate of the window's position in the specified display. ",
                "name": "number x (nil)"
            },
            {
                "descr": "The y-coordinate of the window's position in the specified display. ",
                "name": "number y (nil)"
            },
            {
                "descr": "Removed in 0.10.0 (set t.gammacorrect in conf.lua instead). ",
                "name": "boolean srgb (false)"
            },
            {
                "descr": "True if successful, false otherwise.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.window.setmode",
        "syntax": "success = love.window.setMode( width, height, flags )",
        "type": "love.window"
    },
    "love.window.setPosition": {
        "descr": "Sets the position of the window on the screen.",
        "name": "love.window.setPosition",
        "params": [
            {
                "descr": "The x-coordinate of the window's position.",
                "name": "number x"
            },
            {
                "descr": "The y-coordinate of the window's position.",
                "name": "number y"
            },
            {
                "descr": "The index of the display that the new window position is relative to.",
                "name": "number display (1)"
            }
        ],
        "path": "love/love.window.setposition",
        "syntax": "love.window.setPosition( x, y, display )",
        "type": "love.window"
    },
    "love.window.setTitle": {
        "descr": "Sets the window title.",
        "name": "love.window.setTitle",
        "params": [
            {
                "descr": "The new window title.",
                "name": "string title"
            }
        ],
        "path": "love/love.window.settitle",
        "syntax": "love.window.setTitle( title )",
        "type": "love.window"
    },
    "love.window.showMessageBox": {
        "descr": "Displays a message box dialog above the love window. The message box contains a title, optional text, and buttons.",
        "name": "love.window.showMessageBox",
        "params": [
            {
                "descr": "The title of the message box.",
                "name": "string title"
            },
            {
                "descr": "The text inside the message box.",
                "name": "string message"
            },
            {
                "descr": "The type of the message box.",
                "name": "MessageBoxType type (\"info\")"
            },
            {
                "descr": "Whether the message box should be attached to the love window or free-floating.",
                "name": "boolean attachtowindow (true)"
            },
            {
                "descr": "Whether the message box was successfully displayed.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.window.showmessagebox",
        "syntax": "success = love.window.showMessageBox( title, message, type, attachtowindow )",
        "type": "love.window"
    },
    "love.window.toPixels": {
        "descr": "Converts a number from density-independent units to pixels.",
        "name": "love.window.toPixels",
        "params": [
            {
                "descr": "A number in density-independent units to convert to pixels.",
                "name": "number value"
            },
            {
                "descr": "The converted number, in pixels.",
                "name": "number pixelvalue"
            }
        ],
        "path": "love/love.window.topixels",
        "syntax": "pixelvalue = love.window.toPixels( value )",
        "type": "love.window"
    },
    "love.window.toggleFullscreen": {
        "descr": "Enters or exits fullscreen. The display to use when entering fullscreen is chosen based on which display the window is currently in, if multiple monitors are connected.",
        "name": "love.window.toggleFullscreen",
        "params": [
            {
                "descr": "Whether to enter or exit fullscreen mode.",
                "name": "boolean fullscreen"
            },
            {
                "descr": "True if successful, false otherwise.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.window.togglefullscreen",
        "syntax": "success = love.window.setFullscreen( fullscreen )",
        "type": "love.window"
    },
    "lowmemory": {
        "descr": "Callback function triggered when the system is running out of memory on mobile devices.",
        "name": "love.lowmemory",
        "params": [],
        "path": "love/love.lowmemory",
        "syntax": "love.lowmemory( )",
        "type": "love"
    },
    "maximize": {
        "descr": "Makes the window as large as possible.",
        "name": "love.window.maximize",
        "params": [],
        "path": "love/love.window.maximize",
        "syntax": "love.window.maximize( )",
        "type": "love.window"
    },
    "minimize": {
        "descr": "Minimizes the window to the system's task bar / dock.",
        "name": "love.window.minimize",
        "params": [],
        "path": "love/love.window.minimize",
        "syntax": "love.window.minimize( )",
        "type": "love.window"
    },
    "mkdir": {
        "descr": "Recursively creates a directory.",
        "name": "love.filesystem.mkdir",
        "params": [
            {
                "descr": "The directory to create.",
                "name": "string name"
            },
            {
                "descr": "True if the directory was created, false if not.",
                "name": "boolean ok"
            }
        ],
        "path": "love/love.filesystem.mkdir",
        "syntax": "ok = love.filesystem.mkdir( name )",
        "type": "love.filesystem"
    },
    "mount": {
        "descr": "Mounts a zip file or folder in the game's save directory for reading.",
        "name": "love.filesystem.mount",
        "params": [
            {
                "descr": "The folder or zip file in the game's save directory to mount.",
                "name": "string archive"
            },
            {
                "descr": "The new path the archive will be mounted to.",
                "name": "string mountpoint"
            },
            {
                "descr": "True if the archive was successfully mounted, false otherwise.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.filesystem.mount",
        "syntax": "success = love.filesystem.mount( archive, mountpoint )",
        "type": "love.filesystem"
    },
    "mousefocus": {
        "descr": "Callback function triggered when window receives or loses mouse focus.",
        "name": "love.mousefocus",
        "params": [
            {
                "descr": "Wether the window has mouse focus or not.",
                "name": "boolean focus"
            }
        ],
        "path": "love/love.mousefocus",
        "syntax": "love.mousefocus( focus )",
        "type": "love"
    },
    "mousemoved": {
        "descr": "Callback function triggered when the mouse is moved.",
        "name": "love.mousemoved",
        "params": [
            {
                "descr": "The mouse position on the x-axis.",
                "name": "number x"
            },
            {
                "descr": "The mouse position on the y-axis.",
                "name": "number y"
            },
            {
                "descr": "The amount moved along the x-axis since the last time love.mousemoved was called.",
                "name": "number dx"
            },
            {
                "descr": "The amount moved along the y-axis since the last time love.mousemoved was called.",
                "name": "number dy"
            },
            {
                "descr": "True if the mouse button press originated from a touchscreen touch-press.",
                "name": "boolean istouch"
            }
        ],
        "path": "love/love.mousemoved",
        "syntax": "love.mousemoved( x, y, dx, dy, istouch )",
        "type": "love"
    },
    "mousepressed": {
        "descr": "Callback function triggered when a mouse button is pressed.",
        "name": "love.mousepressed",
        "params": [
            {
                "descr": "Mouse x position, in pixels.",
                "name": "number x"
            },
            {
                "descr": "Mouse y position, in pixels.",
                "name": "number y"
            },
            {
                "descr": "The button index that was pressed. ",
                "name": "number button"
            },
            {
                "descr": "True if the mouse button press originated from a touchscreen touch-press.",
                "name": "boolean istouch"
            }
        ],
        "path": "love/love.mousepressed",
        "syntax": "love.mousepressed( x, y, button, istouch )",
        "type": "love"
    },
    "mousereleased": {
        "descr": "Callback function triggered when a mouse button is released.",
        "name": "love.mousereleased",
        "params": [
            {
                "descr": "Mouse x position, in pixels.",
                "name": "number x"
            },
            {
                "descr": "Mouse y position, in pixels.",
                "name": "number y"
            },
            {
                "descr": "The button index that was released. ",
                "name": "number button"
            },
            {
                "descr": "True if the mouse button release originated from a touchscreen touch-release.",
                "name": "boolean istouch"
            }
        ],
        "path": "love/love.mousereleased",
        "syntax": "love.mousereleased( x, y, button, istouch )",
        "type": "love"
    },
    "newBezierCurve": {
        "descr": "Creates a new BezierCurve object.",
        "name": "love.math.newBezierCurve",
        "params": [
            {
                "descr": "The vertices of the control polygon as a table in the form of {x1, y1, x2, y2, x3, y3, ...}.",
                "name": "table vertices"
            },
            {
                "descr": "A Bézier curve object.",
                "name": "BezierCurve curve"
            }
        ],
        "path": "love/love.math.newbeziercurve",
        "syntax": "curve = love.math.newBezierCurve( vertices )",
        "type": "love.math"
    },
    "newBody": {
        "descr": "Creates a new body.",
        "name": "love.physics.newBody",
        "params": [
            {
                "descr": "The world to create the body in.",
                "name": "World world"
            },
            {
                "descr": "The x position of the body.",
                "name": "number x (0)"
            },
            {
                "descr": "The y position of the body.",
                "name": "number y (0)"
            },
            {
                "descr": "The type of the body.",
                "name": "BodyType type (\"static\")"
            },
            {
                "descr": "A new body.",
                "name": "Body body"
            }
        ],
        "path": "love/love.physics.newbody",
        "syntax": "body = love.physics.newBody( world, x, y, type )",
        "type": "love.physics"
    },
    "newCanvas": {
        "descr": "Creates a new Canvas object for offscreen rendering.",
        "name": "love.graphics.newCanvas",
        "params": [
            {
                "descr": "A new Canvas with dimensions equal to the window's size in pixels.",
                "name": "Canvas canvas"
            }
        ],
        "path": "love/love.graphics.newcanvas",
        "syntax": "canvas = love.graphics.newCanvas( )",
        "type": "love.graphics"
    },
    "newChainShape": {
        "descr": "Creates a new ChainShape.",
        "name": "love.physics.newChainShape",
        "params": [
            {
                "descr": "If the chain should loop back to the first point.",
                "name": "boolean loop"
            },
            {
                "descr": "The x position of the first point.",
                "name": "number x1"
            },
            {
                "descr": "The y position of the first point.",
                "name": "number y1"
            },
            {
                "descr": "The x position of the second point.",
                "name": "number x2"
            },
            {
                "descr": "The y position of the second point.",
                "name": "number y2"
            },
            {
                "descr": "Additional point positions.",
                "name": "number ..."
            },
            {
                "descr": "The new shape.",
                "name": "ChainShape shape"
            }
        ],
        "path": "love/love.physics.newchainshape",
        "syntax": "shape = love.physics.newChainShape( loop, x1, y1, x2, y2, ... )",
        "type": "love.physics"
    },
    "newChannel": {
        "descr": "Create a new unnamed thread channel.",
        "name": "love.thread.newChannel",
        "params": [
            {
                "descr": "The new Channel object.",
                "name": "Channel channel"
            }
        ],
        "path": "love/love.thread.newchannel",
        "syntax": "channel = love.thread.newChannel( )",
        "type": "love.thread"
    },
    "newCircleShape": {
        "descr": "love.physics.newCircleShape needs a script example, help out by writing one.",
        "name": "love.physics.newCircleShape",
        "params": [
            {
                "descr": "The radius of the circle.",
                "name": "number radius"
            },
            {
                "descr": "The new shape.",
                "name": "CircleShape shape"
            }
        ],
        "path": "love/love.physics.newcircleshape",
        "syntax": "shape = love.physics.newCircleShape( radius )",
        "type": "love.physics"
    },
    "newCompressedData": {
        "descr": "Create a new CompressedImageData object from a compressed image file. LÖVE supports several compressed texture formats, enumerated in the CompressedImageFormat page.",
        "name": "love.image.newCompressedData",
        "params": [
            {
                "descr": "The filename of the compressed image file.",
                "name": "string filename"
            },
            {
                "descr": "The new CompressedImageData object.",
                "name": "CompressedImageData compressedImageData"
            }
        ],
        "path": "love/love.image.newcompresseddata",
        "syntax": "compressedImageData = love.image.newCompressedData( filename )",
        "type": "love.image"
    },
    "newCursor": {
        "descr": "Creates a new hardware Cursor object from an image file or ImageData.",
        "name": "love.mouse.newCursor",
        "params": [
            {
                "descr": "The ImageData to use for the new Cursor.",
                "name": "ImageData imageData"
            },
            {
                "descr": "The x-coordinate in the ImageData of the cursor's hot spot.",
                "name": "number hotx (0)"
            },
            {
                "descr": "The y-coordinate in the ImageData of the cursor's hot spot.",
                "name": "number hoty (0)"
            },
            {
                "descr": "The new Cursor object.",
                "name": "Cursor cursor"
            }
        ],
        "path": "love/love.mouse.newcursor",
        "syntax": "cursor = love.mouse.newCursor( imageData, hotx, hoty )",
        "type": "love.mouse"
    },
    "newDecoder": {
        "descr": "Attempts to find a decoder for the encoded sound data in the specified file.",
        "name": "love.sound.newDecoder",
        "params": [
            {
                "descr": "The file with encoded sound data.",
                "name": "File file"
            },
            {
                "descr": "The size of each decoded chunk, in bytes.",
                "name": "number buffer (2048)"
            },
            {
                "descr": "A new Decoder object.",
                "name": "Decoder decoder"
            }
        ],
        "path": "love/love.sound.newdecoder",
        "syntax": "decoder = love.sound.newDecoder( file, buffer )",
        "type": "love.sound"
    },
    "newDistanceJoint": {
        "descr": "Creates a DistanceJoint between two bodies.",
        "name": "love.physics.newDistanceJoint",
        "params": [
            {
                "descr": "The first body to attach to the joint.",
                "name": "Body body1"
            },
            {
                "descr": "The second body to attach to the joint.",
                "name": "Body body2"
            },
            {
                "descr": "The x position of the first anchor point.",
                "name": "number x1"
            },
            {
                "descr": "The y position of the first anchor point.",
                "name": "number y1"
            },
            {
                "descr": "The x position of the second anchor point.",
                "name": "number x2"
            },
            {
                "descr": "The y position of the second anchor point.",
                "name": "number y2"
            },
            {
                "descr": "Specifies whether the two bodies should collide with each other.",
                "name": "boolean collideConnected (false)"
            },
            {
                "descr": "The new distance joint.",
                "name": "DistanceJoint joint"
            }
        ],
        "path": "love/love.physics.newdistancejoint",
        "syntax": "joint = love.physics.newDistanceJoint( body1, body2, x1, y1, x2, y2, collideConnected )",
        "type": "love.physics"
    },
    "newEdgeShape": {
        "descr": "Creates a new EdgeShape.",
        "name": "love.physics.newEdgeShape",
        "params": [
            {
                "descr": "The x position of the first point.",
                "name": "number x1"
            },
            {
                "descr": "The y position of the first point.",
                "name": "number y1"
            },
            {
                "descr": "The x position of the second point.",
                "name": "number x2"
            },
            {
                "descr": "The y position of the second point.",
                "name": "number y2"
            },
            {
                "descr": "The new shape.",
                "name": "EdgeShape shape"
            }
        ],
        "path": "love/love.physics.newedgeshape",
        "syntax": "shape = love.physics.newEdgeShape( x1, y1, x2, y2 )",
        "type": "love.physics"
    },
    "newEncodedImageData": {
        "descr": "Encodes ImageData.",
        "name": "love.image.newEncodedImageData",
        "params": [
            {
                "descr": "The raw ImageData to encode.",
                "name": "ImageData imageData"
            },
            {
                "descr": "The format to encode the image in.",
                "name": "ImageFormat format"
            },
            {
                "descr": "The encoded image data.",
                "name": "Data data"
            }
        ],
        "path": "love/love.image.newencodedimagedata",
        "syntax": "data = love.image.newEncodedImageData( imageData, format )",
        "type": "love.image"
    },
    "newFile": {
        "descr": "Creates a new File object. It needs to be opened before it can be accessed.",
        "name": "love.filesystem.newFile",
        "params": [
            {
                "descr": "The filename of the file.",
                "name": "string filename"
            },
            {
                "descr": "The new File object.",
                "name": "File file"
            }
        ],
        "path": "love/love.filesystem.newfile",
        "syntax": "file = love.filesystem.newFile( filename )",
        "type": "love.filesystem"
    },
    "newFileData": {
        "descr": "Creates a new FileData object.",
        "name": "love.filesystem.newFileData",
        "params": [
            {
                "descr": "The contents of the file.",
                "name": "string contents"
            },
            {
                "descr": "The name of the file.",
                "name": "string name"
            },
            {
                "descr": "The method to use when decoding the contents.",
                "name": "FileDecoder decoder (\"file\")"
            },
            {
                "descr": "Your new FileData.",
                "name": "FileData data"
            }
        ],
        "path": "love/love.filesystem.newfiledata",
        "syntax": "data = love.filesystem.newFileData( contents, name, decoder )",
        "type": "love.filesystem"
    },
    "newFixture": {
        "descr": "Creates and attaches a Fixture to a body.",
        "name": "love.physics.newFixture",
        "params": [
            {
                "descr": "The body which gets the fixture attached.",
                "name": "Body body"
            },
            {
                "descr": "The shape to be copied to the fixture.",
                "name": "Shape shape"
            },
            {
                "descr": "The density of the fixture.",
                "name": "number density (1)"
            },
            {
                "descr": "The new fixture.",
                "name": "Fixture fixture"
            }
        ],
        "path": "love/love.physics.newfixture",
        "syntax": "fixture = love.physics.newFixture( body, shape, density )",
        "type": "love.physics"
    },
    "newFont": {
        "descr": "Creates a new Font. Created fonts are not cached, in that calling this function with the same arguments will always create a new Font object.",
        "name": "love.graphics.newFont",
        "params": [
            {
                "descr": "The filepath to the font file.",
                "name": "string filename"
            },
            {
                "descr": "The size of the font in pixels.",
                "name": "number size (12)"
            },
            {
                "descr": "A Font object which can be used to draw text on screen.",
                "name": "Font font"
            }
        ],
        "path": "love/love.graphics.newfont",
        "syntax": "font = love.graphics.newFont( filename, size )",
        "type": "love.graphics"
    },
    "newFontData": {
        "descr": "Creates a new FontData.",
        "name": "love.font.newFontData",
        "params": [
            {
                "descr": "The Rasterizer containing the font.",
                "name": "Rasterizer rasterizer"
            },
            {
                "descr": "The FontData.",
                "name": "FontData fontData"
            }
        ],
        "path": "love/love.font.newfontdata",
        "syntax": "fontData = love.font.newFontData( rasterizer )",
        "type": "love.font"
    },
    "newFramebuffer": {
        "descr": "Creates a new framebuffer object for offscreen rendering.",
        "name": "love.graphics.newFramebuffer",
        "params": [
            {
                "descr": "A new framebuffer with width/height equal to the window width/height.",
                "name": "Framebuffer framebuffer"
            }
        ],
        "path": "love/love.graphics.newframebuffer",
        "syntax": "framebuffer = love.graphics.newFramebuffer( )",
        "type": "love.graphics"
    },
    "newFrictionJoint": {
        "descr": "Create a friction joint between two bodies. A FrictionJoint applies friction to a body.",
        "name": "love.physics.newFrictionJoint",
        "params": [
            {
                "descr": "The first body to attach to the joint.",
                "name": "Body body1"
            },
            {
                "descr": "The second body to attach to the joint.",
                "name": "Body body2"
            },
            {
                "descr": "The x position of the anchor point.",
                "name": "number x"
            },
            {
                "descr": "The y position of the anchor point.",
                "name": "number y"
            },
            {
                "descr": "Specifies whether the two bodies should collide with each other.",
                "name": "boolean collideConnected (false)"
            },
            {
                "descr": "The new FrictionJoint.",
                "name": "FrictionJoint joint"
            }
        ],
        "path": "love/love.physics.newfrictionjoint",
        "syntax": "joint = love.physics.newFrictionJoint( body1, body2, x, y, collideConnected )",
        "type": "love.physics"
    },
    "newGearJoint": {
        "descr": "Create a GearJoint connecting two Joints.",
        "name": "love.physics.newGearJoint",
        "params": [
            {
                "descr": "The first joint to connect with a gear joint.",
                "name": "Joint joint1"
            },
            {
                "descr": "The second joint to connect with a gear joint.",
                "name": "Joint joint2"
            },
            {
                "descr": "The gear ratio.",
                "name": "number ratio (1)"
            },
            {
                "descr": "Specifies whether the two bodies should collide with each other.",
                "name": "boolean collideConnected (false)"
            },
            {
                "descr": "The new gear joint.",
                "name": "GearJoint joint"
            }
        ],
        "path": "love/love.physics.newgearjoint",
        "syntax": "joint = love.physics.newGearJoint( joint1, joint2, ratio, collideConnected )",
        "type": "love.physics"
    },
    "newGlyphData": {
        "descr": "Creates a new GlyphData.",
        "name": "love.font.newGlyphData",
        "params": [
            {
                "descr": "The Rasterizer containing the font.",
                "name": "Rasterizer rasterizer"
            },
            {
                "descr": "The character code of the glyph.",
                "name": "number glyph"
            },
            {
                "descr": "The GlyphData.",
                "name": "GlyphData glyphData"
            }
        ],
        "path": "love/love.font.newglyphdata",
        "syntax": "glyphData = love.font.newGlyphData( rasterizer, glyph )",
        "type": "love.font"
    },
    "newImage": {
        "descr": "Creates a new Image from a filepath, FileData, an ImageData, or a CompressedImageData, and optionally generates or specifies mipmaps for the image.",
        "name": "love.graphics.newImage",
        "params": [
            {
                "descr": "The filepath to the image file.",
                "name": "string filename"
            },
            {
                "descr": "An Image object which can be drawn on screen.",
                "name": "Image image"
            }
        ],
        "path": "love/love.graphics.newimage",
        "syntax": "image = love.graphics.newImage( filename )",
        "type": "love.graphics"
    },
    "newImageData": {
        "descr": "Creates a new ImageData object.",
        "name": "love.image.newImageData",
        "params": [
            {
                "descr": "The width of the ImageData.",
                "name": "number width"
            },
            {
                "descr": "The height of the ImageData.",
                "name": "number height"
            },
            {
                "descr": "The new blank ImageData object. ",
                "name": "ImageData imageData"
            }
        ],
        "path": "love/love.image.newimagedata",
        "syntax": "imageData = love.image.newImageData( width, height )",
        "type": "love.image"
    },
    "newImageFont": {
        "descr": "Creates a new Font by loading a specifically formatted image.",
        "name": "love.graphics.newImageFont",
        "params": [
            {
                "descr": "The filepath to the image file.",
                "name": "string filename"
            },
            {
                "descr": "A string of the characters in the image in order from left to right.",
                "name": "string glyphs"
            },
            {
                "descr": "A Font object which can be used to draw text on screen.",
                "name": "Font font"
            }
        ],
        "path": "love/love.graphics.newimagefont",
        "syntax": "font = love.graphics.newImageFont( filename, glyphs )",
        "type": "love.graphics"
    },
    "newMesh": {
        "descr": "Creates a new Mesh.",
        "name": "love.graphics.newMesh",
        "params": [
            {
                "descr": "The table filled with vertex information tables for each vertex as follows:  number [1]  The position of the vertex on the x-axis.",
                "name": "table vertices"
            },
            {
                "descr": "The position of the vertex on the y-axis.",
                "name": "number [2]"
            },
            {
                "descr": "The u texture coordinate of the vertex. ",
                "name": "number [3] (0)"
            },
            {
                "descr": "The v texture coordinate of the vertex. ",
                "name": "number [4] (0)"
            },
            {
                "descr": "The red component of the vertex color.",
                "name": "number [5] (255)"
            },
            {
                "descr": "The green component of the vertex color.",
                "name": "number [6] (255)"
            },
            {
                "descr": "The blue component of the vertex color.",
                "name": "number [7] (255)"
            },
            {
                "descr": "The alpha component of the vertex color.",
                "name": "number [8] (255)"
            },
            {
                "descr": "How the vertices are used when drawing. ",
                "name": "MeshDrawMode mode (\"fan\")"
            },
            {
                "descr": "The expected usage of the Mesh. ",
                "name": "SpriteBatchUsage usage (\"dynamic\")"
            },
            {
                "descr": "The new mesh.",
                "name": "Mesh mesh"
            }
        ],
        "path": "love/love.graphics.newmesh",
        "syntax": "mesh = love.graphics.newMesh( vertices, mode, usage )",
        "type": "love.graphics"
    },
    "newMotorJoint": {
        "descr": "Creates a joint between two bodies which controls the relative motion between them.",
        "name": "love.physics.newMotorJoint",
        "params": [
            {
                "descr": "The first body to attach to the joint.",
                "name": "Body body1"
            },
            {
                "descr": "The second body to attach to the joint.",
                "name": "Body body2"
            },
            {
                "descr": "The joint's initial position correction factor, in the range of [0, 1].",
                "name": "number correctionFactor (0.3)"
            },
            {
                "descr": "The new MotorJoint.",
                "name": "MotorJoint joint"
            }
        ],
        "path": "love/love.physics.newmotorjoint",
        "syntax": "joint = love.physics.newMotorJoint( body1, body2, correctionFactor )",
        "type": "love.physics"
    },
    "newMouseJoint": {
        "descr": "Create a joint between a body and the mouse.",
        "name": "love.physics.newMouseJoint",
        "params": [
            {
                "descr": "The body to attach to the mouse.",
                "name": "Body body"
            },
            {
                "descr": "The x position of the connecting point.",
                "name": "number x"
            },
            {
                "descr": "The y position of the connecting point.",
                "name": "number y"
            },
            {
                "descr": "The new mouse joint.",
                "name": "Joint joint"
            }
        ],
        "path": "love/love.physics.newmousejoint",
        "syntax": "joint = love.physics.newMouseJoint( body, x, y )",
        "type": "love.physics"
    },
    "newParticleSystem": {
        "descr": "Creates a new ParticleSystem.",
        "name": "love.graphics.newParticleSystem",
        "params": [
            {
                "descr": "The image to use.",
                "name": "Image image"
            },
            {
                "descr": "The max number of particles at the same time.",
                "name": "number buffer"
            },
            {
                "descr": "A new ParticleSystem.",
                "name": "ParticleSystem system"
            }
        ],
        "path": "love/love.graphics.newparticlesystem",
        "syntax": "system = love.graphics.newParticleSystem( image, buffer )",
        "type": "love.graphics"
    },
    "newPixelEffect": {
        "descr": "Creates a new PixelEffect object for hardware-accelerated pixel level effects.",
        "name": "love.graphics.newPixelEffect",
        "params": [
            {
                "descr": "The pixel effect code.",
                "name": "string code"
            },
            {
                "descr": "A PixelEffect object for use in drawing operations.",
                "name": "PixelEffect pixeleffect"
            },
            {
                "descr": "The drawing color set with love.graphics.setColor.",
                "name": "vec4 color"
            },
            {
                "descr": "The texture of the image or canvas being drawn.",
                "name": "Image texture"
            },
            {
                "descr": "Coordinates of the pixel relative to the texture. ",
                "name": "vec2 texture_coords"
            },
            {
                "descr": "Coordinates of the pixel on the screen. ",
                "name": "vec2 screen_coords"
            },
            {
                "descr": "The color of the pixel.",
                "name": "vec4 output_color"
            }
        ],
        "path": "love/love.graphics.newpixeleffect",
        "syntax": "pixeleffect = love.graphics.newPixelEffect( code )",
        "type": "love.graphics"
    },
    "newPolygonShape": {
        "descr": "Creates a new PolygonShape.",
        "name": "love.physics.newPolygonShape",
        "params": [
            {
                "descr": "The x position of the first point.",
                "name": "number x1"
            },
            {
                "descr": "The y position of the first point.",
                "name": "number y1"
            },
            {
                "descr": "The x position of the second point.",
                "name": "number x2"
            },
            {
                "descr": "The y position of the second point.",
                "name": "number y2"
            },
            {
                "descr": "The x position of the third point.",
                "name": "number x3"
            },
            {
                "descr": "The y position of the third point.",
                "name": "number y3"
            },
            {
                "descr": "You can continue passing more point positions to create the PolygonShape.",
                "name": "number ..."
            },
            {
                "descr": "A new PolygonShape.",
                "name": "PolygonShape shape"
            }
        ],
        "path": "love/love.physics.newpolygonshape",
        "syntax": "shape = love.physics.newPolygonShape( x1, y1, x2, y2, x3, y3, ... )",
        "type": "love.physics"
    },
    "newPrismaticJoint": {
        "descr": "Creates a PrismaticJoint between two bodies.",
        "name": "love.physics.newPrismaticJoint",
        "params": [
            {
                "descr": "The first body to connect with a prismatic joint.",
                "name": "Body body1"
            },
            {
                "descr": "The second body to connect with a prismatic joint.",
                "name": "Body body2"
            },
            {
                "descr": "The x coordinate of the anchor point.",
                "name": "number x"
            },
            {
                "descr": "The y coordinate of the anchor point.",
                "name": "number y"
            },
            {
                "descr": "The x coordinate of the axis vector.",
                "name": "number ax"
            },
            {
                "descr": "The y coordinate of the axis vector.",
                "name": "number ay"
            },
            {
                "descr": "Specifies whether the two bodies should collide with each other.",
                "name": "boolean collideConnected (false)"
            },
            {
                "descr": "The new prismatic joint.",
                "name": "PrismaticJoint joint"
            }
        ],
        "path": "love/love.physics.newprismaticjoint",
        "syntax": "joint = love.physics.newPrismaticJoint( body1, body2, x, y, ax, ay, collideConnected )",
        "type": "love.physics"
    },
    "newPulleyJoint": {
        "descr": "Creates a PulleyJoint to join two bodies to each other and the ground.",
        "name": "love.physics.newPulleyJoint",
        "params": [
            {
                "descr": "The first body to connect with a pulley joint.",
                "name": "Body body1"
            },
            {
                "descr": "The second body to connect with a pulley joint.",
                "name": "Body body2"
            },
            {
                "descr": "The x coordinate of the first body's ground anchor.",
                "name": "number gx1"
            },
            {
                "descr": "The y coordinate of the first body's ground anchor.",
                "name": "number gy1"
            },
            {
                "descr": "The x coordinate of the second body's ground anchor.",
                "name": "number gx2"
            },
            {
                "descr": "The y coordinate of the second body's ground anchor.",
                "name": "number gy2"
            },
            {
                "descr": "The x coordinate of the pulley joint anchor in the first body.",
                "name": "number x1"
            },
            {
                "descr": "The y coordinate of the pulley joint anchor in the first body.",
                "name": "number y1"
            },
            {
                "descr": "The x coordinate of the pulley joint anchor in the second body.",
                "name": "number x2"
            },
            {
                "descr": "The y coordinate of the pulley joint anchor in the second body.",
                "name": "number y2"
            },
            {
                "descr": "The joint ratio.",
                "name": "number ratio (1)"
            },
            {
                "descr": "Specifies whether the two bodies should collide with each other.",
                "name": "boolean collideConnected (true)"
            },
            {
                "descr": "The new pulley joint.",
                "name": "PulleyJoint joint"
            }
        ],
        "path": "love/love.physics.newpulleyjoint",
        "syntax": "joint = love.physics.newPulleyJoint( body1, body2, gx1, gy1, gx2, gy2, x1, y1, x2, y2, ratio, collideConnected )",
        "type": "love.physics"
    },
    "newQuad": {
        "descr": "Creates a new Quad.",
        "name": "love.graphics.newQuad",
        "params": [
            {
                "descr": "The top-left position in the Image along the x-axis.",
                "name": "number x"
            },
            {
                "descr": "The top-left position in the Image along the y-axis.",
                "name": "number y"
            },
            {
                "descr": "The width of the Quad in the Image. ",
                "name": "number width"
            },
            {
                "descr": "The height of the Quad in the Image. ",
                "name": "number height"
            },
            {
                "descr": "The reference width, the width of the Image. ",
                "name": "number sw"
            },
            {
                "descr": "The reference height, the height of the Image. ",
                "name": "number sh"
            },
            {
                "descr": "The new Quad.",
                "name": "Quad quad"
            }
        ],
        "path": "love/love.graphics.newquad",
        "syntax": "quad = love.graphics.newQuad( x, y, width, height, sw, sh )",
        "type": "love.graphics"
    },
    "newRandomGenerator": {
        "descr": "Creates a new RandomGenerator object which is completely independent of other RandomGenerator objects and random functions.",
        "name": "love.math.newRandomGenerator",
        "params": [
            {
                "descr": "The new Random Number Generator object.",
                "name": "RandomGenerator rng"
            }
        ],
        "path": "love/love.math.newrandomgenerator",
        "syntax": "rng = love.math.newRandomGenerator( )",
        "type": "love.math"
    },
    "newRasterizer": {
        "descr": "Creates a new Rasterizer.",
        "name": "love.font.newRasterizer",
        "params": [
            {
                "descr": "The image data containing the drawable pictures of font glyphs.",
                "name": "ImageData imageData"
            },
            {
                "descr": "The sequence of glyphs in the ImageData.",
                "name": "string glyphs"
            },
            {
                "descr": "The rasterizer.",
                "name": "Rasterizer rasterizer"
            }
        ],
        "path": "love/love.font.newrasterizer",
        "syntax": "rasterizer = love.font.newRasterizer( imageData, glyphs )",
        "type": "love.font"
    },
    "newRectangleShape": {
        "descr": "Shorthand for creating rectanglar PolygonShapes.",
        "name": "love.physics.newRectangleShape",
        "params": [
            {
                "descr": "The width of the rectangle.",
                "name": "number width"
            },
            {
                "descr": "The height of the rectangle.",
                "name": "number height"
            },
            {
                "descr": "A new PolygonShape.",
                "name": "PolygonShape shape"
            }
        ],
        "path": "love/love.physics.newrectangleshape",
        "syntax": "shape = love.physics.newRectangleShape( width, height )",
        "type": "love.physics"
    },
    "newRevoluteJoint": {
        "descr": "Creates a pivot joint between two bodies.",
        "name": "love.physics.newRevoluteJoint",
        "params": [
            {
                "descr": "The first body.",
                "name": "Body body1"
            },
            {
                "descr": "The second body.",
                "name": "Body body2"
            },
            {
                "descr": "The x position of the connecting point.",
                "name": "number x"
            },
            {
                "descr": "The y position of the connecting point.",
                "name": "number y"
            },
            {
                "descr": "Specifies whether the two bodies should collide with each other.",
                "name": "boolean collideConnected (false)"
            },
            {
                "descr": "The new revolute joint.",
                "name": "Joint joint"
            }
        ],
        "path": "love/love.physics.newrevolutejoint",
        "syntax": "joint = love.physics.newRevoluteJoint( body1, body2, x, y, collideConnected )",
        "type": "love.physics"
    },
    "newRopeJoint": {
        "descr": "Creates a joint between two bodies. Its only function is enforcing a max distance between these bodies.",
        "name": "love.physics.newRopeJoint",
        "params": [
            {
                "descr": "The first body to attach to the joint.",
                "name": "Body body1"
            },
            {
                "descr": "The second body to attach to the joint.",
                "name": "Body body2"
            },
            {
                "descr": "The x position of the first anchor point.",
                "name": "number x1"
            },
            {
                "descr": "The y position of the first anchor point.",
                "name": "number y1"
            },
            {
                "descr": "The x position of the second anchor point.",
                "name": "number x2"
            },
            {
                "descr": "The y position of the second anchor point.",
                "name": "number y2"
            },
            {
                "descr": "The maximum distance for the bodies.",
                "name": "number maxLength"
            },
            {
                "descr": "Specifies whether the two bodies should collide with each other.",
                "name": "boolean collideConnected (false)"
            },
            {
                "descr": "The new RopeJoint.",
                "name": "RopeJoint joint"
            }
        ],
        "path": "love/love.physics.newropejoint",
        "syntax": "joint = love.physics.newRopeJoint( body1, body2, x1, y1, x2, y2, maxLength, collideConnected )",
        "type": "love.physics"
    },
    "newScreenshot": {
        "descr": "Creates a screenshot and returns the image data.",
        "name": "love.graphics.newScreenshot",
        "params": [
            {
                "descr": "The image data of the screenshot.",
                "name": "ImageData screenshot"
            }
        ],
        "path": "love/love.graphics.newscreenshot",
        "syntax": "screenshot = love.graphics.newScreenshot( )",
        "type": "love.graphics"
    },
    "newShader": {
        "descr": "",
        "name": "love.graphics.newShader",
        "params": [
            {
                "descr": "The pixel shader or vertex shader code, or a filename pointing to a file with the code.",
                "name": "string code"
            },
            {
                "descr": "A Shader object for use in drawing operations.",
                "name": "Shader shader"
            }
        ],
        "path": "love/love.graphics.newshader",
        "syntax": "shader = love.graphics.newShader( code )",
        "type": "love.graphics"
    },
    "newSoundData": {
        "descr": "Creates new SoundData from a filepath, File, or Decoder. It's also possible to create SoundData with a custom sample rate, channel and bit depth.",
        "name": "love.sound.newSoundData",
        "params": [
            {
                "descr": "The file name of the file to load.",
                "name": "string filename"
            },
            {
                "descr": "A new SoundData object.",
                "name": "SoundData soundData"
            }
        ],
        "path": "love/love.sound.newsounddata",
        "syntax": "soundData = love.sound.newSoundData( filename )",
        "type": "love.sound"
    },
    "newSource": {
        "descr": "Creates a new Source from a filepath, File, Decoder or SoundData. Sources created from SoundData are always static.",
        "name": "love.audio.newSource",
        "params": [
            {
                "descr": "The filepath to the audio file.",
                "name": "string filename"
            },
            {
                "descr": "Streaming or static source.",
                "name": "SourceType type (\"stream\")"
            },
            {
                "descr": "A new Source that can play the specified audio.",
                "name": "Source source"
            }
        ],
        "path": "love/love.audio.newsource",
        "syntax": "source = love.audio.newSource( filename, type )",
        "type": "love.audio"
    },
    "newSpriteBatch": {
        "descr": "Creates a new SpriteBatch object.",
        "name": "love.graphics.newSpriteBatch",
        "params": [
            {
                "descr": "The Image to use for the sprites.",
                "name": "Image image"
            },
            {
                "descr": "The maximum number of sprites that the SpriteBatch can contain at any given time.",
                "name": "number maxsprites (1000)"
            },
            {
                "descr": "The new SpriteBatch.",
                "name": "SpriteBatch spriteBatch"
            }
        ],
        "path": "love/love.graphics.newspritebatch",
        "syntax": "spriteBatch = love.graphics.newSpriteBatch( image, maxsprites )",
        "type": "love.graphics"
    },
    "newStencil": {
        "descr": "Creates a new stencil.",
        "name": "love.graphics.newStencil",
        "params": [
            {
                "descr": "Function that draws the stencil.",
                "name": "function stencilFunction"
            },
            {
                "descr": "Function that defines the new stencil.",
                "name": "function myStencil"
            }
        ],
        "path": "love/love.graphics.newstencil",
        "syntax": "myStencil = love.graphics.newStencil( stencilFunction )",
        "type": "love.graphics"
    },
    "newText": {
        "descr": "Creates a new drawable Text object.",
        "name": "love.graphics.newText",
        "params": [
            {
                "descr": "The font to use for the text.",
                "name": "Font font"
            },
            {
                "descr": "The initial string of text that the new Text object will contain. ",
                "name": "string textstring (nil)"
            },
            {
                "descr": "The new drawable Text object.",
                "name": "Text text"
            }
        ],
        "path": "love/love.graphics.newtext",
        "syntax": "text = love.graphics.newText( font, textstring )",
        "type": "love.graphics"
    },
    "newThread": {
        "descr": "Creates a new Thread from a Lua file or FileData object.",
        "name": "love.thread.newThread",
        "params": [
            {
                "descr": "The name of the Lua file to use as the source.",
                "name": "string filename"
            },
            {
                "descr": "A new Thread that has yet to be started.",
                "name": "Thread thread"
            }
        ],
        "path": "love/love.thread.newthread",
        "syntax": "thread = love.thread.newThread( filename )",
        "type": "love.thread"
    },
    "newVideo": {
        "descr": "Creates a new drawable Video. Currently only Ogg Theora video files are supported.",
        "name": "love.graphics.newVideo",
        "params": [
            {
                "descr": "The file path to the Ogg Theora video file.",
                "name": "string filename"
            },
            {
                "descr": "Whether to try to load the video's audio into an audio Source. ",
                "name": "boolean loadaudio (nil)"
            },
            {
                "descr": "A new Video.",
                "name": "Video video"
            }
        ],
        "path": "love/love.graphics.newvideo",
        "syntax": "video = love.graphics.newVideo( filename, loadaudio )",
        "type": "love.graphics"
    },
    "newVideoStream": {
        "descr": "Creates a new VideoStream. Currently only Ogg Theora video files are supported. VideoStreams can't draw videos, see love.graphics.newVideo for that.",
        "name": "love.video.newVideoStream",
        "params": [
            {
                "descr": "The file path to the Ogg Theora video file.",
                "name": "string filename"
            },
            {
                "descr": "A new VideoStream.",
                "name": "VideoStream videostream"
            }
        ],
        "path": "love/love.video.newvideostream",
        "syntax": "videostream = love.video.newVideoStream( filename )",
        "type": "love.video"
    },
    "newWeldJoint": {
        "descr": "Creates a constraint joint between two bodies. A WeldJoint essentially glues two bodies together. The constraint is a bit soft, however, due to Box2D's iterative solver.",
        "name": "love.physics.newWeldJoint",
        "params": [
            {
                "descr": "The first body to attach to the joint.",
                "name": "Body body1"
            },
            {
                "descr": "The second body to attach to the joint.",
                "name": "Body body2"
            },
            {
                "descr": "The x position of the anchor point (world space).",
                "name": "number x"
            },
            {
                "descr": "The y position of the anchor point (world space).",
                "name": "number y"
            },
            {
                "descr": "Specifies whether the two bodies should collide with each other.",
                "name": "boolean collideConnected (false)"
            },
            {
                "descr": "The new WeldJoint.",
                "name": "WeldJoint joint"
            }
        ],
        "path": "love/love.physics.newweldjoint",
        "syntax": "joint = love.physics.newWeldJoint( body1, body2, x, y, collideConnected )",
        "type": "love.physics"
    },
    "newWheelJoint": {
        "descr": "Creates a wheel joint.",
        "name": "love.physics.newWheelJoint",
        "params": [
            {
                "descr": "The first body.",
                "name": "Body body1"
            },
            {
                "descr": "The second body.",
                "name": "Body body2"
            },
            {
                "descr": "The x position of the anchor point.",
                "name": "number x"
            },
            {
                "descr": "The y position of the anchor point.",
                "name": "number y"
            },
            {
                "descr": "The x position of the axis unit vector.",
                "name": "number ax"
            },
            {
                "descr": "The y position of the axis unit vector.",
                "name": "number ay"
            },
            {
                "descr": "Specifies whether the two bodies should collide with each other.",
                "name": "boolean collideConnected (false)"
            },
            {
                "descr": "The new WheelJoint.",
                "name": "WheelJoint joint"
            }
        ],
        "path": "love/love.physics.newwheeljoint",
        "syntax": "joint = love.physics.newWheelJoint( body1, body2, x, y, ax, ay, collideConnected )",
        "type": "love.physics"
    },
    "newWorld": {
        "descr": "Creates a new World.",
        "name": "love.physics.newWorld",
        "params": [
            {
                "descr": "The x component of gravity.",
                "name": "number xg (0)"
            },
            {
                "descr": "The y component of gravity.",
                "name": "number yg (0)"
            },
            {
                "descr": "Whether the bodies in this world are allowed to sleep.",
                "name": "boolean sleep (true)"
            },
            {
                "descr": "A brave new World.",
                "name": "World world"
            }
        ],
        "path": "love/love.physics.newworld",
        "syntax": "world = love.physics.newWorld( xg, yg, sleep )",
        "type": "love.physics"
    },
    "noise": {
        "descr": "Generates a Simplex or Perlin noise value in 1-4 dimensions. The return value will always be the same, given the same arguments.",
        "name": "love.math.noise",
        "params": [
            {
                "descr": "The number used to generate the noise value.",
                "name": "number x"
            },
            {
                "descr": "The noise value in the range of [0, 1].",
                "name": "number value"
            }
        ],
        "path": "love/love.math.noise",
        "syntax": "value = love.math.noise( x )",
        "type": "love.math"
    },
    "open": {
        "descr": "Opens up a joystick to be used, i.e. makes it ready to use. By default joysticks that are available at the start of your game will be opened.  NOTE: Unlike conventional Lua indexes, joysticks begin counting from 0 in LÖVE 0.7.2 and below. To to open the first joystick, you would use love.joystick.open(0). This is not the case in LÖVE 0.8.0 and later.",
        "name": "love.joystick.open",
        "params": [
            {
                "descr": "The joystick to be opened",
                "name": "number joystick"
            },
            {
                "descr": "True if the joystick has been successfully opened or false on failure.",
                "name": "boolean open"
            }
        ],
        "path": "love/love.joystick.open",
        "syntax": "open = love.joystick.open( joystick )",
        "type": "love.joystick"
    },
    "openURL": {
        "descr": "Opens a URL with the user's web or file browser.",
        "name": "love.system.openURL",
        "params": [
            {
                "descr": "The URL to open. Must be formatted as a proper URL.",
                "name": "string url"
            },
            {
                "descr": "Whether the URL was opened successfully.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.system.openurl",
        "syntax": "success = love.system.openURL( url )",
        "type": "love.system"
    },
    "origin": {
        "descr": "Resets the current coordinate transformation.",
        "name": "love.graphics.origin",
        "params": [],
        "path": "love/love.graphics.origin",
        "syntax": "love.graphics.origin()",
        "type": "love.graphics"
    },
    "pause": {
        "descr": "Pauses currently played Sources.",
        "name": "love.audio.pause",
        "params": [],
        "path": "love/love.audio.pause",
        "syntax": "love.audio.pause( )",
        "type": "love.audio"
    },
    "peer:connect id": {
        "descr": "Returns the field ENetPeer::connectID that is assigned for each connection.",
        "name": "enet.peer:connect id",
        "params": [
            {
                "descr": "Unique ID that was assigned to the connection.",
                "name": "number id"
            }
        ],
        "path": "love/enet.peer-connect_id",
        "syntax": "peer:connect_id()",
        "type": "enet"
    },
    "peer:disconnect": {
        "descr": "Requests a disconnection from the  peer. The message is sent on the next  host:service() or  host:flush().",
        "name": "enet.peer:disconnect",
        "params": [
            {
                "descr": "An optional integer value to be associated with the disconnect.",
                "name": "number data"
            }
        ],
        "path": "love/enet.peer-disconnect",
        "syntax": "peer:disconnect(data)",
        "type": "enet"
    },
    "peer:disconnect later": {
        "descr": "Request a disconnection from  peer, but only after all queued outgoing packets are sent.",
        "name": "enet.peer:disconnect later",
        "params": [
            {
                "descr": "Optional integer value to be associated with the disconnect.",
                "name": "number data"
            }
        ],
        "path": "love/enet.peer-disconnect_later",
        "syntax": "peer:disconnect_later(data)",
        "type": "enet"
    },
    "peer:disconnect now": {
        "descr": "Force immediate disconnection from  peer. Foreign  peer not guaranteed to receive disconnect notification.",
        "name": "enet.peer:disconnect now",
        "params": [
            {
                "descr": "Optional integer value to be associated with the disconnect.",
                "name": "number data"
            }
        ],
        "path": "love/enet.peer-disconnect_now",
        "syntax": "peer:disconnect_now(data)",
        "type": "enet"
    },
    "peer:index": {
        "descr": "Returns the index of the  peer. All  peers of an ENet  host are kept in an array. This function finds and returns the index of the  peer of its  host structure.",
        "name": "enet.peer:index",
        "params": [
            {
                "descr": "The index of the peer.",
                "name": "number index"
            }
        ],
        "path": "love/enet.peer-index",
        "syntax": "peer:index()",
        "type": "enet"
    },
    "peer:last round trip time": {
        "descr": "Returns or sets the round trip time of the previous round trip time computation. If value is nil the current value of the  peer is returned. Otherwise the the previous round trip time computation is set to the specified value and returned.",
        "name": "enet.peer:last round trip time",
        "params": [
            {
                "descr": "The  peer's last round trip time computation in milliseconds.",
                "name": "number lastroundtriptime"
            },
            {
                "descr": "Integer value to be used as the last round trip time.",
                "name": "number value"
            }
        ],
        "path": "love/enet.peer-last_round_trip_time",
        "syntax": "peer:last_round_trip_time()",
        "type": "enet"
    },
    "peer:ping": {
        "descr": "Send a ping request to  peer, updates  round_trip_time. This is called automatically at regular intervals.",
        "name": "enet.peer:ping",
        "params": [],
        "path": "love/enet.peer-ping",
        "syntax": "peer:ping()",
        "type": "enet"
    },
    "peer:ping interval": {
        "descr": "Specifies the interval in milliseconds that pings are sent to the other end of the connection (defaults to 500).",
        "name": "enet.peer:ping interval",
        "params": [
            {
                "descr": "Time in milliseconds to wait before automatically calling  peer:ping().",
                "name": "number interval"
            }
        ],
        "path": "love/enet.peer-ping_interval",
        "syntax": "peer:ping_interval(interval)",
        "type": "enet"
    },
    "peer:receive": {
        "descr": "Attempts to dequeue an incoming packet for this  peer. Returns nil if there are no packets waiting. Otherwise returns two values: The string representing the packet data, and the channel the packet came from.",
        "name": "enet.peer:receive",
        "params": [
            {
                "descr": "Data from the received packet in a string.",
                "name": "string data"
            },
            {
                "descr": "Channel the packet was received from.",
                "name": "number channel"
            }
        ],
        "path": "love/enet.peer-receive",
        "syntax": "peer:receive()",
        "type": "enet"
    },
    "peer:reset": {
        "descr": "Forcefully disconnects  peer. The  peer is not notified of the disconnection.",
        "name": "enet.peer:reset",
        "params": [],
        "path": "love/enet.peer-reset",
        "syntax": "peer:reset()",
        "type": "enet"
    },
    "peer:round trip time": {
        "descr": "Returns or sets the current round trip time (i.e. ping). If value is nil the current value of the  peer is returned. Otherwise the round trip time is set to the specified value and returned.",
        "name": "enet.peer:round trip time",
        "params": [
            {
                "descr": "The  peer's current round trip time in milliseconds.",
                "name": "number roundtriptime"
            },
            {
                "descr": "Integer value to be used as the new round trip time.",
                "name": "number value"
            }
        ],
        "path": "love/enet.peer-round_trip_time",
        "syntax": "peer:round_trip_time()",
        "type": "enet"
    },
    "peer:send": {
        "descr": "Queues a packet to be sent to the  peer.",
        "name": "enet.peer:send",
        "params": [
            {
                "descr": "The contents of the packet, it must be a string.",
                "name": "string data"
            },
            {
                "descr": "The channel to send the packet on. ",
                "name": "number channel"
            },
            {
                "descr": "flag is one of \"reliable\", \"unsequenced\", or \"unreliable\". ",
                "name": "string flag"
            }
        ],
        "path": "love/enet.peer-send",
        "syntax": "peer:send(data, channel, flag)",
        "type": "enet"
    },
    "peer:state": {
        "descr": "Returns the state of the  peer as a string.",
        "name": "enet.peer:state",
        "params": [
            {
                "descr": "The  peer's current state. It can be any of the following:",
                "name": "string state"
            }
        ],
        "path": "love/enet.peer-state",
        "syntax": "peer:state()",
        "type": "enet"
    },
    "peer:throttle configure": {
        "descr": "Changes the probability at which unreliable packets should not be dropped.",
        "name": "enet.peer:throttle configure",
        "params": [
            {
                "descr": "Interval in milliseconds to measure lowest mean  RTT.",
                "name": "number interval"
            },
            {
                "descr": "Rate at which to increase throttle probability as mean  RTT declines.",
                "name": "number acceleration"
            },
            {
                "descr": "Rate at which to decrease throttle probability as mean  RTT increases.",
                "name": "number deceleration"
            }
        ],
        "path": "love/enet.peer-throttle_configure",
        "syntax": "peer:throttle_configure(interval, acceleration, deceleration)",
        "type": "enet"
    },
    "peer:timeout": {
        "descr": "Returns or sets the parameters when a timeout is detected. This is happens either after a fixed timeout or a variable timeout of time that takes the round trip time into account. The former is specified with the maximum parameter.",
        "name": "enet.peer:timeout",
        "params": [
            {
                "descr": "A factor that is multiplied with a value that based on the average  round trip time to compute the timeout limit.",
                "name": "number limit"
            },
            {
                "descr": "Timeout value, in milliseconds, that a reliable packet has to be acknowledged if the variable timeout limit was exceeded before dropping the  peer.",
                "name": "number minimum"
            },
            {
                "descr": "Fixed timeout in milliseconds for which any packet has to be acknowledged before dropping the  peer.",
                "name": "number maximum"
            },
            {
                "descr": "A factor that is multiplied with a value that based on the average  round trip time to compute the timeout limit.",
                "name": "number limit"
            },
            {
                "descr": "Timeout value, in milliseconds, that a reliable packet has to be acknowledged if the variable timeout limit was exceeded before dropping the  peer.",
                "name": "number minimum"
            },
            {
                "descr": "Fixed timeout in milliseconds for which any packet has to be acknowledged before dropping the  peer.",
                "name": "number maximum"
            }
        ],
        "path": "love/enet.peer-timeout",
        "syntax": "peer:timeout(limit, minimum, maximum)",
        "type": "enet"
    },
    "play": {
        "descr": "Plays the specified Source.",
        "name": "love.audio.play",
        "params": [
            {
                "descr": "The Source to play.",
                "name": "Source source"
            }
        ],
        "path": "love/love.audio.play",
        "syntax": "love.audio.play( source )",
        "type": "love.audio"
    },
    "point": {
        "descr": "Draws a point.",
        "name": "love.graphics.point",
        "params": [
            {
                "descr": "The position on the x-axis.",
                "name": "number x"
            },
            {
                "descr": "The position on the y-axis.",
                "name": "number y"
            }
        ],
        "path": "love/love.graphics.point",
        "syntax": "love.graphics.point( x, y )",
        "type": "love.graphics"
    },
    "points": {
        "descr": "Draws one or more points.",
        "name": "love.graphics.points",
        "params": [
            {
                "descr": "The position of the first point on the x-axis.",
                "name": "number x"
            },
            {
                "descr": "The position of the first point on the y-axis.",
                "name": "number y"
            },
            {
                "descr": "The x and y coordinates of additional points.",
                "name": "number ..."
            }
        ],
        "path": "love/love.graphics.points",
        "syntax": "love.graphics.points( x, y, ... )",
        "type": "love.graphics"
    },
    "poll": {
        "descr": "Returns an iterator for messages in the event queue.",
        "name": "love.event.poll",
        "params": [
            {
                "descr": "Iterator function usable in a for loop.",
                "name": "function i"
            }
        ],
        "path": "love/love.event.poll",
        "syntax": "i = love.event.poll( )",
        "type": "love.event"
    },
    "polygon": {
        "descr": "Draw a polygon.",
        "name": "love.graphics.polygon",
        "params": [
            {
                "descr": "How to draw the polygon.",
                "name": "DrawMode mode"
            },
            {
                "descr": "The vertices of the polygon.",
                "name": "number ..."
            }
        ],
        "path": "love/love.graphics.polygon",
        "syntax": "love.graphics.polygon( mode, ... )",
        "type": "love.graphics"
    },
    "pop": {
        "descr": "Pops the current coordinate transformation from the transformation stack.",
        "name": "love.graphics.pop",
        "params": [],
        "path": "love/love.graphics.pop",
        "syntax": "love.graphics.pop()",
        "type": "love.graphics"
    },
    "present": {
        "descr": "Displays the results of drawing operations on the screen.",
        "name": "love.graphics.present",
        "params": [],
        "path": "love/love.graphics.present",
        "syntax": "love.graphics.present( )",
        "type": "love.graphics"
    },
    "print": {
        "descr": "Draws text on screen. If no Font is set, one will be created and set (once) if needed.",
        "name": "love.graphics.print",
        "params": [
            {
                "descr": "The text to draw.",
                "name": "string text"
            },
            {
                "descr": "The position to draw the object (x-axis).",
                "name": "number x"
            },
            {
                "descr": "The position to draw the object (y-axis).",
                "name": "number y"
            },
            {
                "descr": "Orientation (radians).",
                "name": "number r (0)"
            },
            {
                "descr": "Scale factor (x-axis).",
                "name": "number sx (1)"
            },
            {
                "descr": "Scale factor (y-axis).",
                "name": "number sy (sx)"
            },
            {
                "descr": "Origin offset (x-axis).",
                "name": "number ox (0)"
            },
            {
                "descr": "Origin offset (y-axis).",
                "name": "number oy (0)"
            },
            {
                "descr": "Shearing factor (x-axis).",
                "name": "number kx (0) Available since 0.8.0"
            },
            {
                "descr": "Shearing factor (y-axis).",
                "name": "number ky (0) Available since 0.8.0"
            }
        ],
        "path": "love/love.graphics.print",
        "syntax": "love.graphics.print( text, x, y, r, sx, sy, ox, oy, kx, ky )",
        "type": "love.graphics"
    },
    "printf": {
        "descr": "Draws formatted text, with word wrap and alignment.",
        "name": "love.graphics.printf",
        "params": [
            {
                "descr": "A text string.",
                "name": "string text"
            },
            {
                "descr": "The position on the x-axis.",
                "name": "number x"
            },
            {
                "descr": "The position on the y-axis.",
                "name": "number y"
            },
            {
                "descr": "Wrap the line after this many horizontal pixels.",
                "name": "number limit"
            },
            {
                "descr": "The alignment.",
                "name": "AlignMode align (\"left\")"
            }
        ],
        "path": "love/love.graphics.printf",
        "syntax": "love.graphics.printf( text, x, y, limit, align )",
        "type": "love.graphics"
    },
    "pump": {
        "descr": "Pump events into the event queue. This is a low-level function, and is usually not called by the user, but by love.run. Note that this does need to be called for any OS to think you're still running, and if you want to handle OS-generated events at all (think callbacks).",
        "name": "love.event.pump",
        "params": [],
        "path": "love/love.event.pump",
        "syntax": "love.event.pump( )",
        "type": "love.event"
    },
    "push": {
        "descr": "Copies and pushes the current coordinate transformation to the transformation stack.",
        "name": "love.graphics.push",
        "params": [],
        "path": "love/love.graphics.push",
        "syntax": "love.graphics.push( )",
        "type": "love.graphics"
    },
    "quad": {
        "descr": "Draws a quadrilateral shape.",
        "name": "love.graphics.quad",
        "params": [
            {
                "descr": "How to draw the quad.",
                "name": "DrawMode mode"
            },
            {
                "descr": "The position of the top left corner along x-axis.",
                "name": "number x1"
            },
            {
                "descr": "The position of the top left corner along y-axis.",
                "name": "number y1"
            },
            {
                "descr": "The position of the top right corner along x-axis.",
                "name": "number x2"
            },
            {
                "descr": "The position of the top right corner along y-axis.",
                "name": "number y2"
            },
            {
                "descr": "The position of the bottom right corner along x-axis.",
                "name": "number x3"
            },
            {
                "descr": "The position of the bottom right corner along y-axis.",
                "name": "number y3"
            },
            {
                "descr": "The position of the bottom left corner along x-axis.",
                "name": "number x4"
            },
            {
                "descr": "The position of the bottom left corner along y-axis.",
                "name": "number y4"
            }
        ],
        "path": "love/love.graphics.quad",
        "syntax": "love.graphics.quad( mode, x1, y1, x2, y2, x3, y3, x4, y4 )",
        "type": "love.graphics"
    },
    "quit": {
        "descr": "Callback function triggered when the game is closed.",
        "name": "love.quit",
        "params": [
            {
                "descr": "Abort quitting. If true, do not close the game.",
                "name": "boolean r"
            }
        ],
        "path": "love/love.quit",
        "syntax": "r = love.quit( )",
        "type": "love"
    },
    "random": {
        "descr": "Generates a pseudo-random number in a platform independent manner.",
        "name": "love.math.random",
        "params": [
            {
                "descr": "The pseudo-random number.",
                "name": "number number"
            }
        ],
        "path": "love/love.math.random",
        "syntax": "number = love.math.random( )",
        "type": "love.math"
    },
    "randomNormal": {
        "descr": "Get a normally distributed pseudo random number.",
        "name": "love.math.randomNormal",
        "params": [
            {
                "descr": "Standard deviation of the distribution.",
                "name": "number stddev (1)"
            },
            {
                "descr": "The mean of the distribution.",
                "name": "number mean (0)"
            },
            {
                "descr": "Normally distributed random number with variance (stddev)² and the specified mean.",
                "name": "number number"
            }
        ],
        "path": "love/love.math.randomnormal",
        "syntax": "number = love.math.randomNormal( stddev, mean )",
        "type": "love.math"
    },
    "read": {
        "descr": "Read the contents of a file",
        "name": "love.filesystem.read",
        "params": [
            {
                "descr": "The name (and path) of the file",
                "name": "string name"
            },
            {
                "descr": "How many bytes to read",
                "name": "number size (all)"
            },
            {
                "descr": "The file contents",
                "name": "string contents"
            },
            {
                "descr": "How many bytes have been read",
                "name": "number size"
            }
        ],
        "path": "love/love.filesystem.read",
        "syntax": "contents, size = love.filesystem.read( name, size )",
        "type": "love.filesystem"
    },
    "rectangle": {
        "descr": "Draws a rectangle.",
        "name": "love.graphics.rectangle",
        "params": [
            {
                "descr": "How to draw the rectangle.",
                "name": "DrawMode mode"
            },
            {
                "descr": "The position of top-left corner along the x-axis.",
                "name": "number x"
            },
            {
                "descr": "The position of top-left corner along the y-axis.",
                "name": "number y"
            },
            {
                "descr": "Width of the rectangle.",
                "name": "number width"
            },
            {
                "descr": "Height of the rectangle.",
                "name": "number height"
            }
        ],
        "path": "love/love.graphics.rectangle",
        "syntax": "love.graphics.rectangle( mode, x, y, width, height )",
        "type": "love.graphics"
    },
    "releaseerrhand": {
        "descr": "Nothing.",
        "name": "love.releaseerrhand",
        "params": [
            {
                "descr": "The error message.",
                "name": "string msg"
            }
        ],
        "path": "love/love.releaseerrhand",
        "syntax": "love.releaseerrhand( msg )",
        "type": "love"
    },
    "remove": {
        "descr": "Removes a file or empty directory.",
        "name": "love.filesystem.remove",
        "params": [
            {
                "descr": "The file or directory to remove.",
                "name": "string name"
            },
            {
                "descr": "True if the file/directory was removed, false otherwise.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.filesystem.remove",
        "syntax": "success = love.filesystem.remove( name )",
        "type": "love.filesystem"
    },
    "requestAttention": {
        "descr": "Causes the window to request the attention of the user if it is not in the foreground.",
        "name": "love.window.requestAttention",
        "params": [
            {
                "descr": "Whether to continuously request attention until the window becomes active, or to do it only once.",
                "name": "boolean continuous (false)"
            }
        ],
        "path": "love/love.window.requestattention",
        "syntax": "love.window.requestAttention( continuous )",
        "type": "love.window"
    },
    "reset": {
        "descr": "Resets the current graphics settings.",
        "name": "love.graphics.reset",
        "params": [],
        "path": "love/love.graphics.reset",
        "syntax": "love.graphics.reset( )",
        "type": "love.graphics"
    },
    "resize": {
        "descr": "Called when the window is resized, for example if the user resizes the window, or if love.window.setMode is called with an unsupported width or height in fullscreen and the window chooses the closest appropriate size.",
        "name": "love.resize",
        "params": [
            {
                "descr": "The new width, in pixels.",
                "name": "number w"
            },
            {
                "descr": "The new height, in pixels.",
                "name": "number h"
            }
        ],
        "path": "love/love.resize",
        "syntax": "love.resize( w, h )",
        "type": "love"
    },
    "resume": {
        "descr": "Resumes all audio.",
        "name": "love.audio.resume",
        "params": [],
        "path": "love/love.audio.resume",
        "syntax": "love.audio.resume( )",
        "type": "love.audio"
    },
    "rewind": {
        "descr": "Rewinds all playing audio.",
        "name": "love.audio.rewind",
        "params": [],
        "path": "love/love.audio.rewind",
        "syntax": "love.audio.rewind( )",
        "type": "love.audio"
    },
    "rotate": {
        "descr": "Rotates the coordinate system in two dimensions.",
        "name": "love.graphics.rotate",
        "params": [
            {
                "descr": "The amount to rotate the coordinate system in radians.",
                "name": "number angle"
            }
        ],
        "path": "love/love.graphics.rotate",
        "syntax": "love.graphics.rotate( angle )",
        "type": "love.graphics"
    },
    "run": {
        "descr": "The main function, containing the main loop. A sensible default is used when left out.",
        "name": "love.run",
        "params": [],
        "path": "love/love.run",
        "syntax": "love.run( )",
        "type": "love"
    },
    "saveGamepadMappings": {
        "descr": "Saves the virtual gamepad mappings of all Joysticks that are recognized as gamepads and have either been recently used or their gamepad bindings have been modified.",
        "name": "love.joystick.saveGamepadMappings",
        "params": [
            {
                "descr": "The filename to save the mappings string to.",
                "name": "string filename"
            },
            {
                "descr": "The mappings string that was written to the file.",
                "name": "string mappings"
            }
        ],
        "path": "love/love.joystick.savegamepadmappings",
        "syntax": "mappings = love.joystick.saveGamepadMappings( filename )",
        "type": "love.joystick"
    },
    "scale": {
        "descr": "Scales the coordinate system in two dimensions.",
        "name": "love.graphics.scale",
        "params": [
            {
                "descr": "The scaling in the direction of the x-axis.",
                "name": "number sx"
            },
            {
                "descr": "The scaling in the direction of the y-axis. ",
                "name": "number sy (sx)"
            }
        ],
        "path": "love/love.graphics.scale",
        "syntax": "love.graphics.scale( sx, sy )",
        "type": "love.graphics"
    },
    "setBackgroundColor": {
        "descr": "Sets the background color.",
        "name": "love.graphics.setBackgroundColor",
        "params": [
            {
                "descr": "The red component (0-255).",
                "name": "number red"
            },
            {
                "descr": "The green component (0-255).",
                "name": "number green"
            },
            {
                "descr": "The blue component (0-255).",
                "name": "number blue"
            }
        ],
        "path": "love/love.graphics.setbackgroundcolor",
        "syntax": "love.graphics.setBackgroundColor( red, green, blue )",
        "type": "love.graphics"
    },
    "setBlendMode": {
        "descr": "Sets the blending mode.",
        "name": "love.graphics.setBlendMode",
        "params": [
            {
                "descr": "The blend mode to use.",
                "name": "BlendMode mode"
            }
        ],
        "path": "love/love.graphics.setblendmode",
        "syntax": "love.graphics.setBlendMode( mode )",
        "type": "love.graphics"
    },
    "setCanvas": {
        "descr": "Captures drawing operations to a Canvas.",
        "name": "love.graphics.setCanvas",
        "params": [
            {
                "descr": "The new target.",
                "name": "Canvas canvas"
            }
        ],
        "path": "love/love.graphics.setcanvas",
        "syntax": "love.graphics.setCanvas( canvas )",
        "type": "love.graphics"
    },
    "setCaption": {
        "descr": "Sets the window caption.",
        "name": "love.graphics.setCaption",
        "params": [
            {
                "descr": "The new window caption.",
                "name": "string caption"
            }
        ],
        "path": "love/love.graphics.setcaption",
        "syntax": "love.graphics.setCaption( caption )",
        "type": "love.graphics"
    },
    "setClipboardText": {
        "descr": "Puts text in the clipboard.",
        "name": "love.system.setClipboardText",
        "params": [
            {
                "descr": "The new text to hold in the system's clipboard.",
                "name": "string text"
            }
        ],
        "path": "love/love.system.setclipboardtext",
        "syntax": "love.system.setClipboardText( text )",
        "type": "love.system"
    },
    "setColor": {
        "descr": "Sets the color used for drawing.",
        "name": "love.graphics.setColor",
        "params": [
            {
                "descr": "The amount of red.",
                "name": "number red"
            },
            {
                "descr": "The amount of green.",
                "name": "number green"
            },
            {
                "descr": "The amount of blue.",
                "name": "number blue"
            },
            {
                "descr": "The amount of alpha. The alpha value will be applied to all subsequent draw operations, even the drawing of an image.",
                "name": "number alpha (255)"
            }
        ],
        "path": "love/love.graphics.setcolor",
        "syntax": "love.graphics.setColor( red, green, blue, alpha )",
        "type": "love.graphics"
    },
    "setColorMask": {
        "descr": "Sets the color mask. Enables or disables specific color components when rendering and clearing the screen. For example, if red is set to false, no further changes will be made to the red component of any pixels.",
        "name": "love.graphics.setColorMask",
        "params": [
            {
                "descr": "Render red component.",
                "name": "boolean red"
            },
            {
                "descr": "Render green component.",
                "name": "boolean green"
            },
            {
                "descr": "Render blue component.",
                "name": "boolean blue"
            },
            {
                "descr": "Render alpha component.",
                "name": "boolean alpha"
            }
        ],
        "path": "love/love.graphics.setcolormask",
        "syntax": "love.graphics.setColorMask( red, green, blue, alpha )",
        "type": "love.graphics"
    },
    "setColorMode": {
        "descr": "Sets the color mode (which controls how images are affected by the current color).",
        "name": "love.graphics.setColorMode",
        "params": [
            {
                "descr": "The color mode to use.",
                "name": "ColorMode mode"
            }
        ],
        "path": "love/love.graphics.setcolormode",
        "syntax": "love.graphics.setColorMode( mode )",
        "type": "love.graphics"
    },
    "setCursor": {
        "descr": "Sets the current mouse cursor.",
        "name": "love.mouse.setCursor",
        "params": [
            {
                "descr": "The Cursor object to use as the current mouse cursor.",
                "name": "Cursor cursor"
            }
        ],
        "path": "love/love.mouse.setcursor",
        "syntax": "love.mouse.setCursor( cursor )",
        "type": "love.mouse"
    },
    "setDefaultFilter": {
        "descr": "Sets the default scaling filters used with Images, Canvases, and Fonts.",
        "name": "love.graphics.setDefaultFilter",
        "params": [
            {
                "descr": "Filter mode used when scaling the image down.",
                "name": "FilterMode min"
            },
            {
                "descr": "Filter mode used when scaling the image up.",
                "name": "FilterMode mag"
            },
            {
                "descr": "Maximum amount of Anisotropic Filtering used.",
                "name": "number anisotropy (1)"
            }
        ],
        "path": "love/love.graphics.setdefaultfilter",
        "syntax": "love.graphics.setDefaultFilter( min, mag, anisotropy )",
        "type": "love.graphics"
    },
    "setDefaultImageFilter": {
        "descr": "Sets the default scaling filters.",
        "name": "love.graphics.setDefaultImageFilter",
        "params": [
            {
                "descr": "Filter mode used when scaling the image down.",
                "name": "FilterMode min"
            },
            {
                "descr": "Filter mode used when scaling the image up.",
                "name": "FilterMode mag"
            }
        ],
        "path": "love/love.graphics.setdefaultimagefilter",
        "syntax": "love.graphics.setDefaultImageFilter( min, mag )",
        "type": "love.graphics"
    },
    "setDisplaySleepEnabled": {
        "descr": "Sets whether the display is allowed to sleep while the program is running.",
        "name": "love.window.setDisplaySleepEnabled",
        "params": [
            {
                "descr": "True to enable system display sleep, false to disable it.",
                "name": "boolean enable"
            }
        ],
        "path": "love/love.window.setdisplaysleepenabled",
        "syntax": "love.window.setDisplaySleepEnabled( enable )",
        "type": "love.window"
    },
    "setDistanceModel": {
        "descr": "Sets the distance attenuation model.",
        "name": "love.audio.setDistanceModel",
        "params": [
            {
                "descr": "The new distance model.",
                "name": "DistanceModel model"
            }
        ],
        "path": "love/love.audio.setdistancemodel",
        "syntax": "love.audio.setDistanceModel( model )",
        "type": "love.audio"
    },
    "setDopplerScale": {
        "descr": "Sets a global scale factor for velocity-based doppler effects. The default scale value is 1.",
        "name": "love.audio.setDopplerScale",
        "params": [
            {
                "descr": "The new doppler scale factor. The scale must be greater than 0.",
                "name": "number scale"
            }
        ],
        "path": "love/love.audio.setdopplerscale",
        "syntax": "love.audio.setDopplerScale( scale )",
        "type": "love.audio"
    },
    "setFont": {
        "descr": "Set an already-loaded Font as the current font or create and load a new one from the file and size.",
        "name": "love.graphics.setFont",
        "params": [
            {
                "descr": "The Font object to use.",
                "name": "Font font"
            }
        ],
        "path": "love/love.graphics.setfont",
        "syntax": "love.graphics.setFont( font )",
        "type": "love.graphics"
    },
    "setFullscreen": {
        "descr": "Enters or exits fullscreen. The display to use when entering fullscreen is chosen based on which display the window is currently in, if multiple monitors are connected.",
        "name": "love.window.setFullscreen",
        "params": [
            {
                "descr": "Whether to enter or exit fullscreen mode.",
                "name": "boolean fullscreen"
            },
            {
                "descr": "True if successful, false otherwise.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.window.setfullscreen",
        "syntax": "success = love.window.setFullscreen( fullscreen )",
        "type": "love.window"
    },
    "setGamepadMapping": {
        "descr": "Binds a virtual gamepad input to a button, axis or hat for all Joysticks of a certain type. For example, if this function is used with a GUID returned by a Dualshock 3 controller in OS X, the binding will affect Joystick:getGamepadAxis and Joystick:isGamepadDown for all Dualshock 3 controllers used with the game when run in OS X.",
        "name": "love.joystick.setGamepadMapping",
        "params": [
            {
                "descr": "The OS-dependent GUID for the type of Joystick the binding will affect.",
                "name": "string guid"
            },
            {
                "descr": "The virtual gamepad button to bind.",
                "name": "GamepadButton button"
            },
            {
                "descr": "The type of input to bind the virtual gamepad button to.",
                "name": "JoystickInputType inputtype"
            },
            {
                "descr": "The index of the axis, button, or hat to bind the virtual gamepad button to.",
                "name": "number inputindex"
            },
            {
                "descr": "The direction of the hat, if the virtual gamepad button will be bound to a hat. ",
                "name": "JoystickHat hatdir (nil)"
            },
            {
                "descr": "Whether the virtual gamepad button was successfully bound.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.joystick.setgamepadmapping",
        "syntax": "success = love.joystick.setGamepadMapping( guid, button, inputtype, inputindex, hatdir )",
        "type": "love.joystick"
    },
    "setGrab": {
        "descr": "Grabs the mouse and confines it to the window.",
        "name": "love.mouse.setGrab",
        "params": [
            {
                "descr": "True to confine the mouse, false to let it leave the window.",
                "name": "boolean grab"
            }
        ],
        "path": "love/love.mouse.setgrab",
        "syntax": "love.mouse.setGrab( grab )",
        "type": "love.mouse"
    },
    "setGrabbed": {
        "descr": "Grabs the mouse and confines it to the window.",
        "name": "love.mouse.setGrabbed",
        "params": [
            {
                "descr": "True to confine the mouse, false to let it leave the window.",
                "name": "boolean grab"
            }
        ],
        "path": "love/love.mouse.setgrabbed",
        "syntax": "love.mouse.setGrabbed( grab )",
        "type": "love.mouse"
    },
    "setIcon": {
        "descr": "Sets the window icon until the game is quit. Not all operating systems support very large icon images.",
        "name": "love.window.setIcon",
        "params": [
            {
                "descr": "The window icon image.",
                "name": "ImageData imagedata"
            },
            {
                "descr": "Whether the icon has been set successfully.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.window.seticon",
        "syntax": "success = love.window.setIcon( imagedata )",
        "type": "love.window"
    },
    "setIdentity": {
        "descr": "Sets the write directory for your game. Note that you can only set the name of the folder to store your files in, not the location.",
        "name": "love.filesystem.setIdentity",
        "params": [
            {
                "descr": "The new identity that will be used as write directory.",
                "name": "string name"
            }
        ],
        "path": "love/love.filesystem.setidentity",
        "syntax": "love.filesystem.setIdentity( name )",
        "type": "love.filesystem"
    },
    "setInvertedStencil": {
        "descr": "Defines an inverted stencil for the drawing operations or releases the active one.",
        "name": "love.graphics.setInvertedStencil",
        "params": [
            {
                "descr": "Function that draws the stencil.",
                "name": "function stencilFunction"
            }
        ],
        "path": "love/love.graphics.setinvertedstencil",
        "syntax": "love.graphics.setInvertedStencil( stencilFunction )",
        "type": "love.graphics"
    },
    "setKeyRepeat": {
        "descr": "Enables or disables key repeat for love.keypressed. It is disabled by default.",
        "name": "love.keyboard.setKeyRepeat",
        "params": [
            {
                "descr": "Whether repeat keypress events should be enabled when a key is held down.",
                "name": "boolean enable"
            }
        ],
        "path": "love/love.keyboard.setkeyrepeat",
        "syntax": "love.keyboard.setKeyRepeat( enable )",
        "type": "love.keyboard"
    },
    "setLine": {
        "descr": "Sets the line width and style.",
        "name": "love.graphics.setLine",
        "params": [
            {
                "descr": "The width of the line.",
                "name": "number width"
            },
            {
                "descr": "The LineStyle to use.",
                "name": "LineStyle style (\"smooth\")"
            }
        ],
        "path": "love/love.graphics.setline",
        "syntax": "love.graphics.setLine( width, style )",
        "type": "love.graphics"
    },
    "setLineJoin": {
        "descr": "Sets the line join style. See LineJoin for the possible options.",
        "name": "love.graphics.setLineJoin",
        "params": [
            {
                "descr": "The LineJoin to use.",
                "name": "LineJoin join"
            }
        ],
        "path": "love/love.graphics.setlinejoin",
        "syntax": "love.graphics.setLineJoin( join )",
        "type": "love.graphics"
    },
    "setLineStipple": {
        "descr": "Sets the line stipple pattern.",
        "name": "love.graphics.setLineStipple",
        "params": [
            {
                "descr": "A 16-bit pattern.",
                "name": "number pattern"
            },
            {
                "descr": "Repeat factor.",
                "name": "number repeat (1)"
            }
        ],
        "path": "love/love.graphics.setlinestipple",
        "syntax": "love.graphics.setLineStipple( pattern, repeat )",
        "type": "love.graphics"
    },
    "setLineStyle": {
        "descr": "Sets the line style.",
        "name": "love.graphics.setLineStyle",
        "params": [
            {
                "descr": "The LineStyle to use. Line styles include smooth and rough.",
                "name": "LineStyle style"
            }
        ],
        "path": "love/love.graphics.setlinestyle",
        "syntax": "love.graphics.setLineStyle( style )",
        "type": "love.graphics"
    },
    "setLineWidth": {
        "descr": "Sets the line width.",
        "name": "love.graphics.setLineWidth",
        "params": [
            {
                "descr": "The width of the line.",
                "name": "number width"
            }
        ],
        "path": "love/love.graphics.setlinewidth",
        "syntax": "love.graphics.setLineWidth( width )",
        "type": "love.graphics"
    },
    "setMeter": {
        "descr": "Sets the pixels to meter scale factor.",
        "name": "love.physics.setMeter",
        "params": [
            {
                "descr": "The scale factor as an integer.",
                "name": "number scale"
            }
        ],
        "path": "love/love.physics.setmeter",
        "syntax": "love.physics.setMeter( scale )",
        "type": "love.physics"
    },
    "setMode": {
        "descr": "Sets the display mode and properties of the window.",
        "name": "love.window.setMode",
        "params": [
            {
                "descr": "Display width.",
                "name": "number width"
            },
            {
                "descr": "Display height.",
                "name": "number height"
            },
            {
                "descr": "The flags table with the options:  boolean fullscreen (false)  Fullscreen (true), or windowed (false).",
                "name": "table flags"
            },
            {
                "descr": "The type of fullscreen to use. This defaults to \"normal\" in 0.9.2 and older.",
                "name": "FullscreenType fullscreentype (\"desktop\")"
            },
            {
                "descr": "True if LÖVE should wait for vsync, false otherwise.",
                "name": "boolean vsync (true)"
            },
            {
                "descr": "The number of antialiasing samples.",
                "name": "number msaa (0)"
            },
            {
                "descr": "True if the window should be resizable in windowed mode, false otherwise.",
                "name": "boolean resizable (false)"
            },
            {
                "descr": "True if the window should be borderless in windowed mode, false otherwise.",
                "name": "boolean borderless (false)"
            },
            {
                "descr": "True if the window should be centered in windowed mode, false otherwise.",
                "name": "boolean centered (true)"
            },
            {
                "descr": "The index of the display to show the window in, if multiple monitors are available.",
                "name": "number display (1)"
            },
            {
                "descr": "The minimum width of the window, if it's resizable. ",
                "name": "number minwidth (1)"
            },
            {
                "descr": "The minimum height of the window, if it's resizable. ",
                "name": "number minheight (1)"
            },
            {
                "descr": "True if high-dpi mode should be used on Retina displays in OS X and iOS. ",
                "name": "boolean highdpi (false)"
            },
            {
                "descr": "The x-coordinate of the window's position in the specified display. ",
                "name": "number x (nil)"
            },
            {
                "descr": "The y-coordinate of the window's position in the specified display. ",
                "name": "number y (nil)"
            },
            {
                "descr": "Removed in 0.10.0 (set t.gammacorrect in conf.lua instead). ",
                "name": "boolean srgb (false)"
            },
            {
                "descr": "True if successful, false otherwise.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.window.setmode",
        "syntax": "success = love.window.setMode( width, height, flags )",
        "type": "love.window"
    },
    "setNewFont": {
        "descr": "Creates and sets a new Font.",
        "name": "love.graphics.setNewFont",
        "params": [
            {
                "descr": "The size of the font.",
                "name": "number size (12)"
            },
            {
                "descr": "The new font.",
                "name": "Font font"
            }
        ],
        "path": "love/love.graphics.setnewfont",
        "syntax": "font = love.graphics.setNewFont( size )",
        "type": "love.graphics"
    },
    "setOrientation": {
        "descr": "Sets the orientation of the listener.",
        "name": "love.audio.setOrientation",
        "params": [
            {
                "descr": "Forward vector of the listener orientation.",
                "name": "number fx, fy, fz"
            },
            {
                "descr": "Up vector of the listener orientation.",
                "name": "number ux, uy, uz"
            }
        ],
        "path": "love/love.audio.setorientation",
        "syntax": "love.audio.setOrientation( fx, fy, fz, ux, uy, uz )",
        "type": "love.audio"
    },
    "setPixelEffect": {
        "descr": "Sets or resets a PixelEffect as the current pixel effect. All drawing operations until the next love.graphics.setPixelEffect will be drawn using the PixelEffect object specified.",
        "name": "love.graphics.setPixelEffect",
        "params": [
            {
                "descr": "The new pixel effect.",
                "name": "PixelEffect pixeleffect"
            }
        ],
        "path": "love/love.graphics.setpixeleffect",
        "syntax": "love.graphics.setPixelEffect( pixeleffect )",
        "type": "love.graphics"
    },
    "setPoint": {
        "descr": "Sets the point size and style.",
        "name": "love.graphics.setPoint",
        "params": [
            {
                "descr": "The new point size.",
                "name": "number size"
            },
            {
                "descr": "The new point style.",
                "name": "PointStyle style"
            }
        ],
        "path": "love/love.graphics.setpoint",
        "syntax": "love.graphics.setPoint( size, style )",
        "type": "love.graphics"
    },
    "setPointSize": {
        "descr": "Sets the point size.",
        "name": "love.graphics.setPointSize",
        "params": [
            {
                "descr": "The new point size.",
                "name": "number size"
            }
        ],
        "path": "love/love.graphics.setpointsize",
        "syntax": "love.graphics.setPointSize( size )",
        "type": "love.graphics"
    },
    "setPointStyle": {
        "descr": "Sets the point style.",
        "name": "love.graphics.setPointStyle",
        "params": [
            {
                "descr": "The new point style.",
                "name": "PointStyle style"
            }
        ],
        "path": "love/love.graphics.setpointstyle",
        "syntax": "love.graphics.setPointStyle( style )",
        "type": "love.graphics"
    },
    "setPosition": {
        "descr": "Sets the position of the window on the screen.",
        "name": "love.window.setPosition",
        "params": [
            {
                "descr": "The x-coordinate of the window's position.",
                "name": "number x"
            },
            {
                "descr": "The y-coordinate of the window's position.",
                "name": "number y"
            },
            {
                "descr": "The index of the display that the new window position is relative to.",
                "name": "number display (1)"
            }
        ],
        "path": "love/love.window.setposition",
        "syntax": "love.window.setPosition( x, y, display )",
        "type": "love.window"
    },
    "setRandomSeed": {
        "descr": "Sets the seed of the random number generator using the specified integer number.",
        "name": "love.math.setRandomSeed",
        "params": [
            {
                "descr": "The integer number with which you want to seed the randomization. ",
                "name": "number seed"
            }
        ],
        "path": "love/love.math.setrandomseed",
        "syntax": "love.math.setRandomSeed( seed )",
        "type": "love.math"
    },
    "setRelativeMode": {
        "descr": "Sets whether relative mode is enabled for the mouse.",
        "name": "love.mouse.setRelativeMode",
        "params": [
            {
                "descr": "True to enable relative mode, false to disable it.",
                "name": "boolean enable"
            }
        ],
        "path": "love/love.mouse.setrelativemode",
        "syntax": "love.mouse.setRelativeMode( enable )",
        "type": "love.mouse"
    },
    "setRenderTarget": {
        "descr": "Sets or resets a Framebuffer as render target. All drawing operations until the next love.graphics.setRenderTarget will be directed to the Framebuffer object specified.",
        "name": "love.graphics.setRenderTarget",
        "params": [
            {
                "descr": "The new render target.",
                "name": "Framebuffer framebuffer"
            }
        ],
        "path": "love/love.graphics.setrendertarget",
        "syntax": "love.graphics.setRenderTarget( framebuffer )",
        "type": "love.graphics"
    },
    "setRequirePath": {
        "descr": "Sets the filesystem paths that will be searched when require is called.",
        "name": "love.filesystem.setRequirePath",
        "params": [
            {
                "descr": "The paths that the require function will check in love's filesystem.",
                "name": "string paths"
            }
        ],
        "path": "love/love.filesystem.setrequirepath",
        "syntax": "love.filesystem.setRequirePath( paths )",
        "type": "love.filesystem"
    },
    "setScissor": {
        "descr": "Sets or disables scissor.",
        "name": "love.graphics.setScissor",
        "params": [
            {
                "descr": "x coordinate of upper left corner.",
                "name": "number x"
            },
            {
                "descr": "y coordinate of upper left corner.",
                "name": "number y"
            },
            {
                "descr": "width of clipping rectangle.",
                "name": "number width"
            },
            {
                "descr": "height of clipping rectangle.",
                "name": "number height"
            }
        ],
        "path": "love/love.graphics.setscissor",
        "syntax": "love.graphics.setScissor( x, y, width, height )",
        "type": "love.graphics"
    },
    "setShader": {
        "descr": "Sets or resets a Shader as the current pixel effect or vertex shaders. All drawing operations until the next love.graphics.setShader will be drawn using the Shader object specified.",
        "name": "love.graphics.setShader",
        "params": [
            {
                "descr": "The new shader.",
                "name": "Shader shader"
            }
        ],
        "path": "love/love.graphics.setshader",
        "syntax": "love.graphics.setShader( shader )",
        "type": "love.graphics"
    },
    "setSource": {
        "descr": "Sets the source of the game, where the code is present. This function can only be called once, and is normally automatically done by LÖVE.",
        "name": "love.filesystem.setSource",
        "params": [
            {
                "descr": "Absolute path to the game's source folder.",
                "name": "string path"
            }
        ],
        "path": "love/love.filesystem.setsource",
        "syntax": "love.filesystem.setSource( path )",
        "type": "love.filesystem"
    },
    "setStencil": {
        "descr": "Defines or releases a stencil for the drawing operations.",
        "name": "love.graphics.setStencil",
        "params": [
            {
                "descr": "Function that draws the stencil.",
                "name": "function stencilFunction"
            }
        ],
        "path": "love/love.graphics.setstencil",
        "syntax": "love.graphics.setStencil( stencilFunction )",
        "type": "love.graphics"
    },
    "setStencilTest": {
        "descr": "Configures or disables stencil testing.",
        "name": "love.graphics.setStencilTest",
        "params": [
            {
                "descr": "The type of comparison to make for each pixel.",
                "name": "CompareMode comparemode"
            },
            {
                "descr": "The value to use when comparing with the stencil value of each pixel. ",
                "name": "number comparevalue"
            }
        ],
        "path": "love/love.graphics.setstenciltest",
        "syntax": "love.graphics.setStencilTest( comparemode, comparevalue )",
        "type": "love.graphics"
    },
    "setSymlinksEnabled": {
        "descr": "Sets whether love.filesystem follows symbolic links. It is enabled by default in version 0.10.0 and newer, and disabled by default in 0.9.2.",
        "name": "love.filesystem.setSymlinksEnabled",
        "params": [
            {
                "descr": "Whether love.filesystem should follow symbolic links.",
                "name": "boolean enable"
            }
        ],
        "path": "love/love.filesystem.setsymlinksenabled",
        "syntax": "love.filesystem.setSymlinksEnabled( enable )",
        "type": "love.filesystem"
    },
    "setTextInput": {
        "descr": "Enables or disables text input events. It is enabled by default on Windows, Mac, and Linux, and disabled by default on iOS and Android.",
        "name": "love.keyboard.setTextInput",
        "params": [
            {
                "descr": "Whether text input events should be enabled.",
                "name": "boolean enable"
            }
        ],
        "path": "love/love.keyboard.settextinput",
        "syntax": "love.keyboard.setTextInput( enable )",
        "type": "love.keyboard"
    },
    "setTitle": {
        "descr": "Sets the window title.",
        "name": "love.window.setTitle",
        "params": [
            {
                "descr": "The new window title.",
                "name": "string title"
            }
        ],
        "path": "love/love.window.settitle",
        "syntax": "love.window.setTitle( title )",
        "type": "love.window"
    },
    "setVelocity": {
        "descr": "Sets the velocity of the listener.",
        "name": "love.audio.setVelocity",
        "params": [
            {
                "descr": "The X velocity of the listener.",
                "name": "number x"
            },
            {
                "descr": "The Y velocity of the listener.",
                "name": "number y"
            },
            {
                "descr": "The Z velocity of the listener.",
                "name": "number z"
            }
        ],
        "path": "love/love.audio.setvelocity",
        "syntax": "love.audio.setVelocity( x, y, z )",
        "type": "love.audio"
    },
    "setVisible": {
        "descr": "Sets the current visibility of the cursor.",
        "name": "love.mouse.setVisible",
        "params": [
            {
                "descr": "True to set the cursor to visible, false to hide the cursor.",
                "name": "boolean visible"
            }
        ],
        "path": "love/love.mouse.setvisible",
        "syntax": "love.mouse.setVisible( visible )",
        "type": "love.mouse"
    },
    "setVolume": {
        "descr": "Sets the master volume.",
        "name": "love.audio.setVolume",
        "params": [
            {
                "descr": "1.0 is max and 0.0 is off.",
                "name": "number volume"
            }
        ],
        "path": "love/love.audio.setvolume",
        "syntax": "love.audio.setVolume( volume )",
        "type": "love.audio"
    },
    "setWireframe": {
        "descr": "Sets whether wireframe lines will be used when drawing.",
        "name": "love.graphics.setWireframe",
        "params": [
            {
                "descr": "True to enable wireframe mode when drawing, false to disable it.",
                "name": "boolean enable"
            }
        ],
        "path": "love/love.graphics.setwireframe",
        "syntax": "love.graphics.setWireframe( enable )",
        "type": "love.graphics"
    },
    "setX": {
        "descr": "Sets the current X position of the mouse.",
        "name": "love.mouse.setX",
        "params": [
            {
                "descr": "The new position of the mouse along the x-axis.",
                "name": "number x"
            }
        ],
        "path": "love/love.mouse.setx",
        "syntax": "love.mouse.setX( x )",
        "type": "love.mouse"
    },
    "setY": {
        "descr": "Sets the current Y position of the mouse.",
        "name": "love.mouse.setY",
        "params": [
            {
                "descr": "The new position of the mouse along the y-axis.",
                "name": "number y"
            }
        ],
        "path": "love/love.mouse.sety",
        "syntax": "love.mouse.setY( y )",
        "type": "love.mouse"
    },
    "shear": {
        "descr": "Shears the coordinate system.",
        "name": "love.graphics.shear",
        "params": [
            {
                "descr": "The shear factor on the x-axis.",
                "name": "number kx"
            },
            {
                "descr": "The shear factor on the y-axis.",
                "name": "number ky"
            }
        ],
        "path": "love/love.graphics.shear",
        "syntax": "love.graphics.shear( kx, ky )",
        "type": "love.graphics"
    },
    "showMessageBox": {
        "descr": "Displays a message box dialog above the love window. The message box contains a title, optional text, and buttons.",
        "name": "love.window.showMessageBox",
        "params": [
            {
                "descr": "The title of the message box.",
                "name": "string title"
            },
            {
                "descr": "The text inside the message box.",
                "name": "string message"
            },
            {
                "descr": "The type of the message box.",
                "name": "MessageBoxType type (\"info\")"
            },
            {
                "descr": "Whether the message box should be attached to the love window or free-floating.",
                "name": "boolean attachtowindow (true)"
            },
            {
                "descr": "Whether the message box was successfully displayed.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.window.showmessagebox",
        "syntax": "success = love.window.showMessageBox( title, message, type, attachtowindow )",
        "type": "love.window"
    },
    "sleep": {
        "descr": "Pauses the current thread for the specified amount of time.",
        "name": "love.timer.sleep",
        "params": [
            {
                "descr": "Seconds to sleep for.",
                "name": "number s"
            }
        ],
        "path": "love/love.timer.sleep",
        "syntax": "love.timer.sleep( s )",
        "type": "love.timer"
    },
    "stencil": {
        "descr": "Draws geometry as a stencil.",
        "name": "love.graphics.stencil",
        "params": [
            {
                "descr": "Function which draws geometry. The stencil values of pixels, rather than the color of each pixel, will be affected by the geometry.",
                "name": "function stencilfunction"
            },
            {
                "descr": "How to modify any stencil values of pixels that are touched by what's drawn in the stencil function.",
                "name": "StencilAction action (\"replace\")"
            },
            {
                "descr": "The new stencil value to use for pixels if the \"replace\" stencil action is used. ",
                "name": "number value (1)"
            },
            {
                "descr": "True to preserve old stencil values of pixels, false to re-set every pixel's stencil value to 0 before executing the stencil function. ",
                "name": "boolean keepvalues (false)"
            }
        ],
        "path": "love/love.graphics.stencil",
        "syntax": "love.graphics.stencil( stencilfunction, action, value, keepvalues )",
        "type": "love.graphics"
    },
    "step": {
        "descr": "Measures the time between two frames. Calling this changes the return value of love.timer.getDelta.",
        "name": "love.timer.step",
        "params": [],
        "path": "love/love.timer.step",
        "syntax": "love.timer.step( )",
        "type": "love.timer"
    },
    "stop": {
        "descr": "Stops currently played sources.",
        "name": "love.audio.stop",
        "params": [],
        "path": "love/love.audio.stop",
        "syntax": "love.audio.stop( )",
        "type": "love.audio"
    },
    "textedited": {
        "descr": "Called when the candidate text for an IME (Input Method Editor) has changed.",
        "name": "love.textedited",
        "params": [
            {
                "descr": "The UTF-8 encoded unicode candidate text.",
                "name": "string text"
            },
            {
                "descr": "The start cursor of the selected candidate text.",
                "name": "number start"
            },
            {
                "descr": "The length of the selected candidate text. ",
                "name": "number length"
            }
        ],
        "path": "love/love.textedited",
        "syntax": "love.textedited( text, start, length )",
        "type": "love"
    },
    "textinput": {
        "descr": "Called when text has been entered by the user. For example if shift-2 is pressed on an American keyboard layout, the text \"@\" will be generated.",
        "name": "love.textinput",
        "params": [
            {
                "descr": "The UTF-8 encoded unicode text.",
                "name": "string text"
            }
        ],
        "path": "love/love.textinput",
        "syntax": "love.textinput( text )",
        "type": "love"
    },
    "threaderror": {
        "descr": "Callback function triggered when a Thread encounters an error.",
        "name": "love.threaderror",
        "params": [
            {
                "descr": "The thread which produced the error.",
                "name": "Thread thread"
            },
            {
                "descr": "The error message.",
                "name": "string errorstr"
            }
        ],
        "path": "love/love.threaderror",
        "syntax": "love.threaderror( thread, errorstr )",
        "type": "love"
    },
    "toPixels": {
        "descr": "Converts a number from density-independent units to pixels.",
        "name": "love.window.toPixels",
        "params": [
            {
                "descr": "A number in density-independent units to convert to pixels.",
                "name": "number value"
            },
            {
                "descr": "The converted number, in pixels.",
                "name": "number pixelvalue"
            }
        ],
        "path": "love/love.window.topixels",
        "syntax": "pixelvalue = love.window.toPixels( value )",
        "type": "love.window"
    },
    "toggleFullscreen": {
        "descr": "Enters or exits fullscreen. The display to use when entering fullscreen is chosen based on which display the window is currently in, if multiple monitors are connected.",
        "name": "love.window.toggleFullscreen",
        "params": [
            {
                "descr": "Whether to enter or exit fullscreen mode.",
                "name": "boolean fullscreen"
            },
            {
                "descr": "True if successful, false otherwise.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.window.togglefullscreen",
        "syntax": "success = love.window.setFullscreen( fullscreen )",
        "type": "love.window"
    },
    "touchmoved": {
        "descr": "Callback function triggered when a touch press moves inside the touch screen.",
        "name": "love.touchmoved",
        "params": [
            {
                "descr": "The identifier for the touch press.",
                "name": "light userdata id"
            },
            {
                "descr": "The x-axis position of the touch inside the window, in pixels.",
                "name": "number x"
            },
            {
                "descr": "The y-axis position of the touch inside the window, in pixels.",
                "name": "number y"
            },
            {
                "descr": "The x-axis movement of the touch inside the window, in pixels.",
                "name": "number dx"
            },
            {
                "descr": "The y-axis movement of the touch inside the window, in pixels.",
                "name": "number dy"
            },
            {
                "descr": "The amount of pressure being applied. ",
                "name": "number pressure"
            }
        ],
        "path": "love/love.touchmoved",
        "syntax": "love.touchmoved( id, x, y, dx, dy, pressure )",
        "type": "love"
    },
    "touchpressed": {
        "descr": "Callback function triggered when the touch screen is touched.",
        "name": "love.touchpressed",
        "params": [
            {
                "descr": "The identifier for the touch press.",
                "name": "light userdata id"
            },
            {
                "descr": "The x-axis position of the touch press inside the window, in pixels.",
                "name": "number x"
            },
            {
                "descr": "The y-axis position of the touch press inside the window, in pixels.",
                "name": "number y"
            },
            {
                "descr": "The x-axis movement of the touch press inside the window, in pixels. ",
                "name": "number dx"
            },
            {
                "descr": "The y-axis movement of the touch press inside the window, in pixels. ",
                "name": "number dy"
            },
            {
                "descr": "The amount of pressure being applied. ",
                "name": "number pressure"
            }
        ],
        "path": "love/love.touchpressed",
        "syntax": "love.touchpressed( id, x, y, dx, dy, pressure )",
        "type": "love"
    },
    "touchreleased": {
        "descr": "Callback function triggered when the touch screen stops being touched.",
        "name": "love.touchreleased",
        "params": [
            {
                "descr": "The identifier for the touch press.",
                "name": "light userdata id"
            },
            {
                "descr": "The x-axis position of the touch inside the window, in pixels.",
                "name": "number x"
            },
            {
                "descr": "The y-axis position of the touch inside the window, in pixels.",
                "name": "number y"
            },
            {
                "descr": "The x-axis movement of the touch inside the window, in pixels.",
                "name": "number dx"
            },
            {
                "descr": "The y-axis movement of the touch inside the window, in pixels.",
                "name": "number dy"
            },
            {
                "descr": "The amount of pressure being applied. ",
                "name": "number pressure"
            }
        ],
        "path": "love/love.touchreleased",
        "syntax": "love.touchreleased( id, x, y, dx, dy, pressure )",
        "type": "love"
    },
    "translate": {
        "descr": "Translates the coordinate system in two dimensions.",
        "name": "love.graphics.translate",
        "params": [
            {
                "descr": "The translation relative to the x-axis.",
                "name": "number dx"
            },
            {
                "descr": "The translation relative to the y-axis.",
                "name": "number dy"
            }
        ],
        "path": "love/love.graphics.translate",
        "syntax": "love.graphics.translate( dx, dy )",
        "type": "love.graphics"
    },
    "triangle": {
        "descr": "Draws a triangle.",
        "name": "love.graphics.triangle",
        "params": [
            {
                "descr": "How to draw the triangle.",
                "name": "DrawMode mode"
            },
            {
                "descr": "The position of first point on the x-axis.",
                "name": "number x1"
            },
            {
                "descr": "The position of first point on the y-axis.",
                "name": "number y1"
            },
            {
                "descr": "The position of second point on the x-axis.",
                "name": "number x2"
            },
            {
                "descr": "The position of second point on the y-axis.",
                "name": "number y2"
            },
            {
                "descr": "The position of third point on the x-axis.",
                "name": "number x3"
            },
            {
                "descr": "The position of third point on the y-axis.",
                "name": "number y3"
            }
        ],
        "path": "love/love.graphics.triangle",
        "syntax": "love.graphics.triangle( mode, x1, y1, x2, y2, x3, y3 )",
        "type": "love.graphics"
    },
    "triangulate": {
        "descr": "Decomposes a simple convex or concave polygon into triangles.",
        "name": "love.math.triangulate",
        "params": [
            {
                "descr": "Polygon to triangulate. Must not intersect itself.",
                "name": "table polygon"
            },
            {
                "descr": "List of triangles the polygon is composed of, in the form of {{x1, y1, x2, y2, x3, y3}, {x1, y1, x2, y2, x3, y3}, ...}.",
                "name": "table triangles"
            }
        ],
        "path": "love/love.math.triangulate",
        "syntax": "triangles = love.math.triangulate( polygon )",
        "type": "love.math"
    },
    "unmount": {
        "descr": "Unmounts a zip file or folder previously mounted for reading with love.filesystem.mount.",
        "name": "love.filesystem.unmount",
        "params": [
            {
                "descr": "The folder or zip file in the game's save directory which is currently mounted.",
                "name": "string archive"
            },
            {
                "descr": "True if the archive was successfully unmounted, false otherwise.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.filesystem.unmount",
        "syntax": "success = love.filesystem.unmount( archive )",
        "type": "love.filesystem"
    },
    "update": {
        "descr": "Callback function used to update the state of the game every frame.",
        "name": "love.update",
        "params": [
            {
                "descr": "Time since the last update in seconds.",
                "name": "number dt"
            }
        ],
        "path": "love/love.update",
        "syntax": "love.update( dt )",
        "type": "love"
    },
    "vibrate": {
        "descr": "Causes the device to vibrate, if possible. Currently this will only work on Android and iOS devices that have a built-in vibration motor.",
        "name": "love.system.vibrate",
        "params": [
            {
                "descr": "The duration to vibrate for. If called on an iOS device, it will always vibrate for 0.5 seconds due to limitations in the iOS system APIs.",
                "name": "number seconds (0.5)"
            }
        ],
        "path": "love/love.system.vibrate",
        "syntax": "love.system.vibrate( seconds )",
        "type": "love.system"
    },
    "visible": {
        "descr": "Callback function triggered when window is minimized/hidden or unminimized by the user.",
        "name": "love.visible",
        "params": [
            {
                "descr": "True if the window is visible, false if it isn't.",
                "name": "boolean visible"
            }
        ],
        "path": "love/love.visible",
        "syntax": "love.visible( visible )",
        "type": "love"
    },
    "wait": {
        "descr": "Like love.event.poll(), but blocks until there is an event in the queue.",
        "name": "love.event.wait",
        "params": [
            {
                "descr": "The type of event.",
                "name": "Event e"
            },
            {
                "descr": "First event argument.",
                "name": "mixed a"
            },
            {
                "descr": "Second event argument.",
                "name": "mixed b"
            },
            {
                "descr": "Third event argument.",
                "name": "mixed c"
            },
            {
                "descr": "Fourth event argument.",
                "name": "mixed d"
            }
        ],
        "path": "love/love.event.wait",
        "syntax": "e, a, b, c, d = love.event.wait( )",
        "type": "love.event"
    },
    "wheelmoved": {
        "descr": "Callback function triggered when the mouse wheel is moved.",
        "name": "love.wheelmoved",
        "params": [
            {
                "descr": "Amount of horizontal mouse wheel movement. ",
                "name": "number x"
            },
            {
                "descr": "Amount of vertical mouse wheel movement. ",
                "name": "number y"
            }
        ],
        "path": "love/love.wheelmoved",
        "syntax": "love.wheelmoved( x, y )",
        "type": "love"
    },
    "write": {
        "descr": "Write data to a file in the save directory. If the file existed already, it will be completely replaced by the new contents.",
        "name": "love.filesystem.write",
        "params": [
            {
                "descr": "The name (and path) of the file.",
                "name": "string name"
            },
            {
                "descr": "The string data to write to the file.",
                "name": "string data"
            },
            {
                "descr": "How many bytes to write.",
                "name": "number size (all)"
            },
            {
                "descr": "If the operation was successful.",
                "name": "boolean success"
            }
        ],
        "path": "love/love.filesystem.write",
        "syntax": "success = love.filesystem.write( name, data, size )",
        "type": "love.filesystem"
    }
}