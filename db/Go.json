{
    "Abs": {
        "descr": "Abs returns the absolute value of x.",
        "name": "math.Abs",
        "params": [],
        "path": "go/math/index#Abs",
        "syntax": "func Abs(x float64) float64",
        "type": "math"
    },
    "Accept": {
        "descr": "",
        "name": "syscall.Accept",
        "params": [],
        "path": "go/syscall/index#Accept",
        "syntax": "func Accept(fd int) (nfd int, sa Sockaddr, err error)",
        "type": "syscall"
    },
    "Accept4": {
        "descr": "",
        "name": "syscall.Accept4",
        "params": [],
        "path": "go/syscall/index#Accept4",
        "syntax": "func Accept4(fd int, flags int) (nfd int, sa Sockaddr, err error)",
        "type": "syscall"
    },
    "Access": {
        "descr": "",
        "name": "syscall.Access",
        "params": [],
        "path": "go/syscall/index#Access",
        "syntax": "func Access(path string, mode uint32) (err error)",
        "type": "syscall"
    },
    "Acct": {
        "descr": "",
        "name": "syscall.Acct",
        "params": [],
        "path": "go/syscall/index#Acct",
        "syntax": "func Acct(path string) (err error)",
        "type": "syscall"
    },
    "Acos": {
        "descr": "Acos returns the arccosine, in radians, of x.",
        "name": "math.Acos",
        "params": [],
        "path": "go/math/index#Acos",
        "syntax": "func Acos(x float64) float64",
        "type": "math"
    },
    "Acosh": {
        "descr": "Acosh returns the inverse hyperbolic cosine of x.",
        "name": "math.Acosh",
        "params": [],
        "path": "go/math/index#Acosh",
        "syntax": "func Acosh(x float64) float64",
        "type": "math"
    },
    "AddExtensionType": {
        "descr": "AddExtensionType sets the MIME type associated with the extension ext to typ. The extension should begin with a leading dot, as in \".html\".",
        "name": "mime.AddExtensionType",
        "params": [],
        "path": "go/mime/index#AddExtensionType",
        "syntax": "func AddExtensionType(ext, typ string) error",
        "type": "mime"
    },
    "Addr": {
        "descr": "Addr represents a network end point address.",
        "name": "net.Addr",
        "params": [],
        "path": "go/net/index#Addr",
        "syntax": "type Addr interface { Network() string // name of the network (for example, \"tcp\", \"udp\") String() string // string form of address (for example, \"192.0.2.1:25\", \"[2001:db8::1]:80\") }",
        "type": "net"
    },
    "AddrError": {
        "descr": "",
        "name": "net.AddrError",
        "params": [],
        "path": "go/net/index#AddrError",
        "syntax": "type AddrError struct { Err string Addr string }",
        "type": "net"
    },
    "AddrError.Error": {
        "descr": "",
        "name": "net.AddrError.Error",
        "params": [],
        "path": "go/net/index#AddrError.Error",
        "syntax": "func (e *AddrError) Error() string",
        "type": "net"
    },
    "AddrError.Temporary": {
        "descr": "",
        "name": "net.AddrError.Temporary",
        "params": [],
        "path": "go/net/index#AddrError.Temporary",
        "syntax": "func (e *AddrError) Temporary() bool",
        "type": "net"
    },
    "AddrError.Timeout": {
        "descr": "",
        "name": "net.AddrError.Timeout",
        "params": [],
        "path": "go/net/index#AddrError.Timeout",
        "syntax": "func (e *AddrError) Timeout() bool",
        "type": "net"
    },
    "Adjtimex": {
        "descr": "",
        "name": "syscall.Adjtimex",
        "params": [],
        "path": "go/syscall/index#Adjtimex",
        "syntax": "func Adjtimex(buf *Timex) (state int, err error)",
        "type": "syscall"
    },
    "After": {
        "descr": "After waits for the duration to elapse and then sends the current time on the returned channel. It is equivalent to NewTimer(d).C. The underlying Timer is not recovered by the garbage collector until the timer fires. If efficiency is a concern, use NewTimer instead and call Timer.Stop if the timer is no longer needed.",
        "name": "time.After",
        "params": [],
        "path": "go/time/index#After",
        "syntax": "func After(d Duration) <-chan Time",
        "type": "time"
    },
    "AfterFunc": {
        "descr": "AfterFunc waits for the duration to elapse and then calls f in its own goroutine. It returns a Timer that can be used to cancel the call using its Stop method.",
        "name": "time.AfterFunc",
        "params": [],
        "path": "go/time/index#AfterFunc",
        "syntax": "func AfterFunc(d Duration, f func()) *Timer",
        "type": "time"
    },
    "Alignof": {
        "descr": "Alignof takes an expression x of any type and returns the required alignment of a hypothetical variable v as if v was declared via var v = x. It is the largest value m such that the address of v is always zero mod m. It is the same as the value returned by reflect.TypeOf(x).Align(). As a special case, if a variable s is of struct type and f is a field within that struct, then Alignof(s.f) will return the required alignment of a field of that type within a struct. This case is the same as the value returned by reflect.TypeOf(s.f).FieldAlign().",
        "name": "unsafe.Alignof",
        "params": [],
        "path": "go/unsafe/index#Alignof",
        "syntax": "func Alignof(x ArbitraryType) uintptr",
        "type": "unsafe"
    },
    "AllocsPerRun": {
        "descr": "AllocsPerRun returns the average number of allocations during calls to f. Although the return value has type float64, it will always be an integral value.",
        "name": "testing.AllocsPerRun",
        "params": [],
        "path": "go/testing/index#AllocsPerRun",
        "syntax": "func AllocsPerRun(runs int, f func()) (avg float64)",
        "type": "testing"
    },
    "Alpha": {
        "descr": "Alpha is an in-memory image whose At method returns color.Alpha values.",
        "name": "image.Alpha",
        "params": [],
        "path": "go/image/index#Alpha",
        "syntax": "type Alpha struct { // Pix holds the image's pixels, as alpha values. The pixel at // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1]. Pix []uint8 // Stride is the Pix stride (in bytes) between vertically adjacent pixels. Stride int // Rect is the image's bounds. Rect Rectangle }",
        "type": "image"
    },
    "Alpha.AlphaAt": {
        "descr": "",
        "name": "image.Alpha.AlphaAt",
        "params": [],
        "path": "go/image/index#Alpha.AlphaAt",
        "syntax": "func (p *Alpha) AlphaAt(x, y int) color.Alpha",
        "type": "image"
    },
    "Alpha.At": {
        "descr": "",
        "name": "image.Alpha.At",
        "params": [],
        "path": "go/image/index#Alpha.At",
        "syntax": "func (p *Alpha) At(x, y int) color.Color",
        "type": "image"
    },
    "Alpha.Bounds": {
        "descr": "",
        "name": "image.Alpha.Bounds",
        "params": [],
        "path": "go/image/index#Alpha.Bounds",
        "syntax": "func (p *Alpha) Bounds() Rectangle",
        "type": "image"
    },
    "Alpha.ColorModel": {
        "descr": "",
        "name": "image.Alpha.ColorModel",
        "params": [],
        "path": "go/image/index#Alpha.ColorModel",
        "syntax": "func (p *Alpha) ColorModel() color.Model",
        "type": "image"
    },
    "Alpha.Opaque": {
        "descr": "Opaque scans the entire image and reports whether it is fully opaque.",
        "name": "image.Alpha.Opaque",
        "params": [],
        "path": "go/image/index#Alpha.Opaque",
        "syntax": "func (p *Alpha) Opaque() bool",
        "type": "image"
    },
    "Alpha.PixOffset": {
        "descr": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y).",
        "name": "image.Alpha.PixOffset",
        "params": [],
        "path": "go/image/index#Alpha.PixOffset",
        "syntax": "func (p *Alpha) PixOffset(x, y int) int",
        "type": "image"
    },
    "Alpha.Set": {
        "descr": "",
        "name": "image.Alpha.Set",
        "params": [],
        "path": "go/image/index#Alpha.Set",
        "syntax": "func (p *Alpha) Set(x, y int, c color.Color)",
        "type": "image"
    },
    "Alpha.SetAlpha": {
        "descr": "",
        "name": "image.Alpha.SetAlpha",
        "params": [],
        "path": "go/image/index#Alpha.SetAlpha",
        "syntax": "func (p *Alpha) SetAlpha(x, y int, c color.Alpha)",
        "type": "image"
    },
    "Alpha.SubImage": {
        "descr": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.",
        "name": "image.Alpha.SubImage",
        "params": [],
        "path": "go/image/index#Alpha.SubImage",
        "syntax": "func (p *Alpha) SubImage(r Rectangle) Image",
        "type": "image"
    },
    "Alpha16": {
        "descr": "Alpha16 is an in-memory image whose At method returns color.Alpha16 values.",
        "name": "image.Alpha16",
        "params": [],
        "path": "go/image/index#Alpha16",
        "syntax": "type Alpha16 struct { // Pix holds the image's pixels, as alpha values in big-endian format. The pixel at // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*2]. Pix []uint8 // Stride is the Pix stride (in bytes) between vertically adjacent pixels. Stride int // Rect is the image's bounds. Rect Rectangle }",
        "type": "image"
    },
    "Alpha16.Alpha16At": {
        "descr": "",
        "name": "image.Alpha16.Alpha16At",
        "params": [],
        "path": "go/image/index#Alpha16.Alpha16At",
        "syntax": "func (p *Alpha16) Alpha16At(x, y int) color.Alpha16",
        "type": "image"
    },
    "Alpha16.At": {
        "descr": "",
        "name": "image.Alpha16.At",
        "params": [],
        "path": "go/image/index#Alpha16.At",
        "syntax": "func (p *Alpha16) At(x, y int) color.Color",
        "type": "image"
    },
    "Alpha16.Bounds": {
        "descr": "",
        "name": "image.Alpha16.Bounds",
        "params": [],
        "path": "go/image/index#Alpha16.Bounds",
        "syntax": "func (p *Alpha16) Bounds() Rectangle",
        "type": "image"
    },
    "Alpha16.ColorModel": {
        "descr": "",
        "name": "image.Alpha16.ColorModel",
        "params": [],
        "path": "go/image/index#Alpha16.ColorModel",
        "syntax": "func (p *Alpha16) ColorModel() color.Model",
        "type": "image"
    },
    "Alpha16.Opaque": {
        "descr": "Opaque scans the entire image and reports whether it is fully opaque.",
        "name": "image.Alpha16.Opaque",
        "params": [],
        "path": "go/image/index#Alpha16.Opaque",
        "syntax": "func (p *Alpha16) Opaque() bool",
        "type": "image"
    },
    "Alpha16.PixOffset": {
        "descr": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y).",
        "name": "image.Alpha16.PixOffset",
        "params": [],
        "path": "go/image/index#Alpha16.PixOffset",
        "syntax": "func (p *Alpha16) PixOffset(x, y int) int",
        "type": "image"
    },
    "Alpha16.Set": {
        "descr": "",
        "name": "image.Alpha16.Set",
        "params": [],
        "path": "go/image/index#Alpha16.Set",
        "syntax": "func (p *Alpha16) Set(x, y int, c color.Color)",
        "type": "image"
    },
    "Alpha16.SetAlpha16": {
        "descr": "",
        "name": "image.Alpha16.SetAlpha16",
        "params": [],
        "path": "go/image/index#Alpha16.SetAlpha16",
        "syntax": "func (p *Alpha16) SetAlpha16(x, y int, c color.Alpha16)",
        "type": "image"
    },
    "Alpha16.SubImage": {
        "descr": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.",
        "name": "image.Alpha16.SubImage",
        "params": [],
        "path": "go/image/index#Alpha16.SubImage",
        "syntax": "func (p *Alpha16) SubImage(r Rectangle) Image",
        "type": "image"
    },
    "Append": {
        "descr": "Append appends the values x to a slice s and returns the resulting slice. As in Go, each x's value must be assignable to the slice's element type.",
        "name": "reflect.Append",
        "params": [],
        "path": "go/reflect/index#Append",
        "syntax": "func Append(s Value, x ...Value) Value",
        "type": "reflect"
    },
    "AppendBool": {
        "descr": "AppendBool appends \"true\" or \"false\", according to the value of b, to dst and returns the extended buffer.",
        "name": "strconv.AppendBool",
        "params": [],
        "path": "go/strconv/index#AppendBool",
        "syntax": "func AppendBool(dst []byte, b bool) []byte",
        "type": "strconv"
    },
    "AppendFloat": {
        "descr": "AppendFloat appends the string form of the floating-point number f, as generated by FormatFloat, to dst and returns the extended buffer.",
        "name": "strconv.AppendFloat",
        "params": [],
        "path": "go/strconv/index#AppendFloat",
        "syntax": "func AppendFloat(dst []byte, f float64, fmt byte, prec, bitSize int) []byte",
        "type": "strconv"
    },
    "AppendInt": {
        "descr": "AppendInt appends the string form of the integer i, as generated by FormatInt, to dst and returns the extended buffer.",
        "name": "strconv.AppendInt",
        "params": [],
        "path": "go/strconv/index#AppendInt",
        "syntax": "func AppendInt(dst []byte, i int64, base int) []byte",
        "type": "strconv"
    },
    "AppendQuote": {
        "descr": "AppendQuote appends a double-quoted Go string literal representing s, as generated by Quote, to dst and returns the extended buffer.",
        "name": "strconv.AppendQuote",
        "params": [],
        "path": "go/strconv/index#AppendQuote",
        "syntax": "func AppendQuote(dst []byte, s string) []byte",
        "type": "strconv"
    },
    "AppendQuoteRune": {
        "descr": "AppendQuoteRune appends a single-quoted Go character literal representing the rune, as generated by QuoteRune, to dst and returns the extended buffer.",
        "name": "strconv.AppendQuoteRune",
        "params": [],
        "path": "go/strconv/index#AppendQuoteRune",
        "syntax": "func AppendQuoteRune(dst []byte, r rune) []byte",
        "type": "strconv"
    },
    "AppendQuoteRuneToASCII": {
        "descr": "AppendQuoteRuneToASCII appends a single-quoted Go character literal representing the rune, as generated by QuoteRuneToASCII, to dst and returns the extended buffer.",
        "name": "strconv.AppendQuoteRuneToASCII",
        "params": [],
        "path": "go/strconv/index#AppendQuoteRuneToASCII",
        "syntax": "func AppendQuoteRuneToASCII(dst []byte, r rune) []byte",
        "type": "strconv"
    },
    "AppendQuoteRuneToGraphic": {
        "descr": "AppendQuoteRuneToGraphic appends a single-quoted Go character literal representing the rune, as generated by QuoteRuneToGraphic, to dst and returns the extended buffer.",
        "name": "strconv.AppendQuoteRuneToGraphic",
        "params": [],
        "path": "go/strconv/index#AppendQuoteRuneToGraphic",
        "syntax": "func AppendQuoteRuneToGraphic(dst []byte, r rune) []byte",
        "type": "strconv"
    },
    "AppendQuoteToASCII": {
        "descr": "AppendQuoteToASCII appends a double-quoted Go string literal representing s, as generated by QuoteToASCII, to dst and returns the extended buffer.",
        "name": "strconv.AppendQuoteToASCII",
        "params": [],
        "path": "go/strconv/index#AppendQuoteToASCII",
        "syntax": "func AppendQuoteToASCII(dst []byte, s string) []byte",
        "type": "strconv"
    },
    "AppendQuoteToGraphic": {
        "descr": "AppendQuoteToGraphic appends a double-quoted Go string literal representing s, as generated by QuoteToGraphic, to dst and returns the extended buffer.",
        "name": "strconv.AppendQuoteToGraphic",
        "params": [],
        "path": "go/strconv/index#AppendQuoteToGraphic",
        "syntax": "func AppendQuoteToGraphic(dst []byte, s string) []byte",
        "type": "strconv"
    },
    "AppendSlice": {
        "descr": "AppendSlice appends a slice t to a slice s and returns the resulting slice. The slices s and t must have the same element type.",
        "name": "reflect.AppendSlice",
        "params": [],
        "path": "go/reflect/index#AppendSlice",
        "syntax": "func AppendSlice(s, t Value) Value",
        "type": "reflect"
    },
    "AppendUint": {
        "descr": "AppendUint appends the string form of the unsigned integer i, as generated by FormatUint, to dst and returns the extended buffer.",
        "name": "strconv.AppendUint",
        "params": [],
        "path": "go/strconv/index#AppendUint",
        "syntax": "func AppendUint(dst []byte, i uint64, base int) []byte",
        "type": "strconv"
    },
    "ArbitraryType": {
        "descr": "ArbitraryType is here for the purposes of documentation only and is not actually part of the unsafe package. It represents the type of an arbitrary Go expression.",
        "name": "unsafe.ArbitraryType",
        "params": [],
        "path": "go/unsafe/index#ArbitraryType",
        "syntax": "type ArbitraryType int",
        "type": "unsafe"
    },
    "Arg": {
        "descr": "Arg returns the i'th command-line argument. Arg(0) is the first remaining argument after flags have been processed. Arg returns an empty string if the requested element does not exist.",
        "name": "flag.Arg",
        "params": [],
        "path": "go/flag/index#Arg",
        "syntax": "func Arg(i int) string",
        "type": "flag"
    },
    "Args": {
        "descr": "Args returns the non-flag command-line arguments.",
        "name": "flag.Args",
        "params": [],
        "path": "go/flag/index#Args",
        "syntax": "func Args() []string",
        "type": "flag"
    },
    "ArrayOf": {
        "descr": "ArrayOf returns the array type with the given count and element type. For example, if t represents int, ArrayOf(5, t) represents [5]int.",
        "name": "reflect.ArrayOf",
        "params": [],
        "path": "go/reflect/index#ArrayOf",
        "syntax": "func ArrayOf(count int, elem Type) Type",
        "type": "reflect"
    },
    "Asin": {
        "descr": "Asin returns the arcsine, in radians, of x.",
        "name": "math.Asin",
        "params": [],
        "path": "go/math/index#Asin",
        "syntax": "func Asin(x float64) float64",
        "type": "math"
    },
    "Asinh": {
        "descr": "Asinh returns the inverse hyperbolic sine of x.",
        "name": "math.Asinh",
        "params": [],
        "path": "go/math/index#Asinh",
        "syntax": "func Asinh(x float64) float64",
        "type": "math"
    },
    "Atan": {
        "descr": "Atan returns the arctangent, in radians, of x.",
        "name": "math.Atan",
        "params": [],
        "path": "go/math/index#Atan",
        "syntax": "func Atan(x float64) float64",
        "type": "math"
    },
    "Atan2": {
        "descr": "Atan2 returns the arc tangent of y/x, using the signs of the two to determine the quadrant of the return value.",
        "name": "math.Atan2",
        "params": [],
        "path": "go/math/index#Atan2",
        "syntax": "func Atan2(y, x float64) float64",
        "type": "math"
    },
    "Atanh": {
        "descr": "Atanh returns the inverse hyperbolic tangent of x.",
        "name": "math.Atanh",
        "params": [],
        "path": "go/math/index#Atanh",
        "syntax": "func Atanh(x float64) float64",
        "type": "math"
    },
    "Atoi": {
        "descr": "Atoi returns the result of ParseInt(s, 10, 0) converted to type int.",
        "name": "strconv.Atoi",
        "params": [],
        "path": "go/strconv/index#Atoi",
        "syntax": "func Atoi(s string) (int, error)",
        "type": "strconv"
    },
    "AttachLsf": {
        "descr": "Deprecated: Use golang.org/x/net/bpf instead.",
        "name": "syscall.AttachLsf",
        "params": [],
        "path": "go/syscall/index#AttachLsf",
        "syntax": "func AttachLsf(fd int, i []SockFilter) error",
        "type": "syscall"
    },
    "B": {
        "descr": "B is a type passed to Benchmark functions to manage benchmark timing and to specify the number of iterations to run.",
        "name": "testing.B",
        "params": [],
        "path": "go/testing/index#B",
        "syntax": "type B struct { N int // contains filtered or unexported fields }",
        "type": "testing"
    },
    "B.Error": {
        "descr": "Error is equivalent to Log followed by Fail.",
        "name": "testing.B.Error",
        "params": [],
        "path": "go/testing/index#B.Error",
        "syntax": "func (c *B) Error(args ...interface{})",
        "type": "testing"
    },
    "B.Errorf": {
        "descr": "Errorf is equivalent to Logf followed by Fail.",
        "name": "testing.B.Errorf",
        "params": [],
        "path": "go/testing/index#B.Errorf",
        "syntax": "func (c *B) Errorf(format string, args ...interface{})",
        "type": "testing"
    },
    "B.Fail": {
        "descr": "Fail marks the function as having failed but continues execution.",
        "name": "testing.B.Fail",
        "params": [],
        "path": "go/testing/index#B.Fail",
        "syntax": "func (c *B) Fail()",
        "type": "testing"
    },
    "B.FailNow": {
        "descr": "FailNow marks the function as having failed and stops its execution by calling runtime.Goexit (which then runs all deferred calls in the current goroutine). Execution will continue at the next test or benchmark. FailNow must be called from the goroutine running the test or benchmark function, not from other goroutines created during the test. Calling FailNow does not stop those other goroutines.",
        "name": "testing.B.FailNow",
        "params": [],
        "path": "go/testing/index#B.FailNow",
        "syntax": "func (c *B) FailNow()",
        "type": "testing"
    },
    "B.Failed": {
        "descr": "Failed reports whether the function has failed.",
        "name": "testing.B.Failed",
        "params": [],
        "path": "go/testing/index#B.Failed",
        "syntax": "func (c *B) Failed() bool",
        "type": "testing"
    },
    "B.Fatal": {
        "descr": "Fatal is equivalent to Log followed by FailNow.",
        "name": "testing.B.Fatal",
        "params": [],
        "path": "go/testing/index#B.Fatal",
        "syntax": "func (c *B) Fatal(args ...interface{})",
        "type": "testing"
    },
    "B.Fatalf": {
        "descr": "Fatalf is equivalent to Logf followed by FailNow.",
        "name": "testing.B.Fatalf",
        "params": [],
        "path": "go/testing/index#B.Fatalf",
        "syntax": "func (c *B) Fatalf(format string, args ...interface{})",
        "type": "testing"
    },
    "B.Helper": {
        "descr": "Helper marks the calling function as a test helper function. When printing file and line information, that function will be skipped. Helper may be called simultaneously from multiple goroutines.",
        "name": "testing.B.Helper",
        "params": [],
        "path": "go/testing/index#B.Helper",
        "syntax": "func (c *B) Helper()",
        "type": "testing"
    },
    "B.Log": {
        "descr": "Log formats its arguments using default formatting, analogous to Println, and records the text in the error log. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag.",
        "name": "testing.B.Log",
        "params": [],
        "path": "go/testing/index#B.Log",
        "syntax": "func (c *B) Log(args ...interface{})",
        "type": "testing"
    },
    "B.Logf": {
        "descr": "Logf formats its arguments according to the format, analogous to Printf, and records the text in the error log. A final newline is added if not provided. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag.",
        "name": "testing.B.Logf",
        "params": [],
        "path": "go/testing/index#B.Logf",
        "syntax": "func (c *B) Logf(format string, args ...interface{})",
        "type": "testing"
    },
    "B.Name": {
        "descr": "Name returns the name of the running test or benchmark.",
        "name": "testing.B.Name",
        "params": [],
        "path": "go/testing/index#B.Name",
        "syntax": "func (c *B) Name() string",
        "type": "testing"
    },
    "B.ReportAllocs": {
        "descr": "ReportAllocs enables malloc statistics for this benchmark. It is equivalent to setting -test.benchmem, but it only affects the benchmark function that calls ReportAllocs.",
        "name": "testing.B.ReportAllocs",
        "params": [],
        "path": "go/testing/index#B.ReportAllocs",
        "syntax": "func (b *B) ReportAllocs()",
        "type": "testing"
    },
    "B.ResetTimer": {
        "descr": "ResetTimer zeros the elapsed benchmark time and memory allocation counters. It does not affect whether the timer is running.",
        "name": "testing.B.ResetTimer",
        "params": [],
        "path": "go/testing/index#B.ResetTimer",
        "syntax": "func (b *B) ResetTimer()",
        "type": "testing"
    },
    "B.Run": {
        "descr": "Run benchmarks f as a subbenchmark with the given name. It reports whether there were any failures.",
        "name": "testing.B.Run",
        "params": [],
        "path": "go/testing/index#B.Run",
        "syntax": "func (b *B) Run(name string, f func(b *B)) bool",
        "type": "testing"
    },
    "B.RunParallel": {
        "descr": "RunParallel runs a benchmark in parallel. It creates multiple goroutines and distributes b.N iterations among them. The number of goroutines defaults to GOMAXPROCS. To increase parallelism for non-CPU-bound benchmarks, call SetParallelism before RunParallel. RunParallel is usually used with the go test -cpu flag.",
        "name": "testing.B.RunParallel",
        "params": [],
        "path": "go/testing/index#B.RunParallel",
        "syntax": "func (b *B) RunParallel(body func(*PB))",
        "type": "testing"
    },
    "B.SetBytes": {
        "descr": "SetBytes records the number of bytes processed in a single operation. If this is called, the benchmark will report ns/op and MB/s.",
        "name": "testing.B.SetBytes",
        "params": [],
        "path": "go/testing/index#B.SetBytes",
        "syntax": "func (b *B) SetBytes(n int64)",
        "type": "testing"
    },
    "B.SetParallelism": {
        "descr": "SetParallelism sets the number of goroutines used by RunParallel to p*GOMAXPROCS. There is usually no need to call SetParallelism for CPU-bound benchmarks. If p is less than 1, this call will have no effect.",
        "name": "testing.B.SetParallelism",
        "params": [],
        "path": "go/testing/index#B.SetParallelism",
        "syntax": "func (b *B) SetParallelism(p int)",
        "type": "testing"
    },
    "B.Skip": {
        "descr": "Skip is equivalent to Log followed by SkipNow.",
        "name": "testing.B.Skip",
        "params": [],
        "path": "go/testing/index#B.Skip",
        "syntax": "func (c *B) Skip(args ...interface{})",
        "type": "testing"
    },
    "B.SkipNow": {
        "descr": "SkipNow marks the test as having been skipped and stops its execution by calling runtime.Goexit. If a test fails (see Error, Errorf, Fail) and is then skipped, it is still considered to have failed. Execution will continue at the next test or benchmark. See also FailNow. SkipNow must be called from the goroutine running the test, not from other goroutines created during the test. Calling SkipNow does not stop those other goroutines.",
        "name": "testing.B.SkipNow",
        "params": [],
        "path": "go/testing/index#B.SkipNow",
        "syntax": "func (c *B) SkipNow()",
        "type": "testing"
    },
    "B.Skipf": {
        "descr": "Skipf is equivalent to Logf followed by SkipNow.",
        "name": "testing.B.Skipf",
        "params": [],
        "path": "go/testing/index#B.Skipf",
        "syntax": "func (c *B) Skipf(format string, args ...interface{})",
        "type": "testing"
    },
    "B.Skipped": {
        "descr": "Skipped reports whether the test was skipped.",
        "name": "testing.B.Skipped",
        "params": [],
        "path": "go/testing/index#B.Skipped",
        "syntax": "func (c *B) Skipped() bool",
        "type": "testing"
    },
    "B.StartTimer": {
        "descr": "StartTimer starts timing a test. This function is called automatically before a benchmark starts, but it can also used to resume timing after a call to StopTimer.",
        "name": "testing.B.StartTimer",
        "params": [],
        "path": "go/testing/index#B.StartTimer",
        "syntax": "func (b *B) StartTimer()",
        "type": "testing"
    },
    "B.StopTimer": {
        "descr": "StopTimer stops timing a test. This can be used to pause the timer while performing complex initialization that you don't want to measure.",
        "name": "testing.B.StopTimer",
        "params": [],
        "path": "go/testing/index#B.StopTimer",
        "syntax": "func (b *B) StopTimer()",
        "type": "testing"
    },
    "Background": {
        "descr": "Background returns a non-nil, empty Context. It is never canceled, has no values, and has no deadline. It is typically used by the main function, initialization, and tests, and as the top-level Context for incoming requests.",
        "name": "context.Background",
        "params": [],
        "path": "go/context/index#Background",
        "syntax": "func Background() Context",
        "type": "context"
    },
    "Base": {
        "descr": "Base returns the last element of path. Trailing slashes are removed before extracting the last element. If the path is empty, Base returns \".\". If the path consists entirely of slashes, Base returns \"/\".",
        "name": "path.Base",
        "params": [],
        "path": "go/path/index#Base",
        "syntax": "func Base(path string) string",
        "type": "path"
    },
    "Benchmark": {
        "descr": "Benchmark benchmarks a single function. Useful for creating custom benchmarks that do not use the \"go test\" command.",
        "name": "testing.Benchmark",
        "params": [],
        "path": "go/testing/index#Benchmark",
        "syntax": "func Benchmark(f func(b *B)) BenchmarkResult",
        "type": "testing"
    },
    "BenchmarkResult": {
        "descr": "The results of a benchmark run.",
        "name": "testing.BenchmarkResult",
        "params": [],
        "path": "go/testing/index#BenchmarkResult",
        "syntax": "type BenchmarkResult struct { N int // The number of iterations. T time.Duration // The total time taken. Bytes int64 // Bytes processed in one iteration. MemAllocs uint64 // The total number of memory allocations; added in Go 1.1 MemBytes uint64 // The total number of bytes allocated; added in Go 1.1 }",
        "type": "testing"
    },
    "BenchmarkResult.AllocedBytesPerOp": {
        "descr": "AllocedBytesPerOp returns r.MemBytes / r.N.",
        "name": "testing.BenchmarkResult.AllocedBytesPerOp",
        "params": [],
        "path": "go/testing/index#BenchmarkResult.AllocedBytesPerOp",
        "syntax": "func (r BenchmarkResult) AllocedBytesPerOp() int64",
        "type": "testing"
    },
    "BenchmarkResult.AllocsPerOp": {
        "descr": "AllocsPerOp returns r.MemAllocs / r.N.",
        "name": "testing.BenchmarkResult.AllocsPerOp",
        "params": [],
        "path": "go/testing/index#BenchmarkResult.AllocsPerOp",
        "syntax": "func (r BenchmarkResult) AllocsPerOp() int64",
        "type": "testing"
    },
    "BenchmarkResult.MemString": {
        "descr": "MemString returns r.AllocedBytesPerOp and r.AllocsPerOp in the same format as 'go test'.",
        "name": "testing.BenchmarkResult.MemString",
        "params": [],
        "path": "go/testing/index#BenchmarkResult.MemString",
        "syntax": "func (r BenchmarkResult) MemString() string",
        "type": "testing"
    },
    "BenchmarkResult.NsPerOp": {
        "descr": "",
        "name": "testing.BenchmarkResult.NsPerOp",
        "params": [],
        "path": "go/testing/index#BenchmarkResult.NsPerOp",
        "syntax": "func (r BenchmarkResult) NsPerOp() int64",
        "type": "testing"
    },
    "BenchmarkResult.String": {
        "descr": "",
        "name": "testing.BenchmarkResult.String",
        "params": [],
        "path": "go/testing/index#BenchmarkResult.String",
        "syntax": "func (r BenchmarkResult) String() string",
        "type": "testing"
    },
    "BinaryMarshaler": {
        "descr": "BinaryMarshaler is the interface implemented by an object that can marshal itself into a binary form.",
        "name": "encoding.BinaryMarshaler",
        "params": [],
        "path": "go/encoding/index#BinaryMarshaler",
        "syntax": "type BinaryMarshaler interface { MarshalBinary() (data []byte, err error) }",
        "type": "encoding"
    },
    "BinaryUnmarshaler": {
        "descr": "BinaryUnmarshaler is the interface implemented by an object that can unmarshal a binary representation of itself.",
        "name": "encoding.BinaryUnmarshaler",
        "params": [],
        "path": "go/encoding/index#BinaryUnmarshaler",
        "syntax": "type BinaryUnmarshaler interface { UnmarshalBinary(data []byte) error }",
        "type": "encoding"
    },
    "Bind": {
        "descr": "",
        "name": "syscall.Bind",
        "params": [],
        "path": "go/syscall/index#Bind",
        "syntax": "func Bind(fd int, sa Sockaddr) (err error)",
        "type": "syscall"
    },
    "BindToDevice": {
        "descr": "BindToDevice binds the socket associated with fd to device.",
        "name": "syscall.BindToDevice",
        "params": [],
        "path": "go/syscall/index#BindToDevice",
        "syntax": "func BindToDevice(fd int, device string) (err error)",
        "type": "syscall"
    },
    "BlockProfile": {
        "descr": "BlockProfile returns n, the number of records in the current blocking profile. If len(p) >= n, BlockProfile copies the profile into p and returns n, true. If len(p) < n, BlockProfile does not change p and returns n, false.",
        "name": "runtime.BlockProfile",
        "params": [],
        "path": "go/runtime/index#BlockProfile",
        "syntax": "func BlockProfile(p []BlockProfileRecord) (n int, ok bool)",
        "type": "runtime"
    },
    "BlockProfileRecord": {
        "descr": "BlockProfileRecord describes blocking events originated at a particular call sequence (stack trace).",
        "name": "runtime.BlockProfileRecord",
        "params": [],
        "path": "go/runtime/index#BlockProfileRecord",
        "syntax": "type BlockProfileRecord struct { Count int64 Cycles int64 StackRecord }",
        "type": "runtime"
    },
    "Bool": {
        "descr": "Bool defines a bool flag with specified name, default value, and usage string. The return value is the address of a bool variable that stores the value of the flag.",
        "name": "flag.Bool",
        "params": [],
        "path": "go/flag/index#Bool",
        "syntax": "func Bool(name string, value bool, usage string) *bool",
        "type": "flag"
    },
    "BoolVar": {
        "descr": "BoolVar defines a bool flag with specified name, default value, and usage string. The argument p points to a bool variable in which to store the value of the flag.",
        "name": "flag.BoolVar",
        "params": [],
        "path": "go/flag/index#BoolVar",
        "syntax": "func BoolVar(p *bool, name string, value bool, usage string)",
        "type": "flag"
    },
    "Breakpoint": {
        "descr": "Breakpoint executes a breakpoint trap.",
        "name": "runtime.Breakpoint",
        "params": [],
        "path": "go/runtime/index#Breakpoint",
        "syntax": "func Breakpoint()",
        "type": "runtime"
    },
    "Buffer": {
        "descr": "A Buffer is a variable-sized buffer of bytes with Read and Write methods. The zero value for Buffer is an empty buffer ready to use.",
        "name": "bytes.Buffer",
        "params": [],
        "path": "go/bytes/index#Buffer",
        "syntax": "type Buffer struct { // contains filtered or unexported fields }",
        "type": "bytes"
    },
    "Buffer.Bytes": {
        "descr": "Bytes returns a slice of length b.Len() holding the unread portion of the buffer. The slice is valid for use only until the next buffer modification (that is, only until the next call to a method like Read, Write, Reset, or Truncate). The slice aliases the buffer content at least until the next buffer modification, so immediate changes to the slice will affect the result of future reads.",
        "name": "bytes.Buffer.Bytes",
        "params": [],
        "path": "go/bytes/index#Buffer.Bytes",
        "syntax": "func (b *Buffer) Bytes() []byte",
        "type": "bytes"
    },
    "Buffer.Cap": {
        "descr": "Cap returns the capacity of the buffer's underlying byte slice, that is, the total space allocated for the buffer's data.",
        "name": "bytes.Buffer.Cap",
        "params": [],
        "path": "go/bytes/index#Buffer.Cap",
        "syntax": "func (b *Buffer) Cap() int",
        "type": "bytes"
    },
    "Buffer.Grow": {
        "descr": "Grow grows the buffer's capacity, if necessary, to guarantee space for another n bytes. After Grow(n), at least n bytes can be written to the buffer without another allocation. If n is negative, Grow will panic. If the buffer can't grow it will panic with ErrTooLarge.",
        "name": "bytes.Buffer.Grow",
        "params": [],
        "path": "go/bytes/index#Buffer.Grow",
        "syntax": "func (b *Buffer) Grow(n int)",
        "type": "bytes"
    },
    "Buffer.Len": {
        "descr": "Len returns the number of bytes of the unread portion of the buffer; b.Len() == len(b.Bytes()).",
        "name": "bytes.Buffer.Len",
        "params": [],
        "path": "go/bytes/index#Buffer.Len",
        "syntax": "func (b *Buffer) Len() int",
        "type": "bytes"
    },
    "Buffer.Next": {
        "descr": "Next returns a slice containing the next n bytes from the buffer, advancing the buffer as if the bytes had been returned by Read. If there are fewer than n bytes in the buffer, Next returns the entire buffer. The slice is only valid until the next call to a read or write method.",
        "name": "bytes.Buffer.Next",
        "params": [],
        "path": "go/bytes/index#Buffer.Next",
        "syntax": "func (b *Buffer) Next(n int) []byte",
        "type": "bytes"
    },
    "Buffer.Read": {
        "descr": "Read reads the next len(p) bytes from the buffer or until the buffer is drained. The return value n is the number of bytes read. If the buffer has no data to return, err is io.EOF (unless len(p) is zero); otherwise it is nil.",
        "name": "bytes.Buffer.Read",
        "params": [],
        "path": "go/bytes/index#Buffer.Read",
        "syntax": "func (b *Buffer) Read(p []byte) (n int, err error)",
        "type": "bytes"
    },
    "Buffer.ReadByte": {
        "descr": "ReadByte reads and returns the next byte from the buffer. If no byte is available, it returns error io.EOF.",
        "name": "bytes.Buffer.ReadByte",
        "params": [],
        "path": "go/bytes/index#Buffer.ReadByte",
        "syntax": "func (b *Buffer) ReadByte() (byte, error)",
        "type": "bytes"
    },
    "Buffer.ReadBytes": {
        "descr": "ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim.",
        "name": "bytes.Buffer.ReadBytes",
        "params": [],
        "path": "go/bytes/index#Buffer.ReadBytes",
        "syntax": "func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)",
        "type": "bytes"
    },
    "Buffer.ReadFrom": {
        "descr": "ReadFrom reads data from r until EOF and appends it to the buffer, growing the buffer as needed. The return value n is the number of bytes read. Any error except io.EOF encountered during the read is also returned. If the buffer becomes too large, ReadFrom will panic with ErrTooLarge.",
        "name": "bytes.Buffer.ReadFrom",
        "params": [],
        "path": "go/bytes/index#Buffer.ReadFrom",
        "syntax": "func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)",
        "type": "bytes"
    },
    "Buffer.ReadRune": {
        "descr": "ReadRune reads and returns the next UTF-8-encoded Unicode code point from the buffer. If no bytes are available, the error returned is io.EOF. If the bytes are an erroneous UTF-8 encoding, it consumes one byte and returns U+FFFD, 1.",
        "name": "bytes.Buffer.ReadRune",
        "params": [],
        "path": "go/bytes/index#Buffer.ReadRune",
        "syntax": "func (b *Buffer) ReadRune() (r rune, size int, err error)",
        "type": "bytes"
    },
    "Buffer.ReadString": {
        "descr": "ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim.",
        "name": "bytes.Buffer.ReadString",
        "params": [],
        "path": "go/bytes/index#Buffer.ReadString",
        "syntax": "func (b *Buffer) ReadString(delim byte) (line string, err error)",
        "type": "bytes"
    },
    "Buffer.Reset": {
        "descr": "Reset resets the buffer to be empty, but it retains the underlying storage for use by future writes. Reset is the same as Truncate(0).",
        "name": "bytes.Buffer.Reset",
        "params": [],
        "path": "go/bytes/index#Buffer.Reset",
        "syntax": "func (b *Buffer) Reset()",
        "type": "bytes"
    },
    "Buffer.String": {
        "descr": "String returns the contents of the unread portion of the buffer as a string. If the Buffer is a nil pointer, it returns \"<nil>\".",
        "name": "bytes.Buffer.String",
        "params": [],
        "path": "go/bytes/index#Buffer.String",
        "syntax": "func (b *Buffer) String() string",
        "type": "bytes"
    },
    "Buffer.Truncate": {
        "descr": "Truncate discards all but the first n unread bytes from the buffer but continues to use the same allocated storage. It panics if n is negative or greater than the length of the buffer.",
        "name": "bytes.Buffer.Truncate",
        "params": [],
        "path": "go/bytes/index#Buffer.Truncate",
        "syntax": "func (b *Buffer) Truncate(n int)",
        "type": "bytes"
    },
    "Buffer.UnreadByte": {
        "descr": "UnreadByte unreads the last byte returned by the most recent successful read operation that read at least one byte. If a write has happened since the last read, if the last read returned an error, or if the read read zero bytes, UnreadByte returns an error.",
        "name": "bytes.Buffer.UnreadByte",
        "params": [],
        "path": "go/bytes/index#Buffer.UnreadByte",
        "syntax": "func (b *Buffer) UnreadByte() error",
        "type": "bytes"
    },
    "Buffer.UnreadRune": {
        "descr": "UnreadRune unreads the last rune returned by ReadRune. If the most recent read or write operation on the buffer was not a successful ReadRune, UnreadRune returns an error. (In this regard it is stricter than UnreadByte, which will unread the last byte from any read operation.)",
        "name": "bytes.Buffer.UnreadRune",
        "params": [],
        "path": "go/bytes/index#Buffer.UnreadRune",
        "syntax": "func (b *Buffer) UnreadRune() error",
        "type": "bytes"
    },
    "Buffer.Write": {
        "descr": "Write appends the contents of p to the buffer, growing the buffer as needed. The return value n is the length of p; err is always nil. If the buffer becomes too large, Write will panic with ErrTooLarge.",
        "name": "bytes.Buffer.Write",
        "params": [],
        "path": "go/bytes/index#Buffer.Write",
        "syntax": "func (b *Buffer) Write(p []byte) (n int, err error)",
        "type": "bytes"
    },
    "Buffer.WriteByte": {
        "descr": "WriteByte appends the byte c to the buffer, growing the buffer as needed. The returned error is always nil, but is included to match bufio.Writer's WriteByte. If the buffer becomes too large, WriteByte will panic with ErrTooLarge.",
        "name": "bytes.Buffer.WriteByte",
        "params": [],
        "path": "go/bytes/index#Buffer.WriteByte",
        "syntax": "func (b *Buffer) WriteByte(c byte) error",
        "type": "bytes"
    },
    "Buffer.WriteRune": {
        "descr": "WriteRune appends the UTF-8 encoding of Unicode code point r to the buffer, returning its length and an error, which is always nil but is included to match bufio.Writer's WriteRune. The buffer is grown as needed; if it becomes too large, WriteRune will panic with ErrTooLarge.",
        "name": "bytes.Buffer.WriteRune",
        "params": [],
        "path": "go/bytes/index#Buffer.WriteRune",
        "syntax": "func (b *Buffer) WriteRune(r rune) (n int, err error)",
        "type": "bytes"
    },
    "Buffer.WriteString": {
        "descr": "WriteString appends the contents of s to the buffer, growing the buffer as needed. The return value n is the length of s; err is always nil. If the buffer becomes too large, WriteString will panic with ErrTooLarge.",
        "name": "bytes.Buffer.WriteString",
        "params": [],
        "path": "go/bytes/index#Buffer.WriteString",
        "syntax": "func (b *Buffer) WriteString(s string) (n int, err error)",
        "type": "bytes"
    },
    "Buffer.WriteTo": {
        "descr": "WriteTo writes data to w until the buffer is drained or an error occurs. The return value n is the number of bytes written; it always fits into an int, but it is int64 to match the io.WriterTo interface. Any error encountered during the write is also returned.",
        "name": "bytes.Buffer.WriteTo",
        "params": [],
        "path": "go/bytes/index#Buffer.WriteTo",
        "syntax": "func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)",
        "type": "bytes"
    },
    "Buffers": {
        "descr": "Buffers contains zero or more runs of bytes to write.",
        "name": "net.Buffers",
        "params": [],
        "path": "go/net/index#Buffers",
        "syntax": "type Buffers [][]byte",
        "type": "net"
    },
    "Buffers.Read": {
        "descr": "",
        "name": "net.Buffers.Read",
        "params": [],
        "path": "go/net/index#Buffers.Read",
        "syntax": "func (v *Buffers) Read(p []byte) (n int, err error)",
        "type": "net"
    },
    "Buffers.WriteTo": {
        "descr": "",
        "name": "net.Buffers.WriteTo",
        "params": [],
        "path": "go/net/index#Buffers.WriteTo",
        "syntax": "func (v *Buffers) WriteTo(w io.Writer) (n int64, err error)",
        "type": "net"
    },
    "Builder": {
        "descr": "A Builder is used to efficiently build a string using Write methods. It minimizes memory copying. The zero value is ready to use. Do not copy a non-zero Builder.",
        "name": "strings.Builder",
        "params": [],
        "path": "go/strings/index#Builder",
        "syntax": "type Builder struct { // contains filtered or unexported fields }",
        "type": "strings"
    },
    "Builder.Grow": {
        "descr": "Grow grows b's capacity, if necessary, to guarantee space for another n bytes. After Grow(n), at least n bytes can be written to b without another allocation. If n is negative, Grow panics.",
        "name": "strings.Builder.Grow",
        "params": [],
        "path": "go/strings/index#Builder.Grow",
        "syntax": "func (b *Builder) Grow(n int)",
        "type": "strings"
    },
    "Builder.Len": {
        "descr": "Len returns the number of accumulated bytes; b.Len() == len(b.String()).",
        "name": "strings.Builder.Len",
        "params": [],
        "path": "go/strings/index#Builder.Len",
        "syntax": "func (b *Builder) Len() int",
        "type": "strings"
    },
    "Builder.Reset": {
        "descr": "Reset resets the Builder to be empty.",
        "name": "strings.Builder.Reset",
        "params": [],
        "path": "go/strings/index#Builder.Reset",
        "syntax": "func (b *Builder) Reset()",
        "type": "strings"
    },
    "Builder.String": {
        "descr": "String returns the accumulated string.",
        "name": "strings.Builder.String",
        "params": [],
        "path": "go/strings/index#Builder.String",
        "syntax": "func (b *Builder) String() string",
        "type": "strings"
    },
    "Builder.Write": {
        "descr": "Write appends the contents of p to b's buffer. Write always returns len(p), nil.",
        "name": "strings.Builder.Write",
        "params": [],
        "path": "go/strings/index#Builder.Write",
        "syntax": "func (b *Builder) Write(p []byte) (int, error)",
        "type": "strings"
    },
    "Builder.WriteByte": {
        "descr": "WriteByte appends the byte c to b's buffer. The returned error is always nil.",
        "name": "strings.Builder.WriteByte",
        "params": [],
        "path": "go/strings/index#Builder.WriteByte",
        "syntax": "func (b *Builder) WriteByte(c byte) error",
        "type": "strings"
    },
    "Builder.WriteRune": {
        "descr": "WriteRune appends the UTF-8 encoding of Unicode code point r to b's buffer. It returns the length of r and a nil error.",
        "name": "strings.Builder.WriteRune",
        "params": [],
        "path": "go/strings/index#Builder.WriteRune",
        "syntax": "func (b *Builder) WriteRune(r rune) (int, error)",
        "type": "strings"
    },
    "Builder.WriteString": {
        "descr": "WriteString appends the contents of s to b's buffer. It returns the length of s and a nil error.",
        "name": "strings.Builder.WriteString",
        "params": [],
        "path": "go/strings/index#Builder.WriteString",
        "syntax": "func (b *Builder) WriteString(s string) (int, error)",
        "type": "strings"
    },
    "BytePtrFromString": {
        "descr": "BytePtrFromString returns a pointer to a NUL-terminated array of bytes containing the text of s. If s contains a NUL byte at any location, it returns (nil, EINVAL).",
        "name": "syscall.BytePtrFromString",
        "params": [],
        "path": "go/syscall/index#BytePtrFromString",
        "syntax": "func BytePtrFromString(s string) (*byte, error)",
        "type": "syscall"
    },
    "ByteReader": {
        "descr": "ByteReader is the interface that wraps the ReadByte method.",
        "name": "io.ByteReader",
        "params": [],
        "path": "go/io/index#ByteReader",
        "syntax": "type ByteReader interface { ReadByte() (byte, error) }",
        "type": "io"
    },
    "ByteScanner": {
        "descr": "ByteScanner is the interface that adds the UnreadByte method to the basic ReadByte method.",
        "name": "io.ByteScanner",
        "params": [],
        "path": "go/io/index#ByteScanner",
        "syntax": "type ByteScanner interface { ByteReader UnreadByte() error }",
        "type": "io"
    },
    "ByteSliceFromString": {
        "descr": "ByteSliceFromString returns a NUL-terminated slice of bytes containing the text of s. If s contains a NUL byte at any location, it returns (nil, EINVAL).",
        "name": "syscall.ByteSliceFromString",
        "params": [],
        "path": "go/syscall/index#ByteSliceFromString",
        "syntax": "func ByteSliceFromString(s string) ([]byte, error)",
        "type": "syscall"
    },
    "ByteWriter": {
        "descr": "ByteWriter is the interface that wraps the WriteByte method.",
        "name": "io.ByteWriter",
        "params": [],
        "path": "go/io/index#ByteWriter",
        "syntax": "type ByteWriter interface { WriteByte(c byte) error }",
        "type": "io"
    },
    "CIDRMask": {
        "descr": "CIDRMask returns an IPMask consisting of `ones' 1 bits followed by 0s up to a total length of `bits' bits. For a mask of this form, CIDRMask is the inverse of IPMask.Size.",
        "name": "net.CIDRMask",
        "params": [],
        "path": "go/net/index#CIDRMask",
        "syntax": "func CIDRMask(ones, bits int) IPMask",
        "type": "net"
    },
    "CMYK": {
        "descr": "CMYK is an in-memory image whose At method returns color.CMYK values.",
        "name": "image.CMYK",
        "params": [],
        "path": "go/image/index#CMYK",
        "syntax": "type CMYK struct { // Pix holds the image's pixels, in C, M, Y, K order. The pixel at // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4]. Pix []uint8 // Stride is the Pix stride (in bytes) between vertically adjacent pixels. Stride int // Rect is the image's bounds. Rect Rectangle }",
        "type": "image"
    },
    "CMYK.At": {
        "descr": "",
        "name": "image.CMYK.At",
        "params": [],
        "path": "go/image/index#CMYK.At",
        "syntax": "func (p *CMYK) At(x, y int) color.Color",
        "type": "image"
    },
    "CMYK.Bounds": {
        "descr": "",
        "name": "image.CMYK.Bounds",
        "params": [],
        "path": "go/image/index#CMYK.Bounds",
        "syntax": "func (p *CMYK) Bounds() Rectangle",
        "type": "image"
    },
    "CMYK.CMYKAt": {
        "descr": "",
        "name": "image.CMYK.CMYKAt",
        "params": [],
        "path": "go/image/index#CMYK.CMYKAt",
        "syntax": "func (p *CMYK) CMYKAt(x, y int) color.CMYK",
        "type": "image"
    },
    "CMYK.ColorModel": {
        "descr": "",
        "name": "image.CMYK.ColorModel",
        "params": [],
        "path": "go/image/index#CMYK.ColorModel",
        "syntax": "func (p *CMYK) ColorModel() color.Model",
        "type": "image"
    },
    "CMYK.Opaque": {
        "descr": "Opaque scans the entire image and reports whether it is fully opaque.",
        "name": "image.CMYK.Opaque",
        "params": [],
        "path": "go/image/index#CMYK.Opaque",
        "syntax": "func (p *CMYK) Opaque() bool",
        "type": "image"
    },
    "CMYK.PixOffset": {
        "descr": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y).",
        "name": "image.CMYK.PixOffset",
        "params": [],
        "path": "go/image/index#CMYK.PixOffset",
        "syntax": "func (p *CMYK) PixOffset(x, y int) int",
        "type": "image"
    },
    "CMYK.Set": {
        "descr": "",
        "name": "image.CMYK.Set",
        "params": [],
        "path": "go/image/index#CMYK.Set",
        "syntax": "func (p *CMYK) Set(x, y int, c color.Color)",
        "type": "image"
    },
    "CMYK.SetCMYK": {
        "descr": "",
        "name": "image.CMYK.SetCMYK",
        "params": [],
        "path": "go/image/index#CMYK.SetCMYK",
        "syntax": "func (p *CMYK) SetCMYK(x, y int, c color.CMYK)",
        "type": "image"
    },
    "CMYK.SubImage": {
        "descr": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.",
        "name": "image.CMYK.SubImage",
        "params": [],
        "path": "go/image/index#CMYK.SubImage",
        "syntax": "func (p *CMYK) SubImage(r Rectangle) Image",
        "type": "image"
    },
    "CPUProfile": {
        "descr": "CPUProfile panics. It formerly provided raw access to chunks of a pprof-format profile generated by the runtime. The details of generating that format have changed, so this functionality has been removed.",
        "name": "runtime.CPUProfile",
        "params": [],
        "path": "go/runtime/index#CPUProfile",
        "syntax": "func CPUProfile() []byte",
        "type": "runtime"
    },
    "Caller": {
        "descr": "Caller reports file and line number information about function invocations on the calling goroutine's stack. The argument skip is the number of stack frames to ascend, with 0 identifying the caller of Caller. (For historical reasons the meaning of skip differs between Caller and Callers.) The return values report the program counter, file name, and line number within the file of the corresponding call. The boolean ok is false if it was not possible to recover the information.",
        "name": "runtime.Caller",
        "params": [],
        "path": "go/runtime/index#Caller",
        "syntax": "func Caller(skip int) (pc uintptr, file string, line int, ok bool)",
        "type": "runtime"
    },
    "Callers": {
        "descr": "Callers fills the slice pc with the return program counters of function invocations on the calling goroutine's stack. The argument skip is the number of stack frames to skip before recording in pc, with 0 identifying the frame for Callers itself and 1 identifying the caller of Callers. It returns the number of entries written to pc.",
        "name": "runtime.Callers",
        "params": [],
        "path": "go/runtime/index#Callers",
        "syntax": "func Callers(skip int, pc []uintptr) int",
        "type": "runtime"
    },
    "CallersFrames": {
        "descr": "CallersFrames takes a slice of PC values returned by Callers and prepares to return function/file/line information. Do not change the slice until you are done with the Frames.",
        "name": "runtime.CallersFrames",
        "params": [],
        "path": "go/runtime/index#CallersFrames",
        "syntax": "func CallersFrames(callers []uintptr) *Frames",
        "type": "runtime"
    },
    "CanBackquote": {
        "descr": "CanBackquote reports whether the string s can be represented unchanged as a single-line backquoted string without control characters other than tab.",
        "name": "strconv.CanBackquote",
        "params": [],
        "path": "go/strconv/index#CanBackquote",
        "syntax": "func CanBackquote(s string) bool",
        "type": "strconv"
    },
    "CancelFunc": {
        "descr": "A CancelFunc tells an operation to abandon its work. A CancelFunc does not wait for the work to stop. After the first call, subsequent calls to a CancelFunc do nothing.",
        "name": "context.CancelFunc",
        "params": [],
        "path": "go/context/index#CancelFunc",
        "syntax": "type CancelFunc func()",
        "type": "context"
    },
    "CaseRange": {
        "descr": "CaseRange represents a range of Unicode code points for simple (one code point to one code point) case conversion. The range runs from Lo to Hi inclusive, with a fixed stride of 1. Deltas are the number to add to the code point to reach the code point for a different case for that character. They may be negative. If zero, it means the character is in the corresponding case. There is a special case representing sequences of alternating corresponding Upper and Lower pairs. It appears with a fixed Delta of",
        "name": "unicode.CaseRange",
        "params": [],
        "path": "go/unicode/index#CaseRange",
        "syntax": "{UpperLower, UpperLower, UpperLower}",
        "type": "unicode"
    },
    "Cbrt": {
        "descr": "Cbrt returns the cube root of x.",
        "name": "math.Cbrt",
        "params": [],
        "path": "go/math/index#Cbrt",
        "syntax": "func Cbrt(x float64) float64",
        "type": "math"
    },
    "Ceil": {
        "descr": "Ceil returns the least integer value greater than or equal to x.",
        "name": "math.Ceil",
        "params": [],
        "path": "go/math/index#Ceil",
        "syntax": "func Ceil(x float64) float64",
        "type": "math"
    },
    "ChanDir": {
        "descr": "ChanDir represents a channel type's direction.",
        "name": "reflect.ChanDir",
        "params": [],
        "path": "go/reflect/index#ChanDir",
        "syntax": "type ChanDir int",
        "type": "reflect"
    },
    "ChanDir.String": {
        "descr": "",
        "name": "reflect.ChanDir.String",
        "params": [],
        "path": "go/reflect/index#ChanDir.String",
        "syntax": "func (d ChanDir) String() string",
        "type": "reflect"
    },
    "ChanOf": {
        "descr": "ChanOf returns the channel type with the given direction and element type. For example, if t represents int, ChanOf(RecvDir, t) represents <-chan int.",
        "name": "reflect.ChanOf",
        "params": [],
        "path": "go/reflect/index#ChanOf",
        "syntax": "func ChanOf(dir ChanDir, t Type) Type",
        "type": "reflect"
    },
    "Chdir": {
        "descr": "",
        "name": "syscall.Chdir",
        "params": [],
        "path": "go/syscall/index#Chdir",
        "syntax": "func Chdir(path string) (err error)",
        "type": "syscall"
    },
    "Chmod": {
        "descr": "",
        "name": "syscall.Chmod",
        "params": [],
        "path": "go/syscall/index#Chmod",
        "syntax": "func Chmod(path string, mode uint32) (err error)",
        "type": "syscall"
    },
    "Chown": {
        "descr": "",
        "name": "syscall.Chown",
        "params": [],
        "path": "go/syscall/index#Chown",
        "syntax": "func Chown(path string, uid int, gid int) (err error)",
        "type": "syscall"
    },
    "Chroot": {
        "descr": "",
        "name": "syscall.Chroot",
        "params": [],
        "path": "go/syscall/index#Chroot",
        "syntax": "func Chroot(path string) (err error)",
        "type": "syscall"
    },
    "Chtimes": {
        "descr": "Chtimes changes the access and modification times of the named file, similar to the Unix utime() or utimes() functions.",
        "name": "os.Chtimes",
        "params": [],
        "path": "go/os/index#Chtimes",
        "syntax": "func Chtimes(name string, atime time.Time, mtime time.Time) error",
        "type": "os"
    },
    "Clean": {
        "descr": "Clean returns the shortest path name equivalent to path by purely lexical processing. It applies the following rules iteratively until no further processing can be done:",
        "name": "path.Clean",
        "params": [],
        "path": "go/path/index#Clean",
        "syntax": "func Clean(path string) string",
        "type": "path"
    },
    "Clearenv": {
        "descr": "",
        "name": "syscall.Clearenv",
        "params": [],
        "path": "go/syscall/index#Clearenv",
        "syntax": "func Clearenv()",
        "type": "syscall"
    },
    "Close": {
        "descr": "",
        "name": "syscall.Close",
        "params": [],
        "path": "go/syscall/index#Close",
        "syntax": "func Close(fd int) (err error)",
        "type": "syscall"
    },
    "CloseOnExec": {
        "descr": "",
        "name": "syscall.CloseOnExec",
        "params": [],
        "path": "go/syscall/index#CloseOnExec",
        "syntax": "func CloseOnExec(fd int)",
        "type": "syscall"
    },
    "Closer": {
        "descr": "Closer is the interface that wraps the basic Close method.",
        "name": "io.Closer",
        "params": [],
        "path": "go/io/index#Closer",
        "syntax": "type Closer interface { Close() error }",
        "type": "io"
    },
    "CmsgLen": {
        "descr": "CmsgLen returns the value to store in the Len field of the Cmsghdr structure, taking into account any necessary alignment.",
        "name": "syscall.CmsgLen",
        "params": [],
        "path": "go/syscall/index#CmsgLen",
        "syntax": "func CmsgLen(datalen int) int",
        "type": "syscall"
    },
    "CmsgSpace": {
        "descr": "CmsgSpace returns the number of bytes an ancillary element with payload of the passed data length occupies.",
        "name": "syscall.CmsgSpace",
        "params": [],
        "path": "go/syscall/index#CmsgSpace",
        "syntax": "func CmsgSpace(datalen int) int",
        "type": "syscall"
    },
    "Cmsghdr": {
        "descr": "",
        "name": "syscall.Cmsghdr",
        "params": [],
        "path": "go/syscall/index#Cmsghdr",
        "syntax": "type Cmsghdr struct { Len uint64 Level int32 Type int32 }",
        "type": "syscall"
    },
    "Cmsghdr.SetLen": {
        "descr": "",
        "name": "syscall.Cmsghdr.SetLen",
        "params": [],
        "path": "go/syscall/index#Cmsghdr.SetLen",
        "syntax": "func (cmsg *Cmsghdr) SetLen(length int)",
        "type": "syscall"
    },
    "Compare": {
        "descr": "Compare returns an integer comparing two strings lexicographically. The result will be 0 if a==b, -1 if a < b, and +1 if a > b.",
        "name": "strings.Compare",
        "params": [],
        "path": "go/strings/index#Compare",
        "syntax": "func Compare(a, b string) int",
        "type": "strings"
    },
    "Compile": {
        "descr": "Compile parses a regular expression and returns, if successful, a Regexp object that can be used to match against text.",
        "name": "regexp.Compile",
        "params": [],
        "path": "go/regexp/index#Compile",
        "syntax": "func Compile(expr string) (*Regexp, error)",
        "type": "regexp"
    },
    "CompilePOSIX": {
        "descr": "CompilePOSIX is like Compile but restricts the regular expression to POSIX ERE (egrep) syntax and changes the match semantics to leftmost-longest.",
        "name": "regexp.CompilePOSIX",
        "params": [],
        "path": "go/regexp/index#CompilePOSIX",
        "syntax": "func CompilePOSIX(expr string) (*Regexp, error)",
        "type": "regexp"
    },
    "ComplexType": {
        "descr": "ComplexType is here for the purposes of documentation only. It is a stand-in for either complex type: complex64 or complex128.",
        "name": "builtin.ComplexType",
        "params": [],
        "path": "go/builtin/index#ComplexType",
        "syntax": "type ComplexType complex64",
        "type": "builtin"
    },
    "Cond": {
        "descr": "Cond implements a condition variable, a rendezvous point for goroutines waiting for or announcing the occurrence of an event.",
        "name": "sync.Cond",
        "params": [],
        "path": "go/sync/index#Cond",
        "syntax": "type Cond struct { // L is held while observing or changing the condition L Locker // contains filtered or unexported fields }",
        "type": "sync"
    },
    "Cond.Broadcast": {
        "descr": "Broadcast wakes all goroutines waiting on c.",
        "name": "sync.Cond.Broadcast",
        "params": [],
        "path": "go/sync/index#Cond.Broadcast",
        "syntax": "func (c *Cond) Broadcast()",
        "type": "sync"
    },
    "Cond.Signal": {
        "descr": "Signal wakes one goroutine waiting on c, if there is any.",
        "name": "sync.Cond.Signal",
        "params": [],
        "path": "go/sync/index#Cond.Signal",
        "syntax": "func (c *Cond) Signal()",
        "type": "sync"
    },
    "Cond.Wait": {
        "descr": "Wait atomically unlocks c.L and suspends execution of the calling goroutine. After later resuming execution, Wait locks c.L before returning. Unlike in other systems, Wait cannot return unless awoken by Broadcast or Signal.",
        "name": "sync.Cond.Wait",
        "params": [],
        "path": "go/sync/index#Cond.Wait",
        "syntax": "func (c *Cond) Wait()",
        "type": "sync"
    },
    "Config": {
        "descr": "Config holds an image's color model and dimensions.",
        "name": "image.Config",
        "params": [],
        "path": "go/image/index#Config",
        "syntax": "type Config struct { ColorModel color.Model Width, Height int }",
        "type": "image"
    },
    "Conn": {
        "descr": "Conn is implemented by some types in the net package to provide access to the underlying file descriptor or handle.",
        "name": "syscall.Conn",
        "params": [],
        "path": "go/syscall/index#Conn",
        "syntax": "type Conn interface { // SyscallConn returns a raw network connection. SyscallConn() (RawConn, error) }",
        "type": "syscall"
    },
    "Connect": {
        "descr": "",
        "name": "syscall.Connect",
        "params": [],
        "path": "go/syscall/index#Connect",
        "syntax": "func Connect(fd int, sa Sockaddr) (err error)",
        "type": "syscall"
    },
    "Contains": {
        "descr": "Contains reports whether substr is within s.",
        "name": "strings.Contains",
        "params": [],
        "path": "go/strings/index#Contains",
        "syntax": "func Contains(s, substr string) bool",
        "type": "strings"
    },
    "ContainsAny": {
        "descr": "ContainsAny reports whether any Unicode code points in chars are within s.",
        "name": "strings.ContainsAny",
        "params": [],
        "path": "go/strings/index#ContainsAny",
        "syntax": "func ContainsAny(s, chars string) bool",
        "type": "strings"
    },
    "ContainsRune": {
        "descr": "ContainsRune reports whether the Unicode code point r is within s.",
        "name": "strings.ContainsRune",
        "params": [],
        "path": "go/strings/index#ContainsRune",
        "syntax": "func ContainsRune(s string, r rune) bool",
        "type": "strings"
    },
    "Context": {
        "descr": "A Context carries a deadline, a cancelation signal, and other values across API boundaries.",
        "name": "context.Context",
        "params": [],
        "path": "go/context/index#Context",
        "syntax": "type Context interface { // Deadline returns the time when work done on behalf of this context // should be canceled. Deadline returns ok==false when no deadline is // set. Successive calls to Deadline return the same results. Deadline() (deadline time.Time, ok bool) // Done returns a channel that's closed when work done on behalf of this // context should be canceled. Done may return nil if this context can // never be canceled. Successive calls to Done return the same value. // // WithCancel arranges for Done to be closed when cancel is called; // WithDeadline arranges for Done to be closed when the deadline // expires; WithTimeout arranges for Done to be closed when the timeout // elapses. // // Done is provided for use in select statements: // // // Stream generates values with DoSomething and sends them to out // // until DoSomething returns an error or ctx.Done is closed. // func Stream(ctx context.Context, out chan<- Value) error { // for { // v, err := DoSomething(ctx) // if err != nil { // return err // } // select { // case <-ctx.Done(): // return ctx.Err() // case out <- v: // } // } // } // // See https://blog.golang.org/pipelines for more examples of how to use // a Done channel for cancelation. Done() <-chan struct{} // If Done is not yet closed, Err returns nil. // If Done is closed, Err returns a non-nil error explaining why: // Canceled if the context was canceled // or DeadlineExceeded if the context's deadline passed. // After Err returns a non-nil error, successive calls to Err return the same error. Err() error // Value returns the value associated with this context for key, or nil // if no value is associated with key. Successive calls to Value with // the same key returns the same result. // // Use context values only for request-scoped data that transits // processes and API boundaries, not for passing optional parameters to // functions. // // A key identifies a specific value in a Context. Functions that wish // to store values in Context typically allocate a key in a global // variable then use that key as the argument to context.WithValue and // Context.Value. A key can be any type that supports equality; // packages should define keys as an unexported type to avoid // collisions. // // Packages that define a Context key should provide type-safe accessors // for the values stored using that key: // // // Package user defines a User type that's stored in Contexts. // package user // // import \"context\" // // // User is the type of value stored in the Contexts. // type User struct {...} // // // key is an unexported type for keys defined in this package. // // This prevents collisions with keys defined in other packages. // type key int // // // userKey is the key for user.User values in Contexts. It is // // unexported; clients use user.NewContext and user.FromContext // // instead of using this key directly. // var userKey key // // // NewContext returns a new Context that carries value u. // func NewContext(ctx context.Context, u *User) context.Context { // return context.WithValue(ctx, userKey, u) // } // // // FromContext returns the User value stored in ctx, if any. // func FromContext(ctx context.Context) (*User, bool) { // u, ok := ctx.Value(userKey).(*User) // return u, ok // } Value(key interface{}) interface{} }",
        "type": "context"
    },
    "Copy": {
        "descr": "Copy copies the contents of src into dst until either dst has been filled or src has been exhausted. It returns the number of elements copied. Dst and src each must have kind Slice or Array, and dst and src must have the same element type.",
        "name": "reflect.Copy",
        "params": [],
        "path": "go/reflect/index#Copy",
        "syntax": "func Copy(dst, src Value) int",
        "type": "reflect"
    },
    "CopyBuffer": {
        "descr": "CopyBuffer is identical to Copy except that it stages through the provided buffer (if one is required) rather than allocating a temporary one. If buf is nil, one is allocated; otherwise if it has zero length, CopyBuffer panics.",
        "name": "io.CopyBuffer",
        "params": [],
        "path": "go/io/index#CopyBuffer",
        "syntax": "func CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error)",
        "type": "io"
    },
    "CopyN": {
        "descr": "CopyN copies n bytes (or until an error) from src to dst. It returns the number of bytes copied and the earliest error encountered while copying. On return, written == n if and only if err == nil.",
        "name": "io.CopyN",
        "params": [],
        "path": "go/io/index#CopyN",
        "syntax": "func CopyN(dst Writer, src Reader, n int64) (written int64, err error)",
        "type": "io"
    },
    "Copysign": {
        "descr": "Copysign returns a value with the magnitude of x and the sign of y.",
        "name": "math.Copysign",
        "params": [],
        "path": "go/math/index#Copysign",
        "syntax": "func Copysign(x, y float64) float64",
        "type": "math"
    },
    "Cos": {
        "descr": "Cos returns the cosine of the radian argument x.",
        "name": "math.Cos",
        "params": [],
        "path": "go/math/index#Cos",
        "syntax": "func Cos(x float64) float64",
        "type": "math"
    },
    "Cosh": {
        "descr": "Cosh returns the hyperbolic cosine of x.",
        "name": "math.Cosh",
        "params": [],
        "path": "go/math/index#Cosh",
        "syntax": "func Cosh(x float64) float64",
        "type": "math"
    },
    "Count": {
        "descr": "Count counts the number of non-overlapping instances of substr in s. If substr is an empty string, Count returns 1 + the number of Unicode code points in s.",
        "name": "strings.Count",
        "params": [],
        "path": "go/strings/index#Count",
        "syntax": "func Count(s, substr string) int",
        "type": "strings"
    },
    "Cover": {
        "descr": "Cover records information about test coverage checking. NOTE: This struct is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines.",
        "name": "testing.Cover",
        "params": [],
        "path": "go/testing/index#Cover",
        "syntax": "type Cover struct { Mode string Counters map[string][]uint32 Blocks map[string][]CoverBlock CoveredPackages string }",
        "type": "testing"
    },
    "CoverBlock": {
        "descr": "CoverBlock records the coverage data for a single basic block. The fields are 1-indexed, as in an editor: The opening line of the file is number 1, for example. Columns are measured in bytes. NOTE: This struct is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines.",
        "name": "testing.CoverBlock",
        "params": [],
        "path": "go/testing/index#CoverBlock",
        "syntax": "type CoverBlock struct { Line0 uint32 // Line number for block start. Col0 uint16 // Column number for block start. Line1 uint32 // Line number for block end. Col1 uint16 // Column number for block end. Stmts uint16 // Number of statements included in this block. }",
        "type": "testing"
    },
    "CoverMode": {
        "descr": "CoverMode reports what the test coverage mode is set to. The values are \"set\", \"count\", or \"atomic\". The return value will be empty if test coverage is not enabled.",
        "name": "testing.CoverMode",
        "params": [],
        "path": "go/testing/index#CoverMode",
        "syntax": "func CoverMode() string",
        "type": "testing"
    },
    "Coverage": {
        "descr": "Coverage reports the current code coverage as a fraction in the range [0, 1]. If coverage is not enabled, Coverage returns 0.",
        "name": "testing.Coverage",
        "params": [],
        "path": "go/testing/index#Coverage",
        "syntax": "func Coverage() float64",
        "type": "testing"
    },
    "Creat": {
        "descr": "",
        "name": "syscall.Creat",
        "params": [],
        "path": "go/syscall/index#Creat",
        "syntax": "func Creat(path string, mode uint32) (fd int, err error)",
        "type": "syscall"
    },
    "Create": {
        "descr": "Create creates the named file with mode 0666 (before umask), truncating it if it already exists. If successful, methods on the returned File can be used for I/O; the associated file descriptor has mode O_RDWR. If there is an error, it will be of type *PathError.",
        "name": "os.Create",
        "params": [],
        "path": "go/os/index#Create",
        "syntax": "func Create(name string) (*File, error)",
        "type": "os"
    },
    "Credential": {
        "descr": "Credential holds user and group identities to be assumed by a child process started by StartProcess.",
        "name": "syscall.Credential",
        "params": [],
        "path": "go/syscall/index#Credential",
        "syntax": "type Credential struct { Uid uint32 // User ID. Gid uint32 // Group ID. Groups []uint32 // Supplementary group IDs. NoSetGroups bool // If true, don't set supplementary groups }",
        "type": "syscall"
    },
    "DNSConfigError": {
        "descr": "DNSConfigError represents an error reading the machine's DNS configuration. (No longer used; kept for compatibility.)",
        "name": "net.DNSConfigError",
        "params": [],
        "path": "go/net/index#DNSConfigError",
        "syntax": "type DNSConfigError struct { Err error }",
        "type": "net"
    },
    "DNSConfigError.Error": {
        "descr": "",
        "name": "net.DNSConfigError.Error",
        "params": [],
        "path": "go/net/index#DNSConfigError.Error",
        "syntax": "func (e *DNSConfigError) Error() string",
        "type": "net"
    },
    "DNSConfigError.Temporary": {
        "descr": "",
        "name": "net.DNSConfigError.Temporary",
        "params": [],
        "path": "go/net/index#DNSConfigError.Temporary",
        "syntax": "func (e *DNSConfigError) Temporary() bool",
        "type": "net"
    },
    "DNSConfigError.Timeout": {
        "descr": "",
        "name": "net.DNSConfigError.Timeout",
        "params": [],
        "path": "go/net/index#DNSConfigError.Timeout",
        "syntax": "func (e *DNSConfigError) Timeout() bool",
        "type": "net"
    },
    "DNSError": {
        "descr": "DNSError represents a DNS lookup error.",
        "name": "net.DNSError",
        "params": [],
        "path": "go/net/index#DNSError",
        "syntax": "type DNSError struct { Err string // description of the error Name string // name looked for Server string // server used IsTimeout bool // if true, timed out; not all timeouts set this IsTemporary bool // if true, error is temporary; not all errors set this; added in Go 1.6 }",
        "type": "net"
    },
    "DNSError.Error": {
        "descr": "",
        "name": "net.DNSError.Error",
        "params": [],
        "path": "go/net/index#DNSError.Error",
        "syntax": "func (e *DNSError) Error() string",
        "type": "net"
    },
    "DNSError.Temporary": {
        "descr": "Temporary reports whether the DNS error is known to be temporary. This is not always known; a DNS lookup may fail due to a temporary error and return a DNSError for which Temporary returns false.",
        "name": "net.DNSError.Temporary",
        "params": [],
        "path": "go/net/index#DNSError.Temporary",
        "syntax": "func (e *DNSError) Temporary() bool",
        "type": "net"
    },
    "DNSError.Timeout": {
        "descr": "Timeout reports whether the DNS lookup is known to have timed out. This is not always known; a DNS lookup may fail due to a timeout and return a DNSError for which Timeout returns false.",
        "name": "net.DNSError.Timeout",
        "params": [],
        "path": "go/net/index#DNSError.Timeout",
        "syntax": "func (e *DNSError) Timeout() bool",
        "type": "net"
    },
    "Date": {
        "descr": "Date returns the Time corresponding to",
        "name": "time.Date",
        "params": [],
        "path": "go/time/index#Date",
        "syntax": "func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time",
        "type": "time"
    },
    "Decode": {
        "descr": "Decode decodes an image that has been encoded in a registered format. The string returned is the format name used during format registration. Format registration is typically done by an init function in the codec- specific package.",
        "name": "image.Decode",
        "params": [],
        "path": "go/image/index#Decode",
        "syntax": "func Decode(r io.Reader) (Image, string, error)",
        "type": "image"
    },
    "DecodeConfig": {
        "descr": "DecodeConfig decodes the color model and dimensions of an image that has been encoded in a registered format. The string returned is the format name used during format registration. Format registration is typically done by an init function in the codec-specific package.",
        "name": "image.DecodeConfig",
        "params": [],
        "path": "go/image/index#DecodeConfig",
        "syntax": "func DecodeConfig(r io.Reader) (Config, string, error)",
        "type": "image"
    },
    "Decrypter": {
        "descr": "Decrypter is an interface for an opaque private key that can be used for asymmetric decryption operations. An example would be an RSA key kept in a hardware module.",
        "name": "crypto.Decrypter",
        "params": [],
        "path": "go/crypto/index#Decrypter",
        "syntax": "type Decrypter interface { // Public returns the public key corresponding to the opaque, // private key. Public() PublicKey // Decrypt decrypts msg. The opts argument should be appropriate for // the primitive used. See the documentation in each implementation for // details. Decrypt(rand io.Reader, msg []byte, opts DecrypterOpts) (plaintext []byte, err error) }",
        "type": "crypto"
    },
    "DecrypterOpts": {
        "descr": "",
        "name": "crypto.DecrypterOpts",
        "params": [],
        "path": "go/crypto/index#DecrypterOpts",
        "syntax": "type DecrypterOpts interface{}",
        "type": "crypto"
    },
    "DeepEqual": {
        "descr": "DeepEqual reports whether x and y are deeply equal, defined as follows. Two values of identical type are deeply equal if one of the following cases applies. Values of distinct types are never deeply equal.",
        "name": "reflect.DeepEqual",
        "params": [],
        "path": "go/reflect/index#DeepEqual",
        "syntax": "func DeepEqual(x, y interface{}) bool",
        "type": "reflect"
    },
    "DetachLsf": {
        "descr": "Deprecated: Use golang.org/x/net/bpf instead.",
        "name": "syscall.DetachLsf",
        "params": [],
        "path": "go/syscall/index#DetachLsf",
        "syntax": "func DetachLsf(fd int) error",
        "type": "syscall"
    },
    "Dial": {
        "descr": "Dial connects to the address on the named network.",
        "name": "net.Dial",
        "params": [],
        "path": "go/net/index#Dial",
        "syntax": "func Dial(network, address string) (Conn, error)",
        "type": "net"
    },
    "DialIP": {
        "descr": "DialIP acts like Dial for IP networks.",
        "name": "net.DialIP",
        "params": [],
        "path": "go/net/index#DialIP",
        "syntax": "func DialIP(network string, laddr, raddr *IPAddr) (*IPConn, error)",
        "type": "net"
    },
    "DialTCP": {
        "descr": "DialTCP acts like Dial for TCP networks.",
        "name": "net.DialTCP",
        "params": [],
        "path": "go/net/index#DialTCP",
        "syntax": "func DialTCP(network string, laddr, raddr *TCPAddr) (*TCPConn, error)",
        "type": "net"
    },
    "DialTimeout": {
        "descr": "DialTimeout acts like Dial but takes a timeout.",
        "name": "net.DialTimeout",
        "params": [],
        "path": "go/net/index#DialTimeout",
        "syntax": "func DialTimeout(network, address string, timeout time.Duration) (Conn, error)",
        "type": "net"
    },
    "DialUDP": {
        "descr": "DialUDP acts like Dial for UDP networks.",
        "name": "net.DialUDP",
        "params": [],
        "path": "go/net/index#DialUDP",
        "syntax": "func DialUDP(network string, laddr, raddr *UDPAddr) (*UDPConn, error)",
        "type": "net"
    },
    "DialUnix": {
        "descr": "DialUnix acts like Dial for Unix networks.",
        "name": "net.DialUnix",
        "params": [],
        "path": "go/net/index#DialUnix",
        "syntax": "func DialUnix(network string, laddr, raddr *UnixAddr) (*UnixConn, error)",
        "type": "net"
    },
    "Dialer": {
        "descr": "A Dialer contains options for connecting to an address.",
        "name": "net.Dialer",
        "params": [],
        "path": "go/net/index#Dialer",
        "syntax": "type Dialer struct { // Timeout is the maximum amount of time a dial will wait for // a connect to complete. If Deadline is also set, it may fail // earlier. // // The default is no timeout. // // When using TCP and dialing a host name with multiple IP // addresses, the timeout may be divided between them. // // With or without a timeout, the operating system may impose // its own earlier timeout. For instance, TCP timeouts are // often around 3 minutes. Timeout time.Duration // Deadline is the absolute point in time after which dials // will fail. If Timeout is set, it may fail earlier. // Zero means no deadline, or dependent on the operating system // as with the Timeout option. Deadline time.Time // LocalAddr is the local address to use when dialing an // address. The address must be of a compatible type for the // network being dialed. // If nil, a local address is automatically chosen. LocalAddr Addr // DualStack enables RFC 6555-compliant \"Happy Eyeballs\" // dialing when the network is \"tcp\" and the host in the // address parameter resolves to both IPv4 and IPv6 addresses. // This allows a client to tolerate networks where one address // family is silently broken. DualStack bool // Go 1.2 // FallbackDelay specifies the length of time to wait before // spawning a fallback connection, when DualStack is enabled. // If zero, a default delay of 300ms is used. FallbackDelay time.Duration // Go 1.5 // KeepAlive specifies the keep-alive period for an active // network connection. // If zero, keep-alives are not enabled. Network protocols // that do not support keep-alives ignore this field. KeepAlive time.Duration // Go 1.3 // Resolver optionally specifies an alternate resolver to use. Resolver *Resolver // Go 1.8 // Cancel is an optional channel whose closure indicates that // the dial should be canceled. Not all types of dials support // cancelation. // // Deprecated: Use DialContext instead. Cancel <-chan struct{} // Go 1.6 // If Control is not nil, it is called after creating the network // connection but before actually dialing. // // Network and address parameters passed to Control method are not // necessarily the ones passed to Dial. For example, passing \"tcp\" to Dial // will cause the Control function to be called with \"tcp4\" or \"tcp6\". Control func(network, address string, c syscall.RawConn) error // Go 1.11 }",
        "type": "net"
    },
    "Dialer.Dial": {
        "descr": "Dial connects to the address on the named network.",
        "name": "net.Dialer.Dial",
        "params": [],
        "path": "go/net/index#Dialer.Dial",
        "syntax": "func (d *Dialer) Dial(network, address string) (Conn, error)",
        "type": "net"
    },
    "Dialer.DialContext": {
        "descr": "DialContext connects to the address on the named network using the provided context.",
        "name": "net.Dialer.DialContext",
        "params": [],
        "path": "go/net/index#Dialer.DialContext",
        "syntax": "func (d *Dialer) DialContext(ctx context.Context, network, address string) (Conn, error)",
        "type": "net"
    },
    "Dim": {
        "descr": "Dim returns the maximum of x-y or 0.",
        "name": "math.Dim",
        "params": [],
        "path": "go/math/index#Dim",
        "syntax": "func Dim(x, y float64) float64",
        "type": "math"
    },
    "Dir": {
        "descr": "Dir returns all but the last element of path, typically the path's directory. After dropping the final element using Split, the path is Cleaned and trailing slashes are removed. If the path is empty, Dir returns \".\". If the path consists entirely of slashes followed by non-slash bytes, Dir returns a single slash. In any other case, the returned path does not end in a slash.",
        "name": "path.Dir",
        "params": [],
        "path": "go/path/index#Dir",
        "syntax": "func Dir(path string) string",
        "type": "path"
    },
    "Dirent": {
        "descr": "",
        "name": "syscall.Dirent",
        "params": [],
        "path": "go/syscall/index#Dirent",
        "syntax": "type Dirent struct { Ino uint64 Off int64 Reclen uint16 Type uint8 Name [256]int8 Pad_cgo_0 [5]byte }",
        "type": "syscall"
    },
    "Do": {
        "descr": "Do calls f for each exported variable. The global variable map is locked during the iteration, but existing entries may be concurrently updated.",
        "name": "expvar.Do",
        "params": [],
        "path": "go/expvar/index#Do",
        "syntax": "func Do(f func(KeyValue))",
        "type": "expvar"
    },
    "Dup": {
        "descr": "",
        "name": "syscall.Dup",
        "params": [],
        "path": "go/syscall/index#Dup",
        "syntax": "func Dup(oldfd int) (fd int, err error)",
        "type": "syscall"
    },
    "Dup2": {
        "descr": "",
        "name": "syscall.Dup2",
        "params": [],
        "path": "go/syscall/index#Dup2",
        "syntax": "func Dup2(oldfd int, newfd int) (err error)",
        "type": "syscall"
    },
    "Dup3": {
        "descr": "",
        "name": "syscall.Dup3",
        "params": [],
        "path": "go/syscall/index#Dup3",
        "syntax": "func Dup3(oldfd int, newfd int, flags int) (err error)",
        "type": "syscall"
    },
    "Duration": {
        "descr": "A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.",
        "name": "time.Duration",
        "params": [],
        "path": "go/time/index#Duration",
        "syntax": "type Duration int64",
        "type": "time"
    },
    "Duration.Hours": {
        "descr": "Hours returns the duration as a floating point number of hours.",
        "name": "time.Duration.Hours",
        "params": [],
        "path": "go/time/index#Duration.Hours",
        "syntax": "func (d Duration) Hours() float64",
        "type": "time"
    },
    "Duration.Minutes": {
        "descr": "Minutes returns the duration as a floating point number of minutes.",
        "name": "time.Duration.Minutes",
        "params": [],
        "path": "go/time/index#Duration.Minutes",
        "syntax": "func (d Duration) Minutes() float64",
        "type": "time"
    },
    "Duration.Nanoseconds": {
        "descr": "Nanoseconds returns the duration as an integer nanosecond count.",
        "name": "time.Duration.Nanoseconds",
        "params": [],
        "path": "go/time/index#Duration.Nanoseconds",
        "syntax": "func (d Duration) Nanoseconds() int64",
        "type": "time"
    },
    "Duration.Round": {
        "descr": "Round returns the result of rounding d to the nearest multiple of m. The rounding behavior for halfway values is to round away from zero. If the result exceeds the maximum (or minimum) value that can be stored in a Duration, Round returns the maximum (or minimum) duration. If m <= 0, Round returns d unchanged.",
        "name": "time.Duration.Round",
        "params": [],
        "path": "go/time/index#Duration.Round",
        "syntax": "func (d Duration) Round(m Duration) Duration",
        "type": "time"
    },
    "Duration.Seconds": {
        "descr": "Seconds returns the duration as a floating point number of seconds.",
        "name": "time.Duration.Seconds",
        "params": [],
        "path": "go/time/index#Duration.Seconds",
        "syntax": "func (d Duration) Seconds() float64",
        "type": "time"
    },
    "Duration.String": {
        "descr": "String returns a string representing the duration in the form \"72h3m0.5s\". Leading zero units are omitted. As a special case, durations less than one second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure that the leading digit is non-zero. The zero duration formats as 0s.",
        "name": "time.Duration.String",
        "params": [],
        "path": "go/time/index#Duration.String",
        "syntax": "func (d Duration) String() string",
        "type": "time"
    },
    "Duration.Truncate": {
        "descr": "Truncate returns the result of rounding d toward zero to a multiple of m. If m <= 0, Truncate returns d unchanged.",
        "name": "time.Duration.Truncate",
        "params": [],
        "path": "go/time/index#Duration.Truncate",
        "syntax": "func (d Duration) Truncate(m Duration) Duration",
        "type": "time"
    },
    "DurationVar": {
        "descr": "DurationVar defines a time.Duration flag with specified name, default value, and usage string. The argument p points to a time.Duration variable in which to store the value of the flag. The flag accepts a value acceptable to time.ParseDuration.",
        "name": "flag.DurationVar",
        "params": [],
        "path": "go/flag/index#DurationVar",
        "syntax": "func DurationVar(p *time.Duration, name string, value time.Duration, usage string)",
        "type": "flag"
    },
    "Environ": {
        "descr": "",
        "name": "syscall.Environ",
        "params": [],
        "path": "go/syscall/index#Environ",
        "syntax": "func Environ() []string",
        "type": "syscall"
    },
    "EpollCreate": {
        "descr": "",
        "name": "syscall.EpollCreate",
        "params": [],
        "path": "go/syscall/index#EpollCreate",
        "syntax": "func EpollCreate(size int) (fd int, err error)",
        "type": "syscall"
    },
    "EpollCreate1": {
        "descr": "",
        "name": "syscall.EpollCreate1",
        "params": [],
        "path": "go/syscall/index#EpollCreate1",
        "syntax": "func EpollCreate1(flag int) (fd int, err error)",
        "type": "syscall"
    },
    "EpollCtl": {
        "descr": "",
        "name": "syscall.EpollCtl",
        "params": [],
        "path": "go/syscall/index#EpollCtl",
        "syntax": "func EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error)",
        "type": "syscall"
    },
    "EpollEvent": {
        "descr": "",
        "name": "syscall.EpollEvent",
        "params": [],
        "path": "go/syscall/index#EpollEvent",
        "syntax": "type EpollEvent struct { Events uint32 Fd int32 Pad int32 }",
        "type": "syscall"
    },
    "EpollWait": {
        "descr": "",
        "name": "syscall.EpollWait",
        "params": [],
        "path": "go/syscall/index#EpollWait",
        "syntax": "func EpollWait(epfd int, events []EpollEvent, msec int) (n int, err error)",
        "type": "syscall"
    },
    "Equal": {
        "descr": "Equal returns a boolean reporting whether a and b are the same length and contain the same bytes. A nil argument is equivalent to an empty slice.",
        "name": "bytes.Equal",
        "params": [],
        "path": "go/bytes/index#Equal",
        "syntax": "func Equal(a, b []byte) bool",
        "type": "bytes"
    },
    "EqualFold": {
        "descr": "EqualFold reports whether s and t, interpreted as UTF-8 strings, are equal under Unicode case-folding.",
        "name": "strings.EqualFold",
        "params": [],
        "path": "go/strings/index#EqualFold",
        "syntax": "func EqualFold(s, t string) bool",
        "type": "strings"
    },
    "Erf": {
        "descr": "Erf returns the error function of x.",
        "name": "math.Erf",
        "params": [],
        "path": "go/math/index#Erf",
        "syntax": "func Erf(x float64) float64",
        "type": "math"
    },
    "Erfc": {
        "descr": "Erfc returns the complementary error function of x.",
        "name": "math.Erfc",
        "params": [],
        "path": "go/math/index#Erfc",
        "syntax": "func Erfc(x float64) float64",
        "type": "math"
    },
    "Erfcinv": {
        "descr": "Erfcinv returns the inverse of Erfc(x).",
        "name": "math.Erfcinv",
        "params": [],
        "path": "go/math/index#Erfcinv",
        "syntax": "func Erfcinv(x float64) float64",
        "type": "math"
    },
    "Erfinv": {
        "descr": "Erfinv returns the inverse error function of x.",
        "name": "math.Erfinv",
        "params": [],
        "path": "go/math/index#Erfinv",
        "syntax": "func Erfinv(x float64) float64",
        "type": "math"
    },
    "Errno": {
        "descr": "An Errno is an unsigned number describing an error condition. It implements the error interface. The zero Errno is by convention a non-error, so code to convert from Errno to error should use:",
        "name": "syscall.Errno",
        "params": [],
        "path": "go/syscall/index#Errno",
        "syntax": "err = nil if errno != 0 { err = errno }",
        "type": "syscall"
    },
    "Errno.Error": {
        "descr": "",
        "name": "syscall.Errno.Error",
        "params": [],
        "path": "go/syscall/index#Errno.Error",
        "syntax": "func (e Errno) Error() string",
        "type": "syscall"
    },
    "Errno.Temporary": {
        "descr": "",
        "name": "syscall.Errno.Temporary",
        "params": [],
        "path": "go/syscall/index#Errno.Temporary",
        "syntax": "func (e Errno) Temporary() bool",
        "type": "syscall"
    },
    "Errno.Timeout": {
        "descr": "",
        "name": "syscall.Errno.Timeout",
        "params": [],
        "path": "go/syscall/index#Errno.Timeout",
        "syntax": "func (e Errno) Timeout() bool",
        "type": "syscall"
    },
    "Error": {
        "descr": "The Error interface identifies a run time error.",
        "name": "runtime.Error",
        "params": [],
        "path": "go/runtime/index#Error",
        "syntax": "type Error interface { error // RuntimeError is a no-op function but // serves to distinguish types that are run time // errors from ordinary errors: a type is a // run time error if it has a RuntimeError method. RuntimeError() }",
        "type": "runtime"
    },
    "ErrorHandling": {
        "descr": "ErrorHandling defines how FlagSet.Parse behaves if the parse fails.",
        "name": "flag.ErrorHandling",
        "params": [],
        "path": "go/flag/index#ErrorHandling",
        "syntax": "type ErrorHandling int",
        "type": "flag"
    },
    "Errorf": {
        "descr": "Errorf formats according to a format specifier and returns the string as a value that satisfies error.",
        "name": "fmt.Errorf",
        "params": [],
        "path": "go/fmt/index#Errorf",
        "syntax": "func Errorf(format string, a ...interface{}) error",
        "type": "fmt"
    },
    "EscapeString": {
        "descr": "EscapeString escapes special characters like \"<\" to become \"&lt;\". It escapes only five such characters: <, >, &, ' and \". UnescapeString(EscapeString(s)) == s always holds, but the converse isn't always true.",
        "name": "html.EscapeString",
        "params": [],
        "path": "go/html/index#EscapeString",
        "syntax": "func EscapeString(s string) string",
        "type": "html"
    },
    "Exec": {
        "descr": "Exec invokes the execve(2) system call.",
        "name": "syscall.Exec",
        "params": [],
        "path": "go/syscall/index#Exec",
        "syntax": "func Exec(argv0 string, argv []string, envv []string) (err error)",
        "type": "syscall"
    },
    "Executable": {
        "descr": "Executable returns the path name for the executable that started the current process. There is no guarantee that the path is still pointing to the correct executable. If a symlink was used to start the process, depending on the operating system, the result might be the symlink or the path it pointed to. If a stable result is needed, path/filepath.EvalSymlinks might help.",
        "name": "os.Executable",
        "params": [],
        "path": "go/os/index#Executable",
        "syntax": "func Executable() (string, error)",
        "type": "os"
    },
    "Exit": {
        "descr": "",
        "name": "syscall.Exit",
        "params": [],
        "path": "go/syscall/index#Exit",
        "syntax": "func Exit(code int)",
        "type": "syscall"
    },
    "Exp": {
        "descr": "Exp returns e**x, the base-e exponential of x.",
        "name": "math.Exp",
        "params": [],
        "path": "go/math/index#Exp",
        "syntax": "func Exp(x float64) float64",
        "type": "math"
    },
    "Exp2": {
        "descr": "Exp2 returns 2**x, the base-2 exponential of x.",
        "name": "math.Exp2",
        "params": [],
        "path": "go/math/index#Exp2",
        "syntax": "func Exp2(x float64) float64",
        "type": "math"
    },
    "Expand": {
        "descr": "Expand replaces ${var} or $var in the string based on the mapping function. For example, os.ExpandEnv(s) is equivalent to os.Expand(s, os.Getenv).",
        "name": "os.Expand",
        "params": [],
        "path": "go/os/index#Expand",
        "syntax": "func Expand(s string, mapping func(string) string) string",
        "type": "os"
    },
    "ExpandEnv": {
        "descr": "ExpandEnv replaces ${var} or $var in the string according to the values of the current environment variables. References to undefined variables are replaced by the empty string.",
        "name": "os.ExpandEnv",
        "params": [],
        "path": "go/os/index#ExpandEnv",
        "syntax": "func ExpandEnv(s string) string",
        "type": "os"
    },
    "Expm1": {
        "descr": "Expm1 returns e**x - 1, the base-e exponential of x minus 1. It is more accurate than Exp(x) - 1 when x is near zero.",
        "name": "math.Expm1",
        "params": [],
        "path": "go/math/index#Expm1",
        "syntax": "func Expm1(x float64) float64",
        "type": "math"
    },
    "Ext": {
        "descr": "Ext returns the file name extension used by path. The extension is the suffix beginning at the final dot in the final slash-separated element of path; it is empty if there is no dot.",
        "name": "path.Ext",
        "params": [],
        "path": "go/path/index#Ext",
        "syntax": "func Ext(path string) string",
        "type": "path"
    },
    "ExtensionsByType": {
        "descr": "ExtensionsByType returns the extensions known to be associated with the MIME type typ. The returned extensions will each begin with a leading dot, as in \".html\". When typ has no associated extensions, ExtensionsByType returns an nil slice.",
        "name": "mime.ExtensionsByType",
        "params": [],
        "path": "go/mime/index#ExtensionsByType",
        "syntax": "func ExtensionsByType(typ string) ([]string, error)",
        "type": "mime"
    },
    "Faccessat": {
        "descr": "",
        "name": "syscall.Faccessat",
        "params": [],
        "path": "go/syscall/index#Faccessat",
        "syntax": "func Faccessat(dirfd int, path string, mode uint32, flags int) (err error)",
        "type": "syscall"
    },
    "Fallocate": {
        "descr": "",
        "name": "syscall.Fallocate",
        "params": [],
        "path": "go/syscall/index#Fallocate",
        "syntax": "func Fallocate(fd int, mode uint32, off int64, len int64) (err error)",
        "type": "syscall"
    },
    "Fatal": {
        "descr": "Fatal is equivalent to Print() followed by a call to os.Exit(1).",
        "name": "log.Fatal",
        "params": [],
        "path": "go/log/index#Fatal",
        "syntax": "func Fatal(v ...interface{})",
        "type": "log"
    },
    "Fatalf": {
        "descr": "Fatalf is equivalent to Printf() followed by a call to os.Exit(1).",
        "name": "log.Fatalf",
        "params": [],
        "path": "go/log/index#Fatalf",
        "syntax": "func Fatalf(format string, v ...interface{})",
        "type": "log"
    },
    "Fatalln": {
        "descr": "Fatalln is equivalent to Println() followed by a call to os.Exit(1).",
        "name": "log.Fatalln",
        "params": [],
        "path": "go/log/index#Fatalln",
        "syntax": "func Fatalln(v ...interface{})",
        "type": "log"
    },
    "Fchdir": {
        "descr": "",
        "name": "syscall.Fchdir",
        "params": [],
        "path": "go/syscall/index#Fchdir",
        "syntax": "func Fchdir(fd int) (err error)",
        "type": "syscall"
    },
    "Fchmod": {
        "descr": "",
        "name": "syscall.Fchmod",
        "params": [],
        "path": "go/syscall/index#Fchmod",
        "syntax": "func Fchmod(fd int, mode uint32) (err error)",
        "type": "syscall"
    },
    "Fchmodat": {
        "descr": "",
        "name": "syscall.Fchmodat",
        "params": [],
        "path": "go/syscall/index#Fchmodat",
        "syntax": "func Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)",
        "type": "syscall"
    },
    "Fchown": {
        "descr": "",
        "name": "syscall.Fchown",
        "params": [],
        "path": "go/syscall/index#Fchown",
        "syntax": "func Fchown(fd int, uid int, gid int) (err error)",
        "type": "syscall"
    },
    "Fchownat": {
        "descr": "",
        "name": "syscall.Fchownat",
        "params": [],
        "path": "go/syscall/index#Fchownat",
        "syntax": "func Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)",
        "type": "syscall"
    },
    "FcntlFlock": {
        "descr": "FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command.",
        "name": "syscall.FcntlFlock",
        "params": [],
        "path": "go/syscall/index#FcntlFlock",
        "syntax": "func FcntlFlock(fd uintptr, cmd int, lk *Flock_t) error",
        "type": "syscall"
    },
    "FdSet": {
        "descr": "",
        "name": "syscall.FdSet",
        "params": [],
        "path": "go/syscall/index#FdSet",
        "syntax": "type FdSet struct { Bits [16]int64 }",
        "type": "syscall"
    },
    "Fdatasync": {
        "descr": "",
        "name": "syscall.Fdatasync",
        "params": [],
        "path": "go/syscall/index#Fdatasync",
        "syntax": "func Fdatasync(fd int) (err error)",
        "type": "syscall"
    },
    "Fields": {
        "descr": "Fields splits the string s around each instance of one or more consecutive white space characters, as defined by unicode.IsSpace, returning a slice of substrings of s or an empty slice if s contains only white space.",
        "name": "strings.Fields",
        "params": [],
        "path": "go/strings/index#Fields",
        "syntax": "func Fields(s string) []string",
        "type": "strings"
    },
    "FieldsFunc": {
        "descr": "FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c) and returns an array of slices of s. If all code points in s satisfy f(c) or the string is empty, an empty slice is returned. FieldsFunc makes no guarantees about the order in which it calls f(c). If f does not return consistent results for a given c, FieldsFunc may crash.",
        "name": "strings.FieldsFunc",
        "params": [],
        "path": "go/strings/index#FieldsFunc",
        "syntax": "func FieldsFunc(s string, f func(rune) bool) []string",
        "type": "strings"
    },
    "File": {
        "descr": "File represents an open file descriptor.",
        "name": "os.File",
        "params": [],
        "path": "go/os/index#File",
        "syntax": "type File struct { // contains filtered or unexported fields }",
        "type": "os"
    },
    "File.Chdir": {
        "descr": "Chdir changes the current working directory to the file, which must be a directory. If there is an error, it will be of type *PathError.",
        "name": "os.File.Chdir",
        "params": [],
        "path": "go/os/index#File.Chdir",
        "syntax": "func (f *File) Chdir() error",
        "type": "os"
    },
    "File.Chmod": {
        "descr": "Chmod changes the mode of the file to mode. If there is an error, it will be of type *PathError.",
        "name": "os.File.Chmod",
        "params": [],
        "path": "go/os/index#File.Chmod",
        "syntax": "func (f *File) Chmod(mode FileMode) error",
        "type": "os"
    },
    "File.Chown": {
        "descr": "Chown changes the numeric uid and gid of the named file. If there is an error, it will be of type *PathError.",
        "name": "os.File.Chown",
        "params": [],
        "path": "go/os/index#File.Chown",
        "syntax": "func (f *File) Chown(uid, gid int) error",
        "type": "os"
    },
    "File.Close": {
        "descr": "Close closes the File, rendering it unusable for I/O. On files that support SetDeadline, any pending I/O operations will be canceled and return immediately with an error.",
        "name": "os.File.Close",
        "params": [],
        "path": "go/os/index#File.Close",
        "syntax": "func (f *File) Close() error",
        "type": "os"
    },
    "File.Fd": {
        "descr": "Fd returns the integer Unix file descriptor referencing the open file. The file descriptor is valid only until f.Close is called or f is garbage collected. On Unix systems this will cause the SetDeadline methods to stop working.",
        "name": "os.File.Fd",
        "params": [],
        "path": "go/os/index#File.Fd",
        "syntax": "func (f *File) Fd() uintptr",
        "type": "os"
    },
    "File.Name": {
        "descr": "Name returns the name of the file as presented to Open.",
        "name": "os.File.Name",
        "params": [],
        "path": "go/os/index#File.Name",
        "syntax": "func (f *File) Name() string",
        "type": "os"
    },
    "File.Read": {
        "descr": "Read reads up to len(b) bytes from the File. It returns the number of bytes read and any error encountered. At end of file, Read returns 0, io.EOF.",
        "name": "os.File.Read",
        "params": [],
        "path": "go/os/index#File.Read",
        "syntax": "func (f *File) Read(b []byte) (n int, err error)",
        "type": "os"
    },
    "File.ReadAt": {
        "descr": "ReadAt reads len(b) bytes from the File starting at byte offset off. It returns the number of bytes read and the error, if any. ReadAt always returns a non-nil error when n < len(b). At end of file, that error is io.EOF.",
        "name": "os.File.ReadAt",
        "params": [],
        "path": "go/os/index#File.ReadAt",
        "syntax": "func (f *File) ReadAt(b []byte, off int64) (n int, err error)",
        "type": "os"
    },
    "File.Readdir": {
        "descr": "Readdir reads the contents of the directory associated with file and returns a slice of up to n FileInfo values, as would be returned by Lstat, in directory order. Subsequent calls on the same file will yield further FileInfos.",
        "name": "os.File.Readdir",
        "params": [],
        "path": "go/os/index#File.Readdir",
        "syntax": "func (f *File) Readdir(n int) ([]FileInfo, error)",
        "type": "os"
    },
    "File.Readdirnames": {
        "descr": "Readdirnames reads and returns a slice of names from the directory f.",
        "name": "os.File.Readdirnames",
        "params": [],
        "path": "go/os/index#File.Readdirnames",
        "syntax": "func (f *File) Readdirnames(n int) (names []string, err error)",
        "type": "os"
    },
    "File.Seek": {
        "descr": "Seek sets the offset for the next Read or Write on file to offset, interpreted according to whence: 0 means relative to the origin of the file, 1 means relative to the current offset, and 2 means relative to the end. It returns the new offset and an error, if any. The behavior of Seek on a file opened with O_APPEND is not specified.",
        "name": "os.File.Seek",
        "params": [],
        "path": "go/os/index#File.Seek",
        "syntax": "func (f *File) Seek(offset int64, whence int) (ret int64, err error)",
        "type": "os"
    },
    "File.SetDeadline": {
        "descr": "SetDeadline sets the read and write deadlines for a File. It is equivalent to calling both SetReadDeadline and SetWriteDeadline.",
        "name": "os.File.SetDeadline",
        "params": [],
        "path": "go/os/index#File.SetDeadline",
        "syntax": "func (f *File) SetDeadline(t time.Time) error",
        "type": "os"
    },
    "File.SetReadDeadline": {
        "descr": "SetReadDeadline sets the deadline for future Read calls and any currently-blocked Read call. A zero value for t means Read will not time out. Not all files support setting deadlines; see SetDeadline.",
        "name": "os.File.SetReadDeadline",
        "params": [],
        "path": "go/os/index#File.SetReadDeadline",
        "syntax": "func (f *File) SetReadDeadline(t time.Time) error",
        "type": "os"
    },
    "File.SetWriteDeadline": {
        "descr": "SetWriteDeadline sets the deadline for any future Write calls and any currently-blocked Write call. Even if Write times out, it may return n > 0, indicating that some of the data was successfully written. A zero value for t means Write will not time out. Not all files support setting deadlines; see SetDeadline.",
        "name": "os.File.SetWriteDeadline",
        "params": [],
        "path": "go/os/index#File.SetWriteDeadline",
        "syntax": "func (f *File) SetWriteDeadline(t time.Time) error",
        "type": "os"
    },
    "File.Stat": {
        "descr": "Stat returns the FileInfo structure describing file. If there is an error, it will be of type *PathError.",
        "name": "os.File.Stat",
        "params": [],
        "path": "go/os/index#File.Stat",
        "syntax": "func (f *File) Stat() (FileInfo, error)",
        "type": "os"
    },
    "File.Sync": {
        "descr": "Sync commits the current contents of the file to stable storage. Typically, this means flushing the file system's in-memory copy of recently written data to disk.",
        "name": "os.File.Sync",
        "params": [],
        "path": "go/os/index#File.Sync",
        "syntax": "func (f *File) Sync() error",
        "type": "os"
    },
    "File.Truncate": {
        "descr": "Truncate changes the size of the file. It does not change the I/O offset. If there is an error, it will be of type *PathError.",
        "name": "os.File.Truncate",
        "params": [],
        "path": "go/os/index#File.Truncate",
        "syntax": "func (f *File) Truncate(size int64) error",
        "type": "os"
    },
    "File.Write": {
        "descr": "Write writes len(b) bytes to the File. It returns the number of bytes written and an error, if any. Write returns a non-nil error when n != len(b).",
        "name": "os.File.Write",
        "params": [],
        "path": "go/os/index#File.Write",
        "syntax": "func (f *File) Write(b []byte) (n int, err error)",
        "type": "os"
    },
    "File.WriteAt": {
        "descr": "WriteAt writes len(b) bytes to the File starting at byte offset off. It returns the number of bytes written and an error, if any. WriteAt returns a non-nil error when n != len(b).",
        "name": "os.File.WriteAt",
        "params": [],
        "path": "go/os/index#File.WriteAt",
        "syntax": "func (f *File) WriteAt(b []byte, off int64) (n int, err error)",
        "type": "os"
    },
    "File.WriteString": {
        "descr": "WriteString is like Write, but writes the contents of string s rather than a slice of bytes.",
        "name": "os.File.WriteString",
        "params": [],
        "path": "go/os/index#File.WriteString",
        "syntax": "func (f *File) WriteString(s string) (n int, err error)",
        "type": "os"
    },
    "FileConn": {
        "descr": "FileConn returns a copy of the network connection corresponding to the open file f. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.",
        "name": "net.FileConn",
        "params": [],
        "path": "go/net/index#FileConn",
        "syntax": "func FileConn(f *os.File) (c Conn, err error)",
        "type": "net"
    },
    "FileInfo": {
        "descr": "A FileInfo describes a file and is returned by Stat and Lstat.",
        "name": "os.FileInfo",
        "params": [],
        "path": "go/os/index#FileInfo",
        "syntax": "type FileInfo interface { Name() string // base name of the file Size() int64 // length in bytes for regular files; system-dependent for others Mode() FileMode // file mode bits ModTime() time.Time // modification time IsDir() bool // abbreviation for Mode().IsDir() Sys() interface{} // underlying data source (can return nil) }",
        "type": "os"
    },
    "FileListener": {
        "descr": "FileListener returns a copy of the network listener corresponding to the open file f. It is the caller's responsibility to close ln when finished. Closing ln does not affect f, and closing f does not affect ln.",
        "name": "net.FileListener",
        "params": [],
        "path": "go/net/index#FileListener",
        "syntax": "func FileListener(f *os.File) (ln Listener, err error)",
        "type": "net"
    },
    "FileMode": {
        "descr": "A FileMode represents a file's mode and permission bits. The bits have the same definition on all systems, so that information about files can be moved from one system to another portably. Not all bits apply to all systems. The only required bit is ModeDir for directories.",
        "name": "os.FileMode",
        "params": [],
        "path": "go/os/index#FileMode",
        "syntax": "type FileMode uint32",
        "type": "os"
    },
    "FileMode.IsDir": {
        "descr": "IsDir reports whether m describes a directory. That is, it tests for the ModeDir bit being set in m.",
        "name": "os.FileMode.IsDir",
        "params": [],
        "path": "go/os/index#FileMode.IsDir",
        "syntax": "func (m FileMode) IsDir() bool",
        "type": "os"
    },
    "FileMode.IsRegular": {
        "descr": "IsRegular reports whether m describes a regular file. That is, it tests that no mode type bits are set.",
        "name": "os.FileMode.IsRegular",
        "params": [],
        "path": "go/os/index#FileMode.IsRegular",
        "syntax": "func (m FileMode) IsRegular() bool",
        "type": "os"
    },
    "FileMode.Perm": {
        "descr": "Perm returns the Unix permission bits in m.",
        "name": "os.FileMode.Perm",
        "params": [],
        "path": "go/os/index#FileMode.Perm",
        "syntax": "func (m FileMode) Perm() FileMode",
        "type": "os"
    },
    "FileMode.String": {
        "descr": "",
        "name": "os.FileMode.String",
        "params": [],
        "path": "go/os/index#FileMode.String",
        "syntax": "func (m FileMode) String() string",
        "type": "os"
    },
    "FilePacketConn": {
        "descr": "FilePacketConn returns a copy of the packet network connection corresponding to the open file f. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.",
        "name": "net.FilePacketConn",
        "params": [],
        "path": "go/net/index#FilePacketConn",
        "syntax": "func FilePacketConn(f *os.File) (c PacketConn, err error)",
        "type": "net"
    },
    "FindProcess": {
        "descr": "FindProcess looks for a running process by its pid.",
        "name": "os.FindProcess",
        "params": [],
        "path": "go/os/index#FindProcess",
        "syntax": "func FindProcess(pid int) (*Process, error)",
        "type": "os"
    },
    "FixedZone": {
        "descr": "FixedZone returns a Location that always uses the given zone name and offset (seconds east of UTC).",
        "name": "time.FixedZone",
        "params": [],
        "path": "go/time/index#FixedZone",
        "syntax": "func FixedZone(name string, offset int) *Location",
        "type": "time"
    },
    "Flag": {
        "descr": "A Flag represents the state of a flag.",
        "name": "flag.Flag",
        "params": [],
        "path": "go/flag/index#Flag",
        "syntax": "type Flag struct { Name string // name as it appears on command line Usage string // help message Value Value // value as set DefValue string // default value (as text);\n or  for usage message });",
        "type": "flag"
    },
    "FlagSet": {
        "descr": "A FlagSet represents a set of defined flags. The zero value of a FlagSet has no name and has ContinueOnError error handling.",
        "name": "flag.FlagSet",
        "params": [],
        "path": "go/flag/index#FlagSet",
        "syntax": "type FlagSet struct { // Usage is the function called when an error occurs while parsing flags. // The field is a function (not a method) that may be changed to point to // a custom error handler. What happens after Usage is called depends // on the ErrorHandling setting; for the command line, this defaults // to ExitOnError, which exits the program after calling Usage. Usage func() // contains filtered or unexported fields }",
        "type": "flag"
    },
    "FlagSet.Arg": {
        "descr": "Arg returns the i'th argument. Arg(0) is the first remaining argument after flags have been processed. Arg returns an empty string if the requested element does not exist.",
        "name": "flag.FlagSet.Arg",
        "params": [],
        "path": "go/flag/index#FlagSet.Arg",
        "syntax": "func (f *FlagSet) Arg(i int) string",
        "type": "flag"
    },
    "FlagSet.Args": {
        "descr": "Args returns the non-flag arguments.",
        "name": "flag.FlagSet.Args",
        "params": [],
        "path": "go/flag/index#FlagSet.Args",
        "syntax": "func (f *FlagSet) Args() []string",
        "type": "flag"
    },
    "FlagSet.Bool": {
        "descr": "Bool defines a bool flag with specified name, default value, and usage string. The return value is the address of a bool variable that stores the value of the flag.",
        "name": "flag.FlagSet.Bool",
        "params": [],
        "path": "go/flag/index#FlagSet.Bool",
        "syntax": "func (f *FlagSet) Bool(name string, value bool, usage string) *bool",
        "type": "flag"
    },
    "FlagSet.BoolVar": {
        "descr": "BoolVar defines a bool flag with specified name, default value, and usage string. The argument p points to a bool variable in which to store the value of the flag.",
        "name": "flag.FlagSet.BoolVar",
        "params": [],
        "path": "go/flag/index#FlagSet.BoolVar",
        "syntax": "func (f *FlagSet) BoolVar(p *bool, name string, value bool, usage string)",
        "type": "flag"
    },
    "FlagSet.Duration": {
        "descr": "Duration defines a time.Duration flag with specified name, default value, and usage string. The return value is the address of a time.Duration variable that stores the value of the flag. The flag accepts a value acceptable to time.ParseDuration.",
        "name": "flag.FlagSet.Duration",
        "params": [],
        "path": "go/flag/index#FlagSet.Duration",
        "syntax": "func (f *FlagSet) Duration(name string, value time.Duration, usage string) *time.Duration",
        "type": "flag"
    },
    "FlagSet.DurationVar": {
        "descr": "DurationVar defines a time.Duration flag with specified name, default value, and usage string. The argument p points to a time.Duration variable in which to store the value of the flag. The flag accepts a value acceptable to time.ParseDuration.",
        "name": "flag.FlagSet.DurationVar",
        "params": [],
        "path": "go/flag/index#FlagSet.DurationVar",
        "syntax": "func (f *FlagSet) DurationVar(p *time.Duration, name string, value time.Duration, usage string)",
        "type": "flag"
    },
    "FlagSet.ErrorHandling": {
        "descr": "ErrorHandling returns the error handling behavior of the flag set.",
        "name": "flag.FlagSet.ErrorHandling",
        "params": [],
        "path": "go/flag/index#FlagSet.ErrorHandling",
        "syntax": "func (f *FlagSet) ErrorHandling() ErrorHandling",
        "type": "flag"
    },
    "FlagSet.Float64": {
        "descr": "Float64 defines a float64 flag with specified name, default value, and usage string. The return value is the address of a float64 variable that stores the value of the flag.",
        "name": "flag.FlagSet.Float64",
        "params": [],
        "path": "go/flag/index#FlagSet.Float64",
        "syntax": "func (f *FlagSet) Float64(name string, value float64, usage string) *float64",
        "type": "flag"
    },
    "FlagSet.Float64Var": {
        "descr": "Float64Var defines a float64 flag with specified name, default value, and usage string. The argument p points to a float64 variable in which to store the value of the flag.",
        "name": "flag.FlagSet.Float64Var",
        "params": [],
        "path": "go/flag/index#FlagSet.Float64Var",
        "syntax": "func (f *FlagSet) Float64Var(p *float64, name string, value float64, usage string)",
        "type": "flag"
    },
    "FlagSet.Init": {
        "descr": "Init sets the name and error handling property for a flag set. By default, the zero FlagSet uses an empty name and the ContinueOnError error handling policy.",
        "name": "flag.FlagSet.Init",
        "params": [],
        "path": "go/flag/index#FlagSet.Init",
        "syntax": "func (f *FlagSet) Init(name string, errorHandling ErrorHandling)",
        "type": "flag"
    },
    "FlagSet.Int": {
        "descr": "Int defines an int flag with specified name, default value, and usage string. The return value is the address of an int variable that stores the value of the flag.",
        "name": "flag.FlagSet.Int",
        "params": [],
        "path": "go/flag/index#FlagSet.Int",
        "syntax": "func (f *FlagSet) Int(name string, value int, usage string) *int",
        "type": "flag"
    },
    "FlagSet.Int64": {
        "descr": "Int64 defines an int64 flag with specified name, default value, and usage string. The return value is the address of an int64 variable that stores the value of the flag.",
        "name": "flag.FlagSet.Int64",
        "params": [],
        "path": "go/flag/index#FlagSet.Int64",
        "syntax": "func (f *FlagSet) Int64(name string, value int64, usage string) *int64",
        "type": "flag"
    },
    "FlagSet.Int64Var": {
        "descr": "Int64Var defines an int64 flag with specified name, default value, and usage string. The argument p points to an int64 variable in which to store the value of the flag.",
        "name": "flag.FlagSet.Int64Var",
        "params": [],
        "path": "go/flag/index#FlagSet.Int64Var",
        "syntax": "func (f *FlagSet) Int64Var(p *int64, name string, value int64, usage string)",
        "type": "flag"
    },
    "FlagSet.IntVar": {
        "descr": "IntVar defines an int flag with specified name, default value, and usage string. The argument p points to an int variable in which to store the value of the flag.",
        "name": "flag.FlagSet.IntVar",
        "params": [],
        "path": "go/flag/index#FlagSet.IntVar",
        "syntax": "func (f *FlagSet) IntVar(p *int, name string, value int, usage string)",
        "type": "flag"
    },
    "FlagSet.Lookup": {
        "descr": "Lookup returns the Flag structure of the named flag, returning nil if none exists.",
        "name": "flag.FlagSet.Lookup",
        "params": [],
        "path": "go/flag/index#FlagSet.Lookup",
        "syntax": "func (f *FlagSet) Lookup(name string) *Flag",
        "type": "flag"
    },
    "FlagSet.NArg": {
        "descr": "NArg is the number of arguments remaining after flags have been processed.",
        "name": "flag.FlagSet.NArg",
        "params": [],
        "path": "go/flag/index#FlagSet.NArg",
        "syntax": "func (f *FlagSet) NArg() int",
        "type": "flag"
    },
    "FlagSet.NFlag": {
        "descr": "NFlag returns the number of flags that have been set.",
        "name": "flag.FlagSet.NFlag",
        "params": [],
        "path": "go/flag/index#FlagSet.NFlag",
        "syntax": "func (f *FlagSet) NFlag() int",
        "type": "flag"
    },
    "FlagSet.Name": {
        "descr": "Name returns the name of the flag set.",
        "name": "flag.FlagSet.Name",
        "params": [],
        "path": "go/flag/index#FlagSet.Name",
        "syntax": "func (f *FlagSet) Name() string",
        "type": "flag"
    },
    "FlagSet.Output": {
        "descr": "Output returns the destination for usage and error messages. os.Stderr is returned if output was not set or was set to nil.",
        "name": "flag.FlagSet.Output",
        "params": [],
        "path": "go/flag/index#FlagSet.Output",
        "syntax": "func (f *FlagSet) Output() io.Writer",
        "type": "flag"
    },
    "FlagSet.Parse": {
        "descr": "Parse parses flag definitions from the argument list, which should not include the command name. Must be called after all flags in the FlagSet are defined and before flags are accessed by the program. The return value will be ErrHelp if -help or -h were set but not defined.",
        "name": "flag.FlagSet.Parse",
        "params": [],
        "path": "go/flag/index#FlagSet.Parse",
        "syntax": "func (f *FlagSet) Parse(arguments []string) error",
        "type": "flag"
    },
    "FlagSet.Parsed": {
        "descr": "Parsed reports whether f.Parse has been called.",
        "name": "flag.FlagSet.Parsed",
        "params": [],
        "path": "go/flag/index#FlagSet.Parsed",
        "syntax": "func (f *FlagSet) Parsed() bool",
        "type": "flag"
    },
    "FlagSet.PrintDefaults": {
        "descr": "PrintDefaults prints, to standard error unless configured otherwise, the default values of all defined command-line flags in the set. See the documentation for the global function PrintDefaults for more information.",
        "name": "flag.FlagSet.PrintDefaults",
        "params": [],
        "path": "go/flag/index#FlagSet.PrintDefaults",
        "syntax": "func (f *FlagSet) PrintDefaults()",
        "type": "flag"
    },
    "FlagSet.Set": {
        "descr": "Set sets the value of the named flag.",
        "name": "flag.FlagSet.Set",
        "params": [],
        "path": "go/flag/index#FlagSet.Set",
        "syntax": "func (f *FlagSet) Set(name, value string) error",
        "type": "flag"
    },
    "FlagSet.SetOutput": {
        "descr": "SetOutput sets the destination for usage and error messages. If output is nil, os.Stderr is used.",
        "name": "flag.FlagSet.SetOutput",
        "params": [],
        "path": "go/flag/index#FlagSet.SetOutput",
        "syntax": "func (f *FlagSet) SetOutput(output io.Writer)",
        "type": "flag"
    },
    "FlagSet.String": {
        "descr": "String defines a string flag with specified name, default value, and usage string. The return value is the address of a string variable that stores the value of the flag.",
        "name": "flag.FlagSet.String",
        "params": [],
        "path": "go/flag/index#FlagSet.String",
        "syntax": "func (f *FlagSet) String(name string, value string, usage string) *string",
        "type": "flag"
    },
    "FlagSet.StringVar": {
        "descr": "StringVar defines a string flag with specified name, default value, and usage string. The argument p points to a string variable in which to store the value of the flag.",
        "name": "flag.FlagSet.StringVar",
        "params": [],
        "path": "go/flag/index#FlagSet.StringVar",
        "syntax": "func (f *FlagSet) StringVar(p *string, name string, value string, usage string)",
        "type": "flag"
    },
    "FlagSet.Uint": {
        "descr": "Uint defines a uint flag with specified name, default value, and usage string. The return value is the address of a uint variable that stores the value of the flag.",
        "name": "flag.FlagSet.Uint",
        "params": [],
        "path": "go/flag/index#FlagSet.Uint",
        "syntax": "func (f *FlagSet) Uint(name string, value uint, usage string) *uint",
        "type": "flag"
    },
    "FlagSet.Uint64": {
        "descr": "Uint64 defines a uint64 flag with specified name, default value, and usage string. The return value is the address of a uint64 variable that stores the value of the flag.",
        "name": "flag.FlagSet.Uint64",
        "params": [],
        "path": "go/flag/index#FlagSet.Uint64",
        "syntax": "func (f *FlagSet) Uint64(name string, value uint64, usage string) *uint64",
        "type": "flag"
    },
    "FlagSet.Uint64Var": {
        "descr": "Uint64Var defines a uint64 flag with specified name, default value, and usage string. The argument p points to a uint64 variable in which to store the value of the flag.",
        "name": "flag.FlagSet.Uint64Var",
        "params": [],
        "path": "go/flag/index#FlagSet.Uint64Var",
        "syntax": "func (f *FlagSet) Uint64Var(p *uint64, name string, value uint64, usage string)",
        "type": "flag"
    },
    "FlagSet.UintVar": {
        "descr": "UintVar defines a uint flag with specified name, default value, and usage string. The argument p points to a uint variable in which to store the value of the flag.",
        "name": "flag.FlagSet.UintVar",
        "params": [],
        "path": "go/flag/index#FlagSet.UintVar",
        "syntax": "func (f *FlagSet) UintVar(p *uint, name string, value uint, usage string)",
        "type": "flag"
    },
    "FlagSet.Var": {
        "descr": "Var defines a flag with the specified name and usage string. The type and value of the flag are represented by the first argument, of type Value, which typically holds a user-defined implementation of Value. For instance, the caller could create a flag that turns a comma-separated string into a slice of strings by giving the slice the methods of Value; in particular, Set would decompose the comma-separated string into the slice.",
        "name": "flag.FlagSet.Var",
        "params": [],
        "path": "go/flag/index#FlagSet.Var",
        "syntax": "func (f *FlagSet) Var(value Value, name string, usage string)",
        "type": "flag"
    },
    "FlagSet.Visit": {
        "descr": "Visit visits the flags in lexicographical order, calling fn for each. It visits only those flags that have been set.",
        "name": "flag.FlagSet.Visit",
        "params": [],
        "path": "go/flag/index#FlagSet.Visit",
        "syntax": "func (f *FlagSet) Visit(fn func(*Flag))",
        "type": "flag"
    },
    "FlagSet.VisitAll": {
        "descr": "VisitAll visits the flags in lexicographical order, calling fn for each. It visits all flags, even those not set.",
        "name": "flag.FlagSet.VisitAll",
        "params": [],
        "path": "go/flag/index#FlagSet.VisitAll",
        "syntax": "func (f *FlagSet) VisitAll(fn func(*Flag))",
        "type": "flag"
    },
    "Flags": {
        "descr": "",
        "name": "net.Flags",
        "params": [],
        "path": "go/net/index#Flags",
        "syntax": "type Flags uint",
        "type": "net"
    },
    "Flags.String": {
        "descr": "",
        "name": "net.Flags.String",
        "params": [],
        "path": "go/net/index#Flags.String",
        "syntax": "func (f Flags) String() string",
        "type": "net"
    },
    "Float": {
        "descr": "Float is a 64-bit float variable that satisfies the Var interface.",
        "name": "expvar.Float",
        "params": [],
        "path": "go/expvar/index#Float",
        "syntax": "type Float struct { // contains filtered or unexported fields }",
        "type": "expvar"
    },
    "Float.Add": {
        "descr": "Add adds delta to v.",
        "name": "expvar.Float.Add",
        "params": [],
        "path": "go/expvar/index#Float.Add",
        "syntax": "func (v *Float) Add(delta float64)",
        "type": "expvar"
    },
    "Float.Set": {
        "descr": "Set sets v to value.",
        "name": "expvar.Float.Set",
        "params": [],
        "path": "go/expvar/index#Float.Set",
        "syntax": "func (v *Float) Set(value float64)",
        "type": "expvar"
    },
    "Float.String": {
        "descr": "",
        "name": "expvar.Float.String",
        "params": [],
        "path": "go/expvar/index#Float.String",
        "syntax": "func (v *Float) String() string",
        "type": "expvar"
    },
    "Float.Value": {
        "descr": "",
        "name": "expvar.Float.Value",
        "params": [],
        "path": "go/expvar/index#Float.Value",
        "syntax": "func (v *Float) Value() float64",
        "type": "expvar"
    },
    "Float32bits": {
        "descr": "Float32bits returns the IEEE 754 binary representation of f.",
        "name": "math.Float32bits",
        "params": [],
        "path": "go/math/index#Float32bits",
        "syntax": "func Float32bits(f float32) uint32",
        "type": "math"
    },
    "Float32frombits": {
        "descr": "Float32frombits returns the floating point number corresponding to the IEEE 754 binary representation b.",
        "name": "math.Float32frombits",
        "params": [],
        "path": "go/math/index#Float32frombits",
        "syntax": "func Float32frombits(b uint32) float32",
        "type": "math"
    },
    "Float64": {
        "descr": "Float64 defines a float64 flag with specified name, default value, and usage string. The return value is the address of a float64 variable that stores the value of the flag.",
        "name": "flag.Float64",
        "params": [],
        "path": "go/flag/index#Float64",
        "syntax": "func Float64(name string, value float64, usage string) *float64",
        "type": "flag"
    },
    "Float64Slice": {
        "descr": "Float64Slice attaches the methods of Interface to []float64, sorting in increasing order (not-a-number values are treated as less than other values).",
        "name": "sort.Float64Slice",
        "params": [],
        "path": "go/sort/index#Float64Slice",
        "syntax": "type Float64Slice []float64",
        "type": "sort"
    },
    "Float64Slice.Len": {
        "descr": "",
        "name": "sort.Float64Slice.Len",
        "params": [],
        "path": "go/sort/index#Float64Slice.Len",
        "syntax": "func (p Float64Slice) Len() int",
        "type": "sort"
    },
    "Float64Slice.Less": {
        "descr": "",
        "name": "sort.Float64Slice.Less",
        "params": [],
        "path": "go/sort/index#Float64Slice.Less",
        "syntax": "func (p Float64Slice) Less(i, j int) bool",
        "type": "sort"
    },
    "Float64Slice.Search": {
        "descr": "Search returns the result of applying SearchFloat64s to the receiver and x.",
        "name": "sort.Float64Slice.Search",
        "params": [],
        "path": "go/sort/index#Float64Slice.Search",
        "syntax": "func (p Float64Slice) Search(x float64) int",
        "type": "sort"
    },
    "Float64Slice.Sort": {
        "descr": "Sort is a convenience method.",
        "name": "sort.Float64Slice.Sort",
        "params": [],
        "path": "go/sort/index#Float64Slice.Sort",
        "syntax": "func (p Float64Slice) Sort()",
        "type": "sort"
    },
    "Float64Slice.Swap": {
        "descr": "",
        "name": "sort.Float64Slice.Swap",
        "params": [],
        "path": "go/sort/index#Float64Slice.Swap",
        "syntax": "func (p Float64Slice) Swap(i, j int)",
        "type": "sort"
    },
    "Float64Var": {
        "descr": "Float64Var defines a float64 flag with specified name, default value, and usage string. The argument p points to a float64 variable in which to store the value of the flag.",
        "name": "flag.Float64Var",
        "params": [],
        "path": "go/flag/index#Float64Var",
        "syntax": "func Float64Var(p *float64, name string, value float64, usage string)",
        "type": "flag"
    },
    "Float64bits": {
        "descr": "Float64bits returns the IEEE 754 binary representation of f.",
        "name": "math.Float64bits",
        "params": [],
        "path": "go/math/index#Float64bits",
        "syntax": "func Float64bits(f float64) uint64",
        "type": "math"
    },
    "Float64frombits": {
        "descr": "Float64frombits returns the floating point number corresponding the IEEE 754 binary representation b.",
        "name": "math.Float64frombits",
        "params": [],
        "path": "go/math/index#Float64frombits",
        "syntax": "func Float64frombits(b uint64) float64",
        "type": "math"
    },
    "Float64s": {
        "descr": "Float64s sorts a slice of float64s in increasing order (not-a-number values are treated as less than other values).",
        "name": "sort.Float64s",
        "params": [],
        "path": "go/sort/index#Float64s",
        "syntax": "func Float64s(a []float64)",
        "type": "sort"
    },
    "Float64sAreSorted": {
        "descr": "Float64sAreSorted tests whether a slice of float64s is sorted in increasing order (not-a-number values are treated as less than other values).",
        "name": "sort.Float64sAreSorted",
        "params": [],
        "path": "go/sort/index#Float64sAreSorted",
        "syntax": "func Float64sAreSorted(a []float64) bool",
        "type": "sort"
    },
    "FloatType": {
        "descr": "FloatType is here for the purposes of documentation only. It is a stand-in for either float type: float32 or float64.",
        "name": "builtin.FloatType",
        "params": [],
        "path": "go/builtin/index#FloatType",
        "syntax": "type FloatType float32",
        "type": "builtin"
    },
    "Flock": {
        "descr": "",
        "name": "syscall.Flock",
        "params": [],
        "path": "go/syscall/index#Flock",
        "syntax": "func Flock(fd int, how int) (err error)",
        "type": "syscall"
    },
    "Flock_t": {
        "descr": "",
        "name": "syscall.Flock_t",
        "params": [],
        "path": "go/syscall/index#Flock_t",
        "syntax": "type Flock_t struct { Type int16 Whence int16 Pad_cgo_0 [4]byte Start int64 Len int64 Pid int32 Pad_cgo_1 [4]byte }",
        "type": "syscall"
    },
    "Floor": {
        "descr": "Floor returns the greatest integer value less than or equal to x.",
        "name": "math.Floor",
        "params": [],
        "path": "go/math/index#Floor",
        "syntax": "func Floor(x float64) float64",
        "type": "math"
    },
    "ForkExec": {
        "descr": "Combination of fork and exec, careful to be thread safe.",
        "name": "syscall.ForkExec",
        "params": [],
        "path": "go/syscall/index#ForkExec",
        "syntax": "func ForkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err error)",
        "type": "syscall"
    },
    "FormatBool": {
        "descr": "FormatBool returns \"true\" or \"false\" according to the value of b.",
        "name": "strconv.FormatBool",
        "params": [],
        "path": "go/strconv/index#FormatBool",
        "syntax": "func FormatBool(b bool) string",
        "type": "strconv"
    },
    "FormatFloat": {
        "descr": "FormatFloat converts the floating-point number f to a string, according to the format fmt and precision prec. It rounds the result assuming that the original was obtained from a floating-point value of bitSize bits (32 for float32, 64 for float64).",
        "name": "strconv.FormatFloat",
        "params": [],
        "path": "go/strconv/index#FormatFloat",
        "syntax": "func FormatFloat(f float64, fmt byte, prec, bitSize int) string",
        "type": "strconv"
    },
    "FormatInt": {
        "descr": "FormatInt returns the string representation of i in the given base, for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z' for digit values >= 10.",
        "name": "strconv.FormatInt",
        "params": [],
        "path": "go/strconv/index#FormatInt",
        "syntax": "func FormatInt(i int64, base int) string",
        "type": "strconv"
    },
    "FormatMediaType": {
        "descr": "FormatMediaType serializes mediatype t and the parameters param as a media type conforming to RFC 2045 and RFC 2616. The type and parameter names are written in lower-case. When any of the arguments result in a standard violation then FormatMediaType returns the empty string.",
        "name": "mime.FormatMediaType",
        "params": [],
        "path": "go/mime/index#FormatMediaType",
        "syntax": "func FormatMediaType(t string, param map[string]string) string",
        "type": "mime"
    },
    "FormatUint": {
        "descr": "FormatUint returns the string representation of i in the given base, for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z' for digit values >= 10.",
        "name": "strconv.FormatUint",
        "params": [],
        "path": "go/strconv/index#FormatUint",
        "syntax": "func FormatUint(i uint64, base int) string",
        "type": "strconv"
    },
    "Formatter": {
        "descr": "Formatter is the interface implemented by values with a custom formatter. The implementation of Format may call Sprint(f) or Fprint(f) etc. to generate its output.",
        "name": "fmt.Formatter",
        "params": [],
        "path": "go/fmt/index#Formatter",
        "syntax": "type Formatter interface { Format(f State, c rune) }",
        "type": "fmt"
    },
    "Fprint": {
        "descr": "Fprint formats using the default formats for its operands and writes to w. Spaces are added between operands when neither is a string. It returns the number of bytes written and any write error encountered.",
        "name": "fmt.Fprint",
        "params": [],
        "path": "go/fmt/index#Fprint",
        "syntax": "func Fprint(w io.Writer, a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "Fprintf": {
        "descr": "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered.",
        "name": "fmt.Fprintf",
        "params": [],
        "path": "go/fmt/index#Fprintf",
        "syntax": "func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "Fprintln": {
        "descr": "Fprintln formats using the default formats for its operands and writes to w. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered.",
        "name": "fmt.Fprintln",
        "params": [],
        "path": "go/fmt/index#Fprintln",
        "syntax": "func Fprintln(w io.Writer, a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "Frame": {
        "descr": "Frame is the information returned by Frames for each call frame.",
        "name": "runtime.Frame",
        "params": [],
        "path": "go/runtime/index#Frame",
        "syntax": "type Frame struct { // PC is the program counter for the location in this frame. // For a frame that calls another frame, this will be the // program counter of a call instruction. Because of inlining, // multiple frames may have the same PC value, but different // symbolic information. PC uintptr // Func is the Func value of this call frame. This may be nil // for non-Go code or fully inlined functions. Func *Func // Function is the package path-qualified function name of // this call frame. If non-empty, this string uniquely // identifies a single function in the program. // This may be the empty string if not known. // If Func is not nil then Function == Func.Name(). Function string // File and Line are the file name and line number of the // location in this frame. For non-leaf frames, this will be // the location of a call. These may be the empty string and // zero, respectively, if not known. File string Line int // Entry point program counter for the function; may be zero // if not known. If Func is not nil then Entry == // Func.Entry(). Entry uintptr }",
        "type": "runtime"
    },
    "Frames": {
        "descr": "Frames may be used to get function/file/line information for a slice of PC values returned by Callers.",
        "name": "runtime.Frames",
        "params": [],
        "path": "go/runtime/index#Frames",
        "syntax": "type Frames struct { // contains filtered or unexported fields }",
        "type": "runtime"
    },
    "Frames.Next": {
        "descr": "Next returns frame information for the next caller. If more is false, there are no more callers (the Frame value is valid).",
        "name": "runtime.Frames.Next",
        "params": [],
        "path": "go/runtime/index#Frames.Next",
        "syntax": "func (ci *Frames) Next() (frame Frame, more bool)",
        "type": "runtime"
    },
    "Frexp": {
        "descr": "Frexp breaks f into a normalized fraction and an integral power of two. It returns frac and exp satisfying f == frac  2**exp, with the absolute value of frac in the interval [, 1).",
        "name": "math.Frexp",
        "params": [],
        "path": "go/math/index#Frexp",
        "syntax": "func Frexp(f float64) (frac float64, exp int)",
        "type": "math"
    },
    "Fscan": {
        "descr": "Fscan scans text read from r, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why.",
        "name": "fmt.Fscan",
        "params": [],
        "path": "go/fmt/index#Fscan",
        "syntax": "func Fscan(r io.Reader, a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "Fscanf": {
        "descr": "Fscanf scans text read from r, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully parsed. Newlines in the input must match newlines in the format.",
        "name": "fmt.Fscanf",
        "params": [],
        "path": "go/fmt/index#Fscanf",
        "syntax": "func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "Fscanln": {
        "descr": "Fscanln is similar to Fscan, but stops scanning at a newline and after the final item there must be a newline or EOF.",
        "name": "fmt.Fscanln",
        "params": [],
        "path": "go/fmt/index#Fscanln",
        "syntax": "func Fscanln(r io.Reader, a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "Fsid": {
        "descr": "",
        "name": "syscall.Fsid",
        "params": [],
        "path": "go/syscall/index#Fsid",
        "syntax": "type Fsid struct { X__val [2]int32 }",
        "type": "syscall"
    },
    "Fstat": {
        "descr": "",
        "name": "syscall.Fstat",
        "params": [],
        "path": "go/syscall/index#Fstat",
        "syntax": "func Fstat(fd int, stat *Stat_t) (err error)",
        "type": "syscall"
    },
    "Fstatfs": {
        "descr": "",
        "name": "syscall.Fstatfs",
        "params": [],
        "path": "go/syscall/index#Fstatfs",
        "syntax": "func Fstatfs(fd int, buf *Statfs_t) (err error)",
        "type": "syscall"
    },
    "Fsync": {
        "descr": "",
        "name": "syscall.Fsync",
        "params": [],
        "path": "go/syscall/index#Fsync",
        "syntax": "func Fsync(fd int) (err error)",
        "type": "syscall"
    },
    "Ftruncate": {
        "descr": "",
        "name": "syscall.Ftruncate",
        "params": [],
        "path": "go/syscall/index#Ftruncate",
        "syntax": "func Ftruncate(fd int, length int64) (err error)",
        "type": "syscall"
    },
    "Func": {
        "descr": "A Func represents a Go function in the running binary.",
        "name": "runtime.Func",
        "params": [],
        "path": "go/runtime/index#Func",
        "syntax": "type Func struct { // contains filtered or unexported fields }",
        "type": "runtime"
    },
    "Func.Entry": {
        "descr": "Entry returns the entry address of the function.",
        "name": "runtime.Func.Entry",
        "params": [],
        "path": "go/runtime/index#Func.Entry",
        "syntax": "func (f *Func) Entry() uintptr",
        "type": "runtime"
    },
    "Func.FileLine": {
        "descr": "FileLine returns the file name and line number of the source code corresponding to the program counter pc. The result will not be accurate if pc is not a program counter within f.",
        "name": "runtime.Func.FileLine",
        "params": [],
        "path": "go/runtime/index#Func.FileLine",
        "syntax": "func (f *Func) FileLine(pc uintptr) (file string, line int)",
        "type": "runtime"
    },
    "Func.Name": {
        "descr": "Name returns the name of the function.",
        "name": "runtime.Func.Name",
        "params": [],
        "path": "go/runtime/index#Func.Name",
        "syntax": "func (f *Func) Name() string",
        "type": "runtime"
    },
    "Func.String": {
        "descr": "",
        "name": "expvar.Func.String",
        "params": [],
        "path": "go/expvar/index#Func.String",
        "syntax": "func (f Func) String() string",
        "type": "expvar"
    },
    "Func.Value": {
        "descr": "",
        "name": "expvar.Func.Value",
        "params": [],
        "path": "go/expvar/index#Func.Value",
        "syntax": "func (f Func) Value() interface{}",
        "type": "expvar"
    },
    "FuncForPC": {
        "descr": "FuncForPC returns a *Func describing the function that contains the given program counter address, or else nil.",
        "name": "runtime.FuncForPC",
        "params": [],
        "path": "go/runtime/index#FuncForPC",
        "syntax": "func FuncForPC(pc uintptr) *Func",
        "type": "runtime"
    },
    "FuncOf": {
        "descr": "FuncOf returns the function type with the given argument and result types. For example if k represents int and e represents string, FuncOf([]Type{k}, []Type{e}, false) represents func(int) string.",
        "name": "reflect.FuncOf",
        "params": [],
        "path": "go/reflect/index#FuncOf",
        "syntax": "func FuncOf(in, out []Type, variadic bool) Type",
        "type": "reflect"
    },
    "Futimes": {
        "descr": "",
        "name": "syscall.Futimes",
        "params": [],
        "path": "go/syscall/index#Futimes",
        "syntax": "func Futimes(fd int, tv []Timeval) (err error)",
        "type": "syscall"
    },
    "Futimesat": {
        "descr": "",
        "name": "syscall.Futimesat",
        "params": [],
        "path": "go/syscall/index#Futimesat",
        "syntax": "func Futimesat(dirfd int, path string, tv []Timeval) (err error)",
        "type": "syscall"
    },
    "GC": {
        "descr": "GC runs a garbage collection and blocks the caller until the garbage collection is complete. It may also block the entire program.",
        "name": "runtime.GC",
        "params": [],
        "path": "go/runtime/index#GC",
        "syntax": "func GC()",
        "type": "runtime"
    },
    "GOMAXPROCS": {
        "descr": "GOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously and returns the previous setting. If n < 1, it does not change the current setting. The number of logical CPUs on the local machine can be queried with NumCPU. This call will go away when the scheduler improves.",
        "name": "runtime.GOMAXPROCS",
        "params": [],
        "path": "go/runtime/index#GOMAXPROCS",
        "syntax": "func GOMAXPROCS(n int) int",
        "type": "runtime"
    },
    "GOROOT": {
        "descr": "GOROOT returns the root of the Go tree. It uses the GOROOT environment variable, if set at process start, or else the root used during the Go build.",
        "name": "runtime.GOROOT",
        "params": [],
        "path": "go/runtime/index#GOROOT",
        "syntax": "func GOROOT() string",
        "type": "runtime"
    },
    "Gamma": {
        "descr": "Gamma returns the Gamma function of x.",
        "name": "math.Gamma",
        "params": [],
        "path": "go/math/index#Gamma",
        "syntax": "func Gamma(x float64) float64",
        "type": "math"
    },
    "Get": {
        "descr": "Get retrieves a named exported variable. It returns nil if the name has not been registered.",
        "name": "expvar.Get",
        "params": [],
        "path": "go/expvar/index#Get",
        "syntax": "func Get(name string) Var",
        "type": "expvar"
    },
    "Getcwd": {
        "descr": "",
        "name": "syscall.Getcwd",
        "params": [],
        "path": "go/syscall/index#Getcwd",
        "syntax": "func Getcwd(buf []byte) (n int, err error)",
        "type": "syscall"
    },
    "Getdents": {
        "descr": "",
        "name": "syscall.Getdents",
        "params": [],
        "path": "go/syscall/index#Getdents",
        "syntax": "func Getdents(fd int, buf []byte) (n int, err error)",
        "type": "syscall"
    },
    "Getegid": {
        "descr": "",
        "name": "syscall.Getegid",
        "params": [],
        "path": "go/syscall/index#Getegid",
        "syntax": "func Getegid() (egid int)",
        "type": "syscall"
    },
    "Getenv": {
        "descr": "",
        "name": "syscall.Getenv",
        "params": [],
        "path": "go/syscall/index#Getenv",
        "syntax": "func Getenv(key string) (value string, found bool)",
        "type": "syscall"
    },
    "Geteuid": {
        "descr": "",
        "name": "syscall.Geteuid",
        "params": [],
        "path": "go/syscall/index#Geteuid",
        "syntax": "func Geteuid() (euid int)",
        "type": "syscall"
    },
    "Getgid": {
        "descr": "",
        "name": "syscall.Getgid",
        "params": [],
        "path": "go/syscall/index#Getgid",
        "syntax": "func Getgid() (gid int)",
        "type": "syscall"
    },
    "Getgroups": {
        "descr": "",
        "name": "syscall.Getgroups",
        "params": [],
        "path": "go/syscall/index#Getgroups",
        "syntax": "func Getgroups() (gids []int, err error)",
        "type": "syscall"
    },
    "Getpagesize": {
        "descr": "",
        "name": "syscall.Getpagesize",
        "params": [],
        "path": "go/syscall/index#Getpagesize",
        "syntax": "func Getpagesize() int",
        "type": "syscall"
    },
    "Getpeername": {
        "descr": "",
        "name": "syscall.Getpeername",
        "params": [],
        "path": "go/syscall/index#Getpeername",
        "syntax": "func Getpeername(fd int) (sa Sockaddr, err error)",
        "type": "syscall"
    },
    "Getpgid": {
        "descr": "",
        "name": "syscall.Getpgid",
        "params": [],
        "path": "go/syscall/index#Getpgid",
        "syntax": "func Getpgid(pid int) (pgid int, err error)",
        "type": "syscall"
    },
    "Getpgrp": {
        "descr": "",
        "name": "syscall.Getpgrp",
        "params": [],
        "path": "go/syscall/index#Getpgrp",
        "syntax": "func Getpgrp() (pid int)",
        "type": "syscall"
    },
    "Getpid": {
        "descr": "",
        "name": "syscall.Getpid",
        "params": [],
        "path": "go/syscall/index#Getpid",
        "syntax": "func Getpid() (pid int)",
        "type": "syscall"
    },
    "Getppid": {
        "descr": "",
        "name": "syscall.Getppid",
        "params": [],
        "path": "go/syscall/index#Getppid",
        "syntax": "func Getppid() (ppid int)",
        "type": "syscall"
    },
    "Getpriority": {
        "descr": "",
        "name": "syscall.Getpriority",
        "params": [],
        "path": "go/syscall/index#Getpriority",
        "syntax": "func Getpriority(which int, who int) (prio int, err error)",
        "type": "syscall"
    },
    "Getrlimit": {
        "descr": "",
        "name": "syscall.Getrlimit",
        "params": [],
        "path": "go/syscall/index#Getrlimit",
        "syntax": "func Getrlimit(resource int, rlim *Rlimit) (err error)",
        "type": "syscall"
    },
    "Getrusage": {
        "descr": "",
        "name": "syscall.Getrusage",
        "params": [],
        "path": "go/syscall/index#Getrusage",
        "syntax": "func Getrusage(who int, rusage *Rusage) (err error)",
        "type": "syscall"
    },
    "Getsockname": {
        "descr": "",
        "name": "syscall.Getsockname",
        "params": [],
        "path": "go/syscall/index#Getsockname",
        "syntax": "func Getsockname(fd int) (sa Sockaddr, err error)",
        "type": "syscall"
    },
    "GetsockoptICMPv6Filter": {
        "descr": "",
        "name": "syscall.GetsockoptICMPv6Filter",
        "params": [],
        "path": "go/syscall/index#GetsockoptICMPv6Filter",
        "syntax": "func GetsockoptICMPv6Filter(fd, level, opt int) (*ICMPv6Filter, error)",
        "type": "syscall"
    },
    "GetsockoptIPMreq": {
        "descr": "",
        "name": "syscall.GetsockoptIPMreq",
        "params": [],
        "path": "go/syscall/index#GetsockoptIPMreq",
        "syntax": "func GetsockoptIPMreq(fd, level, opt int) (*IPMreq, error)",
        "type": "syscall"
    },
    "GetsockoptIPMreqn": {
        "descr": "",
        "name": "syscall.GetsockoptIPMreqn",
        "params": [],
        "path": "go/syscall/index#GetsockoptIPMreqn",
        "syntax": "func GetsockoptIPMreqn(fd, level, opt int) (*IPMreqn, error)",
        "type": "syscall"
    },
    "GetsockoptIPv6MTUInfo": {
        "descr": "",
        "name": "syscall.GetsockoptIPv6MTUInfo",
        "params": [],
        "path": "go/syscall/index#GetsockoptIPv6MTUInfo",
        "syntax": "func GetsockoptIPv6MTUInfo(fd, level, opt int) (*IPv6MTUInfo, error)",
        "type": "syscall"
    },
    "GetsockoptIPv6Mreq": {
        "descr": "",
        "name": "syscall.GetsockoptIPv6Mreq",
        "params": [],
        "path": "go/syscall/index#GetsockoptIPv6Mreq",
        "syntax": "func GetsockoptIPv6Mreq(fd, level, opt int) (*IPv6Mreq, error)",
        "type": "syscall"
    },
    "GetsockoptInet4Addr": {
        "descr": "",
        "name": "syscall.GetsockoptInet4Addr",
        "params": [],
        "path": "go/syscall/index#GetsockoptInet4Addr",
        "syntax": "func GetsockoptInet4Addr(fd, level, opt int) (value [4]byte, err error)",
        "type": "syscall"
    },
    "GetsockoptInt": {
        "descr": "",
        "name": "syscall.GetsockoptInt",
        "params": [],
        "path": "go/syscall/index#GetsockoptInt",
        "syntax": "func GetsockoptInt(fd, level, opt int) (value int, err error)",
        "type": "syscall"
    },
    "GetsockoptUcred": {
        "descr": "",
        "name": "syscall.GetsockoptUcred",
        "params": [],
        "path": "go/syscall/index#GetsockoptUcred",
        "syntax": "func GetsockoptUcred(fd, level, opt int) (*Ucred, error)",
        "type": "syscall"
    },
    "Getter": {
        "descr": "Getter is an interface that allows the contents of a Value to be retrieved. It wraps the Value interface, rather than being part of it, because it appeared after Go 1 and its compatibility rules. All Value types provided by this package satisfy the Getter interface.",
        "name": "flag.Getter",
        "params": [],
        "path": "go/flag/index#Getter",
        "syntax": "type Getter interface { Value Get() interface{} }",
        "type": "flag"
    },
    "Gettid": {
        "descr": "",
        "name": "syscall.Gettid",
        "params": [],
        "path": "go/syscall/index#Gettid",
        "syntax": "func Gettid() (tid int)",
        "type": "syscall"
    },
    "Gettimeofday": {
        "descr": "",
        "name": "syscall.Gettimeofday",
        "params": [],
        "path": "go/syscall/index#Gettimeofday",
        "syntax": "func Gettimeofday(tv *Timeval) (err error)",
        "type": "syscall"
    },
    "Getuid": {
        "descr": "",
        "name": "syscall.Getuid",
        "params": [],
        "path": "go/syscall/index#Getuid",
        "syntax": "func Getuid() (uid int)",
        "type": "syscall"
    },
    "Getwd": {
        "descr": "",
        "name": "syscall.Getwd",
        "params": [],
        "path": "go/syscall/index#Getwd",
        "syntax": "func Getwd() (wd string, err error)",
        "type": "syscall"
    },
    "Getxattr": {
        "descr": "",
        "name": "syscall.Getxattr",
        "params": [],
        "path": "go/syscall/index#Getxattr",
        "syntax": "func Getxattr(path string, attr string, dest []byte) (sz int, err error)",
        "type": "syscall"
    },
    "GoStringer": {
        "descr": "GoStringer is implemented by any value that has a GoString method, which defines the Go syntax for that value. The GoString method is used to print values passed as an operand to a %#v format.",
        "name": "fmt.GoStringer",
        "params": [],
        "path": "go/fmt/index#GoStringer",
        "syntax": "type GoStringer interface { GoString() string }",
        "type": "fmt"
    },
    "Goexit": {
        "descr": "Goexit terminates the goroutine that calls it. No other goroutine is affected. Goexit runs all deferred calls before terminating the goroutine. Because Goexit is not a panic, any recover calls in those deferred functions will return nil.",
        "name": "runtime.Goexit",
        "params": [],
        "path": "go/runtime/index#Goexit",
        "syntax": "func Goexit()",
        "type": "runtime"
    },
    "GoroutineProfile": {
        "descr": "GoroutineProfile returns n, the number of records in the active goroutine stack profile. If len(p) >= n, GoroutineProfile copies the profile into p and returns n, true. If len(p) < n, GoroutineProfile does not change p and returns n, false.",
        "name": "runtime.GoroutineProfile",
        "params": [],
        "path": "go/runtime/index#GoroutineProfile",
        "syntax": "func GoroutineProfile(p []StackRecord) (n int, ok bool)",
        "type": "runtime"
    },
    "Gosched": {
        "descr": "Gosched yields the processor, allowing other goroutines to run. It does not suspend the current goroutine, so execution resumes automatically.",
        "name": "runtime.Gosched",
        "params": [],
        "path": "go/runtime/index#Gosched",
        "syntax": "func Gosched()",
        "type": "runtime"
    },
    "Gray": {
        "descr": "Gray is an in-memory image whose At method returns color.Gray values.",
        "name": "image.Gray",
        "params": [],
        "path": "go/image/index#Gray",
        "syntax": "type Gray struct { // Pix holds the image's pixels, as gray values. The pixel at // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1]. Pix []uint8 // Stride is the Pix stride (in bytes) between vertically adjacent pixels. Stride int // Rect is the image's bounds. Rect Rectangle }",
        "type": "image"
    },
    "Gray.At": {
        "descr": "",
        "name": "image.Gray.At",
        "params": [],
        "path": "go/image/index#Gray.At",
        "syntax": "func (p *Gray) At(x, y int) color.Color",
        "type": "image"
    },
    "Gray.Bounds": {
        "descr": "",
        "name": "image.Gray.Bounds",
        "params": [],
        "path": "go/image/index#Gray.Bounds",
        "syntax": "func (p *Gray) Bounds() Rectangle",
        "type": "image"
    },
    "Gray.ColorModel": {
        "descr": "",
        "name": "image.Gray.ColorModel",
        "params": [],
        "path": "go/image/index#Gray.ColorModel",
        "syntax": "func (p *Gray) ColorModel() color.Model",
        "type": "image"
    },
    "Gray.GrayAt": {
        "descr": "",
        "name": "image.Gray.GrayAt",
        "params": [],
        "path": "go/image/index#Gray.GrayAt",
        "syntax": "func (p *Gray) GrayAt(x, y int) color.Gray",
        "type": "image"
    },
    "Gray.Opaque": {
        "descr": "Opaque scans the entire image and reports whether it is fully opaque.",
        "name": "image.Gray.Opaque",
        "params": [],
        "path": "go/image/index#Gray.Opaque",
        "syntax": "func (p *Gray) Opaque() bool",
        "type": "image"
    },
    "Gray.PixOffset": {
        "descr": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y).",
        "name": "image.Gray.PixOffset",
        "params": [],
        "path": "go/image/index#Gray.PixOffset",
        "syntax": "func (p *Gray) PixOffset(x, y int) int",
        "type": "image"
    },
    "Gray.Set": {
        "descr": "",
        "name": "image.Gray.Set",
        "params": [],
        "path": "go/image/index#Gray.Set",
        "syntax": "func (p *Gray) Set(x, y int, c color.Color)",
        "type": "image"
    },
    "Gray.SetGray": {
        "descr": "",
        "name": "image.Gray.SetGray",
        "params": [],
        "path": "go/image/index#Gray.SetGray",
        "syntax": "func (p *Gray) SetGray(x, y int, c color.Gray)",
        "type": "image"
    },
    "Gray.SubImage": {
        "descr": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.",
        "name": "image.Gray.SubImage",
        "params": [],
        "path": "go/image/index#Gray.SubImage",
        "syntax": "func (p *Gray) SubImage(r Rectangle) Image",
        "type": "image"
    },
    "Gray16": {
        "descr": "Gray16 is an in-memory image whose At method returns color.Gray16 values.",
        "name": "image.Gray16",
        "params": [],
        "path": "go/image/index#Gray16",
        "syntax": "type Gray16 struct { // Pix holds the image's pixels, as gray values in big-endian format. The pixel at // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*2]. Pix []uint8 // Stride is the Pix stride (in bytes) between vertically adjacent pixels. Stride int // Rect is the image's bounds. Rect Rectangle }",
        "type": "image"
    },
    "Gray16.At": {
        "descr": "",
        "name": "image.Gray16.At",
        "params": [],
        "path": "go/image/index#Gray16.At",
        "syntax": "func (p *Gray16) At(x, y int) color.Color",
        "type": "image"
    },
    "Gray16.Bounds": {
        "descr": "",
        "name": "image.Gray16.Bounds",
        "params": [],
        "path": "go/image/index#Gray16.Bounds",
        "syntax": "func (p *Gray16) Bounds() Rectangle",
        "type": "image"
    },
    "Gray16.ColorModel": {
        "descr": "",
        "name": "image.Gray16.ColorModel",
        "params": [],
        "path": "go/image/index#Gray16.ColorModel",
        "syntax": "func (p *Gray16) ColorModel() color.Model",
        "type": "image"
    },
    "Gray16.Gray16At": {
        "descr": "",
        "name": "image.Gray16.Gray16At",
        "params": [],
        "path": "go/image/index#Gray16.Gray16At",
        "syntax": "func (p *Gray16) Gray16At(x, y int) color.Gray16",
        "type": "image"
    },
    "Gray16.Opaque": {
        "descr": "Opaque scans the entire image and reports whether it is fully opaque.",
        "name": "image.Gray16.Opaque",
        "params": [],
        "path": "go/image/index#Gray16.Opaque",
        "syntax": "func (p *Gray16) Opaque() bool",
        "type": "image"
    },
    "Gray16.PixOffset": {
        "descr": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y).",
        "name": "image.Gray16.PixOffset",
        "params": [],
        "path": "go/image/index#Gray16.PixOffset",
        "syntax": "func (p *Gray16) PixOffset(x, y int) int",
        "type": "image"
    },
    "Gray16.Set": {
        "descr": "",
        "name": "image.Gray16.Set",
        "params": [],
        "path": "go/image/index#Gray16.Set",
        "syntax": "func (p *Gray16) Set(x, y int, c color.Color)",
        "type": "image"
    },
    "Gray16.SetGray16": {
        "descr": "",
        "name": "image.Gray16.SetGray16",
        "params": [],
        "path": "go/image/index#Gray16.SetGray16",
        "syntax": "func (p *Gray16) SetGray16(x, y int, c color.Gray16)",
        "type": "image"
    },
    "Gray16.SubImage": {
        "descr": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.",
        "name": "image.Gray16.SubImage",
        "params": [],
        "path": "go/image/index#Gray16.SubImage",
        "syntax": "func (p *Gray16) SubImage(r Rectangle) Image",
        "type": "image"
    },
    "Handler": {
        "descr": "Handler returns the expvar HTTP Handler.",
        "name": "expvar.Handler",
        "params": [],
        "path": "go/expvar/index#Handler",
        "syntax": "func Handler() http.Handler",
        "type": "expvar"
    },
    "HardwareAddr": {
        "descr": "A HardwareAddr represents a physical hardware address.",
        "name": "net.HardwareAddr",
        "params": [],
        "path": "go/net/index#HardwareAddr",
        "syntax": "type HardwareAddr []byte",
        "type": "net"
    },
    "HardwareAddr.String": {
        "descr": "",
        "name": "net.HardwareAddr.String",
        "params": [],
        "path": "go/net/index#HardwareAddr.String",
        "syntax": "func (a HardwareAddr) String() string",
        "type": "net"
    },
    "HasPrefix": {
        "descr": "HasPrefix tests whether the string s begins with prefix.",
        "name": "strings.HasPrefix",
        "params": [],
        "path": "go/strings/index#HasPrefix",
        "syntax": "func HasPrefix(s, prefix string) bool",
        "type": "strings"
    },
    "HasSuffix": {
        "descr": "HasSuffix tests whether the string s ends with suffix.",
        "name": "strings.HasSuffix",
        "params": [],
        "path": "go/strings/index#HasSuffix",
        "syntax": "func HasSuffix(s, suffix string) bool",
        "type": "strings"
    },
    "Hash": {
        "descr": "Hash is the common interface implemented by all hash functions.",
        "name": "hash.Hash",
        "params": [],
        "path": "go/hash/index#Hash",
        "syntax": "type Hash interface { // Write (via the embedded io.Writer interface) adds more data to the running hash. // It never returns an error. io.Writer // Sum appends the current hash to b and returns the resulting slice. // It does not change the underlying hash state. Sum(b []byte) []byte // Reset resets the Hash to its initial state. Reset() // Size returns the number of bytes Sum will return. Size() int // BlockSize returns the hash's underlying block size. // The Write method must be able to accept any amount // of data, but it may operate more efficiently if all writes // are a multiple of the block size. BlockSize() int }",
        "type": "hash"
    },
    "Hash.Available": {
        "descr": "Available reports whether the given hash function is linked into the binary.",
        "name": "crypto.Hash.Available",
        "params": [],
        "path": "go/crypto/index#Hash.Available",
        "syntax": "func (h Hash) Available() bool",
        "type": "crypto"
    },
    "Hash.HashFunc": {
        "descr": "HashFunc simply returns the value of h so that Hash implements SignerOpts.",
        "name": "crypto.Hash.HashFunc",
        "params": [],
        "path": "go/crypto/index#Hash.HashFunc",
        "syntax": "func (h Hash) HashFunc() Hash",
        "type": "crypto"
    },
    "Hash.New": {
        "descr": "New returns a new hash.Hash calculating the given hash function. New panics if the hash function is not linked into the binary.",
        "name": "crypto.Hash.New",
        "params": [],
        "path": "go/crypto/index#Hash.New",
        "syntax": "func (h Hash) New() hash.Hash",
        "type": "crypto"
    },
    "Hash.Size": {
        "descr": "Size returns the length, in bytes, of a digest resulting from the given hash function. It doesn't require that the hash function in question be linked into the program.",
        "name": "crypto.Hash.Size",
        "params": [],
        "path": "go/crypto/index#Hash.Size",
        "syntax": "func (h Hash) Size() int",
        "type": "crypto"
    },
    "Hash32": {
        "descr": "Hash32 is the common interface implemented by all 32-bit hash functions.",
        "name": "hash.Hash32",
        "params": [],
        "path": "go/hash/index#Hash32",
        "syntax": "type Hash32 interface { Hash Sum32() uint32 }",
        "type": "hash"
    },
    "Hash64": {
        "descr": "Hash64 is the common interface implemented by all 64-bit hash functions.",
        "name": "hash.Hash64",
        "params": [],
        "path": "go/hash/index#Hash64",
        "syntax": "type Hash64 interface { Hash Sum64() uint64 }",
        "type": "hash"
    },
    "Hostname": {
        "descr": "Hostname returns the host name reported by the kernel.",
        "name": "os.Hostname",
        "params": [],
        "path": "go/os/index#Hostname",
        "syntax": "func Hostname() (name string, err error)",
        "type": "os"
    },
    "Hypot": {
        "descr": "Hypot returns Sqrt(p*p + q*q), taking care to avoid unnecessary overflow and underflow.",
        "name": "math.Hypot",
        "params": [],
        "path": "go/math/index#Hypot",
        "syntax": "func Hypot(p, q float64) float64",
        "type": "math"
    },
    "ICMPv6Filter": {
        "descr": "",
        "name": "syscall.ICMPv6Filter",
        "params": [],
        "path": "go/syscall/index#ICMPv6Filter",
        "syntax": "type ICMPv6Filter struct { Data [8]uint32 }",
        "type": "syscall"
    },
    "IP": {
        "descr": "An IP is a single IP address, a slice of bytes. Functions in this package accept either 4-byte (IPv4) or 16-byte (IPv6) slices as input.",
        "name": "net.IP",
        "params": [],
        "path": "go/net/index#IP",
        "syntax": "type IP []byte",
        "type": "net"
    },
    "IP.DefaultMask": {
        "descr": "DefaultMask returns the default IP mask for the IP address ip. Only IPv4 addresses have default masks; DefaultMask returns nil if ip is not a valid IPv4 address.",
        "name": "net.IP.DefaultMask",
        "params": [],
        "path": "go/net/index#IP.DefaultMask",
        "syntax": "func (ip IP) DefaultMask() IPMask",
        "type": "net"
    },
    "IP.Equal": {
        "descr": "Equal reports whether ip and x are the same IP address. An IPv4 address and that same address in IPv6 form are considered to be equal.",
        "name": "net.IP.Equal",
        "params": [],
        "path": "go/net/index#IP.Equal",
        "syntax": "func (ip IP) Equal(x IP) bool",
        "type": "net"
    },
    "IP.IsGlobalUnicast": {
        "descr": "IsGlobalUnicast reports whether ip is a global unicast address.",
        "name": "net.IP.IsGlobalUnicast",
        "params": [],
        "path": "go/net/index#IP.IsGlobalUnicast",
        "syntax": "func (ip IP) IsGlobalUnicast() bool",
        "type": "net"
    },
    "IP.IsInterfaceLocalMulticast": {
        "descr": "IsInterfaceLocalMulticast reports whether ip is an interface-local multicast address.",
        "name": "net.IP.IsInterfaceLocalMulticast",
        "params": [],
        "path": "go/net/index#IP.IsInterfaceLocalMulticast",
        "syntax": "func (ip IP) IsInterfaceLocalMulticast() bool",
        "type": "net"
    },
    "IP.IsLinkLocalMulticast": {
        "descr": "IsLinkLocalMulticast reports whether ip is a link-local multicast address.",
        "name": "net.IP.IsLinkLocalMulticast",
        "params": [],
        "path": "go/net/index#IP.IsLinkLocalMulticast",
        "syntax": "func (ip IP) IsLinkLocalMulticast() bool",
        "type": "net"
    },
    "IP.IsLinkLocalUnicast": {
        "descr": "IsLinkLocalUnicast reports whether ip is a link-local unicast address.",
        "name": "net.IP.IsLinkLocalUnicast",
        "params": [],
        "path": "go/net/index#IP.IsLinkLocalUnicast",
        "syntax": "func (ip IP) IsLinkLocalUnicast() bool",
        "type": "net"
    },
    "IP.IsLoopback": {
        "descr": "IsLoopback reports whether ip is a loopback address.",
        "name": "net.IP.IsLoopback",
        "params": [],
        "path": "go/net/index#IP.IsLoopback",
        "syntax": "func (ip IP) IsLoopback() bool",
        "type": "net"
    },
    "IP.IsMulticast": {
        "descr": "IsMulticast reports whether ip is a multicast address.",
        "name": "net.IP.IsMulticast",
        "params": [],
        "path": "go/net/index#IP.IsMulticast",
        "syntax": "func (ip IP) IsMulticast() bool",
        "type": "net"
    },
    "IP.IsUnspecified": {
        "descr": "IsUnspecified reports whether ip is an unspecified address, either the IPv4 address \"0.0.0.0\" or the IPv6 address \"::\".",
        "name": "net.IP.IsUnspecified",
        "params": [],
        "path": "go/net/index#IP.IsUnspecified",
        "syntax": "func (ip IP) IsUnspecified() bool",
        "type": "net"
    },
    "IP.MarshalText": {
        "descr": "MarshalText implements the encoding.TextMarshaler interface. The encoding is the same as returned by String, with one exception: When len(ip) is zero, it returns an empty slice.",
        "name": "net.IP.MarshalText",
        "params": [],
        "path": "go/net/index#IP.MarshalText",
        "syntax": "func (ip IP) MarshalText() ([]byte, error)",
        "type": "net"
    },
    "IP.Mask": {
        "descr": "Mask returns the result of masking the IP address ip with mask.",
        "name": "net.IP.Mask",
        "params": [],
        "path": "go/net/index#IP.Mask",
        "syntax": "func (ip IP) Mask(mask IPMask) IP",
        "type": "net"
    },
    "IP.String": {
        "descr": "String returns the string form of the IP address ip. It returns one of 4 forms:",
        "name": "net.IP.String",
        "params": [],
        "path": "go/net/index#IP.String",
        "syntax": "func (ip IP) String() string",
        "type": "net"
    },
    "IP.To16": {
        "descr": "To16 converts the IP address ip to a 16-byte representation. If ip is not an IP address (it is the wrong length), To16 returns nil.",
        "name": "net.IP.To16",
        "params": [],
        "path": "go/net/index#IP.To16",
        "syntax": "func (ip IP) To16() IP",
        "type": "net"
    },
    "IP.To4": {
        "descr": "To4 converts the IPv4 address ip to a 4-byte representation. If ip is not an IPv4 address, To4 returns nil.",
        "name": "net.IP.To4",
        "params": [],
        "path": "go/net/index#IP.To4",
        "syntax": "func (ip IP) To4() IP",
        "type": "net"
    },
    "IP.UnmarshalText": {
        "descr": "UnmarshalText implements the encoding.TextUnmarshaler interface. The IP address is expected in a form accepted by ParseIP.",
        "name": "net.IP.UnmarshalText",
        "params": [],
        "path": "go/net/index#IP.UnmarshalText",
        "syntax": "func (ip *IP) UnmarshalText(text []byte) error",
        "type": "net"
    },
    "IPAddr": {
        "descr": "IPAddr represents the address of an IP end point.",
        "name": "net.IPAddr",
        "params": [],
        "path": "go/net/index#IPAddr",
        "syntax": "type IPAddr struct { IP IP Zone string // IPv6 scoped addressing zone; added in Go 1.1 }",
        "type": "net"
    },
    "IPAddr.Network": {
        "descr": "Network returns the address's network name, \"ip\".",
        "name": "net.IPAddr.Network",
        "params": [],
        "path": "go/net/index#IPAddr.Network",
        "syntax": "func (a *IPAddr) Network() string",
        "type": "net"
    },
    "IPAddr.String": {
        "descr": "",
        "name": "net.IPAddr.String",
        "params": [],
        "path": "go/net/index#IPAddr.String",
        "syntax": "func (a *IPAddr) String() string",
        "type": "net"
    },
    "IPConn": {
        "descr": "IPConn is the implementation of the Conn and PacketConn interfaces for IP network connections.",
        "name": "net.IPConn",
        "params": [],
        "path": "go/net/index#IPConn",
        "syntax": "type IPConn struct { // contains filtered or unexported fields }",
        "type": "net"
    },
    "IPConn.Close": {
        "descr": "Close closes the connection.",
        "name": "net.IPConn.Close",
        "params": [],
        "path": "go/net/index#IPConn.Close",
        "syntax": "func (c *IPConn) Close() error",
        "type": "net"
    },
    "IPConn.File": {
        "descr": "File returns a copy of the underlying os.File It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.",
        "name": "net.IPConn.File",
        "params": [],
        "path": "go/net/index#IPConn.File",
        "syntax": "func (c *IPConn) File() (f *os.File, err error)",
        "type": "net"
    },
    "IPConn.LocalAddr": {
        "descr": "LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it.",
        "name": "net.IPConn.LocalAddr",
        "params": [],
        "path": "go/net/index#IPConn.LocalAddr",
        "syntax": "func (c *IPConn) LocalAddr() Addr",
        "type": "net"
    },
    "IPConn.Read": {
        "descr": "Read implements the Conn Read method.",
        "name": "net.IPConn.Read",
        "params": [],
        "path": "go/net/index#IPConn.Read",
        "syntax": "func (c *IPConn) Read(b []byte) (int, error)",
        "type": "net"
    },
    "IPConn.ReadFrom": {
        "descr": "ReadFrom implements the PacketConn ReadFrom method.",
        "name": "net.IPConn.ReadFrom",
        "params": [],
        "path": "go/net/index#IPConn.ReadFrom",
        "syntax": "func (c *IPConn) ReadFrom(b []byte) (int, Addr, error)",
        "type": "net"
    },
    "IPConn.ReadFromIP": {
        "descr": "ReadFromIP acts like ReadFrom but returns an IPAddr.",
        "name": "net.IPConn.ReadFromIP",
        "params": [],
        "path": "go/net/index#IPConn.ReadFromIP",
        "syntax": "func (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error)",
        "type": "net"
    },
    "IPConn.ReadMsgIP": {
        "descr": "ReadMsgIP reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message.",
        "name": "net.IPConn.ReadMsgIP",
        "params": [],
        "path": "go/net/index#IPConn.ReadMsgIP",
        "syntax": "func (c *IPConn) ReadMsgIP(b, oob []byte) (n, oobn, flags int, addr *IPAddr, err error)",
        "type": "net"
    },
    "IPConn.RemoteAddr": {
        "descr": "RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it.",
        "name": "net.IPConn.RemoteAddr",
        "params": [],
        "path": "go/net/index#IPConn.RemoteAddr",
        "syntax": "func (c *IPConn) RemoteAddr() Addr",
        "type": "net"
    },
    "IPConn.SetDeadline": {
        "descr": "SetDeadline implements the Conn SetDeadline method.",
        "name": "net.IPConn.SetDeadline",
        "params": [],
        "path": "go/net/index#IPConn.SetDeadline",
        "syntax": "func (c *IPConn) SetDeadline(t time.Time) error",
        "type": "net"
    },
    "IPConn.SetReadBuffer": {
        "descr": "SetReadBuffer sets the size of the operating system's receive buffer associated with the connection.",
        "name": "net.IPConn.SetReadBuffer",
        "params": [],
        "path": "go/net/index#IPConn.SetReadBuffer",
        "syntax": "func (c *IPConn) SetReadBuffer(bytes int) error",
        "type": "net"
    },
    "IPConn.SetReadDeadline": {
        "descr": "SetReadDeadline implements the Conn SetReadDeadline method.",
        "name": "net.IPConn.SetReadDeadline",
        "params": [],
        "path": "go/net/index#IPConn.SetReadDeadline",
        "syntax": "func (c *IPConn) SetReadDeadline(t time.Time) error",
        "type": "net"
    },
    "IPConn.SetWriteBuffer": {
        "descr": "SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection.",
        "name": "net.IPConn.SetWriteBuffer",
        "params": [],
        "path": "go/net/index#IPConn.SetWriteBuffer",
        "syntax": "func (c *IPConn) SetWriteBuffer(bytes int) error",
        "type": "net"
    },
    "IPConn.SetWriteDeadline": {
        "descr": "SetWriteDeadline implements the Conn SetWriteDeadline method.",
        "name": "net.IPConn.SetWriteDeadline",
        "params": [],
        "path": "go/net/index#IPConn.SetWriteDeadline",
        "syntax": "func (c *IPConn) SetWriteDeadline(t time.Time) error",
        "type": "net"
    },
    "IPConn.SyscallConn": {
        "descr": "SyscallConn returns a raw network connection. This implements the syscall.Conn interface.",
        "name": "net.IPConn.SyscallConn",
        "params": [],
        "path": "go/net/index#IPConn.SyscallConn",
        "syntax": "func (c *IPConn) SyscallConn() (syscall.RawConn, error)",
        "type": "net"
    },
    "IPConn.Write": {
        "descr": "Write implements the Conn Write method.",
        "name": "net.IPConn.Write",
        "params": [],
        "path": "go/net/index#IPConn.Write",
        "syntax": "func (c *IPConn) Write(b []byte) (int, error)",
        "type": "net"
    },
    "IPConn.WriteMsgIP": {
        "descr": "WriteMsgIP writes a message to addr via c, copying the payload from b and the associated out-of-band data from oob. It returns the number of payload and out-of-band bytes written.",
        "name": "net.IPConn.WriteMsgIP",
        "params": [],
        "path": "go/net/index#IPConn.WriteMsgIP",
        "syntax": "func (c *IPConn) WriteMsgIP(b, oob []byte, addr *IPAddr) (n, oobn int, err error)",
        "type": "net"
    },
    "IPConn.WriteTo": {
        "descr": "WriteTo implements the PacketConn WriteTo method.",
        "name": "net.IPConn.WriteTo",
        "params": [],
        "path": "go/net/index#IPConn.WriteTo",
        "syntax": "func (c *IPConn) WriteTo(b []byte, addr Addr) (int, error)",
        "type": "net"
    },
    "IPConn.WriteToIP": {
        "descr": "WriteToIP acts like WriteTo but takes an IPAddr.",
        "name": "net.IPConn.WriteToIP",
        "params": [],
        "path": "go/net/index#IPConn.WriteToIP",
        "syntax": "func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (int, error)",
        "type": "net"
    },
    "IPMask": {
        "descr": "An IP mask is an IP address.",
        "name": "net.IPMask",
        "params": [],
        "path": "go/net/index#IPMask",
        "syntax": "type IPMask []byte",
        "type": "net"
    },
    "IPMask.Size": {
        "descr": "Size returns the number of leading ones and total bits in the mask. If the mask is not in the canonical form--ones followed by zeros--then Size returns 0, 0.",
        "name": "net.IPMask.Size",
        "params": [],
        "path": "go/net/index#IPMask.Size",
        "syntax": "func (m IPMask) Size() (ones, bits int)",
        "type": "net"
    },
    "IPMask.String": {
        "descr": "String returns the hexadecimal form of m, with no punctuation.",
        "name": "net.IPMask.String",
        "params": [],
        "path": "go/net/index#IPMask.String",
        "syntax": "func (m IPMask) String() string",
        "type": "net"
    },
    "IPMreq": {
        "descr": "",
        "name": "syscall.IPMreq",
        "params": [],
        "path": "go/syscall/index#IPMreq",
        "syntax": "type IPMreq struct { Multiaddr [4]byte /* in_addr */ Interface [4]byte /* in_addr */ }",
        "type": "syscall"
    },
    "IPMreqn": {
        "descr": "",
        "name": "syscall.IPMreqn",
        "params": [],
        "path": "go/syscall/index#IPMreqn",
        "syntax": "type IPMreqn struct { Multiaddr [4]byte /* in_addr */ Address [4]byte /* in_addr */ Ifindex int32 }",
        "type": "syscall"
    },
    "IPNet": {
        "descr": "An IPNet represents an IP network.",
        "name": "net.IPNet",
        "params": [],
        "path": "go/net/index#IPNet",
        "syntax": "type IPNet struct { IP IP // network number Mask IPMask // network mask }",
        "type": "net"
    },
    "IPNet.Contains": {
        "descr": "Contains reports whether the network includes ip.",
        "name": "net.IPNet.Contains",
        "params": [],
        "path": "go/net/index#IPNet.Contains",
        "syntax": "func (n *IPNet) Contains(ip IP) bool",
        "type": "net"
    },
    "IPNet.Network": {
        "descr": "Network returns the address's network name, \"ip+net\".",
        "name": "net.IPNet.Network",
        "params": [],
        "path": "go/net/index#IPNet.Network",
        "syntax": "func (n *IPNet) Network() string",
        "type": "net"
    },
    "IPNet.String": {
        "descr": "String returns the CIDR notation of n like \"192.0.2.1/24\" or \"2001:db8::/48\" as defined in RFC 4632 and RFC 4291. If the mask is not in the canonical form, it returns the string which consists of an IP address, followed by a slash character and a mask expressed as hexadecimal form with no punctuation like \"198.51.100.1/c000ff00\".",
        "name": "net.IPNet.String",
        "params": [],
        "path": "go/net/index#IPNet.String",
        "syntax": "func (n *IPNet) String() string",
        "type": "net"
    },
    "IPv4": {
        "descr": "IPv4 returns the IP address (in 16-byte form) of the IPv4 address a.b.c.d.",
        "name": "net.IPv4",
        "params": [],
        "path": "go/net/index#IPv4",
        "syntax": "func IPv4(a, b, c, d byte) IP",
        "type": "net"
    },
    "IPv4Mask": {
        "descr": "IPv4Mask returns the IP mask (in 4-byte form) of the IPv4 mask a.b.c.d.",
        "name": "net.IPv4Mask",
        "params": [],
        "path": "go/net/index#IPv4Mask",
        "syntax": "func IPv4Mask(a, b, c, d byte) IPMask",
        "type": "net"
    },
    "IPv6MTUInfo": {
        "descr": "",
        "name": "syscall.IPv6MTUInfo",
        "params": [],
        "path": "go/syscall/index#IPv6MTUInfo",
        "syntax": "type IPv6MTUInfo struct { Addr RawSockaddrInet6 Mtu uint32 }",
        "type": "syscall"
    },
    "IPv6Mreq": {
        "descr": "",
        "name": "syscall.IPv6Mreq",
        "params": [],
        "path": "go/syscall/index#IPv6Mreq",
        "syntax": "type IPv6Mreq struct { Multiaddr [16]byte /* in6_addr */ Interface uint32 }",
        "type": "syscall"
    },
    "IfAddrmsg": {
        "descr": "",
        "name": "syscall.IfAddrmsg",
        "params": [],
        "path": "go/syscall/index#IfAddrmsg",
        "syntax": "type IfAddrmsg struct { Family uint8 Prefixlen uint8 Flags uint8 Scope uint8 Index uint32 }",
        "type": "syscall"
    },
    "IfInfomsg": {
        "descr": "",
        "name": "syscall.IfInfomsg",
        "params": [],
        "path": "go/syscall/index#IfInfomsg",
        "syntax": "type IfInfomsg struct { Family uint8 X__ifi_pad uint8 Type uint16 Index int32 Flags uint32 Change uint32 }",
        "type": "syscall"
    },
    "Ilogb": {
        "descr": "Ilogb returns the binary exponent of x as an integer.",
        "name": "math.Ilogb",
        "params": [],
        "path": "go/math/index#Ilogb",
        "syntax": "func Ilogb(x float64) int",
        "type": "math"
    },
    "Image": {
        "descr": "Image is a finite rectangular grid of color.Color values taken from a color model.",
        "name": "image.Image",
        "params": [],
        "path": "go/image/index#Image",
        "syntax": "type Image interface { // ColorModel returns the Image's color model. ColorModel() color.Model // Bounds returns the domain for which At can return non-zero color. // The bounds do not necessarily contain the point (0, 0). Bounds() Rectangle // At returns the color of the pixel at (x, y). // At(Bounds().Min.X, Bounds().Min.Y) returns the upper-left pixel of the grid. // At(Bounds().Max.X-1, Bounds().Max.Y-1) returns the lower-right one. At(x, y int) color.Color }",
        "type": "image"
    },
    "In": {
        "descr": "In reports whether the rune is a member of one of the ranges.",
        "name": "unicode.In",
        "params": [],
        "path": "go/unicode/index#In",
        "syntax": "func In(r rune, ranges ...*RangeTable) bool",
        "type": "unicode"
    },
    "Index": {
        "descr": "Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.",
        "name": "strings.Index",
        "params": [],
        "path": "go/strings/index#Index",
        "syntax": "func Index(s, substr string) int",
        "type": "strings"
    },
    "IndexAny": {
        "descr": "IndexAny returns the index of the first instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s.",
        "name": "strings.IndexAny",
        "params": [],
        "path": "go/strings/index#IndexAny",
        "syntax": "func IndexAny(s, chars string) int",
        "type": "strings"
    },
    "IndexByte": {
        "descr": "IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.",
        "name": "strings.IndexByte",
        "params": [],
        "path": "go/strings/index#IndexByte",
        "syntax": "func IndexByte(s string, c byte) int",
        "type": "strings"
    },
    "IndexFunc": {
        "descr": "IndexFunc returns the index into s of the first Unicode code point satisfying f(c), or -1 if none do.",
        "name": "strings.IndexFunc",
        "params": [],
        "path": "go/strings/index#IndexFunc",
        "syntax": "func IndexFunc(s string, f func(rune) bool) int",
        "type": "strings"
    },
    "IndexRune": {
        "descr": "IndexRune returns the index of the first instance of the Unicode code point r, or -1 if rune is not present in s. If r is utf8.RuneError, it returns the first instance of any invalid UTF-8 byte sequence.",
        "name": "strings.IndexRune",
        "params": [],
        "path": "go/strings/index#IndexRune",
        "syntax": "func IndexRune(s string, r rune) int",
        "type": "strings"
    },
    "Indirect": {
        "descr": "Indirect returns the value that v points to. If v is a nil pointer, Indirect returns a zero Value. If v is not a pointer, Indirect returns v.",
        "name": "reflect.Indirect",
        "params": [],
        "path": "go/reflect/index#Indirect",
        "syntax": "func Indirect(v Value) Value",
        "type": "reflect"
    },
    "Inet4Pktinfo": {
        "descr": "",
        "name": "syscall.Inet4Pktinfo",
        "params": [],
        "path": "go/syscall/index#Inet4Pktinfo",
        "syntax": "type Inet4Pktinfo struct { Ifindex int32 Spec_dst [4]byte /* in_addr */ Addr [4]byte /* in_addr */ }",
        "type": "syscall"
    },
    "Inet6Pktinfo": {
        "descr": "",
        "name": "syscall.Inet6Pktinfo",
        "params": [],
        "path": "go/syscall/index#Inet6Pktinfo",
        "syntax": "type Inet6Pktinfo struct { Addr [16]byte /* in6_addr */ Ifindex uint32 }",
        "type": "syscall"
    },
    "Inf": {
        "descr": "Inf returns positive infinity if sign >= 0, negative infinity if sign < 0.",
        "name": "math.Inf",
        "params": [],
        "path": "go/math/index#Inf",
        "syntax": "func Inf(sign int) float64",
        "type": "math"
    },
    "InotifyAddWatch": {
        "descr": "",
        "name": "syscall.InotifyAddWatch",
        "params": [],
        "path": "go/syscall/index#InotifyAddWatch",
        "syntax": "func InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error)",
        "type": "syscall"
    },
    "InotifyEvent": {
        "descr": "",
        "name": "syscall.InotifyEvent",
        "params": [],
        "path": "go/syscall/index#InotifyEvent",
        "syntax": "type InotifyEvent struct { Wd int32 Mask uint32 Cookie uint32 Len uint32 Name [0]uint8 }",
        "type": "syscall"
    },
    "InotifyInit": {
        "descr": "",
        "name": "syscall.InotifyInit",
        "params": [],
        "path": "go/syscall/index#InotifyInit",
        "syntax": "func InotifyInit() (fd int, err error)",
        "type": "syscall"
    },
    "InotifyInit1": {
        "descr": "",
        "name": "syscall.InotifyInit1",
        "params": [],
        "path": "go/syscall/index#InotifyInit1",
        "syntax": "func InotifyInit1(flags int) (fd int, err error)",
        "type": "syscall"
    },
    "InotifyRmWatch": {
        "descr": "",
        "name": "syscall.InotifyRmWatch",
        "params": [],
        "path": "go/syscall/index#InotifyRmWatch",
        "syntax": "func InotifyRmWatch(fd int, watchdesc uint32) (success int, err error)",
        "type": "syscall"
    },
    "Int": {
        "descr": "Int defines an int flag with specified name, default value, and usage string. The return value is the address of an int variable that stores the value of the flag.",
        "name": "flag.Int",
        "params": [],
        "path": "go/flag/index#Int",
        "syntax": "func Int(name string, value int, usage string) *int",
        "type": "flag"
    },
    "Int.Add": {
        "descr": "",
        "name": "expvar.Int.Add",
        "params": [],
        "path": "go/expvar/index#Int.Add",
        "syntax": "func (v *Int) Add(delta int64)",
        "type": "expvar"
    },
    "Int.Set": {
        "descr": "",
        "name": "expvar.Int.Set",
        "params": [],
        "path": "go/expvar/index#Int.Set",
        "syntax": "func (v *Int) Set(value int64)",
        "type": "expvar"
    },
    "Int.String": {
        "descr": "",
        "name": "expvar.Int.String",
        "params": [],
        "path": "go/expvar/index#Int.String",
        "syntax": "func (v *Int) String() string",
        "type": "expvar"
    },
    "Int.Value": {
        "descr": "",
        "name": "expvar.Int.Value",
        "params": [],
        "path": "go/expvar/index#Int.Value",
        "syntax": "func (v *Int) Value() int64",
        "type": "expvar"
    },
    "Int64": {
        "descr": "Int64 defines an int64 flag with specified name, default value, and usage string. The return value is the address of an int64 variable that stores the value of the flag.",
        "name": "flag.Int64",
        "params": [],
        "path": "go/flag/index#Int64",
        "syntax": "func Int64(name string, value int64, usage string) *int64",
        "type": "flag"
    },
    "Int64Var": {
        "descr": "Int64Var defines an int64 flag with specified name, default value, and usage string. The argument p points to an int64 variable in which to store the value of the flag.",
        "name": "flag.Int64Var",
        "params": [],
        "path": "go/flag/index#Int64Var",
        "syntax": "func Int64Var(p *int64, name string, value int64, usage string)",
        "type": "flag"
    },
    "IntSlice": {
        "descr": "IntSlice attaches the methods of Interface to []int, sorting in increasing order.",
        "name": "sort.IntSlice",
        "params": [],
        "path": "go/sort/index#IntSlice",
        "syntax": "type IntSlice []int",
        "type": "sort"
    },
    "IntSlice.Len": {
        "descr": "",
        "name": "sort.IntSlice.Len",
        "params": [],
        "path": "go/sort/index#IntSlice.Len",
        "syntax": "func (p IntSlice) Len() int",
        "type": "sort"
    },
    "IntSlice.Less": {
        "descr": "",
        "name": "sort.IntSlice.Less",
        "params": [],
        "path": "go/sort/index#IntSlice.Less",
        "syntax": "func (p IntSlice) Less(i, j int) bool",
        "type": "sort"
    },
    "IntSlice.Search": {
        "descr": "Search returns the result of applying SearchInts to the receiver and x.",
        "name": "sort.IntSlice.Search",
        "params": [],
        "path": "go/sort/index#IntSlice.Search",
        "syntax": "func (p IntSlice) Search(x int) int",
        "type": "sort"
    },
    "IntSlice.Sort": {
        "descr": "Sort is a convenience method.",
        "name": "sort.IntSlice.Sort",
        "params": [],
        "path": "go/sort/index#IntSlice.Sort",
        "syntax": "func (p IntSlice) Sort()",
        "type": "sort"
    },
    "IntSlice.Swap": {
        "descr": "",
        "name": "sort.IntSlice.Swap",
        "params": [],
        "path": "go/sort/index#IntSlice.Swap",
        "syntax": "func (p IntSlice) Swap(i, j int)",
        "type": "sort"
    },
    "IntVar": {
        "descr": "IntVar defines an int flag with specified name, default value, and usage string. The argument p points to an int variable in which to store the value of the flag.",
        "name": "flag.IntVar",
        "params": [],
        "path": "go/flag/index#IntVar",
        "syntax": "func IntVar(p *int, name string, value int, usage string)",
        "type": "flag"
    },
    "IntegerType": {
        "descr": "IntegerType is here for the purposes of documentation only. It is a stand-in for any integer type: int, uint, int8 etc.",
        "name": "builtin.IntegerType",
        "params": [],
        "path": "go/builtin/index#IntegerType",
        "syntax": "type IntegerType int",
        "type": "builtin"
    },
    "Interface": {
        "descr": "A type, typically a collection, that satisfies sort.Interface can be sorted by the routines in this package. The methods require that the elements of the collection be enumerated by an integer index.",
        "name": "sort.Interface",
        "params": [],
        "path": "go/sort/index#Interface",
        "syntax": "type Interface interface { // Len is the number of elements in the collection. Len() int // Less reports whether the element with // index i should sort before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }",
        "type": "sort"
    },
    "Interface.Addrs": {
        "descr": "Addrs returns a list of unicast interface addresses for a specific interface.",
        "name": "net.Interface.Addrs",
        "params": [],
        "path": "go/net/index#Interface.Addrs",
        "syntax": "func (ifi *Interface) Addrs() ([]Addr, error)",
        "type": "net"
    },
    "Interface.MulticastAddrs": {
        "descr": "MulticastAddrs returns a list of multicast, joined group addresses for a specific interface.",
        "name": "net.Interface.MulticastAddrs",
        "params": [],
        "path": "go/net/index#Interface.MulticastAddrs",
        "syntax": "func (ifi *Interface) MulticastAddrs() ([]Addr, error)",
        "type": "net"
    },
    "InterfaceAddrs": {
        "descr": "InterfaceAddrs returns a list of the system's unicast interface addresses.",
        "name": "net.InterfaceAddrs",
        "params": [],
        "path": "go/net/index#InterfaceAddrs",
        "syntax": "func InterfaceAddrs() ([]Addr, error)",
        "type": "net"
    },
    "InterfaceByIndex": {
        "descr": "InterfaceByIndex returns the interface specified by index.",
        "name": "net.InterfaceByIndex",
        "params": [],
        "path": "go/net/index#InterfaceByIndex",
        "syntax": "func InterfaceByIndex(index int) (*Interface, error)",
        "type": "net"
    },
    "InterfaceByName": {
        "descr": "InterfaceByName returns the interface specified by name.",
        "name": "net.InterfaceByName",
        "params": [],
        "path": "go/net/index#InterfaceByName",
        "syntax": "func InterfaceByName(name string) (*Interface, error)",
        "type": "net"
    },
    "Interfaces": {
        "descr": "Interfaces returns a list of the system's network interfaces.",
        "name": "net.Interfaces",
        "params": [],
        "path": "go/net/index#Interfaces",
        "syntax": "func Interfaces() ([]Interface, error)",
        "type": "net"
    },
    "InternalBenchmark": {
        "descr": "An internal type but exported because it is cross-package; part of the implementation of the \"go test\" command.",
        "name": "testing.InternalBenchmark",
        "params": [],
        "path": "go/testing/index#InternalBenchmark",
        "syntax": "type InternalBenchmark struct { Name string F func(b *B) }",
        "type": "testing"
    },
    "InternalExample": {
        "descr": "",
        "name": "testing.InternalExample",
        "params": [],
        "path": "go/testing/index#InternalExample",
        "syntax": "type InternalExample struct { Name string F func() Output string Unordered bool // Go 1.7 }",
        "type": "testing"
    },
    "InternalTest": {
        "descr": "An internal type but exported because it is cross-package; part of the implementation of the \"go test\" command.",
        "name": "testing.InternalTest",
        "params": [],
        "path": "go/testing/index#InternalTest",
        "syntax": "type InternalTest struct { Name string F func(*T) }",
        "type": "testing"
    },
    "Ints": {
        "descr": "Ints sorts a slice of ints in increasing order.",
        "name": "sort.Ints",
        "params": [],
        "path": "go/sort/index#Ints",
        "syntax": "func Ints(a []int)",
        "type": "sort"
    },
    "IntsAreSorted": {
        "descr": "IntsAreSorted tests whether a slice of ints is sorted in increasing order.",
        "name": "sort.IntsAreSorted",
        "params": [],
        "path": "go/sort/index#IntsAreSorted",
        "syntax": "func IntsAreSorted(a []int) bool",
        "type": "sort"
    },
    "InvalidAddrError": {
        "descr": "",
        "name": "net.InvalidAddrError",
        "params": [],
        "path": "go/net/index#InvalidAddrError",
        "syntax": "type InvalidAddrError string",
        "type": "net"
    },
    "InvalidAddrError.Error": {
        "descr": "",
        "name": "net.InvalidAddrError.Error",
        "params": [],
        "path": "go/net/index#InvalidAddrError.Error",
        "syntax": "func (e InvalidAddrError) Error() string",
        "type": "net"
    },
    "InvalidAddrError.Temporary": {
        "descr": "",
        "name": "net.InvalidAddrError.Temporary",
        "params": [],
        "path": "go/net/index#InvalidAddrError.Temporary",
        "syntax": "func (e InvalidAddrError) Temporary() bool",
        "type": "net"
    },
    "InvalidAddrError.Timeout": {
        "descr": "",
        "name": "net.InvalidAddrError.Timeout",
        "params": [],
        "path": "go/net/index#InvalidAddrError.Timeout",
        "syntax": "func (e InvalidAddrError) Timeout() bool",
        "type": "net"
    },
    "Ioperm": {
        "descr": "",
        "name": "syscall.Ioperm",
        "params": [],
        "path": "go/syscall/index#Ioperm",
        "syntax": "func Ioperm(from int, num int, on int) (err error)",
        "type": "syscall"
    },
    "Iopl": {
        "descr": "",
        "name": "syscall.Iopl",
        "params": [],
        "path": "go/syscall/index#Iopl",
        "syntax": "func Iopl(level int) (err error)",
        "type": "syscall"
    },
    "Iovec": {
        "descr": "",
        "name": "syscall.Iovec",
        "params": [],
        "path": "go/syscall/index#Iovec",
        "syntax": "type Iovec struct { Base *byte Len uint64 }",
        "type": "syscall"
    },
    "Iovec.SetLen": {
        "descr": "",
        "name": "syscall.Iovec.SetLen",
        "params": [],
        "path": "go/syscall/index#Iovec.SetLen",
        "syntax": "func (iov *Iovec) SetLen(length int)",
        "type": "syscall"
    },
    "Is": {
        "descr": "Is reports whether the rune is in the specified table of ranges.",
        "name": "unicode.Is",
        "params": [],
        "path": "go/unicode/index#Is",
        "syntax": "func Is(rangeTab *RangeTable, r rune) bool",
        "type": "unicode"
    },
    "IsAbs": {
        "descr": "IsAbs reports whether the path is absolute.",
        "name": "path.IsAbs",
        "params": [],
        "path": "go/path/index#IsAbs",
        "syntax": "func IsAbs(path string) bool",
        "type": "path"
    },
    "IsControl": {
        "descr": "IsControl reports whether the rune is a control character. The C (Other) Unicode category includes more code points such as surrogates; use Is(C, r) to test for them.",
        "name": "unicode.IsControl",
        "params": [],
        "path": "go/unicode/index#IsControl",
        "syntax": "func IsControl(r rune) bool",
        "type": "unicode"
    },
    "IsDigit": {
        "descr": "IsDigit reports whether the rune is a decimal digit.",
        "name": "unicode.IsDigit",
        "params": [],
        "path": "go/unicode/index#IsDigit",
        "syntax": "func IsDigit(r rune) bool",
        "type": "unicode"
    },
    "IsExist": {
        "descr": "IsExist returns a boolean indicating whether the error is known to report that a file or directory already exists. It is satisfied by ErrExist as well as some syscall errors.",
        "name": "os.IsExist",
        "params": [],
        "path": "go/os/index#IsExist",
        "syntax": "func IsExist(err error) bool",
        "type": "os"
    },
    "IsGraphic": {
        "descr": "IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such characters include letters, marks, numbers, punctuation, symbols, and spaces, from categories L, M, N, P, S, Zs.",
        "name": "unicode.IsGraphic",
        "params": [],
        "path": "go/unicode/index#IsGraphic",
        "syntax": "func IsGraphic(r rune) bool",
        "type": "unicode"
    },
    "IsInf": {
        "descr": "IsInf reports whether f is an infinity, according to sign. If sign > 0, IsInf reports whether f is positive infinity. If sign < 0, IsInf reports whether f is negative infinity. If sign == 0, IsInf reports whether f is either infinity.",
        "name": "math.IsInf",
        "params": [],
        "path": "go/math/index#IsInf",
        "syntax": "func IsInf(f float64, sign int) bool",
        "type": "math"
    },
    "IsLetter": {
        "descr": "IsLetter reports whether the rune is a letter (category L).",
        "name": "unicode.IsLetter",
        "params": [],
        "path": "go/unicode/index#IsLetter",
        "syntax": "func IsLetter(r rune) bool",
        "type": "unicode"
    },
    "IsLower": {
        "descr": "IsLower reports whether the rune is a lower case letter.",
        "name": "unicode.IsLower",
        "params": [],
        "path": "go/unicode/index#IsLower",
        "syntax": "func IsLower(r rune) bool",
        "type": "unicode"
    },
    "IsMark": {
        "descr": "IsMark reports whether the rune is a mark character (category M).",
        "name": "unicode.IsMark",
        "params": [],
        "path": "go/unicode/index#IsMark",
        "syntax": "func IsMark(r rune) bool",
        "type": "unicode"
    },
    "IsNaN": {
        "descr": "IsNaN reports whether f is an IEEE 754 not-a-number value.",
        "name": "math.IsNaN",
        "params": [],
        "path": "go/math/index#IsNaN",
        "syntax": "func IsNaN(f float64) (is bool)",
        "type": "math"
    },
    "IsNotExist": {
        "descr": "IsNotExist returns a boolean indicating whether the error is known to report that a file or directory does not exist. It is satisfied by ErrNotExist as well as some syscall errors.",
        "name": "os.IsNotExist",
        "params": [],
        "path": "go/os/index#IsNotExist",
        "syntax": "func IsNotExist(err error) bool",
        "type": "os"
    },
    "IsNumber": {
        "descr": "IsNumber reports whether the rune is a number (category N).",
        "name": "unicode.IsNumber",
        "params": [],
        "path": "go/unicode/index#IsNumber",
        "syntax": "func IsNumber(r rune) bool",
        "type": "unicode"
    },
    "IsOneOf": {
        "descr": "IsOneOf reports whether the rune is a member of one of the ranges. The function \"In\" provides a nicer signature and should be used in preference to IsOneOf.",
        "name": "unicode.IsOneOf",
        "params": [],
        "path": "go/unicode/index#IsOneOf",
        "syntax": "func IsOneOf(ranges []*RangeTable, r rune) bool",
        "type": "unicode"
    },
    "IsPathSeparator": {
        "descr": "IsPathSeparator reports whether c is a directory separator character.",
        "name": "os.IsPathSeparator",
        "params": [],
        "path": "go/os/index#IsPathSeparator",
        "syntax": "func IsPathSeparator(c uint8) bool",
        "type": "os"
    },
    "IsPermission": {
        "descr": "IsPermission returns a boolean indicating whether the error is known to report that permission is denied. It is satisfied by ErrPermission as well as some syscall errors.",
        "name": "os.IsPermission",
        "params": [],
        "path": "go/os/index#IsPermission",
        "syntax": "func IsPermission(err error) bool",
        "type": "os"
    },
    "IsPrint": {
        "descr": "IsPrint reports whether the rune is defined as printable by Go. Such characters include letters, marks, numbers, punctuation, symbols, and the ASCII space character, from categories L, M, N, P, S and the ASCII space character. This categorization is the same as IsGraphic except that the only spacing character is ASCII space, U+0020.",
        "name": "unicode.IsPrint",
        "params": [],
        "path": "go/unicode/index#IsPrint",
        "syntax": "func IsPrint(r rune) bool",
        "type": "unicode"
    },
    "IsPunct": {
        "descr": "IsPunct reports whether the rune is a Unicode punctuation character (category P).",
        "name": "unicode.IsPunct",
        "params": [],
        "path": "go/unicode/index#IsPunct",
        "syntax": "func IsPunct(r rune) bool",
        "type": "unicode"
    },
    "IsSorted": {
        "descr": "IsSorted reports whether data is sorted.",
        "name": "sort.IsSorted",
        "params": [],
        "path": "go/sort/index#IsSorted",
        "syntax": "func IsSorted(data Interface) bool",
        "type": "sort"
    },
    "IsSpace": {
        "descr": "IsSpace reports whether the rune is a space character as defined by Unicode's White Space property; in the Latin-1 space this is",
        "name": "unicode.IsSpace",
        "params": [],
        "path": "go/unicode/index#IsSpace",
        "syntax": "func IsSpace(r rune) bool",
        "type": "unicode"
    },
    "IsSymbol": {
        "descr": "IsSymbol reports whether the rune is a symbolic character.",
        "name": "unicode.IsSymbol",
        "params": [],
        "path": "go/unicode/index#IsSymbol",
        "syntax": "func IsSymbol(r rune) bool",
        "type": "unicode"
    },
    "IsTimeout": {
        "descr": "IsTimeout returns a boolean indicating whether the error is known to report that a timeout occurred.",
        "name": "os.IsTimeout",
        "params": [],
        "path": "go/os/index#IsTimeout",
        "syntax": "func IsTimeout(err error) bool",
        "type": "os"
    },
    "IsTitle": {
        "descr": "IsTitle reports whether the rune is a title case letter.",
        "name": "unicode.IsTitle",
        "params": [],
        "path": "go/unicode/index#IsTitle",
        "syntax": "func IsTitle(r rune) bool",
        "type": "unicode"
    },
    "IsUpper": {
        "descr": "IsUpper reports whether the rune is an upper case letter.",
        "name": "unicode.IsUpper",
        "params": [],
        "path": "go/unicode/index#IsUpper",
        "syntax": "func IsUpper(r rune) bool",
        "type": "unicode"
    },
    "Itoa": {
        "descr": "Itoa is shorthand for FormatInt(int64(i), 10).",
        "name": "strconv.Itoa",
        "params": [],
        "path": "go/strconv/index#Itoa",
        "syntax": "func Itoa(i int) string",
        "type": "strconv"
    },
    "J0": {
        "descr": "J0 returns the order-zero Bessel function of the first kind.",
        "name": "math.J0",
        "params": [],
        "path": "go/math/index#J0",
        "syntax": "func J0(x float64) float64",
        "type": "math"
    },
    "J1": {
        "descr": "J1 returns the order-one Bessel function of the first kind.",
        "name": "math.J1",
        "params": [],
        "path": "go/math/index#J1",
        "syntax": "func J1(x float64) float64",
        "type": "math"
    },
    "Jn": {
        "descr": "Jn returns the order-n Bessel function of the first kind.",
        "name": "math.Jn",
        "params": [],
        "path": "go/math/index#Jn",
        "syntax": "func Jn(n int, x float64) float64",
        "type": "math"
    },
    "Join": {
        "descr": "Join concatenates the elements of a to create a single string. The separator string sep is placed between elements in the resulting string.",
        "name": "strings.Join",
        "params": [],
        "path": "go/strings/index#Join",
        "syntax": "func Join(a []string, sep string) string",
        "type": "strings"
    },
    "JoinHostPort": {
        "descr": "JoinHostPort combines host and port into a network address of the form \"host:port\". If host contains a colon, as found in literal IPv6 addresses, then JoinHostPort returns \"[host]:port\".",
        "name": "net.JoinHostPort",
        "params": [],
        "path": "go/net/index#JoinHostPort",
        "syntax": "func JoinHostPort(host, port string) string",
        "type": "net"
    },
    "KeepAlive": {
        "descr": "KeepAlive marks its argument as currently reachable. This ensures that the object is not freed, and its finalizer is not run, before the point in the program where KeepAlive is called.",
        "name": "runtime.KeepAlive",
        "params": [],
        "path": "go/runtime/index#KeepAlive",
        "syntax": "func KeepAlive(x interface{})",
        "type": "runtime"
    },
    "KeyValue": {
        "descr": "KeyValue represents a single entry in a Map.",
        "name": "expvar.KeyValue",
        "params": [],
        "path": "go/expvar/index#KeyValue",
        "syntax": "type KeyValue struct { Key string Value Var }",
        "type": "expvar"
    },
    "Kill": {
        "descr": "",
        "name": "syscall.Kill",
        "params": [],
        "path": "go/syscall/index#Kill",
        "syntax": "func Kill(pid int, sig Signal) (err error)",
        "type": "syscall"
    },
    "Kind": {
        "descr": "A Kind represents the specific kind of type that a Type represents. The zero Kind is not a valid kind.",
        "name": "reflect.Kind",
        "params": [],
        "path": "go/reflect/index#Kind",
        "syntax": "type Kind uint",
        "type": "reflect"
    },
    "Kind.String": {
        "descr": "",
        "name": "reflect.Kind.String",
        "params": [],
        "path": "go/reflect/index#Kind.String",
        "syntax": "func (k Kind) String() string",
        "type": "reflect"
    },
    "Klogctl": {
        "descr": "",
        "name": "syscall.Klogctl",
        "params": [],
        "path": "go/syscall/index#Klogctl",
        "syntax": "func Klogctl(typ int, buf []byte) (n int, err error)",
        "type": "syscall"
    },
    "LastIndex": {
        "descr": "LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.",
        "name": "strings.LastIndex",
        "params": [],
        "path": "go/strings/index#LastIndex",
        "syntax": "func LastIndex(s, substr string) int",
        "type": "strings"
    },
    "LastIndexAny": {
        "descr": "LastIndexAny returns the index of the last instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s.",
        "name": "strings.LastIndexAny",
        "params": [],
        "path": "go/strings/index#LastIndexAny",
        "syntax": "func LastIndexAny(s, chars string) int",
        "type": "strings"
    },
    "LastIndexByte": {
        "descr": "LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.",
        "name": "strings.LastIndexByte",
        "params": [],
        "path": "go/strings/index#LastIndexByte",
        "syntax": "func LastIndexByte(s string, c byte) int",
        "type": "strings"
    },
    "LastIndexFunc": {
        "descr": "LastIndexFunc returns the index into s of the last Unicode code point satisfying f(c), or -1 if none do.",
        "name": "strings.LastIndexFunc",
        "params": [],
        "path": "go/strings/index#LastIndexFunc",
        "syntax": "func LastIndexFunc(s string, f func(rune) bool) int",
        "type": "strings"
    },
    "Lchown": {
        "descr": "",
        "name": "syscall.Lchown",
        "params": [],
        "path": "go/syscall/index#Lchown",
        "syntax": "func Lchown(path string, uid int, gid int) (err error)",
        "type": "syscall"
    },
    "Ldexp": {
        "descr": "Ldexp is the inverse of Frexp. It returns frac  2**exp.",
        "name": "math.Ldexp",
        "params": [],
        "path": "go/math/index#Ldexp",
        "syntax": "func Ldexp(frac float64, exp int) float64",
        "type": "math"
    },
    "Lgamma": {
        "descr": "Lgamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).",
        "name": "math.Lgamma",
        "params": [],
        "path": "go/math/index#Lgamma",
        "syntax": "func Lgamma(x float64) (lgamma float64, sign int)",
        "type": "math"
    },
    "LimitReader": {
        "descr": "LimitReader returns a Reader that reads from r but stops with EOF after n bytes. The underlying implementation is a *LimitedReader.",
        "name": "io.LimitReader",
        "params": [],
        "path": "go/io/index#LimitReader",
        "syntax": "func LimitReader(r Reader, n int64) Reader",
        "type": "io"
    },
    "LimitedReader": {
        "descr": "A LimitedReader reads from R but limits the amount of data returned to just N bytes. Each call to Read updates N to reflect the new amount remaining. Read returns EOF when N <= 0 or when the underlying R returns EOF.",
        "name": "io.LimitedReader",
        "params": [],
        "path": "go/io/index#LimitedReader",
        "syntax": "type LimitedReader struct { R Reader // underlying reader N int64 // max bytes remaining }",
        "type": "io"
    },
    "LimitedReader.Read": {
        "descr": "",
        "name": "io.LimitedReader.Read",
        "params": [],
        "path": "go/io/index#LimitedReader.Read",
        "syntax": "func (l *LimitedReader) Read(p []byte) (n int, err error)",
        "type": "io"
    },
    "Linger": {
        "descr": "",
        "name": "syscall.Linger",
        "params": [],
        "path": "go/syscall/index#Linger",
        "syntax": "type Linger struct { Onoff int32 Linger int32 }",
        "type": "syscall"
    },
    "Link": {
        "descr": "",
        "name": "syscall.Link",
        "params": [],
        "path": "go/syscall/index#Link",
        "syntax": "func Link(oldpath string, newpath string) (err error)",
        "type": "syscall"
    },
    "LinkError": {
        "descr": "LinkError records an error during a link or symlink or rename system call and the paths that caused it.",
        "name": "os.LinkError",
        "params": [],
        "path": "go/os/index#LinkError",
        "syntax": "type LinkError struct { Op string Old string New string Err error }",
        "type": "os"
    },
    "LinkError.Error": {
        "descr": "",
        "name": "os.LinkError.Error",
        "params": [],
        "path": "go/os/index#LinkError.Error",
        "syntax": "func (e *LinkError) Error() string",
        "type": "os"
    },
    "Listen": {
        "descr": "",
        "name": "syscall.Listen",
        "params": [],
        "path": "go/syscall/index#Listen",
        "syntax": "func Listen(s int, n int) (err error)",
        "type": "syscall"
    },
    "ListenConfig": {
        "descr": "ListenConfig contains options for listening to an address.",
        "name": "net.ListenConfig",
        "params": [],
        "path": "go/net/index#ListenConfig",
        "syntax": "type ListenConfig struct { // If Control is not nil, it is called after creating the network // connection but before binding it to the operating system. // // Network and address parameters passed to Control method are not // necessarily the ones passed to Listen. For example, passing \"tcp\" to // Listen will cause the Control function to be called with \"tcp4\" or \"tcp6\". Control func(network, address string, c syscall.RawConn) error }",
        "type": "net"
    },
    "ListenConfig.Listen": {
        "descr": "Listen announces on the local network address.",
        "name": "net.ListenConfig.Listen",
        "params": [],
        "path": "go/net/index#ListenConfig.Listen",
        "syntax": "func (lc *ListenConfig) Listen(ctx context.Context, network, address string) (Listener, error)",
        "type": "net"
    },
    "ListenConfig.ListenPacket": {
        "descr": "ListenPacket announces on the local network address.",
        "name": "net.ListenConfig.ListenPacket",
        "params": [],
        "path": "go/net/index#ListenConfig.ListenPacket",
        "syntax": "func (lc *ListenConfig) ListenPacket(ctx context.Context, network, address string) (PacketConn, error)",
        "type": "net"
    },
    "ListenIP": {
        "descr": "ListenIP acts like ListenPacket for IP networks.",
        "name": "net.ListenIP",
        "params": [],
        "path": "go/net/index#ListenIP",
        "syntax": "func ListenIP(network string, laddr *IPAddr) (*IPConn, error)",
        "type": "net"
    },
    "ListenMulticastUDP": {
        "descr": "ListenMulticastUDP acts like ListenPacket for UDP networks but takes a group address on a specific network interface.",
        "name": "net.ListenMulticastUDP",
        "params": [],
        "path": "go/net/index#ListenMulticastUDP",
        "syntax": "func ListenMulticastUDP(network string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)",
        "type": "net"
    },
    "ListenPacket": {
        "descr": "ListenPacket announces on the local network address.",
        "name": "net.ListenPacket",
        "params": [],
        "path": "go/net/index#ListenPacket",
        "syntax": "func ListenPacket(network, address string) (PacketConn, error)",
        "type": "net"
    },
    "ListenTCP": {
        "descr": "ListenTCP acts like Listen for TCP networks.",
        "name": "net.ListenTCP",
        "params": [],
        "path": "go/net/index#ListenTCP",
        "syntax": "func ListenTCP(network string, laddr *TCPAddr) (*TCPListener, error)",
        "type": "net"
    },
    "ListenUDP": {
        "descr": "ListenUDP acts like ListenPacket for UDP networks.",
        "name": "net.ListenUDP",
        "params": [],
        "path": "go/net/index#ListenUDP",
        "syntax": "func ListenUDP(network string, laddr *UDPAddr) (*UDPConn, error)",
        "type": "net"
    },
    "ListenUnix": {
        "descr": "ListenUnix acts like Listen for Unix networks.",
        "name": "net.ListenUnix",
        "params": [],
        "path": "go/net/index#ListenUnix",
        "syntax": "func ListenUnix(network string, laddr *UnixAddr) (*UnixListener, error)",
        "type": "net"
    },
    "ListenUnixgram": {
        "descr": "ListenUnixgram acts like ListenPacket for Unix networks.",
        "name": "net.ListenUnixgram",
        "params": [],
        "path": "go/net/index#ListenUnixgram",
        "syntax": "func ListenUnixgram(network string, laddr *UnixAddr) (*UnixConn, error)",
        "type": "net"
    },
    "Listener": {
        "descr": "A Listener is a generic network listener for stream-oriented protocols.",
        "name": "net.Listener",
        "params": [],
        "path": "go/net/index#Listener",
        "syntax": "type Listener interface { // Accept waits for and returns the next connection to the listener. Accept() (Conn, error) // Close closes the listener. // Any blocked Accept operations will be unblocked and return errors. Close() error // Addr returns the listener's network address. Addr() Addr }",
        "type": "net"
    },
    "Listxattr": {
        "descr": "",
        "name": "syscall.Listxattr",
        "params": [],
        "path": "go/syscall/index#Listxattr",
        "syntax": "func Listxattr(path string, dest []byte) (sz int, err error)",
        "type": "syscall"
    },
    "LoadLocation": {
        "descr": "LoadLocation returns the Location with the given name.",
        "name": "time.LoadLocation",
        "params": [],
        "path": "go/time/index#LoadLocation",
        "syntax": "func LoadLocation(name string) (*Location, error)",
        "type": "time"
    },
    "LoadLocationFromTZData": {
        "descr": "LoadLocationFromTZData returns a Location with the given name initialized from the IANA Time Zone database-formatted data. The data should be in the format of a standard IANA time zone file (for example, the content of /etc/localtime on Unix systems).",
        "name": "time.LoadLocationFromTZData",
        "params": [],
        "path": "go/time/index#LoadLocationFromTZData",
        "syntax": "func LoadLocationFromTZData(name string, data []byte) (*Location, error)",
        "type": "time"
    },
    "Location": {
        "descr": "A Location maps time instants to the zone in use at that time. Typically, the Location represents the collection of time offsets in use in a geographical area, such as CEST and CET for central Europe.",
        "name": "time.Location",
        "params": [],
        "path": "go/time/index#Location",
        "syntax": "type Location struct { // contains filtered or unexported fields }",
        "type": "time"
    },
    "Location.String": {
        "descr": "String returns a descriptive name for the time zone information, corresponding to the name argument to LoadLocation or FixedZone.",
        "name": "time.Location.String",
        "params": [],
        "path": "go/time/index#Location.String",
        "syntax": "func (l *Location) String() string",
        "type": "time"
    },
    "LockOSThread": {
        "descr": "LockOSThread wires the calling goroutine to its current operating system thread. The calling goroutine will always execute in that thread, and no other goroutine will execute in it, until the calling goroutine has made as many calls to UnlockOSThread as to LockOSThread. If the calling goroutine exits without unlocking the thread, the thread will be terminated.",
        "name": "runtime.LockOSThread",
        "params": [],
        "path": "go/runtime/index#LockOSThread",
        "syntax": "func LockOSThread()",
        "type": "runtime"
    },
    "Locker": {
        "descr": "A Locker represents an object that can be locked and unlocked.",
        "name": "sync.Locker",
        "params": [],
        "path": "go/sync/index#Locker",
        "syntax": "type Locker interface { Lock() Unlock() }",
        "type": "sync"
    },
    "Log": {
        "descr": "Log returns the natural logarithm of x.",
        "name": "math.Log",
        "params": [],
        "path": "go/math/index#Log",
        "syntax": "func Log(x float64) float64",
        "type": "math"
    },
    "Log10": {
        "descr": "Log10 returns the decimal logarithm of x. The special cases are the same as for Log.",
        "name": "math.Log10",
        "params": [],
        "path": "go/math/index#Log10",
        "syntax": "func Log10(x float64) float64",
        "type": "math"
    },
    "Log1p": {
        "descr": "Log1p returns the natural logarithm of 1 plus its argument x. It is more accurate than Log(1 + x) when x is near zero.",
        "name": "math.Log1p",
        "params": [],
        "path": "go/math/index#Log1p",
        "syntax": "func Log1p(x float64) float64",
        "type": "math"
    },
    "Log2": {
        "descr": "Log2 returns the binary logarithm of x. The special cases are the same as for Log.",
        "name": "math.Log2",
        "params": [],
        "path": "go/math/index#Log2",
        "syntax": "func Log2(x float64) float64",
        "type": "math"
    },
    "Logb": {
        "descr": "Logb returns the binary exponent of x.",
        "name": "math.Logb",
        "params": [],
        "path": "go/math/index#Logb",
        "syntax": "func Logb(x float64) float64",
        "type": "math"
    },
    "Logger": {
        "descr": "A Logger represents an active logging object that generates lines of output to an io.Writer. Each logging operation makes a single call to the Writer's Write method. A Logger can be used simultaneously from multiple goroutines; it guarantees to serialize access to the Writer.",
        "name": "log.Logger",
        "params": [],
        "path": "go/log/index#Logger",
        "syntax": "type Logger struct { // contains filtered or unexported fields }",
        "type": "log"
    },
    "Logger.Fatal": {
        "descr": "Fatal is equivalent to l.Print() followed by a call to os.Exit(1).",
        "name": "log.Logger.Fatal",
        "params": [],
        "path": "go/log/index#Logger.Fatal",
        "syntax": "func (l *Logger) Fatal(v ...interface{})",
        "type": "log"
    },
    "Logger.Fatalf": {
        "descr": "Fatalf is equivalent to l.Printf() followed by a call to os.Exit(1).",
        "name": "log.Logger.Fatalf",
        "params": [],
        "path": "go/log/index#Logger.Fatalf",
        "syntax": "func (l *Logger) Fatalf(format string, v ...interface{})",
        "type": "log"
    },
    "Logger.Fatalln": {
        "descr": "Fatalln is equivalent to l.Println() followed by a call to os.Exit(1).",
        "name": "log.Logger.Fatalln",
        "params": [],
        "path": "go/log/index#Logger.Fatalln",
        "syntax": "func (l *Logger) Fatalln(v ...interface{})",
        "type": "log"
    },
    "Logger.Flags": {
        "descr": "Flags returns the output flags for the logger.",
        "name": "log.Logger.Flags",
        "params": [],
        "path": "go/log/index#Logger.Flags",
        "syntax": "func (l *Logger) Flags() int",
        "type": "log"
    },
    "Logger.Output": {
        "descr": "Output writes the output for a logging event. The string s contains the text to print after the prefix specified by the flags of the Logger. A newline is appended if the last character of s is not already a newline. Calldepth is used to recover the PC and is provided for generality, although at the moment on all pre-defined paths it will be 2.",
        "name": "log.Logger.Output",
        "params": [],
        "path": "go/log/index#Logger.Output",
        "syntax": "func (l *Logger) Output(calldepth int, s string) error",
        "type": "log"
    },
    "Logger.Panic": {
        "descr": "Panic is equivalent to l.Print() followed by a call to panic().",
        "name": "log.Logger.Panic",
        "params": [],
        "path": "go/log/index#Logger.Panic",
        "syntax": "func (l *Logger) Panic(v ...interface{})",
        "type": "log"
    },
    "Logger.Panicf": {
        "descr": "Panicf is equivalent to l.Printf() followed by a call to panic().",
        "name": "log.Logger.Panicf",
        "params": [],
        "path": "go/log/index#Logger.Panicf",
        "syntax": "func (l *Logger) Panicf(format string, v ...interface{})",
        "type": "log"
    },
    "Logger.Panicln": {
        "descr": "Panicln is equivalent to l.Println() followed by a call to panic().",
        "name": "log.Logger.Panicln",
        "params": [],
        "path": "go/log/index#Logger.Panicln",
        "syntax": "func (l *Logger) Panicln(v ...interface{})",
        "type": "log"
    },
    "Logger.Prefix": {
        "descr": "Prefix returns the output prefix for the logger.",
        "name": "log.Logger.Prefix",
        "params": [],
        "path": "go/log/index#Logger.Prefix",
        "syntax": "func (l *Logger) Prefix() string",
        "type": "log"
    },
    "Logger.Print": {
        "descr": "Print calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Print.",
        "name": "log.Logger.Print",
        "params": [],
        "path": "go/log/index#Logger.Print",
        "syntax": "func (l *Logger) Print(v ...interface{})",
        "type": "log"
    },
    "Logger.Printf": {
        "descr": "Printf calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Printf.",
        "name": "log.Logger.Printf",
        "params": [],
        "path": "go/log/index#Logger.Printf",
        "syntax": "func (l *Logger) Printf(format string, v ...interface{})",
        "type": "log"
    },
    "Logger.Println": {
        "descr": "Println calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Println.",
        "name": "log.Logger.Println",
        "params": [],
        "path": "go/log/index#Logger.Println",
        "syntax": "func (l *Logger) Println(v ...interface{})",
        "type": "log"
    },
    "Logger.SetFlags": {
        "descr": "SetFlags sets the output flags for the logger.",
        "name": "log.Logger.SetFlags",
        "params": [],
        "path": "go/log/index#Logger.SetFlags",
        "syntax": "func (l *Logger) SetFlags(flag int)",
        "type": "log"
    },
    "Logger.SetOutput": {
        "descr": "SetOutput sets the output destination for the logger.",
        "name": "log.Logger.SetOutput",
        "params": [],
        "path": "go/log/index#Logger.SetOutput",
        "syntax": "func (l *Logger) SetOutput(w io.Writer)",
        "type": "log"
    },
    "Logger.SetPrefix": {
        "descr": "SetPrefix sets the output prefix for the logger.",
        "name": "log.Logger.SetPrefix",
        "params": [],
        "path": "go/log/index#Logger.SetPrefix",
        "syntax": "func (l *Logger) SetPrefix(prefix string)",
        "type": "log"
    },
    "Lookup": {
        "descr": "Lookup returns the Flag structure of the named command-line flag, returning nil if none exists.",
        "name": "flag.Lookup",
        "params": [],
        "path": "go/flag/index#Lookup",
        "syntax": "func Lookup(name string) *Flag",
        "type": "flag"
    },
    "LookupAddr": {
        "descr": "LookupAddr performs a reverse lookup for the given address, returning a list of names mapping to that address.",
        "name": "net.LookupAddr",
        "params": [],
        "path": "go/net/index#LookupAddr",
        "syntax": "func LookupAddr(addr string) (names []string, err error)",
        "type": "net"
    },
    "LookupCNAME": {
        "descr": "LookupCNAME returns the canonical name for the given host. Callers that do not care about the canonical name can call LookupHost or LookupIP directly; both take care of resolving the canonical name as part of the lookup.",
        "name": "net.LookupCNAME",
        "params": [],
        "path": "go/net/index#LookupCNAME",
        "syntax": "func LookupCNAME(host string) (cname string, err error)",
        "type": "net"
    },
    "LookupEnv": {
        "descr": "LookupEnv retrieves the value of the environment variable named by the key. If the variable is present in the environment the value (which may be empty) is returned and the boolean is true. Otherwise the returned value will be empty and the boolean will be false.",
        "name": "os.LookupEnv",
        "params": [],
        "path": "go/os/index#LookupEnv",
        "syntax": "func LookupEnv(key string) (string, bool)",
        "type": "os"
    },
    "LookupHost": {
        "descr": "LookupHost looks up the given host using the local resolver. It returns a slice of that host's addresses.",
        "name": "net.LookupHost",
        "params": [],
        "path": "go/net/index#LookupHost",
        "syntax": "func LookupHost(host string) (addrs []string, err error)",
        "type": "net"
    },
    "LookupIP": {
        "descr": "LookupIP looks up host using the local resolver. It returns a slice of that host's IPv4 and IPv6 addresses.",
        "name": "net.LookupIP",
        "params": [],
        "path": "go/net/index#LookupIP",
        "syntax": "func LookupIP(host string) ([]IP, error)",
        "type": "net"
    },
    "LookupMX": {
        "descr": "LookupMX returns the DNS MX records for the given domain name sorted by preference.",
        "name": "net.LookupMX",
        "params": [],
        "path": "go/net/index#LookupMX",
        "syntax": "func LookupMX(name string) ([]*MX, error)",
        "type": "net"
    },
    "LookupNS": {
        "descr": "LookupNS returns the DNS NS records for the given domain name.",
        "name": "net.LookupNS",
        "params": [],
        "path": "go/net/index#LookupNS",
        "syntax": "func LookupNS(name string) ([]*NS, error)",
        "type": "net"
    },
    "LookupPort": {
        "descr": "LookupPort looks up the port for the given network and service.",
        "name": "net.LookupPort",
        "params": [],
        "path": "go/net/index#LookupPort",
        "syntax": "func LookupPort(network, service string) (port int, err error)",
        "type": "net"
    },
    "LookupSRV": {
        "descr": "LookupSRV tries to resolve an SRV query of the given service, protocol, and domain name. The proto is \"tcp\" or \"udp\". The returned records are sorted by priority and randomized by weight within a priority.",
        "name": "net.LookupSRV",
        "params": [],
        "path": "go/net/index#LookupSRV",
        "syntax": "func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error)",
        "type": "net"
    },
    "LookupTXT": {
        "descr": "LookupTXT returns the DNS TXT records for the given domain name.",
        "name": "net.LookupTXT",
        "params": [],
        "path": "go/net/index#LookupTXT",
        "syntax": "func LookupTXT(name string) ([]string, error)",
        "type": "net"
    },
    "LsfJump": {
        "descr": "Deprecated: Use golang.org/x/net/bpf instead.",
        "name": "syscall.LsfJump",
        "params": [],
        "path": "go/syscall/index#LsfJump",
        "syntax": "func LsfJump(code, k, jt, jf int) *SockFilter",
        "type": "syscall"
    },
    "LsfSocket": {
        "descr": "Deprecated: Use golang.org/x/net/bpf instead.",
        "name": "syscall.LsfSocket",
        "params": [],
        "path": "go/syscall/index#LsfSocket",
        "syntax": "func LsfSocket(ifindex, proto int) (int, error)",
        "type": "syscall"
    },
    "LsfStmt": {
        "descr": "Deprecated: Use golang.org/x/net/bpf instead.",
        "name": "syscall.LsfStmt",
        "params": [],
        "path": "go/syscall/index#LsfStmt",
        "syntax": "func LsfStmt(code, k int) *SockFilter",
        "type": "syscall"
    },
    "Lstat": {
        "descr": "",
        "name": "syscall.Lstat",
        "params": [],
        "path": "go/syscall/index#Lstat",
        "syntax": "func Lstat(path string, stat *Stat_t) (err error)",
        "type": "syscall"
    },
    "M": {
        "descr": "M is a type passed to a TestMain function to run the actual tests.",
        "name": "testing.M",
        "params": [],
        "path": "go/testing/index#M",
        "syntax": "type M struct { // contains filtered or unexported fields }",
        "type": "testing"
    },
    "M.Run": {
        "descr": "Run runs the tests. It returns an exit code to pass to os.Exit.",
        "name": "testing.M.Run",
        "params": [],
        "path": "go/testing/index#M.Run",
        "syntax": "func (m *M) Run() int",
        "type": "testing"
    },
    "MX": {
        "descr": "An MX represents a single DNS MX record.",
        "name": "net.MX",
        "params": [],
        "path": "go/net/index#MX",
        "syntax": "type MX struct { Host string Pref uint16 }",
        "type": "net"
    },
    "Madvise": {
        "descr": "",
        "name": "syscall.Madvise",
        "params": [],
        "path": "go/syscall/index#Madvise",
        "syntax": "func Madvise(b []byte, advice int) (err error)",
        "type": "syscall"
    },
    "Main": {
        "descr": "Main is an internal function, part of the implementation of the \"go test\" command. It was exported because it is cross-package and predates \"internal\" packages. It is no longer used by \"go test\" but preserved, as much as possible, for other systems that simulate \"go test\" using Main, but Main sometimes cannot be updated as new functionality is added to the testing package. Systems simulating \"go test\" should be updated to use MainStart.",
        "name": "testing.Main",
        "params": [],
        "path": "go/testing/index#Main",
        "syntax": "func Main(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)",
        "type": "testing"
    },
    "MainStart": {
        "descr": "MainStart is meant for use by tests generated by 'go test'. It is not meant to be called directly and is not subject to the Go 1 compatibility document. It may change signature from release to release.",
        "name": "testing.MainStart",
        "params": [],
        "path": "go/testing/index#MainStart",
        "syntax": "func MainStart(deps testDeps, tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample) *M",
        "type": "testing"
    },
    "MakeChan": {
        "descr": "MakeChan creates a new channel with the specified type and buffer size.",
        "name": "reflect.MakeChan",
        "params": [],
        "path": "go/reflect/index#MakeChan",
        "syntax": "func MakeChan(typ Type, buffer int) Value",
        "type": "reflect"
    },
    "MakeFunc": {
        "descr": "MakeFunc returns a new function of the given Type that wraps the function fn. When called, that new function does the following:",
        "name": "reflect.MakeFunc",
        "params": [],
        "path": "go/reflect/index#MakeFunc",
        "syntax": "func MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value",
        "type": "reflect"
    },
    "MakeMap": {
        "descr": "MakeMap creates a new map with the specified type.",
        "name": "reflect.MakeMap",
        "params": [],
        "path": "go/reflect/index#MakeMap",
        "syntax": "func MakeMap(typ Type) Value",
        "type": "reflect"
    },
    "MakeMapWithSize": {
        "descr": "MakeMapWithSize creates a new map with the specified type and initial space for approximately n elements.",
        "name": "reflect.MakeMapWithSize",
        "params": [],
        "path": "go/reflect/index#MakeMapWithSize",
        "syntax": "func MakeMapWithSize(typ Type, n int) Value",
        "type": "reflect"
    },
    "MakeSlice": {
        "descr": "MakeSlice creates a new zero-initialized slice value for the specified slice type, length, and capacity.",
        "name": "reflect.MakeSlice",
        "params": [],
        "path": "go/reflect/index#MakeSlice",
        "syntax": "func MakeSlice(typ Type, len, cap int) Value",
        "type": "reflect"
    },
    "Map": {
        "descr": "Map is like a Go map[interface{}]interface{} but is safe for concurrent use by multiple goroutines without additional locking or coordination. Loads, stores, and deletes run in amortized constant time.",
        "name": "sync.Map",
        "params": [],
        "path": "go/sync/index#Map",
        "syntax": "type Map struct { // contains filtered or unexported fields }",
        "type": "sync"
    },
    "Map.Add": {
        "descr": "Add adds delta to the *Int value stored under the given map key.",
        "name": "expvar.Map.Add",
        "params": [],
        "path": "go/expvar/index#Map.Add",
        "syntax": "func (v *Map) Add(key string, delta int64)",
        "type": "expvar"
    },
    "Map.AddFloat": {
        "descr": "AddFloat adds delta to the *Float value stored under the given map key.",
        "name": "expvar.Map.AddFloat",
        "params": [],
        "path": "go/expvar/index#Map.AddFloat",
        "syntax": "func (v *Map) AddFloat(key string, delta float64)",
        "type": "expvar"
    },
    "Map.Delete": {
        "descr": "Delete deletes the value for a key.",
        "name": "sync.Map.Delete",
        "params": [],
        "path": "go/sync/index#Map.Delete",
        "syntax": "func (m *Map) Delete(key interface{})",
        "type": "sync"
    },
    "Map.Do": {
        "descr": "Do calls f for each entry in the map. The map is locked during the iteration, but existing entries may be concurrently updated.",
        "name": "expvar.Map.Do",
        "params": [],
        "path": "go/expvar/index#Map.Do",
        "syntax": "func (v *Map) Do(f func(KeyValue))",
        "type": "expvar"
    },
    "Map.Get": {
        "descr": "",
        "name": "expvar.Map.Get",
        "params": [],
        "path": "go/expvar/index#Map.Get",
        "syntax": "func (v *Map) Get(key string) Var",
        "type": "expvar"
    },
    "Map.Init": {
        "descr": "Init removes all keys from the map.",
        "name": "expvar.Map.Init",
        "params": [],
        "path": "go/expvar/index#Map.Init",
        "syntax": "func (v *Map) Init() *Map",
        "type": "expvar"
    },
    "Map.Load": {
        "descr": "Load returns the value stored in the map for a key, or nil if no value is present. The ok result indicates whether value was found in the map.",
        "name": "sync.Map.Load",
        "params": [],
        "path": "go/sync/index#Map.Load",
        "syntax": "func (m *Map) Load(key interface{}) (value interface{}, ok bool)",
        "type": "sync"
    },
    "Map.LoadOrStore": {
        "descr": "LoadOrStore returns the existing value for the key if present. Otherwise, it stores and returns the given value. The loaded result is true if the value was loaded, false if stored.",
        "name": "sync.Map.LoadOrStore",
        "params": [],
        "path": "go/sync/index#Map.LoadOrStore",
        "syntax": "func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)",
        "type": "sync"
    },
    "Map.Range": {
        "descr": "Range calls f sequentially for each key and value present in the map. If f returns false, range stops the iteration.",
        "name": "sync.Map.Range",
        "params": [],
        "path": "go/sync/index#Map.Range",
        "syntax": "func (m *Map) Range(f func(key, value interface{}) bool)",
        "type": "sync"
    },
    "Map.Set": {
        "descr": "",
        "name": "expvar.Map.Set",
        "params": [],
        "path": "go/expvar/index#Map.Set",
        "syntax": "func (v *Map) Set(key string, av Var)",
        "type": "expvar"
    },
    "Map.Store": {
        "descr": "Store sets the value for a key.",
        "name": "sync.Map.Store",
        "params": [],
        "path": "go/sync/index#Map.Store",
        "syntax": "func (m *Map) Store(key, value interface{})",
        "type": "sync"
    },
    "Map.String": {
        "descr": "",
        "name": "expvar.Map.String",
        "params": [],
        "path": "go/expvar/index#Map.String",
        "syntax": "func (v *Map) String() string",
        "type": "expvar"
    },
    "MapOf": {
        "descr": "MapOf returns the map type with the given key and element types. For example, if k represents int and e represents string, MapOf(k, e) represents map[int]string.",
        "name": "reflect.MapOf",
        "params": [],
        "path": "go/reflect/index#MapOf",
        "syntax": "func MapOf(key, elem Type) Type",
        "type": "reflect"
    },
    "Match": {
        "descr": "MatchString reports whether the byte slice b contains any match of the regular expression pattern. More complicated queries need to use Compile and the full Regexp interface.",
        "name": "regexp.Match",
        "params": [],
        "path": "go/regexp/index#Match",
        "syntax": "func Match(pattern string, b []byte) (matched bool, err error)",
        "type": "regexp"
    },
    "MatchReader": {
        "descr": "MatchReader reports whether the text returned by the RuneReader contains any match of the regular expression pattern. More complicated queries need to use Compile and the full Regexp interface.",
        "name": "regexp.MatchReader",
        "params": [],
        "path": "go/regexp/index#MatchReader",
        "syntax": "func MatchReader(pattern string, r io.RuneReader) (matched bool, err error)",
        "type": "regexp"
    },
    "MatchString": {
        "descr": "MatchString reports whether the string s contains any match of the regular expression pattern. More complicated queries need to use Compile and the full Regexp interface.",
        "name": "regexp.MatchString",
        "params": [],
        "path": "go/regexp/index#MatchString",
        "syntax": "func MatchString(pattern string, s string) (matched bool, err error)",
        "type": "regexp"
    },
    "Max": {
        "descr": "Max returns the larger of x or y.",
        "name": "math.Max",
        "params": [],
        "path": "go/math/index#Max",
        "syntax": "func Max(x, y float64) float64",
        "type": "math"
    },
    "MemProfile": {
        "descr": "MemProfile returns a profile of memory allocated and freed per allocation site.",
        "name": "runtime.MemProfile",
        "params": [],
        "path": "go/runtime/index#MemProfile",
        "syntax": "func MemProfile(p []MemProfileRecord, inuseZero bool) (n int, ok bool)",
        "type": "runtime"
    },
    "MemProfileRecord": {
        "descr": "A MemProfileRecord describes the live objects allocated by a particular call sequence (stack trace).",
        "name": "runtime.MemProfileRecord",
        "params": [],
        "path": "go/runtime/index#MemProfileRecord",
        "syntax": "type MemProfileRecord struct { AllocBytes, FreeBytes int64 // number of bytes allocated, freed AllocObjects, FreeObjects int64 // number of objects allocated, freed Stack0 [32]uintptr // stack trace for this record; ends at first 0 entry }",
        "type": "runtime"
    },
    "MemProfileRecord.InUseBytes": {
        "descr": "InUseBytes returns the number of bytes in use (AllocBytes - FreeBytes).",
        "name": "runtime.MemProfileRecord.InUseBytes",
        "params": [],
        "path": "go/runtime/index#MemProfileRecord.InUseBytes",
        "syntax": "func (r *MemProfileRecord) InUseBytes() int64",
        "type": "runtime"
    },
    "MemProfileRecord.InUseObjects": {
        "descr": "InUseObjects returns the number of objects in use (AllocObjects - FreeObjects).",
        "name": "runtime.MemProfileRecord.InUseObjects",
        "params": [],
        "path": "go/runtime/index#MemProfileRecord.InUseObjects",
        "syntax": "func (r *MemProfileRecord) InUseObjects() int64",
        "type": "runtime"
    },
    "MemProfileRecord.Stack": {
        "descr": "Stack returns the stack trace associated with the record, a prefix of r.Stack0.",
        "name": "runtime.MemProfileRecord.Stack",
        "params": [],
        "path": "go/runtime/index#MemProfileRecord.Stack",
        "syntax": "func (r *MemProfileRecord) Stack() []uintptr",
        "type": "runtime"
    },
    "MemStats": {
        "descr": "A MemStats records statistics about the memory allocator.",
        "name": "runtime.MemStats",
        "params": [],
        "path": "go/runtime/index#MemStats",
        "syntax": "type MemStats struct { // Alloc is bytes of allocated heap objects. // // This is the same as HeapAlloc (see below). Alloc uint64 // TotalAlloc is cumulative bytes allocated for heap objects. // // TotalAlloc increases as heap objects are allocated, but // unlike Alloc and HeapAlloc, it does not decrease when // objects are freed. TotalAlloc uint64 // Sys is the total bytes of memory obtained from the OS. // // Sys is the sum of the XSys fields below. Sys measures the // virtual address space reserved by the Go runtime for the // heap, stacks, and other internal data structures. It's // likely that not all of the virtual address space is backed // by physical memory at any given moment, though in general // it all was at some point. Sys uint64 // Lookups is the number of pointer lookups performed by the // runtime. // // This is primarily useful for debugging runtime internals. Lookups uint64 // Mallocs is the cumulative count of heap objects allocated. // The number of live objects is Mallocs - Frees. Mallocs uint64 // Frees is the cumulative count of heap objects freed. Frees uint64 // HeapAlloc is bytes of allocated heap objects. // // \"Allocated\" heap objects include all reachable objects, as // well as unreachable objects that the garbage collector has // not yet freed. Specifically, HeapAlloc increases as heap // objects are allocated and decreases as the heap is swept // and unreachable objects are freed. Sweeping occurs // incrementally between GC cycles, so these two processes // occur simultaneously, and as a result HeapAlloc tends to // change smoothly (in contrast with the sawtooth that is // typical of stop-the-world garbage collectors). HeapAlloc uint64 // HeapSys is bytes of heap memory obtained from the OS. // // HeapSys measures the amount of virtual address space // reserved for the heap. This includes virtual address space // that has been reserved but not yet used, which consumes no // physical memory, but tends to be small, as well as virtual // address space for which the physical memory has been // returned to the OS after it became unused (see HeapReleased // for a measure of the latter). // // HeapSys estimates the largest size the heap has had. HeapSys uint64 // HeapIdle is bytes in idle (unused) spans. // // Idle spans have no objects in them. These spans could be // (and may already have been) returned to the OS, or they can // be reused for heap allocations, or they can be reused as // stack memory. // // HeapIdle minus HeapReleased estimates the amount of memory // that could be returned to the OS, but is being retained by // the runtime so it can grow the heap without requesting more // memory from the OS. If this difference is significantly // larger than the heap size, it indicates there was a recent // transient spike in live heap size. HeapIdle uint64 // HeapInuse is bytes in in-use spans. // // In-use spans have at least one object in them. These spans // can only be used for other objects of roughly the same // size. // // HeapInuse minus HeapAlloc estimates the amount of memory // that has been dedicated to particular size classes, but is // not currently being used. This is an upper bound on // fragmentation, but in general this memory can be reused // efficiently. HeapInuse uint64 // HeapReleased is bytes of physical memory returned to the OS. // // This counts heap memory from idle spans that was returned // to the OS and has not yet been reacquired for the heap. HeapReleased uint64 // HeapObjects is the number of allocated heap objects. // // Like HeapAlloc, this increases as objects are allocated and // decreases as the heap is swept and unreachable objects are // freed. HeapObjects uint64 // StackInuse is bytes in stack spans. // // In-use stack spans have at least one stack in them. These // spans can only be used for other stacks of the same size. // // There is no StackIdle because unused stack spans are // returned to the heap (and hence counted toward HeapIdle). StackInuse uint64 // StackSys is bytes of stack memory obtained from the OS. // // StackSys is StackInuse, plus any memory obtained directly // from the OS for OS thread stacks (which should be minimal). StackSys uint64 // MSpanInuse is bytes of allocated mspan structures. MSpanInuse uint64 // MSpanSys is bytes of memory obtained from the OS for mspan // structures. MSpanSys uint64 // MCacheInuse is bytes of allocated mcache structures. MCacheInuse uint64 // MCacheSys is bytes of memory obtained from the OS for // mcache structures. MCacheSys uint64 // BuckHashSys is bytes of memory in profiling bucket hash tables. BuckHashSys uint64 // GCSys is bytes of memory in garbage collection metadata. GCSys uint64 // Go 1.2 // OtherSys is bytes of memory in miscellaneous off-heap // runtime allocations. OtherSys uint64 // Go 1.2 // NextGC is the target heap size of the next GC cycle. // // The garbage collector's goal is to keep HeapAlloc  NextGC. // At the end of each GC cycle, the target for the next cycle // is computed based on the amount of reachable data and the // value of GOGC. NextGC uint64 // LastGC is the time the last garbage collection finished, as // nanoseconds since 1970 (the UNIX epoch). LastGC uint64 // PauseTotalNs is the cumulative nanoseconds in GC // stop-the-world pauses since the program started. // // During a stop-the-world pause, all goroutines are paused // and only the garbage collector can run. PauseTotalNs uint64 // PauseNs is a circular buffer of recent GC stop-the-world // pause times in nanoseconds. // // The most recent pause is at PauseNs[(NumGC+255)%256]. In // general, PauseNs[N%256] records the time paused in the most // recent N%256th GC cycle. There may be multiple pauses per // GC cycle; this is the sum of all pauses during a cycle. PauseNs [256]uint64 // PauseEnd is a circular buffer of recent GC pause end times, // as nanoseconds since 1970 (the UNIX epoch). // // This buffer is filled the same way as PauseNs. There may be // multiple pauses per GC cycle; this records the end of the // last pause in a cycle. PauseEnd [256]uint64 // Go 1.4 // NumGC is the number of completed GC cycles. NumGC uint32 // NumForcedGC is the number of GC cycles that were forced by // the application calling the GC function. NumForcedGC uint32 // Go 1.8 // GCCPUFraction is the fraction of this program's available // CPU time used by the GC since the program started. // // GCCPUFraction is expressed as a number between 0 and 1, // where 0 means GC has consumed none of this program's CPU. A // program's available CPU time is defined as the integral of // GOMAXPROCS since the program started. That is, if // GOMAXPROCS is 2 and a program has been running for 10 // seconds, its \"available CPU\" is 20 seconds. GCCPUFraction // does not include CPU time used for write barrier activity. // // This is the same as the fraction of CPU reported by // GODEBUG=gctrace=1. GCCPUFraction float64 // Go 1.5 // EnableGC indicates that GC is enabled. It is always true, // even if GOGC=off. EnableGC bool // DebugGC is currently unused. DebugGC bool // BySize reports per-size class allocation statistics. // // BySize[N] gives statistics for allocations of size S where // BySize[N-1].Size < S  BySize[N].Size. // // This does not report allocations larger than BySize[60].Size. BySize [61]struct { // Size is the maximum byte size of an object in this // size class. Size uint32 // Mallocs is the cumulative count of heap objects // allocated in this size class. The cumulative bytes // of allocation is Size*Mallocs. The number of live // objects in this size class is Mallocs - Frees. Mallocs uint64 // Frees is the cumulative count of heap objects freed // in this size class. Frees uint64 } }",
        "type": "runtime"
    },
    "Method": {
        "descr": "Method represents a single method.",
        "name": "reflect.Method",
        "params": [],
        "path": "go/reflect/index#Method",
        "syntax": "type Method struct { // Name is the method name. // PkgPath is the package path that qualifies a lower case (unexported) // method name. It is empty for upper case (exported) method names. // The combination of PkgPath and Name uniquely identifies a method // in a method set. // See https://golang.org/ref/spec#Uniqueness_of_identifiers Name string PkgPath string Type Type // method type Func Value // func with receiver as first argument Index int // index for Type.Method }",
        "type": "reflect"
    },
    "Min": {
        "descr": "Min returns the smaller of x or y.",
        "name": "math.Min",
        "params": [],
        "path": "go/math/index#Min",
        "syntax": "func Min(x, y float64) float64",
        "type": "math"
    },
    "Mkdir": {
        "descr": "",
        "name": "syscall.Mkdir",
        "params": [],
        "path": "go/syscall/index#Mkdir",
        "syntax": "func Mkdir(path string, mode uint32) (err error)",
        "type": "syscall"
    },
    "MkdirAll": {
        "descr": "MkdirAll creates a directory named path, along with any necessary parents, and returns nil, or else returns an error. The permission bits perm (before umask) are used for all directories that MkdirAll creates. If path is already a directory, MkdirAll does nothing and returns nil.",
        "name": "os.MkdirAll",
        "params": [],
        "path": "go/os/index#MkdirAll",
        "syntax": "func MkdirAll(path string, perm FileMode) error",
        "type": "os"
    },
    "Mkdirat": {
        "descr": "",
        "name": "syscall.Mkdirat",
        "params": [],
        "path": "go/syscall/index#Mkdirat",
        "syntax": "func Mkdirat(dirfd int, path string, mode uint32) (err error)",
        "type": "syscall"
    },
    "Mkfifo": {
        "descr": "",
        "name": "syscall.Mkfifo",
        "params": [],
        "path": "go/syscall/index#Mkfifo",
        "syntax": "func Mkfifo(path string, mode uint32) (err error)",
        "type": "syscall"
    },
    "Mknod": {
        "descr": "",
        "name": "syscall.Mknod",
        "params": [],
        "path": "go/syscall/index#Mknod",
        "syntax": "func Mknod(path string, mode uint32, dev int) (err error)",
        "type": "syscall"
    },
    "Mknodat": {
        "descr": "",
        "name": "syscall.Mknodat",
        "params": [],
        "path": "go/syscall/index#Mknodat",
        "syntax": "func Mknodat(dirfd int, path string, mode uint32, dev int) (err error)",
        "type": "syscall"
    },
    "Mlock": {
        "descr": "",
        "name": "syscall.Mlock",
        "params": [],
        "path": "go/syscall/index#Mlock",
        "syntax": "func Mlock(b []byte) (err error)",
        "type": "syscall"
    },
    "Mlockall": {
        "descr": "",
        "name": "syscall.Mlockall",
        "params": [],
        "path": "go/syscall/index#Mlockall",
        "syntax": "func Mlockall(flags int) (err error)",
        "type": "syscall"
    },
    "Mmap": {
        "descr": "",
        "name": "syscall.Mmap",
        "params": [],
        "path": "go/syscall/index#Mmap",
        "syntax": "func Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, err error)",
        "type": "syscall"
    },
    "Mod": {
        "descr": "Mod returns the floating-point remainder of x/y. The magnitude of the result is less than y and its sign agrees with that of x.",
        "name": "math.Mod",
        "params": [],
        "path": "go/math/index#Mod",
        "syntax": "func Mod(x, y float64) float64",
        "type": "math"
    },
    "Modf": {
        "descr": "Modf returns integer and fractional floating-point numbers that sum to f. Both values have the same sign as f.",
        "name": "math.Modf",
        "params": [],
        "path": "go/math/index#Modf",
        "syntax": "func Modf(f float64) (int float64, frac float64)",
        "type": "math"
    },
    "Month": {
        "descr": "A Month specifies a month of the year (January = 1, ...).",
        "name": "time.Month",
        "params": [],
        "path": "go/time/index#Month",
        "syntax": "type Month int",
        "type": "time"
    },
    "Month.String": {
        "descr": "String returns the English name of the month (\"January\", \"February\", ...).",
        "name": "time.Month.String",
        "params": [],
        "path": "go/time/index#Month.String",
        "syntax": "func (m Month) String() string",
        "type": "time"
    },
    "Mprotect": {
        "descr": "",
        "name": "syscall.Mprotect",
        "params": [],
        "path": "go/syscall/index#Mprotect",
        "syntax": "func Mprotect(b []byte, prot int) (err error)",
        "type": "syscall"
    },
    "Msghdr": {
        "descr": "",
        "name": "syscall.Msghdr",
        "params": [],
        "path": "go/syscall/index#Msghdr",
        "syntax": "type Msghdr struct { Name *byte Namelen uint32 Pad_cgo_0 [4]byte Iov *Iovec Iovlen uint64 Control *byte Controllen uint64 Flags int32 Pad_cgo_1 [4]byte }",
        "type": "syscall"
    },
    "Msghdr.SetControllen": {
        "descr": "",
        "name": "syscall.Msghdr.SetControllen",
        "params": [],
        "path": "go/syscall/index#Msghdr.SetControllen",
        "syntax": "func (msghdr *Msghdr) SetControllen(length int)",
        "type": "syscall"
    },
    "MultiReader": {
        "descr": "MultiReader returns a Reader that's the logical concatenation of the provided input readers. They're read sequentially. Once all inputs have returned EOF, Read will return EOF. If any of the readers return a non-nil, non-EOF error, Read will return that error.",
        "name": "io.MultiReader",
        "params": [],
        "path": "go/io/index#MultiReader",
        "syntax": "func MultiReader(readers ...Reader) Reader",
        "type": "io"
    },
    "MultiWriter": {
        "descr": "MultiWriter creates a writer that duplicates its writes to all the provided writers, similar to the Unix tee(1) command.",
        "name": "io.MultiWriter",
        "params": [],
        "path": "go/io/index#MultiWriter",
        "syntax": "func MultiWriter(writers ...Writer) Writer",
        "type": "io"
    },
    "Munlock": {
        "descr": "",
        "name": "syscall.Munlock",
        "params": [],
        "path": "go/syscall/index#Munlock",
        "syntax": "func Munlock(b []byte) (err error)",
        "type": "syscall"
    },
    "Munlockall": {
        "descr": "",
        "name": "syscall.Munlockall",
        "params": [],
        "path": "go/syscall/index#Munlockall",
        "syntax": "func Munlockall() (err error)",
        "type": "syscall"
    },
    "Munmap": {
        "descr": "",
        "name": "syscall.Munmap",
        "params": [],
        "path": "go/syscall/index#Munmap",
        "syntax": "func Munmap(b []byte) (err error)",
        "type": "syscall"
    },
    "MustCompile": {
        "descr": "MustCompile is like Compile but panics if the expression cannot be parsed. It simplifies safe initialization of global variables holding compiled regular expressions.",
        "name": "regexp.MustCompile",
        "params": [],
        "path": "go/regexp/index#MustCompile",
        "syntax": "func MustCompile(str string) *Regexp",
        "type": "regexp"
    },
    "MustCompilePOSIX": {
        "descr": "MustCompilePOSIX is like CompilePOSIX but panics if the expression cannot be parsed. It simplifies safe initialization of global variables holding compiled regular expressions.",
        "name": "regexp.MustCompilePOSIX",
        "params": [],
        "path": "go/regexp/index#MustCompilePOSIX",
        "syntax": "func MustCompilePOSIX(str string) *Regexp",
        "type": "regexp"
    },
    "Mutex": {
        "descr": "A Mutex is a mutual exclusion lock. The zero value for a Mutex is an unlocked mutex.",
        "name": "sync.Mutex",
        "params": [],
        "path": "go/sync/index#Mutex",
        "syntax": "type Mutex struct { // contains filtered or unexported fields }",
        "type": "sync"
    },
    "Mutex.Lock": {
        "descr": "Lock locks m. If the lock is already in use, the calling goroutine blocks until the mutex is available.",
        "name": "sync.Mutex.Lock",
        "params": [],
        "path": "go/sync/index#Mutex.Lock",
        "syntax": "func (m *Mutex) Lock()",
        "type": "sync"
    },
    "Mutex.Unlock": {
        "descr": "Unlock unlocks m. It is a run-time error if m is not locked on entry to Unlock.",
        "name": "sync.Mutex.Unlock",
        "params": [],
        "path": "go/sync/index#Mutex.Unlock",
        "syntax": "func (m *Mutex) Unlock()",
        "type": "sync"
    },
    "MutexProfile": {
        "descr": "MutexProfile returns n, the number of records in the current mutex profile. If len(p) >= n, MutexProfile copies the profile into p and returns n, true. Otherwise, MutexProfile does not change p, and returns n, false.",
        "name": "runtime.MutexProfile",
        "params": [],
        "path": "go/runtime/index#MutexProfile",
        "syntax": "func MutexProfile(p []BlockProfileRecord) (n int, ok bool)",
        "type": "runtime"
    },
    "NArg": {
        "descr": "NArg is the number of arguments remaining after flags have been processed.",
        "name": "flag.NArg",
        "params": [],
        "path": "go/flag/index#NArg",
        "syntax": "func NArg() int",
        "type": "flag"
    },
    "NFlag": {
        "descr": "NFlag returns the number of command-line flags that have been set.",
        "name": "flag.NFlag",
        "params": [],
        "path": "go/flag/index#NFlag",
        "syntax": "func NFlag() int",
        "type": "flag"
    },
    "NRGBA": {
        "descr": "NRGBA is an in-memory image whose At method returns color.NRGBA values.",
        "name": "image.NRGBA",
        "params": [],
        "path": "go/image/index#NRGBA",
        "syntax": "type NRGBA struct { // Pix holds the image's pixels, in R, G, B, A order. The pixel at // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4]. Pix []uint8 // Stride is the Pix stride (in bytes) between vertically adjacent pixels. Stride int // Rect is the image's bounds. Rect Rectangle }",
        "type": "image"
    },
    "NRGBA.At": {
        "descr": "",
        "name": "image.NRGBA.At",
        "params": [],
        "path": "go/image/index#NRGBA.At",
        "syntax": "func (p *NRGBA) At(x, y int) color.Color",
        "type": "image"
    },
    "NRGBA.Bounds": {
        "descr": "",
        "name": "image.NRGBA.Bounds",
        "params": [],
        "path": "go/image/index#NRGBA.Bounds",
        "syntax": "func (p *NRGBA) Bounds() Rectangle",
        "type": "image"
    },
    "NRGBA.ColorModel": {
        "descr": "",
        "name": "image.NRGBA.ColorModel",
        "params": [],
        "path": "go/image/index#NRGBA.ColorModel",
        "syntax": "func (p *NRGBA) ColorModel() color.Model",
        "type": "image"
    },
    "NRGBA.NRGBAAt": {
        "descr": "",
        "name": "image.NRGBA.NRGBAAt",
        "params": [],
        "path": "go/image/index#NRGBA.NRGBAAt",
        "syntax": "func (p *NRGBA) NRGBAAt(x, y int) color.NRGBA",
        "type": "image"
    },
    "NRGBA.Opaque": {
        "descr": "Opaque scans the entire image and reports whether it is fully opaque.",
        "name": "image.NRGBA.Opaque",
        "params": [],
        "path": "go/image/index#NRGBA.Opaque",
        "syntax": "func (p *NRGBA) Opaque() bool",
        "type": "image"
    },
    "NRGBA.PixOffset": {
        "descr": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y).",
        "name": "image.NRGBA.PixOffset",
        "params": [],
        "path": "go/image/index#NRGBA.PixOffset",
        "syntax": "func (p *NRGBA) PixOffset(x, y int) int",
        "type": "image"
    },
    "NRGBA.Set": {
        "descr": "",
        "name": "image.NRGBA.Set",
        "params": [],
        "path": "go/image/index#NRGBA.Set",
        "syntax": "func (p *NRGBA) Set(x, y int, c color.Color)",
        "type": "image"
    },
    "NRGBA.SetNRGBA": {
        "descr": "",
        "name": "image.NRGBA.SetNRGBA",
        "params": [],
        "path": "go/image/index#NRGBA.SetNRGBA",
        "syntax": "func (p *NRGBA) SetNRGBA(x, y int, c color.NRGBA)",
        "type": "image"
    },
    "NRGBA.SubImage": {
        "descr": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.",
        "name": "image.NRGBA.SubImage",
        "params": [],
        "path": "go/image/index#NRGBA.SubImage",
        "syntax": "func (p *NRGBA) SubImage(r Rectangle) Image",
        "type": "image"
    },
    "NRGBA64": {
        "descr": "NRGBA64 is an in-memory image whose At method returns color.NRGBA64 values.",
        "name": "image.NRGBA64",
        "params": [],
        "path": "go/image/index#NRGBA64",
        "syntax": "type NRGBA64 struct { // Pix holds the image's pixels, in R, G, B, A order and big-endian format. The pixel at // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*8]. Pix []uint8 // Stride is the Pix stride (in bytes) between vertically adjacent pixels. Stride int // Rect is the image's bounds. Rect Rectangle }",
        "type": "image"
    },
    "NRGBA64.At": {
        "descr": "",
        "name": "image.NRGBA64.At",
        "params": [],
        "path": "go/image/index#NRGBA64.At",
        "syntax": "func (p *NRGBA64) At(x, y int) color.Color",
        "type": "image"
    },
    "NRGBA64.Bounds": {
        "descr": "",
        "name": "image.NRGBA64.Bounds",
        "params": [],
        "path": "go/image/index#NRGBA64.Bounds",
        "syntax": "func (p *NRGBA64) Bounds() Rectangle",
        "type": "image"
    },
    "NRGBA64.ColorModel": {
        "descr": "",
        "name": "image.NRGBA64.ColorModel",
        "params": [],
        "path": "go/image/index#NRGBA64.ColorModel",
        "syntax": "func (p *NRGBA64) ColorModel() color.Model",
        "type": "image"
    },
    "NRGBA64.NRGBA64At": {
        "descr": "",
        "name": "image.NRGBA64.NRGBA64At",
        "params": [],
        "path": "go/image/index#NRGBA64.NRGBA64At",
        "syntax": "func (p *NRGBA64) NRGBA64At(x, y int) color.NRGBA64",
        "type": "image"
    },
    "NRGBA64.Opaque": {
        "descr": "Opaque scans the entire image and reports whether it is fully opaque.",
        "name": "image.NRGBA64.Opaque",
        "params": [],
        "path": "go/image/index#NRGBA64.Opaque",
        "syntax": "func (p *NRGBA64) Opaque() bool",
        "type": "image"
    },
    "NRGBA64.PixOffset": {
        "descr": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y).",
        "name": "image.NRGBA64.PixOffset",
        "params": [],
        "path": "go/image/index#NRGBA64.PixOffset",
        "syntax": "func (p *NRGBA64) PixOffset(x, y int) int",
        "type": "image"
    },
    "NRGBA64.Set": {
        "descr": "",
        "name": "image.NRGBA64.Set",
        "params": [],
        "path": "go/image/index#NRGBA64.Set",
        "syntax": "func (p *NRGBA64) Set(x, y int, c color.Color)",
        "type": "image"
    },
    "NRGBA64.SetNRGBA64": {
        "descr": "",
        "name": "image.NRGBA64.SetNRGBA64",
        "params": [],
        "path": "go/image/index#NRGBA64.SetNRGBA64",
        "syntax": "func (p *NRGBA64) SetNRGBA64(x, y int, c color.NRGBA64)",
        "type": "image"
    },
    "NRGBA64.SubImage": {
        "descr": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.",
        "name": "image.NRGBA64.SubImage",
        "params": [],
        "path": "go/image/index#NRGBA64.SubImage",
        "syntax": "func (p *NRGBA64) SubImage(r Rectangle) Image",
        "type": "image"
    },
    "NS": {
        "descr": "An NS represents a single DNS NS record.",
        "name": "net.NS",
        "params": [],
        "path": "go/net/index#NS",
        "syntax": "type NS struct { Host string }",
        "type": "net"
    },
    "NYCbCrA": {
        "descr": "NYCbCrA is an in-memory image of non-alpha-premultiplied Y'CbCr-with-alpha colors. A and AStride are analogous to the Y and YStride fields of the embedded YCbCr.",
        "name": "image.NYCbCrA",
        "params": [],
        "path": "go/image/index#NYCbCrA",
        "syntax": "type NYCbCrA struct { YCbCr A []uint8 AStride int }",
        "type": "image"
    },
    "NYCbCrA.AOffset": {
        "descr": "AOffset returns the index of the first element of A that corresponds to the pixel at (x, y).",
        "name": "image.NYCbCrA.AOffset",
        "params": [],
        "path": "go/image/index#NYCbCrA.AOffset",
        "syntax": "func (p *NYCbCrA) AOffset(x, y int) int",
        "type": "image"
    },
    "NYCbCrA.At": {
        "descr": "",
        "name": "image.NYCbCrA.At",
        "params": [],
        "path": "go/image/index#NYCbCrA.At",
        "syntax": "func (p *NYCbCrA) At(x, y int) color.Color",
        "type": "image"
    },
    "NYCbCrA.ColorModel": {
        "descr": "",
        "name": "image.NYCbCrA.ColorModel",
        "params": [],
        "path": "go/image/index#NYCbCrA.ColorModel",
        "syntax": "func (p *NYCbCrA) ColorModel() color.Model",
        "type": "image"
    },
    "NYCbCrA.NYCbCrAAt": {
        "descr": "",
        "name": "image.NYCbCrA.NYCbCrAAt",
        "params": [],
        "path": "go/image/index#NYCbCrA.NYCbCrAAt",
        "syntax": "func (p *NYCbCrA) NYCbCrAAt(x, y int) color.NYCbCrA",
        "type": "image"
    },
    "NYCbCrA.Opaque": {
        "descr": "Opaque scans the entire image and reports whether it is fully opaque.",
        "name": "image.NYCbCrA.Opaque",
        "params": [],
        "path": "go/image/index#NYCbCrA.Opaque",
        "syntax": "func (p *NYCbCrA) Opaque() bool",
        "type": "image"
    },
    "NYCbCrA.SubImage": {
        "descr": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.",
        "name": "image.NYCbCrA.SubImage",
        "params": [],
        "path": "go/image/index#NYCbCrA.SubImage",
        "syntax": "func (p *NYCbCrA) SubImage(r Rectangle) Image",
        "type": "image"
    },
    "NaN": {
        "descr": "NaN returns an IEEE 754 not-a-number value.",
        "name": "math.NaN",
        "params": [],
        "path": "go/math/index#NaN",
        "syntax": "func NaN() float64",
        "type": "math"
    },
    "Nanosleep": {
        "descr": "",
        "name": "syscall.Nanosleep",
        "params": [],
        "path": "go/syscall/index#Nanosleep",
        "syntax": "func Nanosleep(time *Timespec, leftover *Timespec) (err error)",
        "type": "syscall"
    },
    "NetlinkMessage": {
        "descr": "NetlinkMessage represents a netlink message.",
        "name": "syscall.NetlinkMessage",
        "params": [],
        "path": "go/syscall/index#NetlinkMessage",
        "syntax": "type NetlinkMessage struct { Header NlMsghdr Data []byte }",
        "type": "syscall"
    },
    "NetlinkRIB": {
        "descr": "NetlinkRIB returns routing information base, as known as RIB, which consists of network facility information, states and parameters.",
        "name": "syscall.NetlinkRIB",
        "params": [],
        "path": "go/syscall/index#NetlinkRIB",
        "syntax": "func NetlinkRIB(proto, family int) ([]byte, error)",
        "type": "syscall"
    },
    "NetlinkRouteAttr": {
        "descr": "NetlinkRouteAttr represents a netlink route attribute.",
        "name": "syscall.NetlinkRouteAttr",
        "params": [],
        "path": "go/syscall/index#NetlinkRouteAttr",
        "syntax": "type NetlinkRouteAttr struct { Attr RtAttr Value []byte }",
        "type": "syscall"
    },
    "NetlinkRouteRequest": {
        "descr": "NetlinkRouteRequest represents a request message to receive routing and link states from the kernel.",
        "name": "syscall.NetlinkRouteRequest",
        "params": [],
        "path": "go/syscall/index#NetlinkRouteRequest",
        "syntax": "type NetlinkRouteRequest struct { Header NlMsghdr Data RtGenmsg }",
        "type": "syscall"
    },
    "New": {
        "descr": "New returns a Value representing a pointer to a new zero value for the specified type. That is, the returned Value's Type is PtrTo(typ).",
        "name": "reflect.New",
        "params": [],
        "path": "go/reflect/index#New",
        "syntax": "func New(typ Type) Value",
        "type": "reflect"
    },
    "NewAlpha": {
        "descr": "NewAlpha returns a new Alpha image with the given bounds.",
        "name": "image.NewAlpha",
        "params": [],
        "path": "go/image/index#NewAlpha",
        "syntax": "func NewAlpha(r Rectangle) *Alpha",
        "type": "image"
    },
    "NewAlpha16": {
        "descr": "NewAlpha16 returns a new Alpha16 image with the given bounds.",
        "name": "image.NewAlpha16",
        "params": [],
        "path": "go/image/index#NewAlpha16",
        "syntax": "func NewAlpha16(r Rectangle) *Alpha16",
        "type": "image"
    },
    "NewAt": {
        "descr": "NewAt returns a Value representing a pointer to a value of the specified type, using p as that pointer.",
        "name": "reflect.NewAt",
        "params": [],
        "path": "go/reflect/index#NewAt",
        "syntax": "func NewAt(typ Type, p unsafe.Pointer) Value",
        "type": "reflect"
    },
    "NewBuffer": {
        "descr": "NewBuffer creates and initializes a new Buffer using buf as its initial contents. The new Buffer takes ownership of buf, and the caller should not use buf after this call. NewBuffer is intended to prepare a Buffer to read existing data. It can also be used to size the internal buffer for writing. To do that, buf should have the desired capacity but a length of zero.",
        "name": "bytes.NewBuffer",
        "params": [],
        "path": "go/bytes/index#NewBuffer",
        "syntax": "func NewBuffer(buf []byte) *Buffer",
        "type": "bytes"
    },
    "NewBufferString": {
        "descr": "NewBufferString creates and initializes a new Buffer using string s as its initial contents. It is intended to prepare a buffer to read an existing string.",
        "name": "bytes.NewBufferString",
        "params": [],
        "path": "go/bytes/index#NewBufferString",
        "syntax": "func NewBufferString(s string) *Buffer",
        "type": "bytes"
    },
    "NewCMYK": {
        "descr": "NewCMYK returns a new CMYK image with the given bounds.",
        "name": "image.NewCMYK",
        "params": [],
        "path": "go/image/index#NewCMYK",
        "syntax": "func NewCMYK(r Rectangle) *CMYK",
        "type": "image"
    },
    "NewCond": {
        "descr": "NewCond returns a new Cond with Locker l.",
        "name": "sync.NewCond",
        "params": [],
        "path": "go/sync/index#NewCond",
        "syntax": "func NewCond(l Locker) *Cond",
        "type": "sync"
    },
    "NewFile": {
        "descr": "NewFile returns a new File with the given file descriptor and name. The returned value will be nil if fd is not a valid file descriptor. On Unix systems, if the file descriptor is in non-blocking mode, NewFile will attempt to return a pollable File (one for which the SetDeadline methods work).",
        "name": "os.NewFile",
        "params": [],
        "path": "go/os/index#NewFile",
        "syntax": "func NewFile(fd uintptr, name string) *File",
        "type": "os"
    },
    "NewFlagSet": {
        "descr": "NewFlagSet returns a new, empty flag set with the specified name and error handling property. If the name is not empty, it will be printed in the default usage message and in error messages.",
        "name": "flag.NewFlagSet",
        "params": [],
        "path": "go/flag/index#NewFlagSet",
        "syntax": "func NewFlagSet(name string, errorHandling ErrorHandling) *FlagSet",
        "type": "flag"
    },
    "NewFloat": {
        "descr": "",
        "name": "expvar.NewFloat",
        "params": [],
        "path": "go/expvar/index#NewFloat",
        "syntax": "func NewFloat(name string) *Float",
        "type": "expvar"
    },
    "NewGray": {
        "descr": "NewGray returns a new Gray image with the given bounds.",
        "name": "image.NewGray",
        "params": [],
        "path": "go/image/index#NewGray",
        "syntax": "func NewGray(r Rectangle) *Gray",
        "type": "image"
    },
    "NewGray16": {
        "descr": "NewGray16 returns a new Gray16 image with the given bounds.",
        "name": "image.NewGray16",
        "params": [],
        "path": "go/image/index#NewGray16",
        "syntax": "func NewGray16(r Rectangle) *Gray16",
        "type": "image"
    },
    "NewInt": {
        "descr": "",
        "name": "expvar.NewInt",
        "params": [],
        "path": "go/expvar/index#NewInt",
        "syntax": "func NewInt(name string) *Int",
        "type": "expvar"
    },
    "NewMap": {
        "descr": "",
        "name": "expvar.NewMap",
        "params": [],
        "path": "go/expvar/index#NewMap",
        "syntax": "func NewMap(name string) *Map",
        "type": "expvar"
    },
    "NewNRGBA": {
        "descr": "NewNRGBA returns a new NRGBA image with the given bounds.",
        "name": "image.NewNRGBA",
        "params": [],
        "path": "go/image/index#NewNRGBA",
        "syntax": "func NewNRGBA(r Rectangle) *NRGBA",
        "type": "image"
    },
    "NewNRGBA64": {
        "descr": "NewNRGBA64 returns a new NRGBA64 image with the given bounds.",
        "name": "image.NewNRGBA64",
        "params": [],
        "path": "go/image/index#NewNRGBA64",
        "syntax": "func NewNRGBA64(r Rectangle) *NRGBA64",
        "type": "image"
    },
    "NewNYCbCrA": {
        "descr": "NewNYCbCrA returns a new NYCbCrA image with the given bounds and subsample ratio.",
        "name": "image.NewNYCbCrA",
        "params": [],
        "path": "go/image/index#NewNYCbCrA",
        "syntax": "func NewNYCbCrA(r Rectangle, subsampleRatio YCbCrSubsampleRatio) *NYCbCrA",
        "type": "image"
    },
    "NewPaletted": {
        "descr": "NewPaletted returns a new Paletted image with the given width, height and palette.",
        "name": "image.NewPaletted",
        "params": [],
        "path": "go/image/index#NewPaletted",
        "syntax": "func NewPaletted(r Rectangle, p color.Palette) *Paletted",
        "type": "image"
    },
    "NewRGBA": {
        "descr": "NewRGBA returns a new RGBA image with the given bounds.",
        "name": "image.NewRGBA",
        "params": [],
        "path": "go/image/index#NewRGBA",
        "syntax": "func NewRGBA(r Rectangle) *RGBA",
        "type": "image"
    },
    "NewRGBA64": {
        "descr": "NewRGBA64 returns a new RGBA64 image with the given bounds.",
        "name": "image.NewRGBA64",
        "params": [],
        "path": "go/image/index#NewRGBA64",
        "syntax": "func NewRGBA64(r Rectangle) *RGBA64",
        "type": "image"
    },
    "NewReadWriter": {
        "descr": "NewReadWriter allocates a new ReadWriter that dispatches to r and w.",
        "name": "bufio.NewReadWriter",
        "params": [],
        "path": "go/bufio/index#NewReadWriter",
        "syntax": "func NewReadWriter(r *Reader, w *Writer) *ReadWriter",
        "type": "bufio"
    },
    "NewReader": {
        "descr": "NewReader returns a new Reader reading from s. It is similar to bytes.NewBufferString but more efficient and read-only.",
        "name": "strings.NewReader",
        "params": [],
        "path": "go/strings/index#NewReader",
        "syntax": "func NewReader(s string) *Reader",
        "type": "strings"
    },
    "NewReaderSize": {
        "descr": "NewReaderSize returns a new Reader whose buffer has at least the specified size. If the argument io.Reader is already a Reader with large enough size, it returns the underlying Reader.",
        "name": "bufio.NewReaderSize",
        "params": [],
        "path": "go/bufio/index#NewReaderSize",
        "syntax": "func NewReaderSize(rd io.Reader, size int) *Reader",
        "type": "bufio"
    },
    "NewReplacer": {
        "descr": "NewReplacer returns a new Replacer from a list of old, new string pairs. Replacements are performed in the order they appear in the target string, without overlapping matches.",
        "name": "strings.NewReplacer",
        "params": [],
        "path": "go/strings/index#NewReplacer",
        "syntax": "func NewReplacer(oldnew ...string) *Replacer",
        "type": "strings"
    },
    "NewScanner": {
        "descr": "NewScanner returns a new Scanner to read from r. The split function defaults to ScanLines.",
        "name": "bufio.NewScanner",
        "params": [],
        "path": "go/bufio/index#NewScanner",
        "syntax": "func NewScanner(r io.Reader) *Scanner",
        "type": "bufio"
    },
    "NewSectionReader": {
        "descr": "NewSectionReader returns a SectionReader that reads from r starting at offset off and stops with EOF after n bytes.",
        "name": "io.NewSectionReader",
        "params": [],
        "path": "go/io/index#NewSectionReader",
        "syntax": "func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader",
        "type": "io"
    },
    "NewString": {
        "descr": "",
        "name": "expvar.NewString",
        "params": [],
        "path": "go/expvar/index#NewString",
        "syntax": "func NewString(name string) *String",
        "type": "expvar"
    },
    "NewSyscallError": {
        "descr": "NewSyscallError returns, as an error, a new SyscallError with the given system call name and error details. As a convenience, if err is nil, NewSyscallError returns nil.",
        "name": "os.NewSyscallError",
        "params": [],
        "path": "go/os/index#NewSyscallError",
        "syntax": "func NewSyscallError(syscall string, err error) error",
        "type": "os"
    },
    "NewTicker": {
        "descr": "NewTicker returns a new Ticker containing a channel that will send the time with a period specified by the duration argument. It adjusts the intervals or drops ticks to make up for slow receivers. The duration d must be greater than zero; if not, NewTicker will panic. Stop the ticker to release associated resources.",
        "name": "time.NewTicker",
        "params": [],
        "path": "go/time/index#NewTicker",
        "syntax": "func NewTicker(d Duration) *Ticker",
        "type": "time"
    },
    "NewTimer": {
        "descr": "NewTimer creates a new Timer that will send the current time on its channel after at least duration d.",
        "name": "time.NewTimer",
        "params": [],
        "path": "go/time/index#NewTimer",
        "syntax": "func NewTimer(d Duration) *Timer",
        "type": "time"
    },
    "NewUniform": {
        "descr": "",
        "name": "image.NewUniform",
        "params": [],
        "path": "go/image/index#NewUniform",
        "syntax": "func NewUniform(c color.Color) *Uniform",
        "type": "image"
    },
    "NewWriter": {
        "descr": "NewWriter returns a new Writer whose buffer has the default size.",
        "name": "bufio.NewWriter",
        "params": [],
        "path": "go/bufio/index#NewWriter",
        "syntax": "func NewWriter(w io.Writer) *Writer",
        "type": "bufio"
    },
    "NewWriterSize": {
        "descr": "NewWriterSize returns a new Writer whose buffer has at least the specified size. If the argument io.Writer is already a Writer with large enough size, it returns the underlying Writer.",
        "name": "bufio.NewWriterSize",
        "params": [],
        "path": "go/bufio/index#NewWriterSize",
        "syntax": "func NewWriterSize(w io.Writer, size int) *Writer",
        "type": "bufio"
    },
    "NewYCbCr": {
        "descr": "NewYCbCr returns a new YCbCr image with the given bounds and subsample ratio.",
        "name": "image.NewYCbCr",
        "params": [],
        "path": "go/image/index#NewYCbCr",
        "syntax": "func NewYCbCr(r Rectangle, subsampleRatio YCbCrSubsampleRatio) *YCbCr",
        "type": "image"
    },
    "Nextafter": {
        "descr": "Nextafter returns the next representable float64 value after x towards y.",
        "name": "math.Nextafter",
        "params": [],
        "path": "go/math/index#Nextafter",
        "syntax": "func Nextafter(x, y float64) (r float64)",
        "type": "math"
    },
    "Nextafter32": {
        "descr": "Nextafter32 returns the next representable float32 value after x towards y.",
        "name": "math.Nextafter32",
        "params": [],
        "path": "go/math/index#Nextafter32",
        "syntax": "func Nextafter32(x, y float32) (r float32)",
        "type": "math"
    },
    "NlAttr": {
        "descr": "",
        "name": "syscall.NlAttr",
        "params": [],
        "path": "go/syscall/index#NlAttr",
        "syntax": "type NlAttr struct { Len uint16 Type uint16 }",
        "type": "syscall"
    },
    "NlMsgerr": {
        "descr": "",
        "name": "syscall.NlMsgerr",
        "params": [],
        "path": "go/syscall/index#NlMsgerr",
        "syntax": "type NlMsgerr struct { Error int32 Msg NlMsghdr }",
        "type": "syscall"
    },
    "NlMsghdr": {
        "descr": "",
        "name": "syscall.NlMsghdr",
        "params": [],
        "path": "go/syscall/index#NlMsghdr",
        "syntax": "type NlMsghdr struct { Len uint32 Type uint16 Flags uint16 Seq uint32 Pid uint32 }",
        "type": "syscall"
    },
    "Now": {
        "descr": "Now returns the current local time.",
        "name": "time.Now",
        "params": [],
        "path": "go/time/index#Now",
        "syntax": "func Now() Time",
        "type": "time"
    },
    "NsecToTimespec": {
        "descr": "NsecToTimespec takes a number of nanoseconds since the Unix epoch and returns the corresponding Timespec value.",
        "name": "syscall.NsecToTimespec",
        "params": [],
        "path": "go/syscall/index#NsecToTimespec",
        "syntax": "func NsecToTimespec(nsec int64) Timespec",
        "type": "syscall"
    },
    "NsecToTimeval": {
        "descr": "NsecToTimeval takes a number of nanoseconds since the Unix epoch and returns the corresponding Timeval value.",
        "name": "syscall.NsecToTimeval",
        "params": [],
        "path": "go/syscall/index#NsecToTimeval",
        "syntax": "func NsecToTimeval(nsec int64) Timeval",
        "type": "syscall"
    },
    "NumCPU": {
        "descr": "NumCPU returns the number of logical CPUs usable by the current process.",
        "name": "runtime.NumCPU",
        "params": [],
        "path": "go/runtime/index#NumCPU",
        "syntax": "func NumCPU() int",
        "type": "runtime"
    },
    "NumCgoCall": {
        "descr": "NumCgoCall returns the number of cgo calls made by the current process.",
        "name": "runtime.NumCgoCall",
        "params": [],
        "path": "go/runtime/index#NumCgoCall",
        "syntax": "func NumCgoCall() int64",
        "type": "runtime"
    },
    "NumError": {
        "descr": "A NumError records a failed conversion.",
        "name": "strconv.NumError",
        "params": [],
        "path": "go/strconv/index#NumError",
        "syntax": "type NumError struct { Func string // the failing function (ParseBool, ParseInt, ParseUint, ParseFloat) Num string // the input Err error // the reason the conversion failed (e.g. ErrRange, ErrSyntax, etc.) }",
        "type": "strconv"
    },
    "NumError.Error": {
        "descr": "",
        "name": "strconv.NumError.Error",
        "params": [],
        "path": "go/strconv/index#NumError.Error",
        "syntax": "func (e *NumError) Error() string",
        "type": "strconv"
    },
    "NumGoroutine": {
        "descr": "NumGoroutine returns the number of goroutines that currently exist.",
        "name": "runtime.NumGoroutine",
        "params": [],
        "path": "go/runtime/index#NumGoroutine",
        "syntax": "func NumGoroutine() int",
        "type": "runtime"
    },
    "Offsetof": {
        "descr": "Offsetof returns the offset within the struct of the field represented by x, which must be of the form structValue.field. In other words, it returns the number of bytes between the start of the struct and the start of the field.",
        "name": "unsafe.Offsetof",
        "params": [],
        "path": "go/unsafe/index#Offsetof",
        "syntax": "func Offsetof(x ArbitraryType) uintptr",
        "type": "unsafe"
    },
    "Once": {
        "descr": "Once is an object that will perform exactly one action.",
        "name": "sync.Once",
        "params": [],
        "path": "go/sync/index#Once",
        "syntax": "type Once struct { // contains filtered or unexported fields }",
        "type": "sync"
    },
    "Once.Do": {
        "descr": "Do calls the function f if and only if Do is being called for the first time for this instance of Once. In other words, given",
        "name": "sync.Once.Do",
        "params": [],
        "path": "go/sync/index#Once.Do",
        "syntax": "func (o *Once) Do(f func())",
        "type": "sync"
    },
    "OpError": {
        "descr": "OpError is the error type usually returned by functions in the net package. It describes the operation, network type, and address of an error.",
        "name": "net.OpError",
        "params": [],
        "path": "go/net/index#OpError",
        "syntax": "type OpError struct { // Op is the operation which caused the error, such as // \"read\" or \"write\". Op string // Net is the network type on which this error occurred, // such as \"tcp\" or \"udp6\". Net string // For operations involving a remote network connection, like // Dial, Read, or Write, Source is the corresponding local // network address. Source Addr // Go 1.5 // Addr is the network address for which this error occurred. // For local operations, like Listen or SetDeadline, Addr is // the address of the local endpoint being manipulated. // For operations involving a remote network connection, like // Dial, Read, or Write, Addr is the remote address of that // connection. Addr Addr // Err is the error that occurred during the operation. Err error }",
        "type": "net"
    },
    "OpError.Error": {
        "descr": "",
        "name": "net.OpError.Error",
        "params": [],
        "path": "go/net/index#OpError.Error",
        "syntax": "func (e *OpError) Error() string",
        "type": "net"
    },
    "OpError.Temporary": {
        "descr": "",
        "name": "net.OpError.Temporary",
        "params": [],
        "path": "go/net/index#OpError.Temporary",
        "syntax": "func (e *OpError) Temporary() bool",
        "type": "net"
    },
    "OpError.Timeout": {
        "descr": "",
        "name": "net.OpError.Timeout",
        "params": [],
        "path": "go/net/index#OpError.Timeout",
        "syntax": "func (e *OpError) Timeout() bool",
        "type": "net"
    },
    "Open": {
        "descr": "",
        "name": "syscall.Open",
        "params": [],
        "path": "go/syscall/index#Open",
        "syntax": "func Open(path string, mode int, perm uint32) (fd int, err error)",
        "type": "syscall"
    },
    "OpenFile": {
        "descr": "OpenFile is the generalized open call; most users will use Open or Create instead. It opens the named file with specified flag (O_RDONLY etc.) and perm (before umask), if applicable. If successful, methods on the returned File can be used for I/O. If there is an error, it will be of type *PathError.",
        "name": "os.OpenFile",
        "params": [],
        "path": "go/os/index#OpenFile",
        "syntax": "func OpenFile(name string, flag int, perm FileMode) (*File, error)",
        "type": "os"
    },
    "Openat": {
        "descr": "",
        "name": "syscall.Openat",
        "params": [],
        "path": "go/syscall/index#Openat",
        "syntax": "func Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error)",
        "type": "syscall"
    },
    "Output": {
        "descr": "Output writes the output for a logging event. The string s contains the text to print after the prefix specified by the flags of the Logger. A newline is appended if the last character of s is not already a newline. Calldepth is the count of the number of frames to skip when computing the file name and line number if Llongfile or Lshortfile is set; a value of 1 will print the details for the caller of Output.",
        "name": "log.Output",
        "params": [],
        "path": "go/log/index#Output",
        "syntax": "func Output(calldepth int, s string) error",
        "type": "log"
    },
    "PB": {
        "descr": "A PB is used by RunParallel for running parallel benchmarks.",
        "name": "testing.PB",
        "params": [],
        "path": "go/testing/index#PB",
        "syntax": "type PB struct { // contains filtered or unexported fields }",
        "type": "testing"
    },
    "PB.Next": {
        "descr": "Next reports whether there are more iterations to execute.",
        "name": "testing.PB.Next",
        "params": [],
        "path": "go/testing/index#PB.Next",
        "syntax": "func (pb *PB) Next() bool",
        "type": "testing"
    },
    "PacketConn": {
        "descr": "PacketConn is a generic packet-oriented network connection.",
        "name": "net.PacketConn",
        "params": [],
        "path": "go/net/index#PacketConn",
        "syntax": "type PacketConn interface { // ReadFrom reads a packet from the connection, // copying the payload into p. It returns the number of // bytes copied into p and the return address that // was on the packet. // It returns the number of bytes read (0 <= n <= len(p)) // and any error encountered. Callers should always process // the n > 0 bytes returned before considering the error err. // ReadFrom can be made to time out and return // an Error with Timeout() == true after a fixed time limit; // see SetDeadline and SetReadDeadline. ReadFrom(p []byte) (n int, addr Addr, err error) // WriteTo writes a packet with payload p to addr. // WriteTo can be made to time out and return // an Error with Timeout() == true after a fixed time limit; // see SetDeadline and SetWriteDeadline. // On packet-oriented connections, write timeouts are rare. WriteTo(p []byte, addr Addr) (n int, err error) // Close closes the connection. // Any blocked ReadFrom or WriteTo operations will be unblocked and return errors. Close() error // LocalAddr returns the local network address. LocalAddr() Addr // SetDeadline sets the read and write deadlines associated // with the connection. It is equivalent to calling both // SetReadDeadline and SetWriteDeadline. // // A deadline is an absolute time after which I/O operations // fail with a timeout (see type Error) instead of // blocking. The deadline applies to all future and pending // I/O, not just the immediately following call to ReadFrom or // WriteTo. After a deadline has been exceeded, the connection // can be refreshed by setting a deadline in the future. // // An idle timeout can be implemented by repeatedly extending // the deadline after successful ReadFrom or WriteTo calls. // // A zero value for t means I/O operations will not time out. SetDeadline(t time.Time) error // SetReadDeadline sets the deadline for future ReadFrom calls // and any currently-blocked ReadFrom call. // A zero value for t means ReadFrom will not time out. SetReadDeadline(t time.Time) error // SetWriteDeadline sets the deadline for future WriteTo calls // and any currently-blocked WriteTo call. // Even if write times out, it may return n > 0, indicating that // some of the data was successfully written. // A zero value for t means WriteTo will not time out. SetWriteDeadline(t time.Time) error }",
        "type": "net"
    },
    "Paletted": {
        "descr": "Paletted is an in-memory image of uint8 indices into a given palette.",
        "name": "image.Paletted",
        "params": [],
        "path": "go/image/index#Paletted",
        "syntax": "type Paletted struct { // Pix holds the image's pixels, as palette indices. The pixel at // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1]. Pix []uint8 // Stride is the Pix stride (in bytes) between vertically adjacent pixels. Stride int // Rect is the image's bounds. Rect Rectangle // Palette is the image's palette. Palette color.Palette }",
        "type": "image"
    },
    "Paletted.At": {
        "descr": "",
        "name": "image.Paletted.At",
        "params": [],
        "path": "go/image/index#Paletted.At",
        "syntax": "func (p *Paletted) At(x, y int) color.Color",
        "type": "image"
    },
    "Paletted.Bounds": {
        "descr": "",
        "name": "image.Paletted.Bounds",
        "params": [],
        "path": "go/image/index#Paletted.Bounds",
        "syntax": "func (p *Paletted) Bounds() Rectangle",
        "type": "image"
    },
    "Paletted.ColorIndexAt": {
        "descr": "",
        "name": "image.Paletted.ColorIndexAt",
        "params": [],
        "path": "go/image/index#Paletted.ColorIndexAt",
        "syntax": "func (p *Paletted) ColorIndexAt(x, y int) uint8",
        "type": "image"
    },
    "Paletted.ColorModel": {
        "descr": "",
        "name": "image.Paletted.ColorModel",
        "params": [],
        "path": "go/image/index#Paletted.ColorModel",
        "syntax": "func (p *Paletted) ColorModel() color.Model",
        "type": "image"
    },
    "Paletted.Opaque": {
        "descr": "Opaque scans the entire image and reports whether it is fully opaque.",
        "name": "image.Paletted.Opaque",
        "params": [],
        "path": "go/image/index#Paletted.Opaque",
        "syntax": "func (p *Paletted) Opaque() bool",
        "type": "image"
    },
    "Paletted.PixOffset": {
        "descr": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y).",
        "name": "image.Paletted.PixOffset",
        "params": [],
        "path": "go/image/index#Paletted.PixOffset",
        "syntax": "func (p *Paletted) PixOffset(x, y int) int",
        "type": "image"
    },
    "Paletted.Set": {
        "descr": "",
        "name": "image.Paletted.Set",
        "params": [],
        "path": "go/image/index#Paletted.Set",
        "syntax": "func (p *Paletted) Set(x, y int, c color.Color)",
        "type": "image"
    },
    "Paletted.SetColorIndex": {
        "descr": "",
        "name": "image.Paletted.SetColorIndex",
        "params": [],
        "path": "go/image/index#Paletted.SetColorIndex",
        "syntax": "func (p *Paletted) SetColorIndex(x, y int, index uint8)",
        "type": "image"
    },
    "Paletted.SubImage": {
        "descr": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.",
        "name": "image.Paletted.SubImage",
        "params": [],
        "path": "go/image/index#Paletted.SubImage",
        "syntax": "func (p *Paletted) SubImage(r Rectangle) Image",
        "type": "image"
    },
    "PalettedImage": {
        "descr": "PalettedImage is an image whose colors may come from a limited palette. If m is a PalettedImage and m.ColorModel() returns a color.Palette p, then m.At(x, y) should be equivalent to p[m.ColorIndexAt(x, y)]. If m's color model is not a color.Palette, then ColorIndexAt's behavior is undefined.",
        "name": "image.PalettedImage",
        "params": [],
        "path": "go/image/index#PalettedImage",
        "syntax": "type PalettedImage interface { // ColorIndexAt returns the palette index of the pixel at (x, y). ColorIndexAt(x, y int) uint8 Image }",
        "type": "image"
    },
    "Panic": {
        "descr": "Panic is equivalent to Print() followed by a call to panic().",
        "name": "log.Panic",
        "params": [],
        "path": "go/log/index#Panic",
        "syntax": "func Panic(v ...interface{})",
        "type": "log"
    },
    "Panicf": {
        "descr": "Panicf is equivalent to Printf() followed by a call to panic().",
        "name": "log.Panicf",
        "params": [],
        "path": "go/log/index#Panicf",
        "syntax": "func Panicf(format string, v ...interface{})",
        "type": "log"
    },
    "Panicln": {
        "descr": "Panicln is equivalent to Println() followed by a call to panic().",
        "name": "log.Panicln",
        "params": [],
        "path": "go/log/index#Panicln",
        "syntax": "func Panicln(v ...interface{})",
        "type": "log"
    },
    "Parse": {
        "descr": "Parse parses a formatted string and returns the time value it represents. The layout defines the format by showing how the reference time, defined to be",
        "name": "time.Parse",
        "params": [],
        "path": "go/time/index#Parse",
        "syntax": "func Parse(layout, value string) (Time, error)",
        "type": "time"
    },
    "ParseBool": {
        "descr": "ParseBool returns the boolean value represented by the string. It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False. Any other value returns an error.",
        "name": "strconv.ParseBool",
        "params": [],
        "path": "go/strconv/index#ParseBool",
        "syntax": "func ParseBool(str string) (bool, error)",
        "type": "strconv"
    },
    "ParseCIDR": {
        "descr": "ParseCIDR parses s as a CIDR notation IP address and prefix length, like \"192.0.2.0/24\" or \"2001:db8::/32\", as defined in RFC 4632 and RFC 4291.",
        "name": "net.ParseCIDR",
        "params": [],
        "path": "go/net/index#ParseCIDR",
        "syntax": "func ParseCIDR(s string) (IP, *IPNet, error)",
        "type": "net"
    },
    "ParseDirent": {
        "descr": "ParseDirent parses up to max directory entries in buf, appending the names to names. It returns the number of bytes consumed from buf, the number of entries added to names, and the new names slice.",
        "name": "syscall.ParseDirent",
        "params": [],
        "path": "go/syscall/index#ParseDirent",
        "syntax": "func ParseDirent(buf []byte, max int, names []string) (consumed int, count int, newnames []string)",
        "type": "syscall"
    },
    "ParseDuration": {
        "descr": "ParseDuration parses a duration string. A duration string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as \"300ms\", \"-1.5h\" or \"2h45m\". Valid time units are \"ns\", \"us\" (or \"s\"), \"ms\", \"s\", \"m\", \"h\".",
        "name": "time.ParseDuration",
        "params": [],
        "path": "go/time/index#ParseDuration",
        "syntax": "func ParseDuration(s string) (Duration, error)",
        "type": "time"
    },
    "ParseError": {
        "descr": "ParseError describes a problem parsing a time string.",
        "name": "time.ParseError",
        "params": [],
        "path": "go/time/index#ParseError",
        "syntax": "type ParseError struct { Layout string Value string LayoutElem string ValueElem string Message string }",
        "type": "time"
    },
    "ParseError.Error": {
        "descr": "Error returns the string representation of a ParseError.",
        "name": "time.ParseError.Error",
        "params": [],
        "path": "go/time/index#ParseError.Error",
        "syntax": "func (e *ParseError) Error() string",
        "type": "time"
    },
    "ParseFloat": {
        "descr": "ParseFloat converts the string s to a floating-point number with the precision specified by bitSize: 32 for float32, or 64 for float64. When bitSize=32, the result still has type float64, but it will be convertible to float32 without changing its value.",
        "name": "strconv.ParseFloat",
        "params": [],
        "path": "go/strconv/index#ParseFloat",
        "syntax": "func ParseFloat(s string, bitSize int) (float64, error)",
        "type": "strconv"
    },
    "ParseIP": {
        "descr": "ParseIP parses s as an IP address, returning the result. The string s can be in dotted decimal (\"192.0.2.1\") or IPv6 (\"2001:db8::68\") form. If s is not a valid textual representation of an IP address, ParseIP returns nil.",
        "name": "net.ParseIP",
        "params": [],
        "path": "go/net/index#ParseIP",
        "syntax": "func ParseIP(s string) IP",
        "type": "net"
    },
    "ParseInLocation": {
        "descr": "ParseInLocation is like Parse but differs in two important ways. First, in the absence of time zone information, Parse interprets a time as UTC; ParseInLocation interprets the time as in the given location. Second, when given a zone offset or abbreviation, Parse tries to match it against the Local location; ParseInLocation uses the given location.",
        "name": "time.ParseInLocation",
        "params": [],
        "path": "go/time/index#ParseInLocation",
        "syntax": "func ParseInLocation(layout, value string, loc *Location) (Time, error)",
        "type": "time"
    },
    "ParseInt": {
        "descr": "ParseInt interprets a string s in the given base (0, 2 to 36) and bit size (0 to 64) and returns the corresponding value i.",
        "name": "strconv.ParseInt",
        "params": [],
        "path": "go/strconv/index#ParseInt",
        "syntax": "func ParseInt(s string, base int, bitSize int) (i int64, err error)",
        "type": "strconv"
    },
    "ParseMAC": {
        "descr": "ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet IP over InfiniBand link-layer address using one of the following formats:",
        "name": "net.ParseMAC",
        "params": [],
        "path": "go/net/index#ParseMAC",
        "syntax": "func ParseMAC(s string) (hw HardwareAddr, err error)",
        "type": "net"
    },
    "ParseNetlinkMessage": {
        "descr": "ParseNetlinkMessage parses b as an array of netlink messages and returns the slice containing the NetlinkMessage structures.",
        "name": "syscall.ParseNetlinkMessage",
        "params": [],
        "path": "go/syscall/index#ParseNetlinkMessage",
        "syntax": "func ParseNetlinkMessage(b []byte) ([]NetlinkMessage, error)",
        "type": "syscall"
    },
    "ParseNetlinkRouteAttr": {
        "descr": "ParseNetlinkRouteAttr parses m's payload as an array of netlink route attributes and returns the slice containing the NetlinkRouteAttr structures.",
        "name": "syscall.ParseNetlinkRouteAttr",
        "params": [],
        "path": "go/syscall/index#ParseNetlinkRouteAttr",
        "syntax": "func ParseNetlinkRouteAttr(m *NetlinkMessage) ([]NetlinkRouteAttr, error)",
        "type": "syscall"
    },
    "ParseSocketControlMessage": {
        "descr": "ParseSocketControlMessage parses b as an array of socket control messages.",
        "name": "syscall.ParseSocketControlMessage",
        "params": [],
        "path": "go/syscall/index#ParseSocketControlMessage",
        "syntax": "func ParseSocketControlMessage(b []byte) ([]SocketControlMessage, error)",
        "type": "syscall"
    },
    "ParseUint": {
        "descr": "ParseUint is like ParseInt but for unsigned numbers.",
        "name": "strconv.ParseUint",
        "params": [],
        "path": "go/strconv/index#ParseUint",
        "syntax": "func ParseUint(s string, base int, bitSize int) (uint64, error)",
        "type": "strconv"
    },
    "ParseUnixCredentials": {
        "descr": "ParseUnixCredentials decodes a socket control message that contains credentials in a Ucred structure. To receive such a message, the SO_PASSCRED option must be enabled on the socket.",
        "name": "syscall.ParseUnixCredentials",
        "params": [],
        "path": "go/syscall/index#ParseUnixCredentials",
        "syntax": "func ParseUnixCredentials(m *SocketControlMessage) (*Ucred, error)",
        "type": "syscall"
    },
    "ParseUnixRights": {
        "descr": "ParseUnixRights decodes a socket control message that contains an integer array of open file descriptors from another process.",
        "name": "syscall.ParseUnixRights",
        "params": [],
        "path": "go/syscall/index#ParseUnixRights",
        "syntax": "func ParseUnixRights(m *SocketControlMessage) ([]int, error)",
        "type": "syscall"
    },
    "Parsed": {
        "descr": "Parsed reports whether the command-line flags have been parsed.",
        "name": "flag.Parsed",
        "params": [],
        "path": "go/flag/index#Parsed",
        "syntax": "func Parsed() bool",
        "type": "flag"
    },
    "PathError": {
        "descr": "PathError records an error and the operation and file path that caused it.",
        "name": "os.PathError",
        "params": [],
        "path": "go/os/index#PathError",
        "syntax": "type PathError struct { Op string Path string Err error }",
        "type": "os"
    },
    "PathError.Error": {
        "descr": "",
        "name": "os.PathError.Error",
        "params": [],
        "path": "go/os/index#PathError.Error",
        "syntax": "func (e *PathError) Error() string",
        "type": "os"
    },
    "PathError.Timeout": {
        "descr": "Timeout reports whether this error represents a timeout.",
        "name": "os.PathError.Timeout",
        "params": [],
        "path": "go/os/index#PathError.Timeout",
        "syntax": "func (e *PathError) Timeout() bool",
        "type": "os"
    },
    "Pause": {
        "descr": "",
        "name": "syscall.Pause",
        "params": [],
        "path": "go/syscall/index#Pause",
        "syntax": "func Pause() (err error)",
        "type": "syscall"
    },
    "Pipe": {
        "descr": "",
        "name": "syscall.Pipe",
        "params": [],
        "path": "go/syscall/index#Pipe",
        "syntax": "func Pipe(p []int) (err error)",
        "type": "syscall"
    },
    "Pipe2": {
        "descr": "",
        "name": "syscall.Pipe2",
        "params": [],
        "path": "go/syscall/index#Pipe2",
        "syntax": "func Pipe2(p []int, flags int) (err error)",
        "type": "syscall"
    },
    "PipeReader": {
        "descr": "A PipeReader is the read half of a pipe.",
        "name": "io.PipeReader",
        "params": [],
        "path": "go/io/index#PipeReader",
        "syntax": "type PipeReader struct { // contains filtered or unexported fields }",
        "type": "io"
    },
    "PipeReader.Close": {
        "descr": "Close closes the reader; subsequent writes to the write half of the pipe will return the error ErrClosedPipe.",
        "name": "io.PipeReader.Close",
        "params": [],
        "path": "go/io/index#PipeReader.Close",
        "syntax": "func (r *PipeReader) Close() error",
        "type": "io"
    },
    "PipeReader.CloseWithError": {
        "descr": "CloseWithError closes the reader; subsequent writes to the write half of the pipe will return the error err.",
        "name": "io.PipeReader.CloseWithError",
        "params": [],
        "path": "go/io/index#PipeReader.CloseWithError",
        "syntax": "func (r *PipeReader) CloseWithError(err error) error",
        "type": "io"
    },
    "PipeReader.Read": {
        "descr": "Read implements the standard Read interface: it reads data from the pipe, blocking until a writer arrives or the write end is closed. If the write end is closed with an error, that error is returned as err; otherwise err is EOF.",
        "name": "io.PipeReader.Read",
        "params": [],
        "path": "go/io/index#PipeReader.Read",
        "syntax": "func (r *PipeReader) Read(data []byte) (n int, err error)",
        "type": "io"
    },
    "PipeWriter": {
        "descr": "A PipeWriter is the write half of a pipe.",
        "name": "io.PipeWriter",
        "params": [],
        "path": "go/io/index#PipeWriter",
        "syntax": "type PipeWriter struct { // contains filtered or unexported fields }",
        "type": "io"
    },
    "PipeWriter.Close": {
        "descr": "Close closes the writer; subsequent reads from the read half of the pipe will return no bytes and EOF.",
        "name": "io.PipeWriter.Close",
        "params": [],
        "path": "go/io/index#PipeWriter.Close",
        "syntax": "func (w *PipeWriter) Close() error",
        "type": "io"
    },
    "PipeWriter.CloseWithError": {
        "descr": "CloseWithError closes the writer; subsequent reads from the read half of the pipe will return no bytes and the error err, or EOF if err is nil.",
        "name": "io.PipeWriter.CloseWithError",
        "params": [],
        "path": "go/io/index#PipeWriter.CloseWithError",
        "syntax": "func (w *PipeWriter) CloseWithError(err error) error",
        "type": "io"
    },
    "PipeWriter.Write": {
        "descr": "Write implements the standard Write interface: it writes data to the pipe, blocking until one or more readers have consumed all the data or the read end is closed. If the read end is closed with an error, that err is returned as err; otherwise err is ErrClosedPipe.",
        "name": "io.PipeWriter.Write",
        "params": [],
        "path": "go/io/index#PipeWriter.Write",
        "syntax": "func (w *PipeWriter) Write(data []byte) (n int, err error)",
        "type": "io"
    },
    "PivotRoot": {
        "descr": "",
        "name": "syscall.PivotRoot",
        "params": [],
        "path": "go/syscall/index#PivotRoot",
        "syntax": "func PivotRoot(newroot string, putold string) (err error)",
        "type": "syscall"
    },
    "Plugin": {
        "descr": "Plugin is a loaded Go plugin.",
        "name": "plugin.Plugin",
        "params": [],
        "path": "go/plugin/index#Plugin",
        "syntax": "type Plugin struct { // contains filtered or unexported fields }",
        "type": "plugin"
    },
    "Plugin.Lookup": {
        "descr": "Lookup searches for a symbol named symName in plugin p. A symbol is any exported variable or function. It reports an error if the symbol is not found. It is safe for concurrent use by multiple goroutines.",
        "name": "plugin.Plugin.Lookup",
        "params": [],
        "path": "go/plugin/index#Plugin.Lookup",
        "syntax": "func (p *Plugin) Lookup(symName string) (Symbol, error)",
        "type": "plugin"
    },
    "Point": {
        "descr": "A Point is an X, Y coordinate pair. The axes increase right and down.",
        "name": "image.Point",
        "params": [],
        "path": "go/image/index#Point",
        "syntax": "type Point struct { X, Y int }",
        "type": "image"
    },
    "Point.Add": {
        "descr": "Add returns the vector p+q.",
        "name": "image.Point.Add",
        "params": [],
        "path": "go/image/index#Point.Add",
        "syntax": "func (p Point) Add(q Point) Point",
        "type": "image"
    },
    "Point.Div": {
        "descr": "Div returns the vector p/k.",
        "name": "image.Point.Div",
        "params": [],
        "path": "go/image/index#Point.Div",
        "syntax": "func (p Point) Div(k int) Point",
        "type": "image"
    },
    "Point.Eq": {
        "descr": "Eq reports whether p and q are equal.",
        "name": "image.Point.Eq",
        "params": [],
        "path": "go/image/index#Point.Eq",
        "syntax": "func (p Point) Eq(q Point) bool",
        "type": "image"
    },
    "Point.In": {
        "descr": "In reports whether p is in r.",
        "name": "image.Point.In",
        "params": [],
        "path": "go/image/index#Point.In",
        "syntax": "func (p Point) In(r Rectangle) bool",
        "type": "image"
    },
    "Point.Mod": {
        "descr": "Mod returns the point q in r such that p.X-q.X is a multiple of r's width and p.Y-q.Y is a multiple of r's height.",
        "name": "image.Point.Mod",
        "params": [],
        "path": "go/image/index#Point.Mod",
        "syntax": "func (p Point) Mod(r Rectangle) Point",
        "type": "image"
    },
    "Point.Mul": {
        "descr": "Mul returns the vector p*k.",
        "name": "image.Point.Mul",
        "params": [],
        "path": "go/image/index#Point.Mul",
        "syntax": "func (p Point) Mul(k int) Point",
        "type": "image"
    },
    "Point.String": {
        "descr": "String returns a string representation of p like \"(3,4)\".",
        "name": "image.Point.String",
        "params": [],
        "path": "go/image/index#Point.String",
        "syntax": "func (p Point) String() string",
        "type": "image"
    },
    "Point.Sub": {
        "descr": "Sub returns the vector p-q.",
        "name": "image.Point.Sub",
        "params": [],
        "path": "go/image/index#Point.Sub",
        "syntax": "func (p Point) Sub(q Point) Point",
        "type": "image"
    },
    "Pointer": {
        "descr": "Pointer represents a pointer to an arbitrary type. There are four special operations available for type Pointer that are not available for other types:",
        "name": "unsafe.Pointer",
        "params": [],
        "path": "go/unsafe/index#Pointer",
        "syntax": "- A pointer value of any type can be converted to a Pointer. - A Pointer can be converted to a pointer value of any type. - A uintptr can be converted to a Pointer. - A Pointer can be converted to a uintptr.",
        "type": "unsafe"
    },
    "Pool": {
        "descr": "A Pool is a set of temporary objects that may be individually saved and retrieved.",
        "name": "sync.Pool",
        "params": [],
        "path": "go/sync/index#Pool",
        "syntax": "type Pool struct { // New optionally specifies a function to generate // a value when Get would otherwise return nil. // It may not be changed concurrently with calls to Get. New func() interface{} // contains filtered or unexported fields }",
        "type": "sync"
    },
    "Pool.Get": {
        "descr": "Get selects an arbitrary item from the Pool, removes it from the Pool, and returns it to the caller. Get may choose to ignore the pool and treat it as empty. Callers should not assume any relation between values passed to Put and the values returned by Get.",
        "name": "sync.Pool.Get",
        "params": [],
        "path": "go/sync/index#Pool.Get",
        "syntax": "func (p *Pool) Get() interface{}",
        "type": "sync"
    },
    "Pool.Put": {
        "descr": "Put adds x to the pool.",
        "name": "sync.Pool.Put",
        "params": [],
        "path": "go/sync/index#Pool.Put",
        "syntax": "func (p *Pool) Put(x interface{})",
        "type": "sync"
    },
    "Pow": {
        "descr": "Pow returns x**y, the base-x exponential of y.",
        "name": "math.Pow",
        "params": [],
        "path": "go/math/index#Pow",
        "syntax": "func Pow(x, y float64) float64",
        "type": "math"
    },
    "Pow10": {
        "descr": "Pow10 returns 10**n, the base-10 exponential of n.",
        "name": "math.Pow10",
        "params": [],
        "path": "go/math/index#Pow10",
        "syntax": "func Pow10(n int) float64",
        "type": "math"
    },
    "Pread": {
        "descr": "",
        "name": "syscall.Pread",
        "params": [],
        "path": "go/syscall/index#Pread",
        "syntax": "func Pread(fd int, p []byte, offset int64) (n int, err error)",
        "type": "syscall"
    },
    "Prefix": {
        "descr": "Prefix returns the output prefix for the standard logger.",
        "name": "log.Prefix",
        "params": [],
        "path": "go/log/index#Prefix",
        "syntax": "func Prefix() string",
        "type": "log"
    },
    "Print": {
        "descr": "Print calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Print.",
        "name": "log.Print",
        "params": [],
        "path": "go/log/index#Print",
        "syntax": "func Print(v ...interface{})",
        "type": "log"
    },
    "PrintDefaults": {
        "descr": "PrintDefaults prints, to standard error unless configured otherwise, a usage message showing the default settings of all defined command-line flags. For an integer valued flag x, the default output has the form",
        "name": "flag.PrintDefaults",
        "params": [],
        "path": "go/flag/index#PrintDefaults",
        "syntax": "func PrintDefaults()",
        "type": "flag"
    },
    "Printf": {
        "descr": "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf.",
        "name": "log.Printf",
        "params": [],
        "path": "go/log/index#Printf",
        "syntax": "func Printf(format string, v ...interface{})",
        "type": "log"
    },
    "Println": {
        "descr": "Println calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Println.",
        "name": "log.Println",
        "params": [],
        "path": "go/log/index#Println",
        "syntax": "func Println(v ...interface{})",
        "type": "log"
    },
    "PrivateKey": {
        "descr": "PrivateKey represents a private key using an unspecified algorithm.",
        "name": "crypto.PrivateKey",
        "params": [],
        "path": "go/crypto/index#PrivateKey",
        "syntax": "type PrivateKey interface{}",
        "type": "crypto"
    },
    "ProcAttr": {
        "descr": "ProcAttr holds attributes that will be applied to a new process started by StartProcess.",
        "name": "syscall.ProcAttr",
        "params": [],
        "path": "go/syscall/index#ProcAttr",
        "syntax": "type ProcAttr struct { Dir string // Current working directory. Env []string // Environment. Files []uintptr // File descriptors. Sys *SysProcAttr }",
        "type": "syscall"
    },
    "Process": {
        "descr": "Process stores the information about a process created by StartProcess.",
        "name": "os.Process",
        "params": [],
        "path": "go/os/index#Process",
        "syntax": "type Process struct { Pid int // contains filtered or unexported fields }",
        "type": "os"
    },
    "Process.Kill": {
        "descr": "Kill causes the Process to exit immediately. Kill does not wait until the Process has actually exited. This only kills the Process itself, not any other processes it may have started.",
        "name": "os.Process.Kill",
        "params": [],
        "path": "go/os/index#Process.Kill",
        "syntax": "func (p *Process) Kill() error",
        "type": "os"
    },
    "Process.Release": {
        "descr": "Release releases any resources associated with the Process p, rendering it unusable in the future. Release only needs to be called if Wait is not.",
        "name": "os.Process.Release",
        "params": [],
        "path": "go/os/index#Process.Release",
        "syntax": "func (p *Process) Release() error",
        "type": "os"
    },
    "Process.Signal": {
        "descr": "Signal sends a signal to the Process. Sending Interrupt on Windows is not implemented.",
        "name": "os.Process.Signal",
        "params": [],
        "path": "go/os/index#Process.Signal",
        "syntax": "func (p *Process) Signal(sig Signal) error",
        "type": "os"
    },
    "Process.Wait": {
        "descr": "Wait waits for the Process to exit, and then returns a ProcessState describing its status and an error, if any. Wait releases any resources associated with the Process. On most operating systems, the Process must be a child of the current process or an error will be returned.",
        "name": "os.Process.Wait",
        "params": [],
        "path": "go/os/index#Process.Wait",
        "syntax": "func (p *Process) Wait() (*ProcessState, error)",
        "type": "os"
    },
    "ProcessState": {
        "descr": "ProcessState stores information about a process, as reported by Wait.",
        "name": "os.ProcessState",
        "params": [],
        "path": "go/os/index#ProcessState",
        "syntax": "type ProcessState struct { // contains filtered or unexported fields }",
        "type": "os"
    },
    "ProcessState.Exited": {
        "descr": "Exited reports whether the program has exited.",
        "name": "os.ProcessState.Exited",
        "params": [],
        "path": "go/os/index#ProcessState.Exited",
        "syntax": "func (p *ProcessState) Exited() bool",
        "type": "os"
    },
    "ProcessState.Pid": {
        "descr": "Pid returns the process id of the exited process.",
        "name": "os.ProcessState.Pid",
        "params": [],
        "path": "go/os/index#ProcessState.Pid",
        "syntax": "func (p *ProcessState) Pid() int",
        "type": "os"
    },
    "ProcessState.String": {
        "descr": "",
        "name": "os.ProcessState.String",
        "params": [],
        "path": "go/os/index#ProcessState.String",
        "syntax": "func (p *ProcessState) String() string",
        "type": "os"
    },
    "ProcessState.Success": {
        "descr": "Success reports whether the program exited successfully, such as with exit status 0 on Unix.",
        "name": "os.ProcessState.Success",
        "params": [],
        "path": "go/os/index#ProcessState.Success",
        "syntax": "func (p *ProcessState) Success() bool",
        "type": "os"
    },
    "ProcessState.Sys": {
        "descr": "Sys returns system-dependent exit information about the process. Convert it to the appropriate underlying type, such as syscall.WaitStatus on Unix, to access its contents.",
        "name": "os.ProcessState.Sys",
        "params": [],
        "path": "go/os/index#ProcessState.Sys",
        "syntax": "func (p *ProcessState) Sys() interface{}",
        "type": "os"
    },
    "ProcessState.SysUsage": {
        "descr": "SysUsage returns system-dependent resource usage information about the exited process. Convert it to the appropriate underlying type, such as *syscall.Rusage on Unix, to access its contents. (On Unix, *syscall.Rusage matches struct rusage as defined in the getrusage(2) manual page.)",
        "name": "os.ProcessState.SysUsage",
        "params": [],
        "path": "go/os/index#ProcessState.SysUsage",
        "syntax": "func (p *ProcessState) SysUsage() interface{}",
        "type": "os"
    },
    "ProcessState.SystemTime": {
        "descr": "SystemTime returns the system CPU time of the exited process and its children.",
        "name": "os.ProcessState.SystemTime",
        "params": [],
        "path": "go/os/index#ProcessState.SystemTime",
        "syntax": "func (p *ProcessState) SystemTime() time.Duration",
        "type": "os"
    },
    "ProcessState.UserTime": {
        "descr": "UserTime returns the user CPU time of the exited process and its children.",
        "name": "os.ProcessState.UserTime",
        "params": [],
        "path": "go/os/index#ProcessState.UserTime",
        "syntax": "func (p *ProcessState) UserTime() time.Duration",
        "type": "os"
    },
    "Pt": {
        "descr": "Pt is shorthand for Point{X, Y}.",
        "name": "image.Pt",
        "params": [],
        "path": "go/image/index#Pt",
        "syntax": "func Pt(X, Y int) Point",
        "type": "image"
    },
    "PtrTo": {
        "descr": "PtrTo returns the pointer type with element t. For example, if t represents type Foo, PtrTo(t) represents *Foo.",
        "name": "reflect.PtrTo",
        "params": [],
        "path": "go/reflect/index#PtrTo",
        "syntax": "func PtrTo(t Type) Type",
        "type": "reflect"
    },
    "PtraceAttach": {
        "descr": "",
        "name": "syscall.PtraceAttach",
        "params": [],
        "path": "go/syscall/index#PtraceAttach",
        "syntax": "func PtraceAttach(pid int) (err error)",
        "type": "syscall"
    },
    "PtraceCont": {
        "descr": "",
        "name": "syscall.PtraceCont",
        "params": [],
        "path": "go/syscall/index#PtraceCont",
        "syntax": "func PtraceCont(pid int, signal int) (err error)",
        "type": "syscall"
    },
    "PtraceDetach": {
        "descr": "",
        "name": "syscall.PtraceDetach",
        "params": [],
        "path": "go/syscall/index#PtraceDetach",
        "syntax": "func PtraceDetach(pid int) (err error)",
        "type": "syscall"
    },
    "PtraceGetEventMsg": {
        "descr": "",
        "name": "syscall.PtraceGetEventMsg",
        "params": [],
        "path": "go/syscall/index#PtraceGetEventMsg",
        "syntax": "func PtraceGetEventMsg(pid int) (msg uint, err error)",
        "type": "syscall"
    },
    "PtraceGetRegs": {
        "descr": "",
        "name": "syscall.PtraceGetRegs",
        "params": [],
        "path": "go/syscall/index#PtraceGetRegs",
        "syntax": "func PtraceGetRegs(pid int, regsout *PtraceRegs) (err error)",
        "type": "syscall"
    },
    "PtracePeekData": {
        "descr": "",
        "name": "syscall.PtracePeekData",
        "params": [],
        "path": "go/syscall/index#PtracePeekData",
        "syntax": "func PtracePeekData(pid int, addr uintptr, out []byte) (count int, err error)",
        "type": "syscall"
    },
    "PtracePeekText": {
        "descr": "",
        "name": "syscall.PtracePeekText",
        "params": [],
        "path": "go/syscall/index#PtracePeekText",
        "syntax": "func PtracePeekText(pid int, addr uintptr, out []byte) (count int, err error)",
        "type": "syscall"
    },
    "PtracePokeData": {
        "descr": "",
        "name": "syscall.PtracePokeData",
        "params": [],
        "path": "go/syscall/index#PtracePokeData",
        "syntax": "func PtracePokeData(pid int, addr uintptr, data []byte) (count int, err error)",
        "type": "syscall"
    },
    "PtracePokeText": {
        "descr": "",
        "name": "syscall.PtracePokeText",
        "params": [],
        "path": "go/syscall/index#PtracePokeText",
        "syntax": "func PtracePokeText(pid int, addr uintptr, data []byte) (count int, err error)",
        "type": "syscall"
    },
    "PtraceRegs": {
        "descr": "",
        "name": "syscall.PtraceRegs",
        "params": [],
        "path": "go/syscall/index#PtraceRegs",
        "syntax": "type PtraceRegs struct { R15 uint64 R14 uint64 R13 uint64 R12 uint64 Rbp uint64 Rbx uint64 R11 uint64 R10 uint64 R9 uint64 R8 uint64 Rax uint64 Rcx uint64 Rdx uint64 Rsi uint64 Rdi uint64 Orig_rax uint64 Rip uint64 Cs uint64 Eflags uint64 Rsp uint64 Ss uint64 Fs_base uint64 Gs_base uint64 Ds uint64 Es uint64 Fs uint64 Gs uint64 }",
        "type": "syscall"
    },
    "PtraceRegs.PC": {
        "descr": "",
        "name": "syscall.PtraceRegs.PC",
        "params": [],
        "path": "go/syscall/index#PtraceRegs.PC",
        "syntax": "func (r *PtraceRegs) PC() uint64",
        "type": "syscall"
    },
    "PtraceRegs.SetPC": {
        "descr": "",
        "name": "syscall.PtraceRegs.SetPC",
        "params": [],
        "path": "go/syscall/index#PtraceRegs.SetPC",
        "syntax": "func (r *PtraceRegs) SetPC(pc uint64)",
        "type": "syscall"
    },
    "PtraceSetOptions": {
        "descr": "",
        "name": "syscall.PtraceSetOptions",
        "params": [],
        "path": "go/syscall/index#PtraceSetOptions",
        "syntax": "func PtraceSetOptions(pid int, options int) (err error)",
        "type": "syscall"
    },
    "PtraceSetRegs": {
        "descr": "",
        "name": "syscall.PtraceSetRegs",
        "params": [],
        "path": "go/syscall/index#PtraceSetRegs",
        "syntax": "func PtraceSetRegs(pid int, regs *PtraceRegs) (err error)",
        "type": "syscall"
    },
    "PtraceSingleStep": {
        "descr": "",
        "name": "syscall.PtraceSingleStep",
        "params": [],
        "path": "go/syscall/index#PtraceSingleStep",
        "syntax": "func PtraceSingleStep(pid int) (err error)",
        "type": "syscall"
    },
    "PtraceSyscall": {
        "descr": "",
        "name": "syscall.PtraceSyscall",
        "params": [],
        "path": "go/syscall/index#PtraceSyscall",
        "syntax": "func PtraceSyscall(pid int, signal int) (err error)",
        "type": "syscall"
    },
    "PublicKey": {
        "descr": "PublicKey represents a public key using an unspecified algorithm.",
        "name": "crypto.PublicKey",
        "params": [],
        "path": "go/crypto/index#PublicKey",
        "syntax": "type PublicKey interface{}",
        "type": "crypto"
    },
    "Publish": {
        "descr": "Publish declares a named exported variable. This should be called from a package's init function when it creates its Vars. If the name is already registered then this will log.Panic.",
        "name": "expvar.Publish",
        "params": [],
        "path": "go/expvar/index#Publish",
        "syntax": "func Publish(name string, v Var)",
        "type": "expvar"
    },
    "Pwrite": {
        "descr": "",
        "name": "syscall.Pwrite",
        "params": [],
        "path": "go/syscall/index#Pwrite",
        "syntax": "func Pwrite(fd int, p []byte, offset int64) (n int, err error)",
        "type": "syscall"
    },
    "Quote": {
        "descr": "Quote returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for control characters and non-printable characters as defined by IsPrint.",
        "name": "strconv.Quote",
        "params": [],
        "path": "go/strconv/index#Quote",
        "syntax": "func Quote(s string) string",
        "type": "strconv"
    },
    "QuoteMeta": {
        "descr": "QuoteMeta returns a string that escapes all regular expression metacharacters inside the argument text; the returned string is a regular expression matching the literal text.",
        "name": "regexp.QuoteMeta",
        "params": [],
        "path": "go/regexp/index#QuoteMeta",
        "syntax": "func QuoteMeta(s string) string",
        "type": "regexp"
    },
    "QuoteRune": {
        "descr": "QuoteRune returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for control characters and non-printable characters as defined by IsPrint.",
        "name": "strconv.QuoteRune",
        "params": [],
        "path": "go/strconv/index#QuoteRune",
        "syntax": "func QuoteRune(r rune) string",
        "type": "strconv"
    },
    "QuoteRuneToASCII": {
        "descr": "QuoteRuneToASCII returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for non-ASCII characters and non-printable characters as defined by IsPrint.",
        "name": "strconv.QuoteRuneToASCII",
        "params": [],
        "path": "go/strconv/index#QuoteRuneToASCII",
        "syntax": "func QuoteRuneToASCII(r rune) string",
        "type": "strconv"
    },
    "QuoteRuneToGraphic": {
        "descr": "QuoteRuneToGraphic returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for non-ASCII characters and non-printable characters as defined by IsGraphic.",
        "name": "strconv.QuoteRuneToGraphic",
        "params": [],
        "path": "go/strconv/index#QuoteRuneToGraphic",
        "syntax": "func QuoteRuneToGraphic(r rune) string",
        "type": "strconv"
    },
    "QuoteToASCII": {
        "descr": "QuoteToASCII returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for non-ASCII characters and non-printable characters as defined by IsPrint.",
        "name": "strconv.QuoteToASCII",
        "params": [],
        "path": "go/strconv/index#QuoteToASCII",
        "syntax": "func QuoteToASCII(s string) string",
        "type": "strconv"
    },
    "QuoteToGraphic": {
        "descr": "QuoteToGraphic returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for non-ASCII characters and non-printable characters as defined by IsGraphic.",
        "name": "strconv.QuoteToGraphic",
        "params": [],
        "path": "go/strconv/index#QuoteToGraphic",
        "syntax": "func QuoteToGraphic(s string) string",
        "type": "strconv"
    },
    "RGBA": {
        "descr": "RGBA is an in-memory image whose At method returns color.RGBA values.",
        "name": "image.RGBA",
        "params": [],
        "path": "go/image/index#RGBA",
        "syntax": "type RGBA struct { // Pix holds the image's pixels, in R, G, B, A order. The pixel at // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4]. Pix []uint8 // Stride is the Pix stride (in bytes) between vertically adjacent pixels. Stride int // Rect is the image's bounds. Rect Rectangle }",
        "type": "image"
    },
    "RGBA.At": {
        "descr": "",
        "name": "image.RGBA.At",
        "params": [],
        "path": "go/image/index#RGBA.At",
        "syntax": "func (p *RGBA) At(x, y int) color.Color",
        "type": "image"
    },
    "RGBA.Bounds": {
        "descr": "",
        "name": "image.RGBA.Bounds",
        "params": [],
        "path": "go/image/index#RGBA.Bounds",
        "syntax": "func (p *RGBA) Bounds() Rectangle",
        "type": "image"
    },
    "RGBA.ColorModel": {
        "descr": "",
        "name": "image.RGBA.ColorModel",
        "params": [],
        "path": "go/image/index#RGBA.ColorModel",
        "syntax": "func (p *RGBA) ColorModel() color.Model",
        "type": "image"
    },
    "RGBA.Opaque": {
        "descr": "Opaque scans the entire image and reports whether it is fully opaque.",
        "name": "image.RGBA.Opaque",
        "params": [],
        "path": "go/image/index#RGBA.Opaque",
        "syntax": "func (p *RGBA) Opaque() bool",
        "type": "image"
    },
    "RGBA.PixOffset": {
        "descr": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y).",
        "name": "image.RGBA.PixOffset",
        "params": [],
        "path": "go/image/index#RGBA.PixOffset",
        "syntax": "func (p *RGBA) PixOffset(x, y int) int",
        "type": "image"
    },
    "RGBA.RGBAAt": {
        "descr": "",
        "name": "image.RGBA.RGBAAt",
        "params": [],
        "path": "go/image/index#RGBA.RGBAAt",
        "syntax": "func (p *RGBA) RGBAAt(x, y int) color.RGBA",
        "type": "image"
    },
    "RGBA.Set": {
        "descr": "",
        "name": "image.RGBA.Set",
        "params": [],
        "path": "go/image/index#RGBA.Set",
        "syntax": "func (p *RGBA) Set(x, y int, c color.Color)",
        "type": "image"
    },
    "RGBA.SetRGBA": {
        "descr": "",
        "name": "image.RGBA.SetRGBA",
        "params": [],
        "path": "go/image/index#RGBA.SetRGBA",
        "syntax": "func (p *RGBA) SetRGBA(x, y int, c color.RGBA)",
        "type": "image"
    },
    "RGBA.SubImage": {
        "descr": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.",
        "name": "image.RGBA.SubImage",
        "params": [],
        "path": "go/image/index#RGBA.SubImage",
        "syntax": "func (p *RGBA) SubImage(r Rectangle) Image",
        "type": "image"
    },
    "RGBA64": {
        "descr": "RGBA64 is an in-memory image whose At method returns color.RGBA64 values.",
        "name": "image.RGBA64",
        "params": [],
        "path": "go/image/index#RGBA64",
        "syntax": "type RGBA64 struct { // Pix holds the image's pixels, in R, G, B, A order and big-endian format. The pixel at // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*8]. Pix []uint8 // Stride is the Pix stride (in bytes) between vertically adjacent pixels. Stride int // Rect is the image's bounds. Rect Rectangle }",
        "type": "image"
    },
    "RGBA64.At": {
        "descr": "",
        "name": "image.RGBA64.At",
        "params": [],
        "path": "go/image/index#RGBA64.At",
        "syntax": "func (p *RGBA64) At(x, y int) color.Color",
        "type": "image"
    },
    "RGBA64.Bounds": {
        "descr": "",
        "name": "image.RGBA64.Bounds",
        "params": [],
        "path": "go/image/index#RGBA64.Bounds",
        "syntax": "func (p *RGBA64) Bounds() Rectangle",
        "type": "image"
    },
    "RGBA64.ColorModel": {
        "descr": "",
        "name": "image.RGBA64.ColorModel",
        "params": [],
        "path": "go/image/index#RGBA64.ColorModel",
        "syntax": "func (p *RGBA64) ColorModel() color.Model",
        "type": "image"
    },
    "RGBA64.Opaque": {
        "descr": "Opaque scans the entire image and reports whether it is fully opaque.",
        "name": "image.RGBA64.Opaque",
        "params": [],
        "path": "go/image/index#RGBA64.Opaque",
        "syntax": "func (p *RGBA64) Opaque() bool",
        "type": "image"
    },
    "RGBA64.PixOffset": {
        "descr": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y).",
        "name": "image.RGBA64.PixOffset",
        "params": [],
        "path": "go/image/index#RGBA64.PixOffset",
        "syntax": "func (p *RGBA64) PixOffset(x, y int) int",
        "type": "image"
    },
    "RGBA64.RGBA64At": {
        "descr": "",
        "name": "image.RGBA64.RGBA64At",
        "params": [],
        "path": "go/image/index#RGBA64.RGBA64At",
        "syntax": "func (p *RGBA64) RGBA64At(x, y int) color.RGBA64",
        "type": "image"
    },
    "RGBA64.Set": {
        "descr": "",
        "name": "image.RGBA64.Set",
        "params": [],
        "path": "go/image/index#RGBA64.Set",
        "syntax": "func (p *RGBA64) Set(x, y int, c color.Color)",
        "type": "image"
    },
    "RGBA64.SetRGBA64": {
        "descr": "",
        "name": "image.RGBA64.SetRGBA64",
        "params": [],
        "path": "go/image/index#RGBA64.SetRGBA64",
        "syntax": "func (p *RGBA64) SetRGBA64(x, y int, c color.RGBA64)",
        "type": "image"
    },
    "RGBA64.SubImage": {
        "descr": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.",
        "name": "image.RGBA64.SubImage",
        "params": [],
        "path": "go/image/index#RGBA64.SubImage",
        "syntax": "func (p *RGBA64) SubImage(r Rectangle) Image",
        "type": "image"
    },
    "RWMutex": {
        "descr": "A RWMutex is a reader/writer mutual exclusion lock. The lock can be held by an arbitrary number of readers or a single writer. The zero value for a RWMutex is an unlocked mutex.",
        "name": "sync.RWMutex",
        "params": [],
        "path": "go/sync/index#RWMutex",
        "syntax": "type RWMutex struct { // contains filtered or unexported fields }",
        "type": "sync"
    },
    "RWMutex.Lock": {
        "descr": "Lock locks rw for writing. If the lock is already locked for reading or writing, Lock blocks until the lock is available.",
        "name": "sync.RWMutex.Lock",
        "params": [],
        "path": "go/sync/index#RWMutex.Lock",
        "syntax": "func (rw *RWMutex) Lock()",
        "type": "sync"
    },
    "RWMutex.RLock": {
        "descr": "RLock locks rw for reading.",
        "name": "sync.RWMutex.RLock",
        "params": [],
        "path": "go/sync/index#RWMutex.RLock",
        "syntax": "func (rw *RWMutex) RLock()",
        "type": "sync"
    },
    "RWMutex.RLocker": {
        "descr": "RLocker returns a Locker interface that implements the Lock and Unlock methods by calling rw.RLock and rw.RUnlock.",
        "name": "sync.RWMutex.RLocker",
        "params": [],
        "path": "go/sync/index#RWMutex.RLocker",
        "syntax": "func (rw *RWMutex) RLocker() Locker",
        "type": "sync"
    },
    "RWMutex.RUnlock": {
        "descr": "RUnlock undoes a single RLock call; it does not affect other simultaneous readers. It is a run-time error if rw is not locked for reading on entry to RUnlock.",
        "name": "sync.RWMutex.RUnlock",
        "params": [],
        "path": "go/sync/index#RWMutex.RUnlock",
        "syntax": "func (rw *RWMutex) RUnlock()",
        "type": "sync"
    },
    "RWMutex.Unlock": {
        "descr": "Unlock unlocks rw for writing. It is a run-time error if rw is not locked for writing on entry to Unlock.",
        "name": "sync.RWMutex.Unlock",
        "params": [],
        "path": "go/sync/index#RWMutex.Unlock",
        "syntax": "func (rw *RWMutex) Unlock()",
        "type": "sync"
    },
    "Range16": {
        "descr": "Range16 represents of a range of 16-bit Unicode code points. The range runs from Lo to Hi inclusive and has the specified stride.",
        "name": "unicode.Range16",
        "params": [],
        "path": "go/unicode/index#Range16",
        "syntax": "type Range16 struct { Lo uint16 Hi uint16 Stride uint16 }",
        "type": "unicode"
    },
    "Range32": {
        "descr": "Range32 represents of a range of Unicode code points and is used when one or more of the values will not fit in 16 bits. The range runs from Lo to Hi inclusive and has the specified stride. Lo and Hi must always be >= 1<<16.",
        "name": "unicode.Range32",
        "params": [],
        "path": "go/unicode/index#Range32",
        "syntax": "type Range32 struct { Lo uint32 Hi uint32 Stride uint32 }",
        "type": "unicode"
    },
    "RangeTable": {
        "descr": "RangeTable defines a set of Unicode code points by listing the ranges of code points within the set. The ranges are listed in two slices to save space: a slice of 16-bit ranges and a slice of 32-bit ranges. The two slices must be in sorted order and non-overlapping. Also, R32 should contain only values >= 0x10000 (1<<16).",
        "name": "unicode.RangeTable",
        "params": [],
        "path": "go/unicode/index#RangeTable",
        "syntax": "type RangeTable struct { R16 []Range16 R32 []Range32 LatinOffset int // number of entries in R16 with Hi <= MaxLatin1; added in Go 1.1 }",
        "type": "unicode"
    },
    "RawConn": {
        "descr": "A RawConn is a raw network connection.",
        "name": "syscall.RawConn",
        "params": [],
        "path": "go/syscall/index#RawConn",
        "syntax": "type RawConn interface { // Control invokes f on the underlying connection's file // descriptor or handle. // The file descriptor fd is guaranteed to remain valid while // f executes but not after f returns. Control(f func(fd uintptr)) error // Read invokes f on the underlying connection's file // descriptor or handle; f is expected to try to read from the // file descriptor. // If f returns true, Read returns. Otherwise Read blocks // waiting for the connection to be ready for reading and // tries again repeatedly. // The file descriptor is guaranteed to remain valid while f // executes but not after f returns. Read(f func(fd uintptr) (done bool)) error // Write is like Read but for writing. Write(f func(fd uintptr) (done bool)) error }",
        "type": "syscall"
    },
    "RawSockaddr": {
        "descr": "",
        "name": "syscall.RawSockaddr",
        "params": [],
        "path": "go/syscall/index#RawSockaddr",
        "syntax": "type RawSockaddr struct { Family uint16 Data [14]int8 }",
        "type": "syscall"
    },
    "RawSockaddrAny": {
        "descr": "",
        "name": "syscall.RawSockaddrAny",
        "params": [],
        "path": "go/syscall/index#RawSockaddrAny",
        "syntax": "type RawSockaddrAny struct { Addr RawSockaddr Pad [96]int8 }",
        "type": "syscall"
    },
    "RawSockaddrInet4": {
        "descr": "",
        "name": "syscall.RawSockaddrInet4",
        "params": [],
        "path": "go/syscall/index#RawSockaddrInet4",
        "syntax": "type RawSockaddrInet4 struct { Family uint16 Port uint16 Addr [4]byte /* in_addr */ Zero [8]uint8 }",
        "type": "syscall"
    },
    "RawSockaddrInet6": {
        "descr": "",
        "name": "syscall.RawSockaddrInet6",
        "params": [],
        "path": "go/syscall/index#RawSockaddrInet6",
        "syntax": "type RawSockaddrInet6 struct { Family uint16 Port uint16 Flowinfo uint32 Addr [16]byte /* in6_addr */ Scope_id uint32 }",
        "type": "syscall"
    },
    "RawSockaddrLinklayer": {
        "descr": "",
        "name": "syscall.RawSockaddrLinklayer",
        "params": [],
        "path": "go/syscall/index#RawSockaddrLinklayer",
        "syntax": "type RawSockaddrLinklayer struct { Family uint16 Protocol uint16 Ifindex int32 Hatype uint16 Pkttype uint8 Halen uint8 Addr [8]uint8 }",
        "type": "syscall"
    },
    "RawSockaddrNetlink": {
        "descr": "",
        "name": "syscall.RawSockaddrNetlink",
        "params": [],
        "path": "go/syscall/index#RawSockaddrNetlink",
        "syntax": "type RawSockaddrNetlink struct { Family uint16 Pad uint16 Pid uint32 Groups uint32 }",
        "type": "syscall"
    },
    "RawSockaddrUnix": {
        "descr": "",
        "name": "syscall.RawSockaddrUnix",
        "params": [],
        "path": "go/syscall/index#RawSockaddrUnix",
        "syntax": "type RawSockaddrUnix struct { Family uint16 Path [108]int8 }",
        "type": "syscall"
    },
    "RawSyscall": {
        "descr": "",
        "name": "syscall.RawSyscall",
        "params": [],
        "path": "go/syscall/index#RawSyscall",
        "syntax": "func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)",
        "type": "syscall"
    },
    "RawSyscall6": {
        "descr": "",
        "name": "syscall.RawSyscall6",
        "params": [],
        "path": "go/syscall/index#RawSyscall6",
        "syntax": "func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)",
        "type": "syscall"
    },
    "Read": {
        "descr": "",
        "name": "syscall.Read",
        "params": [],
        "path": "go/syscall/index#Read",
        "syntax": "func Read(fd int, p []byte) (n int, err error)",
        "type": "syscall"
    },
    "ReadAtLeast": {
        "descr": "ReadAtLeast reads from r into buf until it has read at least min bytes. It returns the number of bytes copied and an error if fewer bytes were read. The error is EOF only if no bytes were read. If an EOF happens after reading fewer than min bytes, ReadAtLeast returns ErrUnexpectedEOF. If min is greater than the length of buf, ReadAtLeast returns ErrShortBuffer. On return, n >= min if and only if err == nil. If r returns an error having read at least min bytes, the error is dropped.",
        "name": "io.ReadAtLeast",
        "params": [],
        "path": "go/io/index#ReadAtLeast",
        "syntax": "func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)",
        "type": "io"
    },
    "ReadCloser": {
        "descr": "ReadCloser is the interface that groups the basic Read and Close methods.",
        "name": "io.ReadCloser",
        "params": [],
        "path": "go/io/index#ReadCloser",
        "syntax": "type ReadCloser interface { Reader Closer }",
        "type": "io"
    },
    "ReadDirent": {
        "descr": "",
        "name": "syscall.ReadDirent",
        "params": [],
        "path": "go/syscall/index#ReadDirent",
        "syntax": "func ReadDirent(fd int, buf []byte) (n int, err error)",
        "type": "syscall"
    },
    "ReadFull": {
        "descr": "ReadFull reads exactly len(buf) bytes from r into buf. It returns the number of bytes copied and an error if fewer bytes were read. The error is EOF only if no bytes were read. If an EOF happens after reading some but not all the bytes, ReadFull returns ErrUnexpectedEOF. On return, n == len(buf) if and only if err == nil. If r returns an error having read at least len(buf) bytes, the error is dropped.",
        "name": "io.ReadFull",
        "params": [],
        "path": "go/io/index#ReadFull",
        "syntax": "func ReadFull(r Reader, buf []byte) (n int, err error)",
        "type": "io"
    },
    "ReadMemStats": {
        "descr": "ReadMemStats populates m with memory allocator statistics.",
        "name": "runtime.ReadMemStats",
        "params": [],
        "path": "go/runtime/index#ReadMemStats",
        "syntax": "func ReadMemStats(m *MemStats)",
        "type": "runtime"
    },
    "ReadSeeker": {
        "descr": "ReadSeeker is the interface that groups the basic Read and Seek methods.",
        "name": "io.ReadSeeker",
        "params": [],
        "path": "go/io/index#ReadSeeker",
        "syntax": "type ReadSeeker interface { Reader Seeker }",
        "type": "io"
    },
    "ReadTrace": {
        "descr": "ReadTrace returns the next chunk of binary tracing data, blocking until data is available. If tracing is turned off and all the data accumulated while it was on has been returned, ReadTrace returns nil. The caller must copy the returned data before calling ReadTrace again. ReadTrace must be called from one goroutine at a time.",
        "name": "runtime.ReadTrace",
        "params": [],
        "path": "go/runtime/index#ReadTrace",
        "syntax": "func ReadTrace() []byte",
        "type": "runtime"
    },
    "ReadWriteCloser": {
        "descr": "ReadWriteCloser is the interface that groups the basic Read, Write and Close methods.",
        "name": "io.ReadWriteCloser",
        "params": [],
        "path": "go/io/index#ReadWriteCloser",
        "syntax": "type ReadWriteCloser interface { Reader Writer Closer }",
        "type": "io"
    },
    "ReadWriteSeeker": {
        "descr": "ReadWriteSeeker is the interface that groups the basic Read, Write and Seek methods.",
        "name": "io.ReadWriteSeeker",
        "params": [],
        "path": "go/io/index#ReadWriteSeeker",
        "syntax": "type ReadWriteSeeker interface { Reader Writer Seeker }",
        "type": "io"
    },
    "ReadWriter": {
        "descr": "ReadWriter is the interface that groups the basic Read and Write methods.",
        "name": "io.ReadWriter",
        "params": [],
        "path": "go/io/index#ReadWriter",
        "syntax": "type ReadWriter interface { Reader Writer }",
        "type": "io"
    },
    "Reader": {
        "descr": "A Reader implements the io.Reader, io.ReaderAt, io.Seeker, io.WriterTo, io.ByteScanner, and io.RuneScanner interfaces by reading from a string.",
        "name": "strings.Reader",
        "params": [],
        "path": "go/strings/index#Reader",
        "syntax": "type Reader struct { // contains filtered or unexported fields }",
        "type": "strings"
    },
    "Reader.Buffered": {
        "descr": "Buffered returns the number of bytes that can be read from the current buffer.",
        "name": "bufio.Reader.Buffered",
        "params": [],
        "path": "go/bufio/index#Reader.Buffered",
        "syntax": "func (b *Reader) Buffered() int",
        "type": "bufio"
    },
    "Reader.Discard": {
        "descr": "Discard skips the next n bytes, returning the number of bytes discarded.",
        "name": "bufio.Reader.Discard",
        "params": [],
        "path": "go/bufio/index#Reader.Discard",
        "syntax": "func (b *Reader) Discard(n int) (discarded int, err error)",
        "type": "bufio"
    },
    "Reader.Len": {
        "descr": "Len returns the number of bytes of the unread portion of the string.",
        "name": "strings.Reader.Len",
        "params": [],
        "path": "go/strings/index#Reader.Len",
        "syntax": "func (r *Reader) Len() int",
        "type": "strings"
    },
    "Reader.Peek": {
        "descr": "Peek returns the next n bytes without advancing the reader. The bytes stop being valid at the next read call. If Peek returns fewer than n bytes, it also returns an error explaining why the read is short. The error is ErrBufferFull if n is larger than b's buffer size.",
        "name": "bufio.Reader.Peek",
        "params": [],
        "path": "go/bufio/index#Reader.Peek",
        "syntax": "func (b *Reader) Peek(n int) ([]byte, error)",
        "type": "bufio"
    },
    "Reader.Read": {
        "descr": "",
        "name": "strings.Reader.Read",
        "params": [],
        "path": "go/strings/index#Reader.Read",
        "syntax": "func (r *Reader) Read(b []byte) (n int, err error)",
        "type": "strings"
    },
    "Reader.ReadAt": {
        "descr": "",
        "name": "strings.Reader.ReadAt",
        "params": [],
        "path": "go/strings/index#Reader.ReadAt",
        "syntax": "func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)",
        "type": "strings"
    },
    "Reader.ReadByte": {
        "descr": "",
        "name": "strings.Reader.ReadByte",
        "params": [],
        "path": "go/strings/index#Reader.ReadByte",
        "syntax": "func (r *Reader) ReadByte() (byte, error)",
        "type": "strings"
    },
    "Reader.ReadBytes": {
        "descr": "ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient.",
        "name": "bufio.Reader.ReadBytes",
        "params": [],
        "path": "go/bufio/index#Reader.ReadBytes",
        "syntax": "func (b *Reader) ReadBytes(delim byte) ([]byte, error)",
        "type": "bufio"
    },
    "Reader.ReadLine": {
        "descr": "ReadLine is a low-level line-reading primitive. Most callers should use ReadBytes('\\n') or ReadString('\\n') instead or use a Scanner.",
        "name": "bufio.Reader.ReadLine",
        "params": [],
        "path": "go/bufio/index#Reader.ReadLine",
        "syntax": "func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)",
        "type": "bufio"
    },
    "Reader.ReadRune": {
        "descr": "",
        "name": "strings.Reader.ReadRune",
        "params": [],
        "path": "go/strings/index#Reader.ReadRune",
        "syntax": "func (r *Reader) ReadRune() (ch rune, size int, err error)",
        "type": "strings"
    },
    "Reader.ReadSlice": {
        "descr": "ReadSlice reads until the first occurrence of delim in the input, returning a slice pointing at the bytes in the buffer. The bytes stop being valid at the next read. If ReadSlice encounters an error before finding a delimiter, it returns all the data in the buffer and the error itself (often io.EOF). ReadSlice fails with error ErrBufferFull if the buffer fills without a delim. Because the data returned from ReadSlice will be overwritten by the next I/O operation, most clients should use ReadBytes or ReadString instead. ReadSlice returns err != nil if and only if line does not end in delim.",
        "name": "bufio.Reader.ReadSlice",
        "params": [],
        "path": "go/bufio/index#Reader.ReadSlice",
        "syntax": "func (b *Reader) ReadSlice(delim byte) (line []byte, err error)",
        "type": "bufio"
    },
    "Reader.ReadString": {
        "descr": "ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient.",
        "name": "bufio.Reader.ReadString",
        "params": [],
        "path": "go/bufio/index#Reader.ReadString",
        "syntax": "func (b *Reader) ReadString(delim byte) (string, error)",
        "type": "bufio"
    },
    "Reader.Reset": {
        "descr": "Reset resets the Reader to be reading from s.",
        "name": "strings.Reader.Reset",
        "params": [],
        "path": "go/strings/index#Reader.Reset",
        "syntax": "func (r *Reader) Reset(s string)",
        "type": "strings"
    },
    "Reader.Seek": {
        "descr": "Seek implements the io.Seeker interface.",
        "name": "strings.Reader.Seek",
        "params": [],
        "path": "go/strings/index#Reader.Seek",
        "syntax": "func (r *Reader) Seek(offset int64, whence int) (int64, error)",
        "type": "strings"
    },
    "Reader.Size": {
        "descr": "Size returns the original length of the underlying string. Size is the number of bytes available for reading via ReadAt. The returned value is always the same and is not affected by calls to any other method.",
        "name": "strings.Reader.Size",
        "params": [],
        "path": "go/strings/index#Reader.Size",
        "syntax": "func (r *Reader) Size() int64",
        "type": "strings"
    },
    "Reader.UnreadByte": {
        "descr": "",
        "name": "strings.Reader.UnreadByte",
        "params": [],
        "path": "go/strings/index#Reader.UnreadByte",
        "syntax": "func (r *Reader) UnreadByte() error",
        "type": "strings"
    },
    "Reader.UnreadRune": {
        "descr": "",
        "name": "strings.Reader.UnreadRune",
        "params": [],
        "path": "go/strings/index#Reader.UnreadRune",
        "syntax": "func (r *Reader) UnreadRune() error",
        "type": "strings"
    },
    "Reader.WriteTo": {
        "descr": "WriteTo implements the io.WriterTo interface.",
        "name": "strings.Reader.WriteTo",
        "params": [],
        "path": "go/strings/index#Reader.WriteTo",
        "syntax": "func (r *Reader) WriteTo(w io.Writer) (n int64, err error)",
        "type": "strings"
    },
    "ReaderAt": {
        "descr": "ReaderAt is the interface that wraps the basic ReadAt method.",
        "name": "io.ReaderAt",
        "params": [],
        "path": "go/io/index#ReaderAt",
        "syntax": "type ReaderAt interface { ReadAt(p []byte, off int64) (n int, err error) }",
        "type": "io"
    },
    "ReaderFrom": {
        "descr": "ReaderFrom is the interface that wraps the ReadFrom method.",
        "name": "io.ReaderFrom",
        "params": [],
        "path": "go/io/index#ReaderFrom",
        "syntax": "type ReaderFrom interface { ReadFrom(r Reader) (n int64, err error) }",
        "type": "io"
    },
    "Readlink": {
        "descr": "",
        "name": "syscall.Readlink",
        "params": [],
        "path": "go/syscall/index#Readlink",
        "syntax": "func Readlink(path string, buf []byte) (n int, err error)",
        "type": "syscall"
    },
    "Reboot": {
        "descr": "",
        "name": "syscall.Reboot",
        "params": [],
        "path": "go/syscall/index#Reboot",
        "syntax": "func Reboot(cmd int) (err error)",
        "type": "syscall"
    },
    "Rect": {
        "descr": "Rect is shorthand for Rectangle{Pt(x0, y0), Pt(x1, y1)}. The returned rectangle has minimum and maximum coordinates swapped if necessary so that it is well-formed.",
        "name": "image.Rect",
        "params": [],
        "path": "go/image/index#Rect",
        "syntax": "func Rect(x0, y0, x1, y1 int) Rectangle",
        "type": "image"
    },
    "Rectangle": {
        "descr": "A Rectangle contains the points with Min.X <= X < Max.X, Min.Y <= Y < Max.Y. It is well-formed if Min.X <= Max.X and likewise for Y. Points are always well-formed. A rectangle's methods always return well-formed outputs for well-formed inputs.",
        "name": "image.Rectangle",
        "params": [],
        "path": "go/image/index#Rectangle",
        "syntax": "type Rectangle struct { Min, Max Point }",
        "type": "image"
    },
    "Rectangle.Add": {
        "descr": "Add returns the rectangle r translated by p.",
        "name": "image.Rectangle.Add",
        "params": [],
        "path": "go/image/index#Rectangle.Add",
        "syntax": "func (r Rectangle) Add(p Point) Rectangle",
        "type": "image"
    },
    "Rectangle.At": {
        "descr": "At implements the Image interface.",
        "name": "image.Rectangle.At",
        "params": [],
        "path": "go/image/index#Rectangle.At",
        "syntax": "func (r Rectangle) At(x, y int) color.Color",
        "type": "image"
    },
    "Rectangle.Bounds": {
        "descr": "Bounds implements the Image interface.",
        "name": "image.Rectangle.Bounds",
        "params": [],
        "path": "go/image/index#Rectangle.Bounds",
        "syntax": "func (r Rectangle) Bounds() Rectangle",
        "type": "image"
    },
    "Rectangle.Canon": {
        "descr": "Canon returns the canonical version of r. The returned rectangle has minimum and maximum coordinates swapped if necessary so that it is well-formed.",
        "name": "image.Rectangle.Canon",
        "params": [],
        "path": "go/image/index#Rectangle.Canon",
        "syntax": "func (r Rectangle) Canon() Rectangle",
        "type": "image"
    },
    "Rectangle.ColorModel": {
        "descr": "ColorModel implements the Image interface.",
        "name": "image.Rectangle.ColorModel",
        "params": [],
        "path": "go/image/index#Rectangle.ColorModel",
        "syntax": "func (r Rectangle) ColorModel() color.Model",
        "type": "image"
    },
    "Rectangle.Dx": {
        "descr": "Dx returns r's width.",
        "name": "image.Rectangle.Dx",
        "params": [],
        "path": "go/image/index#Rectangle.Dx",
        "syntax": "func (r Rectangle) Dx() int",
        "type": "image"
    },
    "Rectangle.Dy": {
        "descr": "Dy returns r's height.",
        "name": "image.Rectangle.Dy",
        "params": [],
        "path": "go/image/index#Rectangle.Dy",
        "syntax": "func (r Rectangle) Dy() int",
        "type": "image"
    },
    "Rectangle.Empty": {
        "descr": "Empty reports whether the rectangle contains no points.",
        "name": "image.Rectangle.Empty",
        "params": [],
        "path": "go/image/index#Rectangle.Empty",
        "syntax": "func (r Rectangle) Empty() bool",
        "type": "image"
    },
    "Rectangle.Eq": {
        "descr": "Eq reports whether r and s contain the same set of points. All empty rectangles are considered equal.",
        "name": "image.Rectangle.Eq",
        "params": [],
        "path": "go/image/index#Rectangle.Eq",
        "syntax": "func (r Rectangle) Eq(s Rectangle) bool",
        "type": "image"
    },
    "Rectangle.In": {
        "descr": "In reports whether every point in r is in s.",
        "name": "image.Rectangle.In",
        "params": [],
        "path": "go/image/index#Rectangle.In",
        "syntax": "func (r Rectangle) In(s Rectangle) bool",
        "type": "image"
    },
    "Rectangle.Inset": {
        "descr": "Inset returns the rectangle r inset by n, which may be negative. If either of r's dimensions is less than 2*n then an empty rectangle near the center of r will be returned.",
        "name": "image.Rectangle.Inset",
        "params": [],
        "path": "go/image/index#Rectangle.Inset",
        "syntax": "func (r Rectangle) Inset(n int) Rectangle",
        "type": "image"
    },
    "Rectangle.Intersect": {
        "descr": "Intersect returns the largest rectangle contained by both r and s. If the two rectangles do not overlap then the zero rectangle will be returned.",
        "name": "image.Rectangle.Intersect",
        "params": [],
        "path": "go/image/index#Rectangle.Intersect",
        "syntax": "func (r Rectangle) Intersect(s Rectangle) Rectangle",
        "type": "image"
    },
    "Rectangle.Overlaps": {
        "descr": "Overlaps reports whether r and s have a non-empty intersection.",
        "name": "image.Rectangle.Overlaps",
        "params": [],
        "path": "go/image/index#Rectangle.Overlaps",
        "syntax": "func (r Rectangle) Overlaps(s Rectangle) bool",
        "type": "image"
    },
    "Rectangle.Size": {
        "descr": "Size returns r's width and height.",
        "name": "image.Rectangle.Size",
        "params": [],
        "path": "go/image/index#Rectangle.Size",
        "syntax": "func (r Rectangle) Size() Point",
        "type": "image"
    },
    "Rectangle.String": {
        "descr": "String returns a string representation of r like \"(3,4)-(6,5)\".",
        "name": "image.Rectangle.String",
        "params": [],
        "path": "go/image/index#Rectangle.String",
        "syntax": "func (r Rectangle) String() string",
        "type": "image"
    },
    "Rectangle.Sub": {
        "descr": "Sub returns the rectangle r translated by -p.",
        "name": "image.Rectangle.Sub",
        "params": [],
        "path": "go/image/index#Rectangle.Sub",
        "syntax": "func (r Rectangle) Sub(p Point) Rectangle",
        "type": "image"
    },
    "Rectangle.Union": {
        "descr": "Union returns the smallest rectangle that contains both r and s.",
        "name": "image.Rectangle.Union",
        "params": [],
        "path": "go/image/index#Rectangle.Union",
        "syntax": "func (r Rectangle) Union(s Rectangle) Rectangle",
        "type": "image"
    },
    "Recvfrom": {
        "descr": "",
        "name": "syscall.Recvfrom",
        "params": [],
        "path": "go/syscall/index#Recvfrom",
        "syntax": "func Recvfrom(fd int, p []byte, flags int) (n int, from Sockaddr, err error)",
        "type": "syscall"
    },
    "Recvmsg": {
        "descr": "",
        "name": "syscall.Recvmsg",
        "params": [],
        "path": "go/syscall/index#Recvmsg",
        "syntax": "func Recvmsg(fd int, p, oob []byte, flags int) (n, oobn int, recvflags int, from Sockaddr, err error)",
        "type": "syscall"
    },
    "Regexp": {
        "descr": "Regexp is the representation of a compiled regular expression. A Regexp is safe for concurrent use by multiple goroutines, except for configuration methods, such as Longest.",
        "name": "regexp.Regexp",
        "params": [],
        "path": "go/regexp/index#Regexp",
        "syntax": "type Regexp struct { // contains filtered or unexported fields }",
        "type": "regexp"
    },
    "Regexp.Copy": {
        "descr": "Copy returns a new Regexp object copied from re.",
        "name": "regexp.Regexp.Copy",
        "params": [],
        "path": "go/regexp/index#Regexp.Copy",
        "syntax": "func (re *Regexp) Copy() *Regexp",
        "type": "regexp"
    },
    "Regexp.Expand": {
        "descr": "Expand appends template to dst and returns the result; during the append, Expand replaces variables in the template with corresponding matches drawn from src. The match slice should have been returned by FindSubmatchIndex.",
        "name": "regexp.Regexp.Expand",
        "params": [],
        "path": "go/regexp/index#Regexp.Expand",
        "syntax": "func (re *Regexp) Expand(dst []byte, template []byte, src []byte, match []int) []byte",
        "type": "regexp"
    },
    "Regexp.ExpandString": {
        "descr": "ExpandString is like Expand but the template and source are strings. It appends to and returns a byte slice in order to give the calling code control over allocation.",
        "name": "regexp.Regexp.ExpandString",
        "params": [],
        "path": "go/regexp/index#Regexp.ExpandString",
        "syntax": "func (re *Regexp) ExpandString(dst []byte, template string, src string, match []int) []byte",
        "type": "regexp"
    },
    "Regexp.Find": {
        "descr": "Find returns a slice holding the text of the leftmost match in b of the regular expression. A return value of nil indicates no match.",
        "name": "regexp.Regexp.Find",
        "params": [],
        "path": "go/regexp/index#Regexp.Find",
        "syntax": "func (re *Regexp) Find(b []byte) []byte",
        "type": "regexp"
    },
    "Regexp.FindAll": {
        "descr": "FindAll is the 'All' version of Find; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindAll",
        "params": [],
        "path": "go/regexp/index#Regexp.FindAll",
        "syntax": "func (re *Regexp) FindAll(b []byte, n int) [][]byte",
        "type": "regexp"
    },
    "Regexp.FindAllIndex": {
        "descr": "FindAllIndex is the 'All' version of FindIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindAllIndex",
        "params": [],
        "path": "go/regexp/index#Regexp.FindAllIndex",
        "syntax": "func (re *Regexp) FindAllIndex(b []byte, n int) [][]int",
        "type": "regexp"
    },
    "Regexp.FindAllString": {
        "descr": "FindAllString is the 'All' version of FindString; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindAllString",
        "params": [],
        "path": "go/regexp/index#Regexp.FindAllString",
        "syntax": "func (re *Regexp) FindAllString(s string, n int) []string",
        "type": "regexp"
    },
    "Regexp.FindAllStringIndex": {
        "descr": "FindAllStringIndex is the 'All' version of FindStringIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindAllStringIndex",
        "params": [],
        "path": "go/regexp/index#Regexp.FindAllStringIndex",
        "syntax": "func (re *Regexp) FindAllStringIndex(s string, n int) [][]int",
        "type": "regexp"
    },
    "Regexp.FindAllStringSubmatch": {
        "descr": "FindAllStringSubmatch is the 'All' version of FindStringSubmatch; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindAllStringSubmatch",
        "params": [],
        "path": "go/regexp/index#Regexp.FindAllStringSubmatch",
        "syntax": "func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string",
        "type": "regexp"
    },
    "Regexp.FindAllStringSubmatchIndex": {
        "descr": "FindAllStringSubmatchIndex is the 'All' version of FindStringSubmatchIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindAllStringSubmatchIndex",
        "params": [],
        "path": "go/regexp/index#Regexp.FindAllStringSubmatchIndex",
        "syntax": "func (re *Regexp) FindAllStringSubmatchIndex(s string, n int) [][]int",
        "type": "regexp"
    },
    "Regexp.FindAllSubmatch": {
        "descr": "FindAllSubmatch is the 'All' version of FindSubmatch; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindAllSubmatch",
        "params": [],
        "path": "go/regexp/index#Regexp.FindAllSubmatch",
        "syntax": "func (re *Regexp) FindAllSubmatch(b []byte, n int) [][][]byte",
        "type": "regexp"
    },
    "Regexp.FindAllSubmatchIndex": {
        "descr": "FindAllSubmatchIndex is the 'All' version of FindSubmatchIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindAllSubmatchIndex",
        "params": [],
        "path": "go/regexp/index#Regexp.FindAllSubmatchIndex",
        "syntax": "func (re *Regexp) FindAllSubmatchIndex(b []byte, n int) [][]int",
        "type": "regexp"
    },
    "Regexp.FindIndex": {
        "descr": "FindIndex returns a two-element slice of integers defining the location of the leftmost match in b of the regular expression. The match itself is at b[loc[0]:loc[1]]. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindIndex",
        "params": [],
        "path": "go/regexp/index#Regexp.FindIndex",
        "syntax": "func (re *Regexp) FindIndex(b []byte) (loc []int)",
        "type": "regexp"
    },
    "Regexp.FindReaderIndex": {
        "descr": "FindReaderIndex returns a two-element slice of integers defining the location of the leftmost match of the regular expression in text read from the RuneReader. The match text was found in the input stream at byte offset loc[0] through loc[1]-1. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindReaderIndex",
        "params": [],
        "path": "go/regexp/index#Regexp.FindReaderIndex",
        "syntax": "func (re *Regexp) FindReaderIndex(r io.RuneReader) (loc []int)",
        "type": "regexp"
    },
    "Regexp.FindReaderSubmatchIndex": {
        "descr": "FindReaderSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression of text read by the RuneReader, and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindReaderSubmatchIndex",
        "params": [],
        "path": "go/regexp/index#Regexp.FindReaderSubmatchIndex",
        "syntax": "func (re *Regexp) FindReaderSubmatchIndex(r io.RuneReader) []int",
        "type": "regexp"
    },
    "Regexp.FindString": {
        "descr": "FindString returns a string holding the text of the leftmost match in s of the regular expression. If there is no match, the return value is an empty string, but it will also be empty if the regular expression successfully matches an empty string. Use FindStringIndex or FindStringSubmatch if it is necessary to distinguish these cases.",
        "name": "regexp.Regexp.FindString",
        "params": [],
        "path": "go/regexp/index#Regexp.FindString",
        "syntax": "func (re *Regexp) FindString(s string) string",
        "type": "regexp"
    },
    "Regexp.FindStringIndex": {
        "descr": "FindStringIndex returns a two-element slice of integers defining the location of the leftmost match in s of the regular expression. The match itself is at s[loc[0]:loc[1]]. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindStringIndex",
        "params": [],
        "path": "go/regexp/index#Regexp.FindStringIndex",
        "syntax": "func (re *Regexp) FindStringIndex(s string) (loc []int)",
        "type": "regexp"
    },
    "Regexp.FindStringSubmatch": {
        "descr": "FindStringSubmatch returns a slice of strings holding the text of the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the 'Submatch' description in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindStringSubmatch",
        "params": [],
        "path": "go/regexp/index#Regexp.FindStringSubmatch",
        "syntax": "func (re *Regexp) FindStringSubmatch(s string) []string",
        "type": "regexp"
    },
    "Regexp.FindStringSubmatchIndex": {
        "descr": "FindStringSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindStringSubmatchIndex",
        "params": [],
        "path": "go/regexp/index#Regexp.FindStringSubmatchIndex",
        "syntax": "func (re *Regexp) FindStringSubmatchIndex(s string) []int",
        "type": "regexp"
    },
    "Regexp.FindSubmatch": {
        "descr": "FindSubmatch returns a slice of slices holding the text of the leftmost match of the regular expression in b and the matches, if any, of its subexpressions, as defined by the 'Submatch' descriptions in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindSubmatch",
        "params": [],
        "path": "go/regexp/index#Regexp.FindSubmatch",
        "syntax": "func (re *Regexp) FindSubmatch(b []byte) [][]byte",
        "type": "regexp"
    },
    "Regexp.FindSubmatchIndex": {
        "descr": "FindSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression in b and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindSubmatchIndex",
        "params": [],
        "path": "go/regexp/index#Regexp.FindSubmatchIndex",
        "syntax": "func (re *Regexp) FindSubmatchIndex(b []byte) []int",
        "type": "regexp"
    },
    "Regexp.LiteralPrefix": {
        "descr": "LiteralPrefix returns a literal string that must begin any match of the regular expression re. It returns the boolean true if the literal string comprises the entire regular expression.",
        "name": "regexp.Regexp.LiteralPrefix",
        "params": [],
        "path": "go/regexp/index#Regexp.LiteralPrefix",
        "syntax": "func (re *Regexp) LiteralPrefix() (prefix string, complete bool)",
        "type": "regexp"
    },
    "Regexp.Longest": {
        "descr": "Longest makes future searches prefer the leftmost-longest match. That is, when matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses a match that is as long as possible. This method modifies the Regexp and may not be called concurrently with any other methods.",
        "name": "regexp.Regexp.Longest",
        "params": [],
        "path": "go/regexp/index#Regexp.Longest",
        "syntax": "func (re *Regexp) Longest()",
        "type": "regexp"
    },
    "Regexp.Match": {
        "descr": "Match reports whether the byte slice b contains any match of the regular expression re.",
        "name": "regexp.Regexp.Match",
        "params": [],
        "path": "go/regexp/index#Regexp.Match",
        "syntax": "func (re *Regexp) Match(b []byte) bool",
        "type": "regexp"
    },
    "Regexp.MatchReader": {
        "descr": "MatchReader reports whether the text returned by the RuneReader contains any match of the regular expression re.",
        "name": "regexp.Regexp.MatchReader",
        "params": [],
        "path": "go/regexp/index#Regexp.MatchReader",
        "syntax": "func (re *Regexp) MatchReader(r io.RuneReader) bool",
        "type": "regexp"
    },
    "Regexp.MatchString": {
        "descr": "MatchString reports whether the string s contains any match of the regular expression re.",
        "name": "regexp.Regexp.MatchString",
        "params": [],
        "path": "go/regexp/index#Regexp.MatchString",
        "syntax": "func (re *Regexp) MatchString(s string) bool",
        "type": "regexp"
    },
    "Regexp.NumSubexp": {
        "descr": "NumSubexp returns the number of parenthesized subexpressions in this Regexp.",
        "name": "regexp.Regexp.NumSubexp",
        "params": [],
        "path": "go/regexp/index#Regexp.NumSubexp",
        "syntax": "func (re *Regexp) NumSubexp() int",
        "type": "regexp"
    },
    "Regexp.ReplaceAll": {
        "descr": "ReplaceAll returns a copy of src, replacing matches of the Regexp with the replacement text repl. Inside repl, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch.",
        "name": "regexp.Regexp.ReplaceAll",
        "params": [],
        "path": "go/regexp/index#Regexp.ReplaceAll",
        "syntax": "func (re *Regexp) ReplaceAll(src, repl []byte) []byte",
        "type": "regexp"
    },
    "Regexp.ReplaceAllFunc": {
        "descr": "ReplaceAllFunc returns a copy of src in which all matches of the Regexp have been replaced by the return value of function repl applied to the matched byte slice. The replacement returned by repl is substituted directly, without using Expand.",
        "name": "regexp.Regexp.ReplaceAllFunc",
        "params": [],
        "path": "go/regexp/index#Regexp.ReplaceAllFunc",
        "syntax": "func (re *Regexp) ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte",
        "type": "regexp"
    },
    "Regexp.ReplaceAllLiteral": {
        "descr": "ReplaceAllLiteral returns a copy of src, replacing matches of the Regexp with the replacement bytes repl. The replacement repl is substituted directly, without using Expand.",
        "name": "regexp.Regexp.ReplaceAllLiteral",
        "params": [],
        "path": "go/regexp/index#Regexp.ReplaceAllLiteral",
        "syntax": "func (re *Regexp) ReplaceAllLiteral(src, repl []byte) []byte",
        "type": "regexp"
    },
    "Regexp.ReplaceAllLiteralString": {
        "descr": "ReplaceAllLiteralString returns a copy of src, replacing matches of the Regexp with the replacement string repl. The replacement repl is substituted directly, without using Expand.",
        "name": "regexp.Regexp.ReplaceAllLiteralString",
        "params": [],
        "path": "go/regexp/index#Regexp.ReplaceAllLiteralString",
        "syntax": "func (re *Regexp) ReplaceAllLiteralString(src, repl string) string",
        "type": "regexp"
    },
    "Regexp.ReplaceAllString": {
        "descr": "ReplaceAllString returns a copy of src, replacing matches of the Regexp with the replacement string repl. Inside repl, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch.",
        "name": "regexp.Regexp.ReplaceAllString",
        "params": [],
        "path": "go/regexp/index#Regexp.ReplaceAllString",
        "syntax": "func (re *Regexp) ReplaceAllString(src, repl string) string",
        "type": "regexp"
    },
    "Regexp.ReplaceAllStringFunc": {
        "descr": "ReplaceAllStringFunc returns a copy of src in which all matches of the Regexp have been replaced by the return value of function repl applied to the matched substring. The replacement returned by repl is substituted directly, without using Expand.",
        "name": "regexp.Regexp.ReplaceAllStringFunc",
        "params": [],
        "path": "go/regexp/index#Regexp.ReplaceAllStringFunc",
        "syntax": "func (re *Regexp) ReplaceAllStringFunc(src string, repl func(string) string) string",
        "type": "regexp"
    },
    "Regexp.Split": {
        "descr": "Split slices s into substrings separated by the expression and returns a slice of the substrings between those expression matches.",
        "name": "regexp.Regexp.Split",
        "params": [],
        "path": "go/regexp/index#Regexp.Split",
        "syntax": "func (re *Regexp) Split(s string, n int) []string",
        "type": "regexp"
    },
    "Regexp.String": {
        "descr": "String returns the source text used to compile the regular expression.",
        "name": "regexp.Regexp.String",
        "params": [],
        "path": "go/regexp/index#Regexp.String",
        "syntax": "func (re *Regexp) String() string",
        "type": "regexp"
    },
    "Regexp.SubexpNames": {
        "descr": "SubexpNames returns the names of the parenthesized subexpressions in this Regexp. The name for the first sub-expression is names[1], so that if m is a match slice, the name for m[i] is SubexpNames()[i]. Since the Regexp as a whole cannot be named, names[0] is always the empty string. The slice should not be modified.",
        "name": "regexp.Regexp.SubexpNames",
        "params": [],
        "path": "go/regexp/index#Regexp.SubexpNames",
        "syntax": "func (re *Regexp) SubexpNames() []string",
        "type": "regexp"
    },
    "RegisterCover": {
        "descr": "RegisterCover records the coverage data accumulators for the tests. NOTE: This function is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines.",
        "name": "testing.RegisterCover",
        "params": [],
        "path": "go/testing/index#RegisterCover",
        "syntax": "func RegisterCover(c Cover)",
        "type": "testing"
    },
    "RegisterFormat": {
        "descr": "RegisterFormat registers an image format for use by Decode. Name is the name of the format, like \"jpeg\" or \"png\". Magic is the magic prefix that identifies the format's encoding. The magic string can contain \"?\" wildcards that each match any one byte. Decode is the function that decodes the encoded image. DecodeConfig is the function that decodes just its configuration.",
        "name": "image.RegisterFormat",
        "params": [],
        "path": "go/image/index#RegisterFormat",
        "syntax": "func RegisterFormat(name, magic string, decode func(io.Reader) (Image, error), decodeConfig func(io.Reader) (Config, error))",
        "type": "image"
    },
    "RegisterHash": {
        "descr": "RegisterHash registers a function that returns a new instance of the given hash function. This is intended to be called from the init function in packages that implement hash functions.",
        "name": "crypto.RegisterHash",
        "params": [],
        "path": "go/crypto/index#RegisterHash",
        "syntax": "func RegisterHash(h Hash, f func() hash.Hash)",
        "type": "crypto"
    },
    "Remainder": {
        "descr": "Remainder returns the IEEE 754 floating-point remainder of x/y.",
        "name": "math.Remainder",
        "params": [],
        "path": "go/math/index#Remainder",
        "syntax": "func Remainder(x, y float64) float64",
        "type": "math"
    },
    "Remove": {
        "descr": "Remove removes the named file or (empty) directory. If there is an error, it will be of type *PathError.",
        "name": "os.Remove",
        "params": [],
        "path": "go/os/index#Remove",
        "syntax": "func Remove(name string) error",
        "type": "os"
    },
    "RemoveAll": {
        "descr": "RemoveAll removes path and any children it contains. It removes everything it can but returns the first error it encounters. If the path does not exist, RemoveAll returns nil (no error).",
        "name": "os.RemoveAll",
        "params": [],
        "path": "go/os/index#RemoveAll",
        "syntax": "func RemoveAll(path string) error",
        "type": "os"
    },
    "Removexattr": {
        "descr": "",
        "name": "syscall.Removexattr",
        "params": [],
        "path": "go/syscall/index#Removexattr",
        "syntax": "func Removexattr(path string, attr string) (err error)",
        "type": "syscall"
    },
    "Rename": {
        "descr": "",
        "name": "syscall.Rename",
        "params": [],
        "path": "go/syscall/index#Rename",
        "syntax": "func Rename(oldpath string, newpath string) (err error)",
        "type": "syscall"
    },
    "Renameat": {
        "descr": "",
        "name": "syscall.Renameat",
        "params": [],
        "path": "go/syscall/index#Renameat",
        "syntax": "func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)",
        "type": "syscall"
    },
    "Repeat": {
        "descr": "Repeat returns a new string consisting of count copies of the string s.",
        "name": "strings.Repeat",
        "params": [],
        "path": "go/strings/index#Repeat",
        "syntax": "func Repeat(s string, count int) string",
        "type": "strings"
    },
    "Replace": {
        "descr": "Replace returns a copy of the string s with the first n non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the string and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune string. If n < 0, there is no limit on the number of replacements.",
        "name": "strings.Replace",
        "params": [],
        "path": "go/strings/index#Replace",
        "syntax": "func Replace(s, old, new string, n int) string",
        "type": "strings"
    },
    "Replacer": {
        "descr": "Replacer replaces a list of strings with replacements. It is safe for concurrent use by multiple goroutines.",
        "name": "strings.Replacer",
        "params": [],
        "path": "go/strings/index#Replacer",
        "syntax": "type Replacer struct { // contains filtered or unexported fields }",
        "type": "strings"
    },
    "Replacer.Replace": {
        "descr": "Replace returns a copy of s with all replacements performed.",
        "name": "strings.Replacer.Replace",
        "params": [],
        "path": "go/strings/index#Replacer.Replace",
        "syntax": "func (r *Replacer) Replace(s string) string",
        "type": "strings"
    },
    "Replacer.WriteString": {
        "descr": "WriteString writes s to w with all replacements performed.",
        "name": "strings.Replacer.WriteString",
        "params": [],
        "path": "go/strings/index#Replacer.WriteString",
        "syntax": "func (r *Replacer) WriteString(w io.Writer, s string) (n int, err error)",
        "type": "strings"
    },
    "ResolveIPAddr": {
        "descr": "ResolveIPAddr returns an address of IP end point.",
        "name": "net.ResolveIPAddr",
        "params": [],
        "path": "go/net/index#ResolveIPAddr",
        "syntax": "func ResolveIPAddr(network, address string) (*IPAddr, error)",
        "type": "net"
    },
    "ResolveTCPAddr": {
        "descr": "ResolveTCPAddr returns an address of TCP end point.",
        "name": "net.ResolveTCPAddr",
        "params": [],
        "path": "go/net/index#ResolveTCPAddr",
        "syntax": "func ResolveTCPAddr(network, address string) (*TCPAddr, error)",
        "type": "net"
    },
    "ResolveUDPAddr": {
        "descr": "ResolveUDPAddr returns an address of UDP end point.",
        "name": "net.ResolveUDPAddr",
        "params": [],
        "path": "go/net/index#ResolveUDPAddr",
        "syntax": "func ResolveUDPAddr(network, address string) (*UDPAddr, error)",
        "type": "net"
    },
    "ResolveUnixAddr": {
        "descr": "ResolveUnixAddr returns an address of Unix domain socket end point.",
        "name": "net.ResolveUnixAddr",
        "params": [],
        "path": "go/net/index#ResolveUnixAddr",
        "syntax": "func ResolveUnixAddr(network, address string) (*UnixAddr, error)",
        "type": "net"
    },
    "Resolver": {
        "descr": "A Resolver looks up names and numbers.",
        "name": "net.Resolver",
        "params": [],
        "path": "go/net/index#Resolver",
        "syntax": "type Resolver struct { // PreferGo controls whether Go's built-in DNS resolver is preferred // on platforms where it's available. It is equivalent to setting // GODEBUG=netdns=go, but scoped to just this resolver. PreferGo bool // StrictErrors controls the behavior of temporary errors // (including timeout, socket errors, and SERVFAIL) when using // Go's built-in resolver. For a query composed of multiple // sub-queries (such as an A+AAAA address lookup, or walking the // DNS search list), this option causes such errors to abort the // whole query instead of returning a partial result. This is // not enabled by default because it may affect compatibility // with resolvers that process AAAA queries incorrectly. StrictErrors bool // Go 1.9 // Dial optionally specifies an alternate dialer for use by // Go's built-in DNS resolver to make TCP and UDP connections // to DNS services. The host in the address parameter will // always be a literal IP address and not a host name, and the // port in the address parameter will be a literal port number // and not a service name. // If the Conn returned is also a PacketConn, sent and received DNS // messages must adhere to RFC 1035 section 4.2.1, \"UDP usage\". // Otherwise, DNS messages transmitted over Conn must adhere // to RFC 7766 section 5, \"Transport Protocol Selection\". // If nil, the default dialer is used. Dial func(ctx context.Context, network, address string) (Conn, error) // Go 1.9 // contains filtered or unexported fields }",
        "type": "net"
    },
    "Resolver.LookupAddr": {
        "descr": "LookupAddr performs a reverse lookup for the given address, returning a list of names mapping to that address.",
        "name": "net.Resolver.LookupAddr",
        "params": [],
        "path": "go/net/index#Resolver.LookupAddr",
        "syntax": "func (r *Resolver) LookupAddr(ctx context.Context, addr string) (names []string, err error)",
        "type": "net"
    },
    "Resolver.LookupCNAME": {
        "descr": "LookupCNAME returns the canonical name for the given host. Callers that do not care about the canonical name can call LookupHost or LookupIP directly; both take care of resolving the canonical name as part of the lookup.",
        "name": "net.Resolver.LookupCNAME",
        "params": [],
        "path": "go/net/index#Resolver.LookupCNAME",
        "syntax": "func (r *Resolver) LookupCNAME(ctx context.Context, host string) (cname string, err error)",
        "type": "net"
    },
    "Resolver.LookupHost": {
        "descr": "LookupHost looks up the given host using the local resolver. It returns a slice of that host's addresses.",
        "name": "net.Resolver.LookupHost",
        "params": [],
        "path": "go/net/index#Resolver.LookupHost",
        "syntax": "func (r *Resolver) LookupHost(ctx context.Context, host string) (addrs []string, err error)",
        "type": "net"
    },
    "Resolver.LookupIPAddr": {
        "descr": "LookupIPAddr looks up host using the local resolver. It returns a slice of that host's IPv4 and IPv6 addresses.",
        "name": "net.Resolver.LookupIPAddr",
        "params": [],
        "path": "go/net/index#Resolver.LookupIPAddr",
        "syntax": "func (r *Resolver) LookupIPAddr(ctx context.Context, host string) ([]IPAddr, error)",
        "type": "net"
    },
    "Resolver.LookupMX": {
        "descr": "LookupMX returns the DNS MX records for the given domain name sorted by preference.",
        "name": "net.Resolver.LookupMX",
        "params": [],
        "path": "go/net/index#Resolver.LookupMX",
        "syntax": "func (r *Resolver) LookupMX(ctx context.Context, name string) ([]*MX, error)",
        "type": "net"
    },
    "Resolver.LookupNS": {
        "descr": "LookupNS returns the DNS NS records for the given domain name.",
        "name": "net.Resolver.LookupNS",
        "params": [],
        "path": "go/net/index#Resolver.LookupNS",
        "syntax": "func (r *Resolver) LookupNS(ctx context.Context, name string) ([]*NS, error)",
        "type": "net"
    },
    "Resolver.LookupPort": {
        "descr": "LookupPort looks up the port for the given network and service.",
        "name": "net.Resolver.LookupPort",
        "params": [],
        "path": "go/net/index#Resolver.LookupPort",
        "syntax": "func (r *Resolver) LookupPort(ctx context.Context, network, service string) (port int, err error)",
        "type": "net"
    },
    "Resolver.LookupSRV": {
        "descr": "LookupSRV tries to resolve an SRV query of the given service, protocol, and domain name. The proto is \"tcp\" or \"udp\". The returned records are sorted by priority and randomized by weight within a priority.",
        "name": "net.Resolver.LookupSRV",
        "params": [],
        "path": "go/net/index#Resolver.LookupSRV",
        "syntax": "func (r *Resolver) LookupSRV(ctx context.Context, service, proto, name string) (cname string, addrs []*SRV, err error)",
        "type": "net"
    },
    "Resolver.LookupTXT": {
        "descr": "LookupTXT returns the DNS TXT records for the given domain name.",
        "name": "net.Resolver.LookupTXT",
        "params": [],
        "path": "go/net/index#Resolver.LookupTXT",
        "syntax": "func (r *Resolver) LookupTXT(ctx context.Context, name string) ([]string, error)",
        "type": "net"
    },
    "Reverse": {
        "descr": "Reverse returns the reverse order for data.",
        "name": "sort.Reverse",
        "params": [],
        "path": "go/sort/index#Reverse",
        "syntax": "func Reverse(data Interface) Interface",
        "type": "sort"
    },
    "Rlimit": {
        "descr": "",
        "name": "syscall.Rlimit",
        "params": [],
        "path": "go/syscall/index#Rlimit",
        "syntax": "type Rlimit struct { Cur uint64 Max uint64 }",
        "type": "syscall"
    },
    "Rmdir": {
        "descr": "",
        "name": "syscall.Rmdir",
        "params": [],
        "path": "go/syscall/index#Rmdir",
        "syntax": "func Rmdir(path string) error",
        "type": "syscall"
    },
    "Round": {
        "descr": "Round returns the nearest integer, rounding half away from zero.",
        "name": "math.Round",
        "params": [],
        "path": "go/math/index#Round",
        "syntax": "func Round(x float64) float64",
        "type": "math"
    },
    "RoundToEven": {
        "descr": "RoundToEven returns the nearest integer, rounding ties to even.",
        "name": "math.RoundToEven",
        "params": [],
        "path": "go/math/index#RoundToEven",
        "syntax": "func RoundToEven(x float64) float64",
        "type": "math"
    },
    "RtAttr": {
        "descr": "",
        "name": "syscall.RtAttr",
        "params": [],
        "path": "go/syscall/index#RtAttr",
        "syntax": "type RtAttr struct { Len uint16 Type uint16 }",
        "type": "syscall"
    },
    "RtGenmsg": {
        "descr": "",
        "name": "syscall.RtGenmsg",
        "params": [],
        "path": "go/syscall/index#RtGenmsg",
        "syntax": "type RtGenmsg struct { Family uint8 }",
        "type": "syscall"
    },
    "RtMsg": {
        "descr": "",
        "name": "syscall.RtMsg",
        "params": [],
        "path": "go/syscall/index#RtMsg",
        "syntax": "type RtMsg struct { Family uint8 Dst_len uint8 Src_len uint8 Tos uint8 Table uint8 Protocol uint8 Scope uint8 Type uint8 Flags uint32 }",
        "type": "syscall"
    },
    "RtNexthop": {
        "descr": "",
        "name": "syscall.RtNexthop",
        "params": [],
        "path": "go/syscall/index#RtNexthop",
        "syntax": "type RtNexthop struct { Len uint16 Flags uint8 Hops uint8 Ifindex int32 }",
        "type": "syscall"
    },
    "RunBenchmarks": {
        "descr": "An internal function but exported because it is cross-package; part of the implementation of the \"go test\" command.",
        "name": "testing.RunBenchmarks",
        "params": [],
        "path": "go/testing/index#RunBenchmarks",
        "syntax": "func RunBenchmarks(matchString func(pat, str string) (bool, error), benchmarks []InternalBenchmark)",
        "type": "testing"
    },
    "RunExamples": {
        "descr": "An internal function but exported because it is cross-package; part of the implementation of the \"go test\" command.",
        "name": "testing.RunExamples",
        "params": [],
        "path": "go/testing/index#RunExamples",
        "syntax": "func RunExamples(matchString func(pat, str string) (bool, error), examples []InternalExample) (ok bool)",
        "type": "testing"
    },
    "RunTests": {
        "descr": "An internal function but exported because it is cross-package; part of the implementation of the \"go test\" command.",
        "name": "testing.RunTests",
        "params": [],
        "path": "go/testing/index#RunTests",
        "syntax": "func RunTests(matchString func(pat, str string) (bool, error), tests []InternalTest) (ok bool)",
        "type": "testing"
    },
    "RuneReader": {
        "descr": "RuneReader is the interface that wraps the ReadRune method.",
        "name": "io.RuneReader",
        "params": [],
        "path": "go/io/index#RuneReader",
        "syntax": "type RuneReader interface { ReadRune() (r rune, size int, err error) }",
        "type": "io"
    },
    "RuneScanner": {
        "descr": "RuneScanner is the interface that adds the UnreadRune method to the basic ReadRune method.",
        "name": "io.RuneScanner",
        "params": [],
        "path": "go/io/index#RuneScanner",
        "syntax": "type RuneScanner interface { RuneReader UnreadRune() error }",
        "type": "io"
    },
    "Runes": {
        "descr": "Runes interprets s as a sequence of UTF-8-encoded code points. It returns a slice of runes (Unicode code points) equivalent to s.",
        "name": "bytes.Runes",
        "params": [],
        "path": "go/bytes/index#Runes",
        "syntax": "func Runes(s []byte) []rune",
        "type": "bytes"
    },
    "Rusage": {
        "descr": "",
        "name": "syscall.Rusage",
        "params": [],
        "path": "go/syscall/index#Rusage",
        "syntax": "type Rusage struct { Utime Timeval Stime Timeval Maxrss int64 Ixrss int64 Idrss int64 Isrss int64 Minflt int64 Majflt int64 Nswap int64 Inblock int64 Oublock int64 Msgsnd int64 Msgrcv int64 Nsignals int64 Nvcsw int64 Nivcsw int64 }",
        "type": "syscall"
    },
    "SRV": {
        "descr": "An SRV represents a single DNS SRV record.",
        "name": "net.SRV",
        "params": [],
        "path": "go/net/index#SRV",
        "syntax": "type SRV struct { Target string Port uint16 Priority uint16 Weight uint16 }",
        "type": "net"
    },
    "SameFile": {
        "descr": "SameFile reports whether fi1 and fi2 describe the same file. For example, on Unix this means that the device and inode fields of the two underlying structures are identical; on other systems the decision may be based on the path names. SameFile only applies to results returned by this package's Stat. It returns false in other cases.",
        "name": "os.SameFile",
        "params": [],
        "path": "go/os/index#SameFile",
        "syntax": "func SameFile(fi1, fi2 FileInfo) bool",
        "type": "os"
    },
    "Scan": {
        "descr": "Scan scans text read from standard input, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why.",
        "name": "fmt.Scan",
        "params": [],
        "path": "go/fmt/index#Scan",
        "syntax": "func Scan(a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "ScanBytes": {
        "descr": "ScanBytes is a split function for a Scanner that returns each byte as a token.",
        "name": "bufio.ScanBytes",
        "params": [],
        "path": "go/bufio/index#ScanBytes",
        "syntax": "func ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)",
        "type": "bufio"
    },
    "ScanLines": {
        "descr": "ScanLines is a split function for a Scanner that returns each line of text, stripped of any trailing end-of-line marker. The returned line may be empty. The end-of-line marker is one optional carriage return followed by one mandatory newline. In regular expression notation, it is `\\r?\\n`. The last non-empty line of input will be returned even if it has no newline.",
        "name": "bufio.ScanLines",
        "params": [],
        "path": "go/bufio/index#ScanLines",
        "syntax": "func ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error)",
        "type": "bufio"
    },
    "ScanRunes": {
        "descr": "ScanRunes is a split function for a Scanner that returns each UTF-8-encoded rune as a token. The sequence of runes returned is equivalent to that from a range loop over the input as a string, which means that erroneous UTF-8 encodings translate to U+FFFD = \"\\xef\\xbf\\xbd\". Because of the Scan interface, this makes it impossible for the client to distinguish correctly encoded replacement runes from encoding errors.",
        "name": "bufio.ScanRunes",
        "params": [],
        "path": "go/bufio/index#ScanRunes",
        "syntax": "func ScanRunes(data []byte, atEOF bool) (advance int, token []byte, err error)",
        "type": "bufio"
    },
    "ScanState": {
        "descr": "ScanState represents the scanner state passed to custom scanners. Scanners may do rune-at-a-time scanning or ask the ScanState to discover the next space-delimited token.",
        "name": "fmt.ScanState",
        "params": [],
        "path": "go/fmt/index#ScanState",
        "syntax": "type ScanState interface { // ReadRune reads the next rune (Unicode code point) from the input. // If invoked during Scanln, Fscanln, or Sscanln, ReadRune() will // return EOF after returning the first '\\n' or when reading beyond // the specified width. ReadRune() (r rune, size int, err error) // UnreadRune causes the next call to ReadRune to return the same rune. UnreadRune() error // SkipSpace skips space in the input. Newlines are treated appropriately // for the operation being performed; see the package documentation // for more information. SkipSpace() // Token skips space in the input if skipSpace is true, then returns the // run of Unicode code points c satisfying f(c). If f is nil, // !unicode.IsSpace(c) is used; that is, the token will hold non-space // characters. Newlines are treated appropriately for the operation being // performed; see the package documentation for more information. // The returned slice points to shared data that may be overwritten // by the next call to Token, a call to a Scan function using the ScanState // as input, or when the calling Scan method returns. Token(skipSpace bool, f func(rune) bool) (token []byte, err error) // Width returns the value of the width option and whether it has been set. // The unit is Unicode code points. Width() (wid int, ok bool) // Because ReadRune is implemented by the interface, Read should never be // called by the scanning routines and a valid implementation of // ScanState may choose always to return an error from Read. Read(buf []byte) (n int, err error) }",
        "type": "fmt"
    },
    "ScanWords": {
        "descr": "ScanWords is a split function for a Scanner that returns each space-separated word of text, with surrounding spaces deleted. It will never return an empty string. The definition of space is set by unicode.IsSpace.",
        "name": "bufio.ScanWords",
        "params": [],
        "path": "go/bufio/index#ScanWords",
        "syntax": "func ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error)",
        "type": "bufio"
    },
    "Scanf": {
        "descr": "Scanf scans text read from standard input, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why. Newlines in the input must match newlines in the format. The one exception: the verb %c always scans the next rune in the input, even if it is a space (or tab etc.) or newline.",
        "name": "fmt.Scanf",
        "params": [],
        "path": "go/fmt/index#Scanf",
        "syntax": "func Scanf(format string, a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "Scanln": {
        "descr": "Scanln is similar to Scan, but stops scanning at a newline and after the final item there must be a newline or EOF.",
        "name": "fmt.Scanln",
        "params": [],
        "path": "go/fmt/index#Scanln",
        "syntax": "func Scanln(a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "Scanner": {
        "descr": "Scanner is implemented by any value that has a Scan method, which scans the input for the representation of a value and stores the result in the receiver, which must be a pointer to be useful. The Scan method is called for any argument to Scan, Scanf, or Scanln that implements it.",
        "name": "fmt.Scanner",
        "params": [],
        "path": "go/fmt/index#Scanner",
        "syntax": "type Scanner interface { Scan(state ScanState, verb rune) error }",
        "type": "fmt"
    },
    "Scanner.Buffer": {
        "descr": "Buffer sets the initial buffer to use when scanning and the maximum size of buffer that may be allocated during scanning. The maximum token size is the larger of max and cap(buf). If max <= cap(buf), Scan will use this buffer only and do no allocation.",
        "name": "bufio.Scanner.Buffer",
        "params": [],
        "path": "go/bufio/index#Scanner.Buffer",
        "syntax": "func (s *Scanner) Buffer(buf []byte, max int)",
        "type": "bufio"
    },
    "Scanner.Bytes": {
        "descr": "Bytes returns the most recent token generated by a call to Scan. The underlying array may point to data that will be overwritten by a subsequent call to Scan. It does no allocation.",
        "name": "bufio.Scanner.Bytes",
        "params": [],
        "path": "go/bufio/index#Scanner.Bytes",
        "syntax": "func (s *Scanner) Bytes() []byte",
        "type": "bufio"
    },
    "Scanner.Err": {
        "descr": "Err returns the first non-EOF error that was encountered by the Scanner.",
        "name": "bufio.Scanner.Err",
        "params": [],
        "path": "go/bufio/index#Scanner.Err",
        "syntax": "func (s *Scanner) Err() error",
        "type": "bufio"
    },
    "Scanner.Scan": {
        "descr": "Scan advances the Scanner to the next token, which will then be available through the Bytes or Text method. It returns false when the scan stops, either by reaching the end of the input or an error. After Scan returns false, the Err method will return any error that occurred during scanning, except that if it was io.EOF, Err will return nil. Scan panics if the split function returns too many empty tokens without advancing the input. This is a common error mode for scanners.",
        "name": "bufio.Scanner.Scan",
        "params": [],
        "path": "go/bufio/index#Scanner.Scan",
        "syntax": "func (s *Scanner) Scan() bool",
        "type": "bufio"
    },
    "Scanner.Split": {
        "descr": "Split sets the split function for the Scanner. The default split function is ScanLines.",
        "name": "bufio.Scanner.Split",
        "params": [],
        "path": "go/bufio/index#Scanner.Split",
        "syntax": "func (s *Scanner) Split(split SplitFunc)",
        "type": "bufio"
    },
    "Scanner.Text": {
        "descr": "Text returns the most recent token generated by a call to Scan as a newly allocated string holding its bytes.",
        "name": "bufio.Scanner.Text",
        "params": [],
        "path": "go/bufio/index#Scanner.Text",
        "syntax": "func (s *Scanner) Text() string",
        "type": "bufio"
    },
    "Search": {
        "descr": "Search uses binary search to find and return the smallest index i in [0, n) at which f(i) is true, assuming that on the range [0, n), f(i) == true implies f(i+1) == true. That is, Search requires that f is false for some (possibly empty) prefix of the input range [0, n) and then true for the (possibly empty) remainder; Search returns the first true index. If there is no such index, Search returns n. (Note that the \"not found\" return value is not -1 as in, for instance, strings.Index.) Search calls f(i) only for i in the range [0, n).",
        "name": "sort.Search",
        "params": [],
        "path": "go/sort/index#Search",
        "syntax": "func Search(n int, f func(int) bool) int",
        "type": "sort"
    },
    "SearchFloat64s": {
        "descr": "SearchFloat64s searches for x in a sorted slice of float64s and returns the index as specified by Search. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order.",
        "name": "sort.SearchFloat64s",
        "params": [],
        "path": "go/sort/index#SearchFloat64s",
        "syntax": "func SearchFloat64s(a []float64, x float64) int",
        "type": "sort"
    },
    "SearchInts": {
        "descr": "SearchInts searches for x in a sorted slice of ints and returns the index as specified by Search. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order.",
        "name": "sort.SearchInts",
        "params": [],
        "path": "go/sort/index#SearchInts",
        "syntax": "func SearchInts(a []int, x int) int",
        "type": "sort"
    },
    "SearchStrings": {
        "descr": "SearchStrings searches for x in a sorted slice of strings and returns the index as specified by Search. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order.",
        "name": "sort.SearchStrings",
        "params": [],
        "path": "go/sort/index#SearchStrings",
        "syntax": "func SearchStrings(a []string, x string) int",
        "type": "sort"
    },
    "SectionReader": {
        "descr": "SectionReader implements Read, Seek, and ReadAt on a section of an underlying ReaderAt.",
        "name": "io.SectionReader",
        "params": [],
        "path": "go/io/index#SectionReader",
        "syntax": "type SectionReader struct { // contains filtered or unexported fields }",
        "type": "io"
    },
    "SectionReader.Read": {
        "descr": "",
        "name": "io.SectionReader.Read",
        "params": [],
        "path": "go/io/index#SectionReader.Read",
        "syntax": "func (s *SectionReader) Read(p []byte) (n int, err error)",
        "type": "io"
    },
    "SectionReader.ReadAt": {
        "descr": "",
        "name": "io.SectionReader.ReadAt",
        "params": [],
        "path": "go/io/index#SectionReader.ReadAt",
        "syntax": "func (s *SectionReader) ReadAt(p []byte, off int64) (n int, err error)",
        "type": "io"
    },
    "SectionReader.Seek": {
        "descr": "",
        "name": "io.SectionReader.Seek",
        "params": [],
        "path": "go/io/index#SectionReader.Seek",
        "syntax": "func (s *SectionReader) Seek(offset int64, whence int) (int64, error)",
        "type": "io"
    },
    "SectionReader.Size": {
        "descr": "Size returns the size of the section in bytes.",
        "name": "io.SectionReader.Size",
        "params": [],
        "path": "go/io/index#SectionReader.Size",
        "syntax": "func (s *SectionReader) Size() int64",
        "type": "io"
    },
    "Seek": {
        "descr": "",
        "name": "syscall.Seek",
        "params": [],
        "path": "go/syscall/index#Seek",
        "syntax": "func Seek(fd int, offset int64, whence int) (off int64, err error)",
        "type": "syscall"
    },
    "Seeker": {
        "descr": "Seeker is the interface that wraps the basic Seek method.",
        "name": "io.Seeker",
        "params": [],
        "path": "go/io/index#Seeker",
        "syntax": "type Seeker interface { Seek(offset int64, whence int) (int64, error) }",
        "type": "io"
    },
    "Select": {
        "descr": "",
        "name": "syscall.Select",
        "params": [],
        "path": "go/syscall/index#Select",
        "syntax": "func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error)",
        "type": "syscall"
    },
    "SelectCase": {
        "descr": "A SelectCase describes a single case in a select operation. The kind of case depends on Dir, the communication direction.",
        "name": "reflect.SelectCase",
        "params": [],
        "path": "go/reflect/index#SelectCase",
        "syntax": "type SelectCase struct { Dir SelectDir // direction of case Chan Value // channel to use (for send or receive) Send Value // value to send (for send) }",
        "type": "reflect"
    },
    "SelectDir": {
        "descr": "A SelectDir describes the communication direction of a select case.",
        "name": "reflect.SelectDir",
        "params": [],
        "path": "go/reflect/index#SelectDir",
        "syntax": "type SelectDir int",
        "type": "reflect"
    },
    "Sendfile": {
        "descr": "",
        "name": "syscall.Sendfile",
        "params": [],
        "path": "go/syscall/index#Sendfile",
        "syntax": "func Sendfile(outfd int, infd int, offset *int64, count int) (written int, err error)",
        "type": "syscall"
    },
    "Sendmsg": {
        "descr": "",
        "name": "syscall.Sendmsg",
        "params": [],
        "path": "go/syscall/index#Sendmsg",
        "syntax": "func Sendmsg(fd int, p, oob []byte, to Sockaddr, flags int) (err error)",
        "type": "syscall"
    },
    "SendmsgN": {
        "descr": "",
        "name": "syscall.SendmsgN",
        "params": [],
        "path": "go/syscall/index#SendmsgN",
        "syntax": "func SendmsgN(fd int, p, oob []byte, to Sockaddr, flags int) (n int, err error)",
        "type": "syscall"
    },
    "Sendto": {
        "descr": "",
        "name": "syscall.Sendto",
        "params": [],
        "path": "go/syscall/index#Sendto",
        "syntax": "func Sendto(fd int, p []byte, flags int, to Sockaddr) (err error)",
        "type": "syscall"
    },
    "Set": {
        "descr": "Set sets the value of the named command-line flag.",
        "name": "flag.Set",
        "params": [],
        "path": "go/flag/index#Set",
        "syntax": "func Set(name, value string) error",
        "type": "flag"
    },
    "SetBlockProfileRate": {
        "descr": "SetBlockProfileRate controls the fraction of goroutine blocking events that are reported in the blocking profile. The profiler aims to sample an average of one blocking event per rate nanoseconds spent blocked.",
        "name": "runtime.SetBlockProfileRate",
        "params": [],
        "path": "go/runtime/index#SetBlockProfileRate",
        "syntax": "func SetBlockProfileRate(rate int)",
        "type": "runtime"
    },
    "SetCPUProfileRate": {
        "descr": "SetCPUProfileRate sets the CPU profiling rate to hz samples per second. If hz <= 0, SetCPUProfileRate turns off profiling. If the profiler is on, the rate cannot be changed without first turning it off.",
        "name": "runtime.SetCPUProfileRate",
        "params": [],
        "path": "go/runtime/index#SetCPUProfileRate",
        "syntax": "func SetCPUProfileRate(hz int)",
        "type": "runtime"
    },
    "SetCgoTraceback": {
        "descr": "SetCgoTraceback records three C functions to use to gather traceback information from C code and to convert that traceback information into symbolic information. These are used when printing stack traces for a program that uses cgo.",
        "name": "runtime.SetCgoTraceback",
        "params": [],
        "path": "go/runtime/index#SetCgoTraceback",
        "syntax": "func SetCgoTraceback(version int, traceback, context, symbolizer unsafe.Pointer)",
        "type": "runtime"
    },
    "SetFinalizer": {
        "descr": "SetFinalizer sets the finalizer associated with obj to the provided finalizer function. When the garbage collector finds an unreachable block with an associated finalizer, it clears the association and runs finalizer(obj) in a separate goroutine. This makes obj reachable again, but now without an associated finalizer. Assuming that SetFinalizer is not called again, the next time the garbage collector sees that obj is unreachable, it will free obj.",
        "name": "runtime.SetFinalizer",
        "params": [],
        "path": "go/runtime/index#SetFinalizer",
        "syntax": "func SetFinalizer(obj interface{}, finalizer interface{})",
        "type": "runtime"
    },
    "SetFlags": {
        "descr": "SetFlags sets the output flags for the standard logger.",
        "name": "log.SetFlags",
        "params": [],
        "path": "go/log/index#SetFlags",
        "syntax": "func SetFlags(flag int)",
        "type": "log"
    },
    "SetLsfPromisc": {
        "descr": "Deprecated: Use golang.org/x/net/bpf instead.",
        "name": "syscall.SetLsfPromisc",
        "params": [],
        "path": "go/syscall/index#SetLsfPromisc",
        "syntax": "func SetLsfPromisc(name string, m bool) error",
        "type": "syscall"
    },
    "SetMutexProfileFraction": {
        "descr": "SetMutexProfileFraction controls the fraction of mutex contention events that are reported in the mutex profile. On average 1/rate events are reported. The previous rate is returned.",
        "name": "runtime.SetMutexProfileFraction",
        "params": [],
        "path": "go/runtime/index#SetMutexProfileFraction",
        "syntax": "func SetMutexProfileFraction(rate int) int",
        "type": "runtime"
    },
    "SetNonblock": {
        "descr": "",
        "name": "syscall.SetNonblock",
        "params": [],
        "path": "go/syscall/index#SetNonblock",
        "syntax": "func SetNonblock(fd int, nonblocking bool) (err error)",
        "type": "syscall"
    },
    "SetOutput": {
        "descr": "SetOutput sets the output destination for the standard logger.",
        "name": "log.SetOutput",
        "params": [],
        "path": "go/log/index#SetOutput",
        "syntax": "func SetOutput(w io.Writer)",
        "type": "log"
    },
    "SetPrefix": {
        "descr": "SetPrefix sets the output prefix for the standard logger.",
        "name": "log.SetPrefix",
        "params": [],
        "path": "go/log/index#SetPrefix",
        "syntax": "func SetPrefix(prefix string)",
        "type": "log"
    },
    "Setdomainname": {
        "descr": "",
        "name": "syscall.Setdomainname",
        "params": [],
        "path": "go/syscall/index#Setdomainname",
        "syntax": "func Setdomainname(p []byte) (err error)",
        "type": "syscall"
    },
    "Setenv": {
        "descr": "",
        "name": "syscall.Setenv",
        "params": [],
        "path": "go/syscall/index#Setenv",
        "syntax": "func Setenv(key, value string) error",
        "type": "syscall"
    },
    "Setfsgid": {
        "descr": "",
        "name": "syscall.Setfsgid",
        "params": [],
        "path": "go/syscall/index#Setfsgid",
        "syntax": "func Setfsgid(gid int) (err error)",
        "type": "syscall"
    },
    "Setfsuid": {
        "descr": "",
        "name": "syscall.Setfsuid",
        "params": [],
        "path": "go/syscall/index#Setfsuid",
        "syntax": "func Setfsuid(uid int) (err error)",
        "type": "syscall"
    },
    "Setgid": {
        "descr": "",
        "name": "syscall.Setgid",
        "params": [],
        "path": "go/syscall/index#Setgid",
        "syntax": "func Setgid(gid int) (err error)",
        "type": "syscall"
    },
    "Setgroups": {
        "descr": "",
        "name": "syscall.Setgroups",
        "params": [],
        "path": "go/syscall/index#Setgroups",
        "syntax": "func Setgroups(gids []int) (err error)",
        "type": "syscall"
    },
    "Sethostname": {
        "descr": "",
        "name": "syscall.Sethostname",
        "params": [],
        "path": "go/syscall/index#Sethostname",
        "syntax": "func Sethostname(p []byte) (err error)",
        "type": "syscall"
    },
    "Setpgid": {
        "descr": "",
        "name": "syscall.Setpgid",
        "params": [],
        "path": "go/syscall/index#Setpgid",
        "syntax": "func Setpgid(pid int, pgid int) (err error)",
        "type": "syscall"
    },
    "Setpriority": {
        "descr": "",
        "name": "syscall.Setpriority",
        "params": [],
        "path": "go/syscall/index#Setpriority",
        "syntax": "func Setpriority(which int, who int, prio int) (err error)",
        "type": "syscall"
    },
    "Setregid": {
        "descr": "",
        "name": "syscall.Setregid",
        "params": [],
        "path": "go/syscall/index#Setregid",
        "syntax": "func Setregid(rgid int, egid int) (err error)",
        "type": "syscall"
    },
    "Setresgid": {
        "descr": "",
        "name": "syscall.Setresgid",
        "params": [],
        "path": "go/syscall/index#Setresgid",
        "syntax": "func Setresgid(rgid int, egid int, sgid int) (err error)",
        "type": "syscall"
    },
    "Setresuid": {
        "descr": "",
        "name": "syscall.Setresuid",
        "params": [],
        "path": "go/syscall/index#Setresuid",
        "syntax": "func Setresuid(ruid int, euid int, suid int) (err error)",
        "type": "syscall"
    },
    "Setreuid": {
        "descr": "",
        "name": "syscall.Setreuid",
        "params": [],
        "path": "go/syscall/index#Setreuid",
        "syntax": "func Setreuid(ruid int, euid int) (err error)",
        "type": "syscall"
    },
    "Setrlimit": {
        "descr": "",
        "name": "syscall.Setrlimit",
        "params": [],
        "path": "go/syscall/index#Setrlimit",
        "syntax": "func Setrlimit(resource int, rlim *Rlimit) (err error)",
        "type": "syscall"
    },
    "Setsid": {
        "descr": "",
        "name": "syscall.Setsid",
        "params": [],
        "path": "go/syscall/index#Setsid",
        "syntax": "func Setsid() (pid int, err error)",
        "type": "syscall"
    },
    "SetsockoptByte": {
        "descr": "",
        "name": "syscall.SetsockoptByte",
        "params": [],
        "path": "go/syscall/index#SetsockoptByte",
        "syntax": "func SetsockoptByte(fd, level, opt int, value byte) (err error)",
        "type": "syscall"
    },
    "SetsockoptICMPv6Filter": {
        "descr": "",
        "name": "syscall.SetsockoptICMPv6Filter",
        "params": [],
        "path": "go/syscall/index#SetsockoptICMPv6Filter",
        "syntax": "func SetsockoptICMPv6Filter(fd, level, opt int, filter *ICMPv6Filter) error",
        "type": "syscall"
    },
    "SetsockoptIPMreq": {
        "descr": "",
        "name": "syscall.SetsockoptIPMreq",
        "params": [],
        "path": "go/syscall/index#SetsockoptIPMreq",
        "syntax": "func SetsockoptIPMreq(fd, level, opt int, mreq *IPMreq) (err error)",
        "type": "syscall"
    },
    "SetsockoptIPMreqn": {
        "descr": "",
        "name": "syscall.SetsockoptIPMreqn",
        "params": [],
        "path": "go/syscall/index#SetsockoptIPMreqn",
        "syntax": "func SetsockoptIPMreqn(fd, level, opt int, mreq *IPMreqn) (err error)",
        "type": "syscall"
    },
    "SetsockoptIPv6Mreq": {
        "descr": "",
        "name": "syscall.SetsockoptIPv6Mreq",
        "params": [],
        "path": "go/syscall/index#SetsockoptIPv6Mreq",
        "syntax": "func SetsockoptIPv6Mreq(fd, level, opt int, mreq *IPv6Mreq) (err error)",
        "type": "syscall"
    },
    "SetsockoptInet4Addr": {
        "descr": "",
        "name": "syscall.SetsockoptInet4Addr",
        "params": [],
        "path": "go/syscall/index#SetsockoptInet4Addr",
        "syntax": "func SetsockoptInet4Addr(fd, level, opt int, value [4]byte) (err error)",
        "type": "syscall"
    },
    "SetsockoptInt": {
        "descr": "",
        "name": "syscall.SetsockoptInt",
        "params": [],
        "path": "go/syscall/index#SetsockoptInt",
        "syntax": "func SetsockoptInt(fd, level, opt int, value int) (err error)",
        "type": "syscall"
    },
    "SetsockoptLinger": {
        "descr": "",
        "name": "syscall.SetsockoptLinger",
        "params": [],
        "path": "go/syscall/index#SetsockoptLinger",
        "syntax": "func SetsockoptLinger(fd, level, opt int, l *Linger) (err error)",
        "type": "syscall"
    },
    "SetsockoptString": {
        "descr": "",
        "name": "syscall.SetsockoptString",
        "params": [],
        "path": "go/syscall/index#SetsockoptString",
        "syntax": "func SetsockoptString(fd, level, opt int, s string) (err error)",
        "type": "syscall"
    },
    "SetsockoptTimeval": {
        "descr": "",
        "name": "syscall.SetsockoptTimeval",
        "params": [],
        "path": "go/syscall/index#SetsockoptTimeval",
        "syntax": "func SetsockoptTimeval(fd, level, opt int, tv *Timeval) (err error)",
        "type": "syscall"
    },
    "Settimeofday": {
        "descr": "",
        "name": "syscall.Settimeofday",
        "params": [],
        "path": "go/syscall/index#Settimeofday",
        "syntax": "func Settimeofday(tv *Timeval) (err error)",
        "type": "syscall"
    },
    "Setuid": {
        "descr": "",
        "name": "syscall.Setuid",
        "params": [],
        "path": "go/syscall/index#Setuid",
        "syntax": "func Setuid(uid int) (err error)",
        "type": "syscall"
    },
    "Setxattr": {
        "descr": "",
        "name": "syscall.Setxattr",
        "params": [],
        "path": "go/syscall/index#Setxattr",
        "syntax": "func Setxattr(path string, attr string, data []byte, flags int) (err error)",
        "type": "syscall"
    },
    "Short": {
        "descr": "Short reports whether the -test.short flag is set.",
        "name": "testing.Short",
        "params": [],
        "path": "go/testing/index#Short",
        "syntax": "func Short() bool",
        "type": "testing"
    },
    "Shutdown": {
        "descr": "",
        "name": "syscall.Shutdown",
        "params": [],
        "path": "go/syscall/index#Shutdown",
        "syntax": "func Shutdown(fd int, how int) (err error)",
        "type": "syscall"
    },
    "Signal": {
        "descr": "A Signal is a number describing a process signal. It implements the os.Signal interface.",
        "name": "syscall.Signal",
        "params": [],
        "path": "go/syscall/index#Signal",
        "syntax": "type Signal int",
        "type": "syscall"
    },
    "Signal.Signal": {
        "descr": "",
        "name": "syscall.Signal.Signal",
        "params": [],
        "path": "go/syscall/index#Signal.Signal",
        "syntax": "func (s Signal) Signal()",
        "type": "syscall"
    },
    "Signal.String": {
        "descr": "",
        "name": "syscall.Signal.String",
        "params": [],
        "path": "go/syscall/index#Signal.String",
        "syntax": "func (s Signal) String() string",
        "type": "syscall"
    },
    "Signbit": {
        "descr": "Signbit returns true if x is negative or negative zero.",
        "name": "math.Signbit",
        "params": [],
        "path": "go/math/index#Signbit",
        "syntax": "func Signbit(x float64) bool",
        "type": "math"
    },
    "Signer": {
        "descr": "Signer is an interface for an opaque private key that can be used for signing operations. For example, an RSA key kept in a hardware module.",
        "name": "crypto.Signer",
        "params": [],
        "path": "go/crypto/index#Signer",
        "syntax": "type Signer interface { // Public returns the public key corresponding to the opaque, // private key. Public() PublicKey // Sign signs digest with the private key, possibly using entropy from // rand. For an RSA key, the resulting signature should be either a // PKCS#1 v1.5 or PSS signature (as indicated by opts). For an (EC)DSA // key, it should be a DER-serialised, ASN.1 signature structure. // // Hash implements the SignerOpts interface and, in most cases, one can // simply pass in the hash function used as opts. Sign may also attempt // to type assert opts to other types in order to obtain algorithm // specific values. See the documentation in each package for details. // // Note that when a signature of a hash of a larger message is needed, // the caller is responsible for hashing the larger message and passing // the hash (as digest) and the hash function (as opts) to Sign. Sign(rand io.Reader, digest []byte, opts SignerOpts) (signature []byte, err error) }",
        "type": "crypto"
    },
    "SignerOpts": {
        "descr": "SignerOpts contains options for signing with a Signer.",
        "name": "crypto.SignerOpts",
        "params": [],
        "path": "go/crypto/index#SignerOpts",
        "syntax": "type SignerOpts interface { // HashFunc returns an identifier for the hash function used to produce // the message passed to Signer.Sign, or else zero to indicate that no // hashing was done. HashFunc() Hash }",
        "type": "crypto"
    },
    "SimpleFold": {
        "descr": "SimpleFold iterates over Unicode code points equivalent under the Unicode-defined simple case folding. Among the code points equivalent to rune (including rune itself), SimpleFold returns the smallest rune > r if one exists, or else the smallest rune >= 0. If r is not a valid Unicode code point, SimpleFold(r) returns r.",
        "name": "unicode.SimpleFold",
        "params": [],
        "path": "go/unicode/index#SimpleFold",
        "syntax": "func SimpleFold(r rune) rune",
        "type": "unicode"
    },
    "Sin": {
        "descr": "Sin returns the sine of the radian argument x.",
        "name": "math.Sin",
        "params": [],
        "path": "go/math/index#Sin",
        "syntax": "func Sin(x float64) float64",
        "type": "math"
    },
    "Since": {
        "descr": "Since returns the time elapsed since t. It is shorthand for time.Now().Sub(t).",
        "name": "time.Since",
        "params": [],
        "path": "go/time/index#Since",
        "syntax": "func Since(t Time) Duration",
        "type": "time"
    },
    "Sincos": {
        "descr": "Sincos returns Sin(x), Cos(x).",
        "name": "math.Sincos",
        "params": [],
        "path": "go/math/index#Sincos",
        "syntax": "func Sincos(x float64) (sin, cos float64)",
        "type": "math"
    },
    "Sinh": {
        "descr": "Sinh returns the hyperbolic sine of x.",
        "name": "math.Sinh",
        "params": [],
        "path": "go/math/index#Sinh",
        "syntax": "func Sinh(x float64) float64",
        "type": "math"
    },
    "Sizeof": {
        "descr": "Sizeof takes an expression x of any type and returns the size in bytes of a hypothetical variable v as if v was declared via var v = x. The size does not include any memory possibly referenced by x. For instance, if x is a slice, Sizeof returns the size of the slice descriptor, not the size of the memory referenced by the slice.",
        "name": "unsafe.Sizeof",
        "params": [],
        "path": "go/unsafe/index#Sizeof",
        "syntax": "func Sizeof(x ArbitraryType) uintptr",
        "type": "unsafe"
    },
    "Sleep": {
        "descr": "Sleep pauses the current goroutine for at least the duration d. A negative or zero duration causes Sleep to return immediately.",
        "name": "time.Sleep",
        "params": [],
        "path": "go/time/index#Sleep",
        "syntax": "func Sleep(d Duration)",
        "type": "time"
    },
    "Slice": {
        "descr": "Slice sorts the provided slice given the provided less function.",
        "name": "sort.Slice",
        "params": [],
        "path": "go/sort/index#Slice",
        "syntax": "func Slice(slice interface{}, less func(i, j int) bool)",
        "type": "sort"
    },
    "SliceHeader": {
        "descr": "SliceHeader is the runtime representation of a slice. It cannot be used safely or portably and its representation may change in a later release. Moreover, the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data.",
        "name": "reflect.SliceHeader",
        "params": [],
        "path": "go/reflect/index#SliceHeader",
        "syntax": "type SliceHeader struct { Data uintptr Len int Cap int }",
        "type": "reflect"
    },
    "SliceIsSorted": {
        "descr": "SliceIsSorted tests whether a slice is sorted.",
        "name": "sort.SliceIsSorted",
        "params": [],
        "path": "go/sort/index#SliceIsSorted",
        "syntax": "func SliceIsSorted(slice interface{}, less func(i, j int) bool) bool",
        "type": "sort"
    },
    "SliceOf": {
        "descr": "SliceOf returns the slice type with element type t. For example, if t represents int, SliceOf(t) represents []int.",
        "name": "reflect.SliceOf",
        "params": [],
        "path": "go/reflect/index#SliceOf",
        "syntax": "func SliceOf(t Type) Type",
        "type": "reflect"
    },
    "SlicePtrFromStrings": {
        "descr": "SlicePtrFromStrings converts a slice of strings to a slice of pointers to NUL-terminated byte arrays. If any string contains a NUL byte, it returns (nil, EINVAL).",
        "name": "syscall.SlicePtrFromStrings",
        "params": [],
        "path": "go/syscall/index#SlicePtrFromStrings",
        "syntax": "func SlicePtrFromStrings(ss []string) ([]*byte, error)",
        "type": "syscall"
    },
    "SliceStable": {
        "descr": "SliceStable sorts the provided slice given the provided less function while keeping the original order of equal elements.",
        "name": "sort.SliceStable",
        "params": [],
        "path": "go/sort/index#SliceStable",
        "syntax": "func SliceStable(slice interface{}, less func(i, j int) bool)",
        "type": "sort"
    },
    "SockFilter": {
        "descr": "",
        "name": "syscall.SockFilter",
        "params": [],
        "path": "go/syscall/index#SockFilter",
        "syntax": "type SockFilter struct { Code uint16 Jt uint8 Jf uint8 K uint32 }",
        "type": "syscall"
    },
    "SockFprog": {
        "descr": "",
        "name": "syscall.SockFprog",
        "params": [],
        "path": "go/syscall/index#SockFprog",
        "syntax": "type SockFprog struct { Len uint16 Pad_cgo_0 [6]byte Filter *SockFilter }",
        "type": "syscall"
    },
    "Sockaddr": {
        "descr": "",
        "name": "syscall.Sockaddr",
        "params": [],
        "path": "go/syscall/index#Sockaddr",
        "syntax": "type Sockaddr interface { // contains filtered or unexported methods }",
        "type": "syscall"
    },
    "SockaddrInet4": {
        "descr": "",
        "name": "syscall.SockaddrInet4",
        "params": [],
        "path": "go/syscall/index#SockaddrInet4",
        "syntax": "type SockaddrInet4 struct { Port int Addr [4]byte // contains filtered or unexported fields }",
        "type": "syscall"
    },
    "SockaddrInet6": {
        "descr": "",
        "name": "syscall.SockaddrInet6",
        "params": [],
        "path": "go/syscall/index#SockaddrInet6",
        "syntax": "type SockaddrInet6 struct { Port int ZoneId uint32 Addr [16]byte // contains filtered or unexported fields }",
        "type": "syscall"
    },
    "SockaddrLinklayer": {
        "descr": "",
        "name": "syscall.SockaddrLinklayer",
        "params": [],
        "path": "go/syscall/index#SockaddrLinklayer",
        "syntax": "type SockaddrLinklayer struct { Protocol uint16 Ifindex int Hatype uint16 Pkttype uint8 Halen uint8 Addr [8]byte // contains filtered or unexported fields }",
        "type": "syscall"
    },
    "SockaddrNetlink": {
        "descr": "",
        "name": "syscall.SockaddrNetlink",
        "params": [],
        "path": "go/syscall/index#SockaddrNetlink",
        "syntax": "type SockaddrNetlink struct { Family uint16 Pad uint16 Pid uint32 Groups uint32 // contains filtered or unexported fields }",
        "type": "syscall"
    },
    "SockaddrUnix": {
        "descr": "",
        "name": "syscall.SockaddrUnix",
        "params": [],
        "path": "go/syscall/index#SockaddrUnix",
        "syntax": "type SockaddrUnix struct { Name string // contains filtered or unexported fields }",
        "type": "syscall"
    },
    "Socket": {
        "descr": "",
        "name": "syscall.Socket",
        "params": [],
        "path": "go/syscall/index#Socket",
        "syntax": "func Socket(domain, typ, proto int) (fd int, err error)",
        "type": "syscall"
    },
    "SocketControlMessage": {
        "descr": "SocketControlMessage represents a socket control message.",
        "name": "syscall.SocketControlMessage",
        "params": [],
        "path": "go/syscall/index#SocketControlMessage",
        "syntax": "type SocketControlMessage struct { Header Cmsghdr Data []byte }",
        "type": "syscall"
    },
    "Socketpair": {
        "descr": "",
        "name": "syscall.Socketpair",
        "params": [],
        "path": "go/syscall/index#Socketpair",
        "syntax": "func Socketpair(domain, typ, proto int) (fd [2]int, err error)",
        "type": "syscall"
    },
    "Sort": {
        "descr": "Sort sorts data. It makes one call to data.Len to determine n, and O(n*log(n)) calls to data.Less and data.Swap. The sort is not guaranteed to be stable.",
        "name": "sort.Sort",
        "params": [],
        "path": "go/sort/index#Sort",
        "syntax": "func Sort(data Interface)",
        "type": "sort"
    },
    "SpecialCase": {
        "descr": "SpecialCase represents language-specific case mappings such as Turkish. Methods of SpecialCase customize (by overriding) the standard mappings.",
        "name": "unicode.SpecialCase",
        "params": [],
        "path": "go/unicode/index#SpecialCase",
        "syntax": "type SpecialCase []CaseRange",
        "type": "unicode"
    },
    "SpecialCase.ToLower": {
        "descr": "ToLower maps the rune to lower case giving priority to the special mapping.",
        "name": "unicode.SpecialCase.ToLower",
        "params": [],
        "path": "go/unicode/index#SpecialCase.ToLower",
        "syntax": "func (special SpecialCase) ToLower(r rune) rune",
        "type": "unicode"
    },
    "SpecialCase.ToTitle": {
        "descr": "ToTitle maps the rune to title case giving priority to the special mapping.",
        "name": "unicode.SpecialCase.ToTitle",
        "params": [],
        "path": "go/unicode/index#SpecialCase.ToTitle",
        "syntax": "func (special SpecialCase) ToTitle(r rune) rune",
        "type": "unicode"
    },
    "SpecialCase.ToUpper": {
        "descr": "ToUpper maps the rune to upper case giving priority to the special mapping.",
        "name": "unicode.SpecialCase.ToUpper",
        "params": [],
        "path": "go/unicode/index#SpecialCase.ToUpper",
        "syntax": "func (special SpecialCase) ToUpper(r rune) rune",
        "type": "unicode"
    },
    "Splice": {
        "descr": "",
        "name": "syscall.Splice",
        "params": [],
        "path": "go/syscall/index#Splice",
        "syntax": "func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error)",
        "type": "syscall"
    },
    "Split": {
        "descr": "Split slices s into all substrings separated by sep and returns a slice of the substrings between those separators.",
        "name": "strings.Split",
        "params": [],
        "path": "go/strings/index#Split",
        "syntax": "func Split(s, sep string) []string",
        "type": "strings"
    },
    "SplitAfter": {
        "descr": "SplitAfter slices s into all substrings after each instance of sep and returns a slice of those substrings.",
        "name": "strings.SplitAfter",
        "params": [],
        "path": "go/strings/index#SplitAfter",
        "syntax": "func SplitAfter(s, sep string) []string",
        "type": "strings"
    },
    "SplitAfterN": {
        "descr": "SplitAfterN slices s into substrings after each instance of sep and returns a slice of those substrings.",
        "name": "strings.SplitAfterN",
        "params": [],
        "path": "go/strings/index#SplitAfterN",
        "syntax": "func SplitAfterN(s, sep string, n int) []string",
        "type": "strings"
    },
    "SplitFunc": {
        "descr": "SplitFunc is the signature of the split function used to tokenize the input. The arguments are an initial substring of the remaining unprocessed data and a flag, atEOF, that reports whether the Reader has no more data to give. The return values are the number of bytes to advance the input and the next token to return to the user, if any, plus an error, if any.",
        "name": "bufio.SplitFunc",
        "params": [],
        "path": "go/bufio/index#SplitFunc",
        "syntax": "type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)",
        "type": "bufio"
    },
    "SplitHostPort": {
        "descr": "SplitHostPort splits a network address of the form \"host:port\", \"host%zone:port\", \"[host]:port\" or \"[host%zone]:port\" into host or host%zone and port.",
        "name": "net.SplitHostPort",
        "params": [],
        "path": "go/net/index#SplitHostPort",
        "syntax": "func SplitHostPort(hostport string) (host, port string, err error)",
        "type": "net"
    },
    "SplitN": {
        "descr": "SplitN slices s into substrings separated by sep and returns a slice of the substrings between those separators.",
        "name": "strings.SplitN",
        "params": [],
        "path": "go/strings/index#SplitN",
        "syntax": "func SplitN(s, sep string, n int) []string",
        "type": "strings"
    },
    "Sprint": {
        "descr": "Sprint formats using the default formats for its operands and returns the resulting string. Spaces are added between operands when neither is a string.",
        "name": "fmt.Sprint",
        "params": [],
        "path": "go/fmt/index#Sprint",
        "syntax": "func Sprint(a ...interface{}) string",
        "type": "fmt"
    },
    "Sprintf": {
        "descr": "Sprintf formats according to a format specifier and returns the resulting string.",
        "name": "fmt.Sprintf",
        "params": [],
        "path": "go/fmt/index#Sprintf",
        "syntax": "func Sprintf(format string, a ...interface{}) string",
        "type": "fmt"
    },
    "Sprintln": {
        "descr": "Sprintln formats using the default formats for its operands and returns the resulting string. Spaces are always added between operands and a newline is appended.",
        "name": "fmt.Sprintln",
        "params": [],
        "path": "go/fmt/index#Sprintln",
        "syntax": "func Sprintln(a ...interface{}) string",
        "type": "fmt"
    },
    "Sqrt": {
        "descr": "Sqrt returns the square root of x.",
        "name": "math.Sqrt",
        "params": [],
        "path": "go/math/index#Sqrt",
        "syntax": "func Sqrt(x float64) float64",
        "type": "math"
    },
    "Sscan": {
        "descr": "Sscan scans the argument string, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why.",
        "name": "fmt.Sscan",
        "params": [],
        "path": "go/fmt/index#Sscan",
        "syntax": "func Sscan(str string, a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "Sscanf": {
        "descr": "Sscanf scans the argument string, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully parsed. Newlines in the input must match newlines in the format.",
        "name": "fmt.Sscanf",
        "params": [],
        "path": "go/fmt/index#Sscanf",
        "syntax": "func Sscanf(str string, format string, a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "Sscanln": {
        "descr": "Sscanln is similar to Sscan, but stops scanning at a newline and after the final item there must be a newline or EOF.",
        "name": "fmt.Sscanln",
        "params": [],
        "path": "go/fmt/index#Sscanln",
        "syntax": "func Sscanln(str string, a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "Stable": {
        "descr": "Stable sorts data while keeping the original order of equal elements.",
        "name": "sort.Stable",
        "params": [],
        "path": "go/sort/index#Stable",
        "syntax": "func Stable(data Interface)",
        "type": "sort"
    },
    "Stack": {
        "descr": "Stack formats a stack trace of the calling goroutine into buf and returns the number of bytes written to buf. If all is true, Stack formats stack traces of all other goroutines into buf after the trace for the current goroutine.",
        "name": "runtime.Stack",
        "params": [],
        "path": "go/runtime/index#Stack",
        "syntax": "func Stack(buf []byte, all bool) int",
        "type": "runtime"
    },
    "StackRecord": {
        "descr": "A StackRecord describes a single execution stack.",
        "name": "runtime.StackRecord",
        "params": [],
        "path": "go/runtime/index#StackRecord",
        "syntax": "type StackRecord struct { Stack0 [32]uintptr // stack trace for this record; ends at first 0 entry }",
        "type": "runtime"
    },
    "StackRecord.Stack": {
        "descr": "Stack returns the stack trace associated with the record, a prefix of r.Stack0.",
        "name": "runtime.StackRecord.Stack",
        "params": [],
        "path": "go/runtime/index#StackRecord.Stack",
        "syntax": "func (r *StackRecord) Stack() []uintptr",
        "type": "runtime"
    },
    "StartProcess": {
        "descr": "StartProcess wraps ForkExec for package os.",
        "name": "syscall.StartProcess",
        "params": [],
        "path": "go/syscall/index#StartProcess",
        "syntax": "func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid int, handle uintptr, err error)",
        "type": "syscall"
    },
    "StartTrace": {
        "descr": "StartTrace enables tracing for the current process. While tracing, the data will be buffered and available via ReadTrace. StartTrace returns an error if tracing is already enabled. Most clients should use the runtime/trace package or the testing package's -test.trace flag instead of calling StartTrace directly.",
        "name": "runtime.StartTrace",
        "params": [],
        "path": "go/runtime/index#StartTrace",
        "syntax": "func StartTrace() error",
        "type": "runtime"
    },
    "Stat": {
        "descr": "",
        "name": "syscall.Stat",
        "params": [],
        "path": "go/syscall/index#Stat",
        "syntax": "func Stat(path string, stat *Stat_t) (err error)",
        "type": "syscall"
    },
    "Stat_t": {
        "descr": "",
        "name": "syscall.Stat_t",
        "params": [],
        "path": "go/syscall/index#Stat_t",
        "syntax": "type Stat_t struct { Dev uint64 Ino uint64 Nlink uint64 Mode uint32 Uid uint32 Gid uint32 X__pad0 int32 Rdev uint64 Size int64 Blksize int64 Blocks int64 Atim Timespec Mtim Timespec Ctim Timespec X__unused [3]int64 }",
        "type": "syscall"
    },
    "State": {
        "descr": "State represents the printer state passed to custom formatters. It provides access to the io.Writer interface plus information about the flags and options for the operand's format specifier.",
        "name": "fmt.State",
        "params": [],
        "path": "go/fmt/index#State",
        "syntax": "type State interface { // Write is the function to call to emit formatted output to be printed. Write(b []byte) (n int, err error) // Width returns the value of the width option and whether it has been set. Width() (wid int, ok bool) // Precision returns the value of the precision option and whether it has been set. Precision() (prec int, ok bool) // Flag reports whether the flag c, a character, has been set. Flag(c int) bool }",
        "type": "fmt"
    },
    "Statfs": {
        "descr": "",
        "name": "syscall.Statfs",
        "params": [],
        "path": "go/syscall/index#Statfs",
        "syntax": "func Statfs(path string, buf *Statfs_t) (err error)",
        "type": "syscall"
    },
    "Statfs_t": {
        "descr": "",
        "name": "syscall.Statfs_t",
        "params": [],
        "path": "go/syscall/index#Statfs_t",
        "syntax": "type Statfs_t struct { Type int64 Bsize int64 Blocks uint64 Bfree uint64 Bavail uint64 Files uint64 Ffree uint64 Fsid Fsid Namelen int64 Frsize int64 Flags int64 Spare [4]int64 }",
        "type": "syscall"
    },
    "StopTrace": {
        "descr": "StopTrace stops tracing, if it was previously enabled. StopTrace only returns after all the reads for the trace have completed.",
        "name": "runtime.StopTrace",
        "params": [],
        "path": "go/runtime/index#StopTrace",
        "syntax": "func StopTrace()",
        "type": "runtime"
    },
    "String": {
        "descr": "String defines a string flag with specified name, default value, and usage string. The return value is the address of a string variable that stores the value of the flag.",
        "name": "flag.String",
        "params": [],
        "path": "go/flag/index#String",
        "syntax": "func String(name string, value string, usage string) *string",
        "type": "flag"
    },
    "String.Set": {
        "descr": "",
        "name": "expvar.String.Set",
        "params": [],
        "path": "go/expvar/index#String.Set",
        "syntax": "func (v *String) Set(value string)",
        "type": "expvar"
    },
    "String.String": {
        "descr": "String implements the Val interface. To get the unquoted string use Value.",
        "name": "expvar.String.String",
        "params": [],
        "path": "go/expvar/index#String.String",
        "syntax": "func (v *String) String() string",
        "type": "expvar"
    },
    "String.Value": {
        "descr": "",
        "name": "expvar.String.Value",
        "params": [],
        "path": "go/expvar/index#String.Value",
        "syntax": "func (v *String) Value() string",
        "type": "expvar"
    },
    "StringBytePtr": {
        "descr": "StringBytePtr returns a pointer to a NUL-terminated array of bytes. If s contains a NUL byte this function panics instead of returning an error.",
        "name": "syscall.StringBytePtr",
        "params": [],
        "path": "go/syscall/index#StringBytePtr",
        "syntax": "func StringBytePtr(s string) *byte",
        "type": "syscall"
    },
    "StringByteSlice": {
        "descr": "StringByteSlice converts a string to a NUL-terminated []byte, If s contains a NUL byte this function panics instead of returning an error.",
        "name": "syscall.StringByteSlice",
        "params": [],
        "path": "go/syscall/index#StringByteSlice",
        "syntax": "func StringByteSlice(s string) []byte",
        "type": "syscall"
    },
    "StringHeader": {
        "descr": "StringHeader is the runtime representation of a string. It cannot be used safely or portably and its representation may change in a later release. Moreover, the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data.",
        "name": "reflect.StringHeader",
        "params": [],
        "path": "go/reflect/index#StringHeader",
        "syntax": "type StringHeader struct { Data uintptr Len int }",
        "type": "reflect"
    },
    "StringSlice": {
        "descr": "StringSlice attaches the methods of Interface to []string, sorting in increasing order.",
        "name": "sort.StringSlice",
        "params": [],
        "path": "go/sort/index#StringSlice",
        "syntax": "type StringSlice []string",
        "type": "sort"
    },
    "StringSlice.Len": {
        "descr": "",
        "name": "sort.StringSlice.Len",
        "params": [],
        "path": "go/sort/index#StringSlice.Len",
        "syntax": "func (p StringSlice) Len() int",
        "type": "sort"
    },
    "StringSlice.Less": {
        "descr": "",
        "name": "sort.StringSlice.Less",
        "params": [],
        "path": "go/sort/index#StringSlice.Less",
        "syntax": "func (p StringSlice) Less(i, j int) bool",
        "type": "sort"
    },
    "StringSlice.Search": {
        "descr": "Search returns the result of applying SearchStrings to the receiver and x.",
        "name": "sort.StringSlice.Search",
        "params": [],
        "path": "go/sort/index#StringSlice.Search",
        "syntax": "func (p StringSlice) Search(x string) int",
        "type": "sort"
    },
    "StringSlice.Sort": {
        "descr": "Sort is a convenience method.",
        "name": "sort.StringSlice.Sort",
        "params": [],
        "path": "go/sort/index#StringSlice.Sort",
        "syntax": "func (p StringSlice) Sort()",
        "type": "sort"
    },
    "StringSlice.Swap": {
        "descr": "",
        "name": "sort.StringSlice.Swap",
        "params": [],
        "path": "go/sort/index#StringSlice.Swap",
        "syntax": "func (p StringSlice) Swap(i, j int)",
        "type": "sort"
    },
    "StringSlicePtr": {
        "descr": "StringSlicePtr converts a slice of strings to a slice of pointers to NUL-terminated byte arrays. If any string contains a NUL byte this function panics instead of returning an error.",
        "name": "syscall.StringSlicePtr",
        "params": [],
        "path": "go/syscall/index#StringSlicePtr",
        "syntax": "func StringSlicePtr(ss []string) []*byte",
        "type": "syscall"
    },
    "StringVar": {
        "descr": "StringVar defines a string flag with specified name, default value, and usage string. The argument p points to a string variable in which to store the value of the flag.",
        "name": "flag.StringVar",
        "params": [],
        "path": "go/flag/index#StringVar",
        "syntax": "func StringVar(p *string, name string, value string, usage string)",
        "type": "flag"
    },
    "Stringer": {
        "descr": "Stringer is implemented by any value that has a String method, which defines the native format for that value. The String method is used to print values passed as an operand to any format that accepts a string or to an unformatted printer such as Print.",
        "name": "fmt.Stringer",
        "params": [],
        "path": "go/fmt/index#Stringer",
        "syntax": "type Stringer interface { String() string }",
        "type": "fmt"
    },
    "Strings": {
        "descr": "Strings sorts a slice of strings in increasing order.",
        "name": "sort.Strings",
        "params": [],
        "path": "go/sort/index#Strings",
        "syntax": "func Strings(a []string)",
        "type": "sort"
    },
    "StringsAreSorted": {
        "descr": "StringsAreSorted tests whether a slice of strings is sorted in increasing order.",
        "name": "sort.StringsAreSorted",
        "params": [],
        "path": "go/sort/index#StringsAreSorted",
        "syntax": "func StringsAreSorted(a []string) bool",
        "type": "sort"
    },
    "StructField": {
        "descr": "A StructField describes a single field in a struct.",
        "name": "reflect.StructField",
        "params": [],
        "path": "go/reflect/index#StructField",
        "syntax": "type StructField struct { // Name is the field name. Name string // PkgPath is the package path that qualifies a lower case (unexported) // field name. It is empty for upper case (exported) field names. // See https://golang.org/ref/spec#Uniqueness_of_identifiers PkgPath string Type Type // field type Tag StructTag // field tag string Offset uintptr // offset within struct, in bytes Index []int // index sequence for Type.FieldByIndex Anonymous bool // is an embedded field }",
        "type": "reflect"
    },
    "StructOf": {
        "descr": "StructOf returns the struct type containing fields. The Offset and Index fields are ignored and computed as they would be by the compiler.",
        "name": "reflect.StructOf",
        "params": [],
        "path": "go/reflect/index#StructOf",
        "syntax": "func StructOf(fields []StructField) Type",
        "type": "reflect"
    },
    "StructTag": {
        "descr": "A StructTag is the tag string in a struct field.",
        "name": "reflect.StructTag",
        "params": [],
        "path": "go/reflect/index#StructTag",
        "syntax": "type StructTag string",
        "type": "reflect"
    },
    "StructTag.Get": {
        "descr": "Get returns the value associated with key in the tag string. If there is no such key in the tag, Get returns the empty string. If the tag does not have the conventional format, the value returned by Get is unspecified. To determine whether a tag is explicitly set to the empty string, use Lookup.",
        "name": "reflect.StructTag.Get",
        "params": [],
        "path": "go/reflect/index#StructTag.Get",
        "syntax": "func (tag StructTag) Get(key string) string",
        "type": "reflect"
    },
    "StructTag.Lookup": {
        "descr": "Lookup returns the value associated with key in the tag string. If the key is present in the tag the value (which may be empty) is returned. Otherwise the returned value will be the empty string. The ok return value reports whether the value was explicitly set in the tag string. If the tag does not have the conventional format, the value returned by Lookup is unspecified.",
        "name": "reflect.StructTag.Lookup",
        "params": [],
        "path": "go/reflect/index#StructTag.Lookup",
        "syntax": "func (tag StructTag) Lookup(key string) (value string, ok bool)",
        "type": "reflect"
    },
    "Swapper": {
        "descr": "Swapper returns a function that swaps the elements in the provided slice.",
        "name": "reflect.Swapper",
        "params": [],
        "path": "go/reflect/index#Swapper",
        "syntax": "func Swapper(slice interface{}) func(i, j int)",
        "type": "reflect"
    },
    "Symbol": {
        "descr": "A Symbol is a pointer to a variable or function.",
        "name": "plugin.Symbol",
        "params": [],
        "path": "go/plugin/index#Symbol",
        "syntax": "package main import \"fmt\" var V int func F() { fmt.Printf(\"Hello, number %d\\n\", V) }",
        "type": "plugin"
    },
    "Symlink": {
        "descr": "",
        "name": "syscall.Symlink",
        "params": [],
        "path": "go/syscall/index#Symlink",
        "syntax": "func Symlink(oldpath string, newpath string) (err error)",
        "type": "syscall"
    },
    "Sync": {
        "descr": "",
        "name": "syscall.Sync",
        "params": [],
        "path": "go/syscall/index#Sync",
        "syntax": "func Sync()",
        "type": "syscall"
    },
    "SyncFileRange": {
        "descr": "",
        "name": "syscall.SyncFileRange",
        "params": [],
        "path": "go/syscall/index#SyncFileRange",
        "syntax": "func SyncFileRange(fd int, off int64, n int64, flags int) (err error)",
        "type": "syscall"
    },
    "SysProcAttr": {
        "descr": "",
        "name": "syscall.SysProcAttr",
        "params": [],
        "path": "go/syscall/index#SysProcAttr",
        "syntax": "type SysProcAttr struct { Chroot string // Chroot. Credential *Credential // Credential. Ptrace bool // Enable tracing. Setsid bool // Create session. Setpgid bool // Set process group ID to Pgid, or, if Pgid == 0, to new pid. Setctty bool // Set controlling terminal to fd Ctty (only meaningful if Setsid is set) Noctty bool // Detach fd 0 from controlling terminal Ctty int // Controlling TTY fd Foreground bool // Place child's process group in foreground. (Implies Setpgid. Uses Ctty as fd of controlling TTY) Pgid int // Child's process group ID if Setpgid. Pdeathsig Signal // Signal that the process will get when its parent dies (Linux only) Cloneflags uintptr // Flags for clone calls (Linux only) Unshareflags uintptr // Flags for unshare calls (Linux only) UidMappings []SysProcIDMap // User ID mappings for user namespaces. GidMappings []SysProcIDMap // Group ID mappings for user namespaces. // GidMappingsEnableSetgroups enabling setgroups syscall. // If false, then setgroups syscall will be disabled for the child process. // This parameter is no-op if GidMappings == nil. Otherwise for unprivileged // users this should be set to false for mappings work. GidMappingsEnableSetgroups bool AmbientCaps []uintptr // Ambient capabilities (Linux only) }",
        "type": "syscall"
    },
    "SysProcIDMap": {
        "descr": "SysProcIDMap holds Container ID to Host ID mappings used for User Namespaces in Linux. See user_namespaces(7).",
        "name": "syscall.SysProcIDMap",
        "params": [],
        "path": "go/syscall/index#SysProcIDMap",
        "syntax": "type SysProcIDMap struct { ContainerID int // Container ID. HostID int // Host ID. Size int // Size. }",
        "type": "syscall"
    },
    "Syscall": {
        "descr": "",
        "name": "syscall.Syscall",
        "params": [],
        "path": "go/syscall/index#Syscall",
        "syntax": "func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)",
        "type": "syscall"
    },
    "Syscall6": {
        "descr": "",
        "name": "syscall.Syscall6",
        "params": [],
        "path": "go/syscall/index#Syscall6",
        "syntax": "func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)",
        "type": "syscall"
    },
    "SyscallError": {
        "descr": "SyscallError records an error from a specific system call.",
        "name": "os.SyscallError",
        "params": [],
        "path": "go/os/index#SyscallError",
        "syntax": "type SyscallError struct { Syscall string Err error }",
        "type": "os"
    },
    "SyscallError.Error": {
        "descr": "",
        "name": "os.SyscallError.Error",
        "params": [],
        "path": "go/os/index#SyscallError.Error",
        "syntax": "func (e *SyscallError) Error() string",
        "type": "os"
    },
    "SyscallError.Timeout": {
        "descr": "Timeout reports whether this error represents a timeout.",
        "name": "os.SyscallError.Timeout",
        "params": [],
        "path": "go/os/index#SyscallError.Timeout",
        "syntax": "func (e *SyscallError) Timeout() bool",
        "type": "os"
    },
    "Sysinfo": {
        "descr": "",
        "name": "syscall.Sysinfo",
        "params": [],
        "path": "go/syscall/index#Sysinfo",
        "syntax": "func Sysinfo(info *Sysinfo_t) (err error)",
        "type": "syscall"
    },
    "Sysinfo_t": {
        "descr": "",
        "name": "syscall.Sysinfo_t",
        "params": [],
        "path": "go/syscall/index#Sysinfo_t",
        "syntax": "type Sysinfo_t struct { Uptime int64 Loads [3]uint64 Totalram uint64 Freeram uint64 Sharedram uint64 Bufferram uint64 Totalswap uint64 Freeswap uint64 Procs uint16 Pad uint16 Pad_cgo_0 [4]byte Totalhigh uint64 Freehigh uint64 Unit uint32 X_f [0]byte Pad_cgo_1 [4]byte }",
        "type": "syscall"
    },
    "T": {
        "descr": "T is a type passed to Test functions to manage test state and support formatted test logs. Logs are accumulated during execution and dumped to standard output when done.",
        "name": "testing.T",
        "params": [],
        "path": "go/testing/index#T",
        "syntax": "type T struct { // contains filtered or unexported fields }",
        "type": "testing"
    },
    "T.Error": {
        "descr": "Error is equivalent to Log followed by Fail.",
        "name": "testing.T.Error",
        "params": [],
        "path": "go/testing/index#T.Error",
        "syntax": "func (c *T) Error(args ...interface{})",
        "type": "testing"
    },
    "T.Errorf": {
        "descr": "Errorf is equivalent to Logf followed by Fail.",
        "name": "testing.T.Errorf",
        "params": [],
        "path": "go/testing/index#T.Errorf",
        "syntax": "func (c *T) Errorf(format string, args ...interface{})",
        "type": "testing"
    },
    "T.Fail": {
        "descr": "Fail marks the function as having failed but continues execution.",
        "name": "testing.T.Fail",
        "params": [],
        "path": "go/testing/index#T.Fail",
        "syntax": "func (c *T) Fail()",
        "type": "testing"
    },
    "T.FailNow": {
        "descr": "FailNow marks the function as having failed and stops its execution by calling runtime.Goexit (which then runs all deferred calls in the current goroutine). Execution will continue at the next test or benchmark. FailNow must be called from the goroutine running the test or benchmark function, not from other goroutines created during the test. Calling FailNow does not stop those other goroutines.",
        "name": "testing.T.FailNow",
        "params": [],
        "path": "go/testing/index#T.FailNow",
        "syntax": "func (c *T) FailNow()",
        "type": "testing"
    },
    "T.Failed": {
        "descr": "Failed reports whether the function has failed.",
        "name": "testing.T.Failed",
        "params": [],
        "path": "go/testing/index#T.Failed",
        "syntax": "func (c *T) Failed() bool",
        "type": "testing"
    },
    "T.Fatal": {
        "descr": "Fatal is equivalent to Log followed by FailNow.",
        "name": "testing.T.Fatal",
        "params": [],
        "path": "go/testing/index#T.Fatal",
        "syntax": "func (c *T) Fatal(args ...interface{})",
        "type": "testing"
    },
    "T.Fatalf": {
        "descr": "Fatalf is equivalent to Logf followed by FailNow.",
        "name": "testing.T.Fatalf",
        "params": [],
        "path": "go/testing/index#T.Fatalf",
        "syntax": "func (c *T) Fatalf(format string, args ...interface{})",
        "type": "testing"
    },
    "T.Helper": {
        "descr": "Helper marks the calling function as a test helper function. When printing file and line information, that function will be skipped. Helper may be called simultaneously from multiple goroutines.",
        "name": "testing.T.Helper",
        "params": [],
        "path": "go/testing/index#T.Helper",
        "syntax": "func (c *T) Helper()",
        "type": "testing"
    },
    "T.Log": {
        "descr": "Log formats its arguments using default formatting, analogous to Println, and records the text in the error log. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag.",
        "name": "testing.T.Log",
        "params": [],
        "path": "go/testing/index#T.Log",
        "syntax": "func (c *T) Log(args ...interface{})",
        "type": "testing"
    },
    "T.Logf": {
        "descr": "Logf formats its arguments according to the format, analogous to Printf, and records the text in the error log. A final newline is added if not provided. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag.",
        "name": "testing.T.Logf",
        "params": [],
        "path": "go/testing/index#T.Logf",
        "syntax": "func (c *T) Logf(format string, args ...interface{})",
        "type": "testing"
    },
    "T.Name": {
        "descr": "Name returns the name of the running test or benchmark.",
        "name": "testing.T.Name",
        "params": [],
        "path": "go/testing/index#T.Name",
        "syntax": "func (c *T) Name() string",
        "type": "testing"
    },
    "T.Parallel": {
        "descr": "Parallel signals that this test is to be run in parallel with (and only with) other parallel tests. When a test is run multiple times due to use of -test.count or -test.cpu, multiple instances of a single test never run in parallel with each other.",
        "name": "testing.T.Parallel",
        "params": [],
        "path": "go/testing/index#T.Parallel",
        "syntax": "func (t *T) Parallel()",
        "type": "testing"
    },
    "T.Run": {
        "descr": "Run runs f as a subtest of t called name. It runs f in a separate goroutine and blocks until f returns or calls t.Parallel to become a parallel test. Run reports whether f succeeded (or at least did not fail before calling t.Parallel).",
        "name": "testing.T.Run",
        "params": [],
        "path": "go/testing/index#T.Run",
        "syntax": "func (t *T) Run(name string, f func(t *T)) bool",
        "type": "testing"
    },
    "T.Skip": {
        "descr": "Skip is equivalent to Log followed by SkipNow.",
        "name": "testing.T.Skip",
        "params": [],
        "path": "go/testing/index#T.Skip",
        "syntax": "func (c *T) Skip(args ...interface{})",
        "type": "testing"
    },
    "T.SkipNow": {
        "descr": "SkipNow marks the test as having been skipped and stops its execution by calling runtime.Goexit. If a test fails (see Error, Errorf, Fail) and is then skipped, it is still considered to have failed. Execution will continue at the next test or benchmark. See also FailNow. SkipNow must be called from the goroutine running the test, not from other goroutines created during the test. Calling SkipNow does not stop those other goroutines.",
        "name": "testing.T.SkipNow",
        "params": [],
        "path": "go/testing/index#T.SkipNow",
        "syntax": "func (c *T) SkipNow()",
        "type": "testing"
    },
    "T.Skipf": {
        "descr": "Skipf is equivalent to Logf followed by SkipNow.",
        "name": "testing.T.Skipf",
        "params": [],
        "path": "go/testing/index#T.Skipf",
        "syntax": "func (c *T) Skipf(format string, args ...interface{})",
        "type": "testing"
    },
    "T.Skipped": {
        "descr": "Skipped reports whether the test was skipped.",
        "name": "testing.T.Skipped",
        "params": [],
        "path": "go/testing/index#T.Skipped",
        "syntax": "func (c *T) Skipped() bool",
        "type": "testing"
    },
    "TB": {
        "descr": "TB is the interface common to T and B.",
        "name": "testing.TB",
        "params": [],
        "path": "go/testing/index#TB",
        "syntax": "type TB interface { Error(args ...interface{}) Errorf(format string, args ...interface{}) Fail() FailNow() Failed() bool Fatal(args ...interface{}) Fatalf(format string, args ...interface{}) Log(args ...interface{}) Logf(format string, args ...interface{}) Name() string Skip(args ...interface{}) SkipNow() Skipf(format string, args ...interface{}) Skipped() bool Helper() // contains filtered or unexported methods }",
        "type": "testing"
    },
    "TCPAddr": {
        "descr": "TCPAddr represents the address of a TCP end point.",
        "name": "net.TCPAddr",
        "params": [],
        "path": "go/net/index#TCPAddr",
        "syntax": "type TCPAddr struct { IP IP Port int Zone string // IPv6 scoped addressing zone; added in Go 1.1 }",
        "type": "net"
    },
    "TCPAddr.Network": {
        "descr": "Network returns the address's network name, \"tcp\".",
        "name": "net.TCPAddr.Network",
        "params": [],
        "path": "go/net/index#TCPAddr.Network",
        "syntax": "func (a *TCPAddr) Network() string",
        "type": "net"
    },
    "TCPAddr.String": {
        "descr": "",
        "name": "net.TCPAddr.String",
        "params": [],
        "path": "go/net/index#TCPAddr.String",
        "syntax": "func (a *TCPAddr) String() string",
        "type": "net"
    },
    "TCPConn": {
        "descr": "TCPConn is an implementation of the Conn interface for TCP network connections.",
        "name": "net.TCPConn",
        "params": [],
        "path": "go/net/index#TCPConn",
        "syntax": "type TCPConn struct { // contains filtered or unexported fields }",
        "type": "net"
    },
    "TCPConn.Close": {
        "descr": "Close closes the connection.",
        "name": "net.TCPConn.Close",
        "params": [],
        "path": "go/net/index#TCPConn.Close",
        "syntax": "func (c *TCPConn) Close() error",
        "type": "net"
    },
    "TCPConn.CloseRead": {
        "descr": "CloseRead shuts down the reading side of the TCP connection. Most callers should just use Close.",
        "name": "net.TCPConn.CloseRead",
        "params": [],
        "path": "go/net/index#TCPConn.CloseRead",
        "syntax": "func (c *TCPConn) CloseRead() error",
        "type": "net"
    },
    "TCPConn.CloseWrite": {
        "descr": "CloseWrite shuts down the writing side of the TCP connection. Most callers should just use Close.",
        "name": "net.TCPConn.CloseWrite",
        "params": [],
        "path": "go/net/index#TCPConn.CloseWrite",
        "syntax": "func (c *TCPConn) CloseWrite() error",
        "type": "net"
    },
    "TCPConn.File": {
        "descr": "File returns a copy of the underlying os.File It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.",
        "name": "net.TCPConn.File",
        "params": [],
        "path": "go/net/index#TCPConn.File",
        "syntax": "func (c *TCPConn) File() (f *os.File, err error)",
        "type": "net"
    },
    "TCPConn.LocalAddr": {
        "descr": "LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it.",
        "name": "net.TCPConn.LocalAddr",
        "params": [],
        "path": "go/net/index#TCPConn.LocalAddr",
        "syntax": "func (c *TCPConn) LocalAddr() Addr",
        "type": "net"
    },
    "TCPConn.Read": {
        "descr": "Read implements the Conn Read method.",
        "name": "net.TCPConn.Read",
        "params": [],
        "path": "go/net/index#TCPConn.Read",
        "syntax": "func (c *TCPConn) Read(b []byte) (int, error)",
        "type": "net"
    },
    "TCPConn.ReadFrom": {
        "descr": "ReadFrom implements the io.ReaderFrom ReadFrom method.",
        "name": "net.TCPConn.ReadFrom",
        "params": [],
        "path": "go/net/index#TCPConn.ReadFrom",
        "syntax": "func (c *TCPConn) ReadFrom(r io.Reader) (int64, error)",
        "type": "net"
    },
    "TCPConn.RemoteAddr": {
        "descr": "RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it.",
        "name": "net.TCPConn.RemoteAddr",
        "params": [],
        "path": "go/net/index#TCPConn.RemoteAddr",
        "syntax": "func (c *TCPConn) RemoteAddr() Addr",
        "type": "net"
    },
    "TCPConn.SetDeadline": {
        "descr": "SetDeadline implements the Conn SetDeadline method.",
        "name": "net.TCPConn.SetDeadline",
        "params": [],
        "path": "go/net/index#TCPConn.SetDeadline",
        "syntax": "func (c *TCPConn) SetDeadline(t time.Time) error",
        "type": "net"
    },
    "TCPConn.SetKeepAlive": {
        "descr": "SetKeepAlive sets whether the operating system should send keepalive messages on the connection.",
        "name": "net.TCPConn.SetKeepAlive",
        "params": [],
        "path": "go/net/index#TCPConn.SetKeepAlive",
        "syntax": "func (c *TCPConn) SetKeepAlive(keepalive bool) error",
        "type": "net"
    },
    "TCPConn.SetKeepAlivePeriod": {
        "descr": "SetKeepAlivePeriod sets period between keep alives.",
        "name": "net.TCPConn.SetKeepAlivePeriod",
        "params": [],
        "path": "go/net/index#TCPConn.SetKeepAlivePeriod",
        "syntax": "func (c *TCPConn) SetKeepAlivePeriod(d time.Duration) error",
        "type": "net"
    },
    "TCPConn.SetLinger": {
        "descr": "SetLinger sets the behavior of Close on a connection which still has data waiting to be sent or to be acknowledged.",
        "name": "net.TCPConn.SetLinger",
        "params": [],
        "path": "go/net/index#TCPConn.SetLinger",
        "syntax": "func (c *TCPConn) SetLinger(sec int) error",
        "type": "net"
    },
    "TCPConn.SetNoDelay": {
        "descr": "SetNoDelay controls whether the operating system should delay packet transmission in hopes of sending fewer packets (Nagle's algorithm). The default is true (no delay), meaning that data is sent as soon as possible after a Write.",
        "name": "net.TCPConn.SetNoDelay",
        "params": [],
        "path": "go/net/index#TCPConn.SetNoDelay",
        "syntax": "func (c *TCPConn) SetNoDelay(noDelay bool) error",
        "type": "net"
    },
    "TCPConn.SetReadBuffer": {
        "descr": "SetReadBuffer sets the size of the operating system's receive buffer associated with the connection.",
        "name": "net.TCPConn.SetReadBuffer",
        "params": [],
        "path": "go/net/index#TCPConn.SetReadBuffer",
        "syntax": "func (c *TCPConn) SetReadBuffer(bytes int) error",
        "type": "net"
    },
    "TCPConn.SetReadDeadline": {
        "descr": "SetReadDeadline implements the Conn SetReadDeadline method.",
        "name": "net.TCPConn.SetReadDeadline",
        "params": [],
        "path": "go/net/index#TCPConn.SetReadDeadline",
        "syntax": "func (c *TCPConn) SetReadDeadline(t time.Time) error",
        "type": "net"
    },
    "TCPConn.SetWriteBuffer": {
        "descr": "SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection.",
        "name": "net.TCPConn.SetWriteBuffer",
        "params": [],
        "path": "go/net/index#TCPConn.SetWriteBuffer",
        "syntax": "func (c *TCPConn) SetWriteBuffer(bytes int) error",
        "type": "net"
    },
    "TCPConn.SetWriteDeadline": {
        "descr": "SetWriteDeadline implements the Conn SetWriteDeadline method.",
        "name": "net.TCPConn.SetWriteDeadline",
        "params": [],
        "path": "go/net/index#TCPConn.SetWriteDeadline",
        "syntax": "func (c *TCPConn) SetWriteDeadline(t time.Time) error",
        "type": "net"
    },
    "TCPConn.SyscallConn": {
        "descr": "SyscallConn returns a raw network connection. This implements the syscall.Conn interface.",
        "name": "net.TCPConn.SyscallConn",
        "params": [],
        "path": "go/net/index#TCPConn.SyscallConn",
        "syntax": "func (c *TCPConn) SyscallConn() (syscall.RawConn, error)",
        "type": "net"
    },
    "TCPConn.Write": {
        "descr": "Write implements the Conn Write method.",
        "name": "net.TCPConn.Write",
        "params": [],
        "path": "go/net/index#TCPConn.Write",
        "syntax": "func (c *TCPConn) Write(b []byte) (int, error)",
        "type": "net"
    },
    "TCPInfo": {
        "descr": "",
        "name": "syscall.TCPInfo",
        "params": [],
        "path": "go/syscall/index#TCPInfo",
        "syntax": "type TCPInfo struct { State uint8 Ca_state uint8 Retransmits uint8 Probes uint8 Backoff uint8 Options uint8 Pad_cgo_0 [2]byte Rto uint32 Ato uint32 Snd_mss uint32 Rcv_mss uint32 Unacked uint32 Sacked uint32 Lost uint32 Retrans uint32 Fackets uint32 Last_data_sent uint32 Last_ack_sent uint32 Last_data_recv uint32 Last_ack_recv uint32 Pmtu uint32 Rcv_ssthresh uint32 Rtt uint32 Rttvar uint32 Snd_ssthresh uint32 Snd_cwnd uint32 Advmss uint32 Reordering uint32 Rcv_rtt uint32 Rcv_space uint32 Total_retrans uint32 }",
        "type": "syscall"
    },
    "TCPListener": {
        "descr": "TCPListener is a TCP network listener. Clients should typically use variables of type Listener instead of assuming TCP.",
        "name": "net.TCPListener",
        "params": [],
        "path": "go/net/index#TCPListener",
        "syntax": "type TCPListener struct { // contains filtered or unexported fields }",
        "type": "net"
    },
    "TCPListener.Accept": {
        "descr": "Accept implements the Accept method in the Listener interface; it waits for the next call and returns a generic Conn.",
        "name": "net.TCPListener.Accept",
        "params": [],
        "path": "go/net/index#TCPListener.Accept",
        "syntax": "func (l *TCPListener) Accept() (Conn, error)",
        "type": "net"
    },
    "TCPListener.AcceptTCP": {
        "descr": "AcceptTCP accepts the next incoming call and returns the new connection.",
        "name": "net.TCPListener.AcceptTCP",
        "params": [],
        "path": "go/net/index#TCPListener.AcceptTCP",
        "syntax": "func (l *TCPListener) AcceptTCP() (*TCPConn, error)",
        "type": "net"
    },
    "TCPListener.Addr": {
        "descr": "Addr returns the listener's network address, a *TCPAddr. The Addr returned is shared by all invocations of Addr, so do not modify it.",
        "name": "net.TCPListener.Addr",
        "params": [],
        "path": "go/net/index#TCPListener.Addr",
        "syntax": "func (l *TCPListener) Addr() Addr",
        "type": "net"
    },
    "TCPListener.Close": {
        "descr": "Close stops listening on the TCP address. Already Accepted connections are not closed.",
        "name": "net.TCPListener.Close",
        "params": [],
        "path": "go/net/index#TCPListener.Close",
        "syntax": "func (l *TCPListener) Close() error",
        "type": "net"
    },
    "TCPListener.File": {
        "descr": "File returns a copy of the underlying os.File. It is the caller's responsibility to close f when finished. Closing l does not affect f, and closing f does not affect l.",
        "name": "net.TCPListener.File",
        "params": [],
        "path": "go/net/index#TCPListener.File",
        "syntax": "func (l *TCPListener) File() (f *os.File, err error)",
        "type": "net"
    },
    "TCPListener.SetDeadline": {
        "descr": "SetDeadline sets the deadline associated with the listener. A zero time value disables the deadline.",
        "name": "net.TCPListener.SetDeadline",
        "params": [],
        "path": "go/net/index#TCPListener.SetDeadline",
        "syntax": "func (l *TCPListener) SetDeadline(t time.Time) error",
        "type": "net"
    },
    "TCPListener.SyscallConn": {
        "descr": "SyscallConn returns a raw network connection. This implements the syscall.Conn interface.",
        "name": "net.TCPListener.SyscallConn",
        "params": [],
        "path": "go/net/index#TCPListener.SyscallConn",
        "syntax": "func (l *TCPListener) SyscallConn() (syscall.RawConn, error)",
        "type": "net"
    },
    "TODO": {
        "descr": "TODO returns a non-nil, empty Context. Code should use context.TODO when it's unclear which Context to use or it is not yet available (because the surrounding function has not yet been extended to accept a Context parameter). TODO is recognized by static analysis tools that determine whether Contexts are propagated correctly in a program.",
        "name": "context.TODO",
        "params": [],
        "path": "go/context/index#TODO",
        "syntax": "func TODO() Context",
        "type": "context"
    },
    "Tan": {
        "descr": "Tan returns the tangent of the radian argument x.",
        "name": "math.Tan",
        "params": [],
        "path": "go/math/index#Tan",
        "syntax": "func Tan(x float64) float64",
        "type": "math"
    },
    "Tanh": {
        "descr": "Tanh returns the hyperbolic tangent of x.",
        "name": "math.Tanh",
        "params": [],
        "path": "go/math/index#Tanh",
        "syntax": "func Tanh(x float64) float64",
        "type": "math"
    },
    "Tee": {
        "descr": "",
        "name": "syscall.Tee",
        "params": [],
        "path": "go/syscall/index#Tee",
        "syntax": "func Tee(rfd int, wfd int, len int, flags int) (n int64, err error)",
        "type": "syscall"
    },
    "TeeReader": {
        "descr": "TeeReader returns a Reader that writes to w what it reads from r. All reads from r performed through it are matched with corresponding writes to w. There is no internal buffering - the write must complete before the read completes. Any error encountered while writing is reported as a read error.",
        "name": "io.TeeReader",
        "params": [],
        "path": "go/io/index#TeeReader",
        "syntax": "func TeeReader(r Reader, w Writer) Reader",
        "type": "io"
    },
    "TempDir": {
        "descr": "TempDir returns the default directory to use for temporary files.",
        "name": "os.TempDir",
        "params": [],
        "path": "go/os/index#TempDir",
        "syntax": "func TempDir() string",
        "type": "os"
    },
    "Termios": {
        "descr": "",
        "name": "syscall.Termios",
        "params": [],
        "path": "go/syscall/index#Termios",
        "syntax": "type Termios struct { Iflag uint32 Oflag uint32 Cflag uint32 Lflag uint32 Line uint8 Cc [32]uint8 Pad_cgo_0 [3]byte Ispeed uint32 Ospeed uint32 }",
        "type": "syscall"
    },
    "TextMarshaler": {
        "descr": "TextMarshaler is the interface implemented by an object that can marshal itself into a textual form.",
        "name": "encoding.TextMarshaler",
        "params": [],
        "path": "go/encoding/index#TextMarshaler",
        "syntax": "type TextMarshaler interface { MarshalText() (text []byte, err error) }",
        "type": "encoding"
    },
    "TextUnmarshaler": {
        "descr": "TextUnmarshaler is the interface implemented by an object that can unmarshal a textual representation of itself.",
        "name": "encoding.TextUnmarshaler",
        "params": [],
        "path": "go/encoding/index#TextUnmarshaler",
        "syntax": "type TextUnmarshaler interface { UnmarshalText(text []byte) error }",
        "type": "encoding"
    },
    "Tgkill": {
        "descr": "",
        "name": "syscall.Tgkill",
        "params": [],
        "path": "go/syscall/index#Tgkill",
        "syntax": "func Tgkill(tgid int, tid int, sig Signal) (err error)",
        "type": "syscall"
    },
    "ThreadCreateProfile": {
        "descr": "ThreadCreateProfile returns n, the number of records in the thread creation profile. If len(p) >= n, ThreadCreateProfile copies the profile into p and returns n, true. If len(p) < n, ThreadCreateProfile does not change p and returns n, false.",
        "name": "runtime.ThreadCreateProfile",
        "params": [],
        "path": "go/runtime/index#ThreadCreateProfile",
        "syntax": "func ThreadCreateProfile(p []StackRecord) (n int, ok bool)",
        "type": "runtime"
    },
    "Tick": {
        "descr": "Tick is a convenience wrapper for NewTicker providing access to the ticking channel only. While Tick is useful for clients that have no need to shut down the Ticker, be aware that without a way to shut it down the underlying Ticker cannot be recovered by the garbage collector; it \"leaks\". Unlike NewTicker, Tick will return nil if d <= 0.",
        "name": "time.Tick",
        "params": [],
        "path": "go/time/index#Tick",
        "syntax": "func Tick(d Duration) <-chan Time",
        "type": "time"
    },
    "Ticker": {
        "descr": "A Ticker holds a channel that delivers `ticks' of a clock at intervals.",
        "name": "time.Ticker",
        "params": [],
        "path": "go/time/index#Ticker",
        "syntax": "type Ticker struct { C <-chan Time // The channel on which the ticks are delivered. // contains filtered or unexported fields }",
        "type": "time"
    },
    "Ticker.Stop": {
        "descr": "Stop turns off a ticker. After Stop, no more ticks will be sent. Stop does not close the channel, to prevent a concurrent goroutine reading from the channel from seeing an erroneous \"tick\".",
        "name": "time.Ticker.Stop",
        "params": [],
        "path": "go/time/index#Ticker.Stop",
        "syntax": "func (t *Ticker) Stop()",
        "type": "time"
    },
    "Time": {
        "descr": "A Time represents an instant in time with nanosecond precision.",
        "name": "time.Time",
        "params": [],
        "path": "go/time/index#Time",
        "syntax": "type Time struct { // contains filtered or unexported fields }",
        "type": "time"
    },
    "Time.Add": {
        "descr": "Add returns the time t+d.",
        "name": "time.Time.Add",
        "params": [],
        "path": "go/time/index#Time.Add",
        "syntax": "func (t Time) Add(d Duration) Time",
        "type": "time"
    },
    "Time.AddDate": {
        "descr": "AddDate returns the time corresponding to adding the given number of years, months, and days to t. For example, AddDate(-1, 2, 3) applied to January 1, 2011 returns March 4, 2010.",
        "name": "time.Time.AddDate",
        "params": [],
        "path": "go/time/index#Time.AddDate",
        "syntax": "func (t Time) AddDate(years int, months int, days int) Time",
        "type": "time"
    },
    "Time.After": {
        "descr": "After reports whether the time instant t is after u.",
        "name": "time.Time.After",
        "params": [],
        "path": "go/time/index#Time.After",
        "syntax": "func (t Time) After(u Time) bool",
        "type": "time"
    },
    "Time.AppendFormat": {
        "descr": "AppendFormat is like Format but appends the textual representation to b and returns the extended buffer.",
        "name": "time.Time.AppendFormat",
        "params": [],
        "path": "go/time/index#Time.AppendFormat",
        "syntax": "func (t Time) AppendFormat(b []byte, layout string) []byte",
        "type": "time"
    },
    "Time.Before": {
        "descr": "Before reports whether the time instant t is before u.",
        "name": "time.Time.Before",
        "params": [],
        "path": "go/time/index#Time.Before",
        "syntax": "func (t Time) Before(u Time) bool",
        "type": "time"
    },
    "Time.Clock": {
        "descr": "Clock returns the hour, minute, and second within the day specified by t.",
        "name": "time.Time.Clock",
        "params": [],
        "path": "go/time/index#Time.Clock",
        "syntax": "func (t Time) Clock() (hour, min, sec int)",
        "type": "time"
    },
    "Time.Date": {
        "descr": "Date returns the year, month, and day in which t occurs.",
        "name": "time.Time.Date",
        "params": [],
        "path": "go/time/index#Time.Date",
        "syntax": "func (t Time) Date() (year int, month Month, day int)",
        "type": "time"
    },
    "Time.Day": {
        "descr": "Day returns the day of the month specified by t.",
        "name": "time.Time.Day",
        "params": [],
        "path": "go/time/index#Time.Day",
        "syntax": "func (t Time) Day() int",
        "type": "time"
    },
    "Time.Equal": {
        "descr": "Equal reports whether t and u represent the same time instant. Two times can be equal even if they are in different locations. For example, 6:00 +0200 CEST and 4:00 UTC are Equal. See the documentation on the Time type for the pitfalls of using == with Time values; most code should use Equal instead.",
        "name": "time.Time.Equal",
        "params": [],
        "path": "go/time/index#Time.Equal",
        "syntax": "func (t Time) Equal(u Time) bool",
        "type": "time"
    },
    "Time.Format": {
        "descr": "Format returns a textual representation of the time value formatted according to layout, which defines the format by showing how the reference time, defined to be",
        "name": "time.Time.Format",
        "params": [],
        "path": "go/time/index#Time.Format",
        "syntax": "func (t Time) Format(layout string) string",
        "type": "time"
    },
    "Time.GobDecode": {
        "descr": "GobDecode implements the gob.GobDecoder interface.",
        "name": "time.Time.GobDecode",
        "params": [],
        "path": "go/time/index#Time.GobDecode",
        "syntax": "func (t *Time) GobDecode(data []byte) error",
        "type": "time"
    },
    "Time.GobEncode": {
        "descr": "GobEncode implements the gob.GobEncoder interface.",
        "name": "time.Time.GobEncode",
        "params": [],
        "path": "go/time/index#Time.GobEncode",
        "syntax": "func (t Time) GobEncode() ([]byte, error)",
        "type": "time"
    },
    "Time.Hour": {
        "descr": "Hour returns the hour within the day specified by t, in the range [0, 23].",
        "name": "time.Time.Hour",
        "params": [],
        "path": "go/time/index#Time.Hour",
        "syntax": "func (t Time) Hour() int",
        "type": "time"
    },
    "Time.ISOWeek": {
        "descr": "ISOWeek returns the ISO 8601 year and week number in which t occurs. Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1 of year n+1.",
        "name": "time.Time.ISOWeek",
        "params": [],
        "path": "go/time/index#Time.ISOWeek",
        "syntax": "func (t Time) ISOWeek() (year, week int)",
        "type": "time"
    },
    "Time.In": {
        "descr": "In returns a copy of t representating the same time instant, but with the copy's location information set to loc for display purposes.",
        "name": "time.Time.In",
        "params": [],
        "path": "go/time/index#Time.In",
        "syntax": "func (t Time) In(loc *Location) Time",
        "type": "time"
    },
    "Time.IsZero": {
        "descr": "IsZero reports whether t represents the zero time instant, January 1, year 1, 00:00:00 UTC.",
        "name": "time.Time.IsZero",
        "params": [],
        "path": "go/time/index#Time.IsZero",
        "syntax": "func (t Time) IsZero() bool",
        "type": "time"
    },
    "Time.Local": {
        "descr": "Local returns t with the location set to local time.",
        "name": "time.Time.Local",
        "params": [],
        "path": "go/time/index#Time.Local",
        "syntax": "func (t Time) Local() Time",
        "type": "time"
    },
    "Time.Location": {
        "descr": "Location returns the time zone information associated with t.",
        "name": "time.Time.Location",
        "params": [],
        "path": "go/time/index#Time.Location",
        "syntax": "func (t Time) Location() *Location",
        "type": "time"
    },
    "Time.MarshalBinary": {
        "descr": "MarshalBinary implements the encoding.BinaryMarshaler interface.",
        "name": "time.Time.MarshalBinary",
        "params": [],
        "path": "go/time/index#Time.MarshalBinary",
        "syntax": "func (t Time) MarshalBinary() ([]byte, error)",
        "type": "time"
    },
    "Time.MarshalJSON": {
        "descr": "MarshalJSON implements the json.Marshaler interface. The time is a quoted string in RFC 3339 format, with sub-second precision added if present.",
        "name": "time.Time.MarshalJSON",
        "params": [],
        "path": "go/time/index#Time.MarshalJSON",
        "syntax": "func (t Time) MarshalJSON() ([]byte, error)",
        "type": "time"
    },
    "Time.MarshalText": {
        "descr": "MarshalText implements the encoding.TextMarshaler interface. The time is formatted in RFC 3339 format, with sub-second precision added if present.",
        "name": "time.Time.MarshalText",
        "params": [],
        "path": "go/time/index#Time.MarshalText",
        "syntax": "func (t Time) MarshalText() ([]byte, error)",
        "type": "time"
    },
    "Time.Minute": {
        "descr": "Minute returns the minute offset within the hour specified by t, in the range [0, 59].",
        "name": "time.Time.Minute",
        "params": [],
        "path": "go/time/index#Time.Minute",
        "syntax": "func (t Time) Minute() int",
        "type": "time"
    },
    "Time.Month": {
        "descr": "Month returns the month of the year specified by t.",
        "name": "time.Time.Month",
        "params": [],
        "path": "go/time/index#Time.Month",
        "syntax": "func (t Time) Month() Month",
        "type": "time"
    },
    "Time.Nanosecond": {
        "descr": "Nanosecond returns the nanosecond offset within the second specified by t, in the range [0, 999999999].",
        "name": "time.Time.Nanosecond",
        "params": [],
        "path": "go/time/index#Time.Nanosecond",
        "syntax": "func (t Time) Nanosecond() int",
        "type": "time"
    },
    "Time.Round": {
        "descr": "Round returns the result of rounding t to the nearest multiple of d (since the zero time). The rounding behavior for halfway values is to round up. If d <= 0, Round returns t stripped of any monotonic clock reading but otherwise unchanged.",
        "name": "time.Time.Round",
        "params": [],
        "path": "go/time/index#Time.Round",
        "syntax": "func (t Time) Round(d Duration) Time",
        "type": "time"
    },
    "Time.Second": {
        "descr": "Second returns the second offset within the minute specified by t, in the range [0, 59].",
        "name": "time.Time.Second",
        "params": [],
        "path": "go/time/index#Time.Second",
        "syntax": "func (t Time) Second() int",
        "type": "time"
    },
    "Time.String": {
        "descr": "String returns the time formatted using the format string",
        "name": "time.Time.String",
        "params": [],
        "path": "go/time/index#Time.String",
        "syntax": "func (t Time) String() string",
        "type": "time"
    },
    "Time.Sub": {
        "descr": "Sub returns the duration t-u. If the result exceeds the maximum (or minimum) value that can be stored in a Duration, the maximum (or minimum) duration will be returned. To compute t-d for a duration d, use t.Add(-d).",
        "name": "time.Time.Sub",
        "params": [],
        "path": "go/time/index#Time.Sub",
        "syntax": "func (t Time) Sub(u Time) Duration",
        "type": "time"
    },
    "Time.Truncate": {
        "descr": "Truncate returns the result of rounding t down to a multiple of d (since the zero time). If d <= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged.",
        "name": "time.Time.Truncate",
        "params": [],
        "path": "go/time/index#Time.Truncate",
        "syntax": "func (t Time) Truncate(d Duration) Time",
        "type": "time"
    },
    "Time.UTC": {
        "descr": "UTC returns t with the location set to UTC.",
        "name": "time.Time.UTC",
        "params": [],
        "path": "go/time/index#Time.UTC",
        "syntax": "func (t Time) UTC() Time",
        "type": "time"
    },
    "Time.Unix": {
        "descr": "Unix returns t as a Unix time, the number of seconds elapsed since January 1, 1970 UTC. The result does not depend on the location associated with t.",
        "name": "time.Time.Unix",
        "params": [],
        "path": "go/time/index#Time.Unix",
        "syntax": "func (t Time) Unix() int64",
        "type": "time"
    },
    "Time.UnixNano": {
        "descr": "UnixNano returns t as a Unix time, the number of nanoseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in nanoseconds cannot be represented by an int64 (a date before the year 1678 or after 2262). Note that this means the result of calling UnixNano on the zero Time is undefined. The result does not depend on the location associated with t.",
        "name": "time.Time.UnixNano",
        "params": [],
        "path": "go/time/index#Time.UnixNano",
        "syntax": "func (t Time) UnixNano() int64",
        "type": "time"
    },
    "Time.UnmarshalBinary": {
        "descr": "UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.",
        "name": "time.Time.UnmarshalBinary",
        "params": [],
        "path": "go/time/index#Time.UnmarshalBinary",
        "syntax": "func (t *Time) UnmarshalBinary(data []byte) error",
        "type": "time"
    },
    "Time.UnmarshalJSON": {
        "descr": "UnmarshalJSON implements the json.Unmarshaler interface. The time is expected to be a quoted string in RFC 3339 format.",
        "name": "time.Time.UnmarshalJSON",
        "params": [],
        "path": "go/time/index#Time.UnmarshalJSON",
        "syntax": "func (t *Time) UnmarshalJSON(data []byte) error",
        "type": "time"
    },
    "Time.UnmarshalText": {
        "descr": "UnmarshalText implements the encoding.TextUnmarshaler interface. The time is expected to be in RFC 3339 format.",
        "name": "time.Time.UnmarshalText",
        "params": [],
        "path": "go/time/index#Time.UnmarshalText",
        "syntax": "func (t *Time) UnmarshalText(data []byte) error",
        "type": "time"
    },
    "Time.Weekday": {
        "descr": "Weekday returns the day of the week specified by t.",
        "name": "time.Time.Weekday",
        "params": [],
        "path": "go/time/index#Time.Weekday",
        "syntax": "func (t Time) Weekday() Weekday",
        "type": "time"
    },
    "Time.Year": {
        "descr": "Year returns the year in which t occurs.",
        "name": "time.Time.Year",
        "params": [],
        "path": "go/time/index#Time.Year",
        "syntax": "func (t Time) Year() int",
        "type": "time"
    },
    "Time.YearDay": {
        "descr": "YearDay returns the day of the year specified by t, in the range [1,365] for non-leap years, and [1,366] in leap years.",
        "name": "time.Time.YearDay",
        "params": [],
        "path": "go/time/index#Time.YearDay",
        "syntax": "func (t Time) YearDay() int",
        "type": "time"
    },
    "Time.Zone": {
        "descr": "Zone computes the time zone in effect at time t, returning the abbreviated name of the zone (such as \"CET\") and its offset in seconds east of UTC.",
        "name": "time.Time.Zone",
        "params": [],
        "path": "go/time/index#Time.Zone",
        "syntax": "func (t Time) Zone() (name string, offset int)",
        "type": "time"
    },
    "Time_t": {
        "descr": "",
        "name": "syscall.Time_t",
        "params": [],
        "path": "go/syscall/index#Time_t",
        "syntax": "type Time_t int64",
        "type": "syscall"
    },
    "Timer": {
        "descr": "The Timer type represents a single event. When the Timer expires, the current time will be sent on C, unless the Timer was created by AfterFunc. A Timer must be created with NewTimer or AfterFunc.",
        "name": "time.Timer",
        "params": [],
        "path": "go/time/index#Timer",
        "syntax": "type Timer struct { C <-chan Time // contains filtered or unexported fields }",
        "type": "time"
    },
    "Timer.Reset": {
        "descr": "Reset changes the timer to expire after duration d. It returns true if the timer had been active, false if the timer had expired or been stopped.",
        "name": "time.Timer.Reset",
        "params": [],
        "path": "go/time/index#Timer.Reset",
        "syntax": "func (t *Timer) Reset(d Duration) bool",
        "type": "time"
    },
    "Timer.Stop": {
        "descr": "Stop prevents the Timer from firing. It returns true if the call stops the timer, false if the timer has already expired or been stopped. Stop does not close the channel, to prevent a read from the channel succeeding incorrectly.",
        "name": "time.Timer.Stop",
        "params": [],
        "path": "go/time/index#Timer.Stop",
        "syntax": "func (t *Timer) Stop() bool",
        "type": "time"
    },
    "Times": {
        "descr": "",
        "name": "syscall.Times",
        "params": [],
        "path": "go/syscall/index#Times",
        "syntax": "func Times(tms *Tms) (ticks uintptr, err error)",
        "type": "syscall"
    },
    "Timespec": {
        "descr": "",
        "name": "syscall.Timespec",
        "params": [],
        "path": "go/syscall/index#Timespec",
        "syntax": "type Timespec struct { Sec int64 Nsec int64 }",
        "type": "syscall"
    },
    "Timespec.Nano": {
        "descr": "Nano returns ts as the number of nanoseconds elapsed since the Unix epoch.",
        "name": "syscall.Timespec.Nano",
        "params": [],
        "path": "go/syscall/index#Timespec.Nano",
        "syntax": "func (ts *Timespec) Nano() int64",
        "type": "syscall"
    },
    "Timespec.Unix": {
        "descr": "Unix returns ts as the number of seconds and nanoseconds elapsed since the Unix epoch.",
        "name": "syscall.Timespec.Unix",
        "params": [],
        "path": "go/syscall/index#Timespec.Unix",
        "syntax": "func (ts *Timespec) Unix() (sec int64, nsec int64)",
        "type": "syscall"
    },
    "TimespecToNsec": {
        "descr": "TimespecToNsec converts a Timespec value into a number of nanoseconds since the Unix epoch.",
        "name": "syscall.TimespecToNsec",
        "params": [],
        "path": "go/syscall/index#TimespecToNsec",
        "syntax": "func TimespecToNsec(ts Timespec) int64",
        "type": "syscall"
    },
    "Timeval": {
        "descr": "",
        "name": "syscall.Timeval",
        "params": [],
        "path": "go/syscall/index#Timeval",
        "syntax": "type Timeval struct { Sec int64 Usec int64 }",
        "type": "syscall"
    },
    "Timeval.Nano": {
        "descr": "Nano returns tv as the number of nanoseconds elapsed since the Unix epoch.",
        "name": "syscall.Timeval.Nano",
        "params": [],
        "path": "go/syscall/index#Timeval.Nano",
        "syntax": "func (tv *Timeval) Nano() int64",
        "type": "syscall"
    },
    "Timeval.Unix": {
        "descr": "Unix returns tv as the number of seconds and nanoseconds elapsed since the Unix epoch.",
        "name": "syscall.Timeval.Unix",
        "params": [],
        "path": "go/syscall/index#Timeval.Unix",
        "syntax": "func (tv *Timeval) Unix() (sec int64, nsec int64)",
        "type": "syscall"
    },
    "TimevalToNsec": {
        "descr": "TimevalToNsec converts a Timeval value into a number of nanoseconds since the Unix epoch.",
        "name": "syscall.TimevalToNsec",
        "params": [],
        "path": "go/syscall/index#TimevalToNsec",
        "syntax": "func TimevalToNsec(tv Timeval) int64",
        "type": "syscall"
    },
    "Timex": {
        "descr": "",
        "name": "syscall.Timex",
        "params": [],
        "path": "go/syscall/index#Timex",
        "syntax": "type Timex struct { Modes uint32 Pad_cgo_0 [4]byte Offset int64 Freq int64 Maxerror int64 Esterror int64 Status int32 Pad_cgo_1 [4]byte Constant int64 Precision int64 Tolerance int64 Time Timeval Tick int64 Ppsfreq int64 Jitter int64 Shift int32 Pad_cgo_2 [4]byte Stabil int64 Jitcnt int64 Calcnt int64 Errcnt int64 Stbcnt int64 Tai int32 Pad_cgo_3 [44]byte }",
        "type": "syscall"
    },
    "Title": {
        "descr": "Title returns a copy of the string s with all Unicode letters that begin words mapped to their title case.",
        "name": "strings.Title",
        "params": [],
        "path": "go/strings/index#Title",
        "syntax": "func Title(s string) string",
        "type": "strings"
    },
    "Tms": {
        "descr": "",
        "name": "syscall.Tms",
        "params": [],
        "path": "go/syscall/index#Tms",
        "syntax": "type Tms struct { Utime int64 Stime int64 Cutime int64 Cstime int64 }",
        "type": "syscall"
    },
    "To": {
        "descr": "To maps the rune to the specified case: UpperCase, LowerCase, or TitleCase.",
        "name": "unicode.To",
        "params": [],
        "path": "go/unicode/index#To",
        "syntax": "func To(_case int, r rune) rune",
        "type": "unicode"
    },
    "ToLower": {
        "descr": "ToLower maps the rune to lower case.",
        "name": "unicode.ToLower",
        "params": [],
        "path": "go/unicode/index#ToLower",
        "syntax": "func ToLower(r rune) rune",
        "type": "unicode"
    },
    "ToLowerSpecial": {
        "descr": "ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their lower case, giving priority to the special casing rules.",
        "name": "strings.ToLowerSpecial",
        "params": [],
        "path": "go/strings/index#ToLowerSpecial",
        "syntax": "func ToLowerSpecial(c unicode.SpecialCase, s string) string",
        "type": "strings"
    },
    "ToTitle": {
        "descr": "ToTitle maps the rune to title case.",
        "name": "unicode.ToTitle",
        "params": [],
        "path": "go/unicode/index#ToTitle",
        "syntax": "func ToTitle(r rune) rune",
        "type": "unicode"
    },
    "ToTitleSpecial": {
        "descr": "ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their title case, giving priority to the special casing rules.",
        "name": "strings.ToTitleSpecial",
        "params": [],
        "path": "go/strings/index#ToTitleSpecial",
        "syntax": "func ToTitleSpecial(c unicode.SpecialCase, s string) string",
        "type": "strings"
    },
    "ToUpper": {
        "descr": "ToUpper maps the rune to upper case.",
        "name": "unicode.ToUpper",
        "params": [],
        "path": "go/unicode/index#ToUpper",
        "syntax": "func ToUpper(r rune) rune",
        "type": "unicode"
    },
    "ToUpperSpecial": {
        "descr": "ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their upper case, giving priority to the special casing rules.",
        "name": "strings.ToUpperSpecial",
        "params": [],
        "path": "go/strings/index#ToUpperSpecial",
        "syntax": "func ToUpperSpecial(c unicode.SpecialCase, s string) string",
        "type": "strings"
    },
    "Trim": {
        "descr": "Trim returns a slice of the string s with all leading and trailing Unicode code points contained in cutset removed.",
        "name": "strings.Trim",
        "params": [],
        "path": "go/strings/index#Trim",
        "syntax": "func Trim(s string, cutset string) string",
        "type": "strings"
    },
    "TrimFunc": {
        "descr": "TrimFunc returns a slice of the string s with all leading and trailing Unicode code points c satisfying f(c) removed.",
        "name": "strings.TrimFunc",
        "params": [],
        "path": "go/strings/index#TrimFunc",
        "syntax": "func TrimFunc(s string, f func(rune) bool) string",
        "type": "strings"
    },
    "TrimLeft": {
        "descr": "TrimLeft returns a slice of the string s with all leading Unicode code points contained in cutset removed.",
        "name": "strings.TrimLeft",
        "params": [],
        "path": "go/strings/index#TrimLeft",
        "syntax": "func TrimLeft(s string, cutset string) string",
        "type": "strings"
    },
    "TrimLeftFunc": {
        "descr": "TrimLeftFunc returns a slice of the string s with all leading Unicode code points c satisfying f(c) removed.",
        "name": "strings.TrimLeftFunc",
        "params": [],
        "path": "go/strings/index#TrimLeftFunc",
        "syntax": "func TrimLeftFunc(s string, f func(rune) bool) string",
        "type": "strings"
    },
    "TrimPrefix": {
        "descr": "TrimPrefix returns s without the provided leading prefix string. If s doesn't start with prefix, s is returned unchanged.",
        "name": "strings.TrimPrefix",
        "params": [],
        "path": "go/strings/index#TrimPrefix",
        "syntax": "func TrimPrefix(s, prefix string) string",
        "type": "strings"
    },
    "TrimRight": {
        "descr": "TrimRight returns a slice of the string s, with all trailing Unicode code points contained in cutset removed.",
        "name": "strings.TrimRight",
        "params": [],
        "path": "go/strings/index#TrimRight",
        "syntax": "func TrimRight(s string, cutset string) string",
        "type": "strings"
    },
    "TrimRightFunc": {
        "descr": "TrimRightFunc returns a slice of the string s with all trailing Unicode code points c satisfying f(c) removed.",
        "name": "strings.TrimRightFunc",
        "params": [],
        "path": "go/strings/index#TrimRightFunc",
        "syntax": "func TrimRightFunc(s string, f func(rune) bool) string",
        "type": "strings"
    },
    "TrimSpace": {
        "descr": "TrimSpace returns a slice of the string s, with all leading and trailing white space removed, as defined by Unicode.",
        "name": "strings.TrimSpace",
        "params": [],
        "path": "go/strings/index#TrimSpace",
        "syntax": "func TrimSpace(s string) string",
        "type": "strings"
    },
    "TrimSuffix": {
        "descr": "TrimSuffix returns s without the provided trailing suffix string. If s doesn't end with suffix, s is returned unchanged.",
        "name": "strings.TrimSuffix",
        "params": [],
        "path": "go/strings/index#TrimSuffix",
        "syntax": "func TrimSuffix(s, suffix string) string",
        "type": "strings"
    },
    "Trunc": {
        "descr": "Trunc returns the integer value of x.",
        "name": "math.Trunc",
        "params": [],
        "path": "go/math/index#Trunc",
        "syntax": "func Trunc(x float64) float64",
        "type": "math"
    },
    "Truncate": {
        "descr": "",
        "name": "syscall.Truncate",
        "params": [],
        "path": "go/syscall/index#Truncate",
        "syntax": "func Truncate(path string, length int64) (err error)",
        "type": "syscall"
    },
    "Type": {
        "descr": "Type is the representation of a Go type.",
        "name": "reflect.Type",
        "params": [],
        "path": "go/reflect/index#Type",
        "syntax": "type Type interface { // Align returns the alignment in bytes of a value of // this type when allocated in memory. Align() int // FieldAlign returns the alignment in bytes of a value of // this type when used as a field in a struct. FieldAlign() int // Method returns the i'th method in the type's method set. // It panics if i is not in the range [0, NumMethod()). // // For a non-interface type T or *T, the returned Method's Type and Func // fields describe a function whose first argument is the receiver. // // For an interface type, the returned Method's Type field gives the // method signature, without a receiver, and the Func field is nil. Method(int) Method // MethodByName returns the method with that name in the type's // method set and a boolean indicating if the method was found. // // For a non-interface type T or *T, the returned Method's Type and Func // fields describe a function whose first argument is the receiver. // // For an interface type, the returned Method's Type field gives the // method signature, without a receiver, and the Func field is nil. MethodByName(string) (Method, bool) // NumMethod returns the number of exported methods in the type's method set. NumMethod() int // Name returns the type's name within its package for a defined type. // For other (non-defined) types it returns the empty string. Name() string // PkgPath returns a defined type's package path, that is, the import path // that uniquely identifies the package, such as \"encoding/base64\". // If the type was predeclared (string, error) or not defined (*T, struct{}, // []int, or A where A is an alias for a non-defined type), the package path // will be the empty string. PkgPath() string // Size returns the number of bytes needed to store // a value of the given type; it is analogous to unsafe.Sizeof. Size() uintptr // String returns a string representation of the type. // The string representation may use shortened package names // (e.g., base64 instead of \"encoding/base64\") and is not // guaranteed to be unique among types. To test for type identity, // compare the Types directly. String() string // Kind returns the specific kind of this type. Kind() Kind // Implements reports whether the type implements the interface type u. Implements(u Type) bool // AssignableTo reports whether a value of the type is assignable to type u. AssignableTo(u Type) bool // ConvertibleTo reports whether a value of the type is convertible to type u. ConvertibleTo(u Type) bool // Comparable reports whether values of this type are comparable. Comparable() bool // Bits returns the size of the type in bits. // It panics if the type's Kind is not one of the // sized or unsized Int, Uint, Float, or Complex kinds. Bits() int // ChanDir returns a channel type's direction. // It panics if the type's Kind is not Chan. ChanDir() ChanDir // IsVariadic reports whether a function type's final input parameter // is a \"...\" parameter. If so, t.In(t.NumIn() - 1) returns the parameter's // implicit actual type []T. // // For concreteness, if t represents func(x int, y ... float64), then // // t.NumIn() == 2 // t.In(0) is the reflect.Type for \"int\" // t.In(1) is the reflect.Type for \"[]float64\" // t.IsVariadic() == true // // IsVariadic panics if the type's Kind is not Func. IsVariadic() bool // Elem returns a type's element type. // It panics if the type's Kind is not Array, Chan, Map, Ptr, or Slice. Elem() Type // Field returns a struct type's i'th field. // It panics if the type's Kind is not Struct. // It panics if i is not in the range [0, NumField()). Field(i int) StructField // FieldByIndex returns the nested field corresponding // to the index sequence. It is equivalent to calling Field // successively for each index i. // It panics if the type's Kind is not Struct. FieldByIndex(index []int) StructField // FieldByName returns the struct field with the given name // and a boolean indicating if the field was found. FieldByName(name string) (StructField, bool) // FieldByNameFunc returns the struct field with a name // that satisfies the match function and a boolean indicating if // the field was found. // // FieldByNameFunc considers the fields in the struct itself // and then the fields in any embedded structs, in breadth first order, // stopping at the shallowest nesting depth containing one or more // fields satisfying the match function. If multiple fields at that depth // satisfy the match function, they cancel each other // and FieldByNameFunc returns no match. // This behavior mirrors Go's handling of name lookup in // structs containing embedded fields. FieldByNameFunc(match func(string) bool) (StructField, bool) // In returns the type of a function type's i'th input parameter. // It panics if the type's Kind is not Func. // It panics if i is not in the range [0, NumIn()). In(i int) Type // Key returns a map type's key type. // It panics if the type's Kind is not Map. Key() Type // Len returns an array type's length. // It panics if the type's Kind is not Array. Len() int // NumField returns a struct type's field count. // It panics if the type's Kind is not Struct. NumField() int // NumIn returns a function type's input parameter count. // It panics if the type's Kind is not Func. NumIn() int // NumOut returns a function type's output parameter count. // It panics if the type's Kind is not Func. NumOut() int // Out returns the type of a function type's i'th output parameter. // It panics if the type's Kind is not Func. // It panics if i is not in the range [0, NumOut()). Out(i int) Type // contains filtered or unexported methods }",
        "type": "reflect"
    },
    "Type1": {
        "descr": "Type1 is here for the purposes of documentation only. It is a stand-in for any Go type, but represents the same type for any given function invocation.",
        "name": "builtin.Type1",
        "params": [],
        "path": "go/builtin/index#Type1",
        "syntax": "type Type1 int",
        "type": "builtin"
    },
    "TypeAssertionError": {
        "descr": "A TypeAssertionError explains a failed type assertion.",
        "name": "runtime.TypeAssertionError",
        "params": [],
        "path": "go/runtime/index#TypeAssertionError",
        "syntax": "type TypeAssertionError struct { // contains filtered or unexported fields }",
        "type": "runtime"
    },
    "TypeAssertionError.Error": {
        "descr": "",
        "name": "runtime.TypeAssertionError.Error",
        "params": [],
        "path": "go/runtime/index#TypeAssertionError.Error",
        "syntax": "func (e *TypeAssertionError) Error() string",
        "type": "runtime"
    },
    "TypeAssertionError.RuntimeError": {
        "descr": "",
        "name": "runtime.TypeAssertionError.RuntimeError",
        "params": [],
        "path": "go/runtime/index#TypeAssertionError.RuntimeError",
        "syntax": "func (*TypeAssertionError) RuntimeError()",
        "type": "runtime"
    },
    "TypeByExtension": {
        "descr": "TypeByExtension returns the MIME type associated with the file extension ext. The extension ext should begin with a leading dot, as in \".html\". When ext has no associated type, TypeByExtension returns \"\".",
        "name": "mime.TypeByExtension",
        "params": [],
        "path": "go/mime/index#TypeByExtension",
        "syntax": "func TypeByExtension(ext string) string",
        "type": "mime"
    },
    "TypeOf": {
        "descr": "TypeOf returns the reflection Type that represents the dynamic type of i. If i is a nil interface value, TypeOf returns nil.",
        "name": "reflect.TypeOf",
        "params": [],
        "path": "go/reflect/index#TypeOf",
        "syntax": "func TypeOf(i interface{}) Type",
        "type": "reflect"
    },
    "UDPAddr": {
        "descr": "UDPAddr represents the address of a UDP end point.",
        "name": "net.UDPAddr",
        "params": [],
        "path": "go/net/index#UDPAddr",
        "syntax": "type UDPAddr struct { IP IP Port int Zone string // IPv6 scoped addressing zone; added in Go 1.1 }",
        "type": "net"
    },
    "UDPAddr.Network": {
        "descr": "Network returns the address's network name, \"udp\".",
        "name": "net.UDPAddr.Network",
        "params": [],
        "path": "go/net/index#UDPAddr.Network",
        "syntax": "func (a *UDPAddr) Network() string",
        "type": "net"
    },
    "UDPAddr.String": {
        "descr": "",
        "name": "net.UDPAddr.String",
        "params": [],
        "path": "go/net/index#UDPAddr.String",
        "syntax": "func (a *UDPAddr) String() string",
        "type": "net"
    },
    "UDPConn": {
        "descr": "UDPConn is the implementation of the Conn and PacketConn interfaces for UDP network connections.",
        "name": "net.UDPConn",
        "params": [],
        "path": "go/net/index#UDPConn",
        "syntax": "type UDPConn struct { // contains filtered or unexported fields }",
        "type": "net"
    },
    "UDPConn.Close": {
        "descr": "Close closes the connection.",
        "name": "net.UDPConn.Close",
        "params": [],
        "path": "go/net/index#UDPConn.Close",
        "syntax": "func (c *UDPConn) Close() error",
        "type": "net"
    },
    "UDPConn.File": {
        "descr": "File returns a copy of the underlying os.File It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.",
        "name": "net.UDPConn.File",
        "params": [],
        "path": "go/net/index#UDPConn.File",
        "syntax": "func (c *UDPConn) File() (f *os.File, err error)",
        "type": "net"
    },
    "UDPConn.LocalAddr": {
        "descr": "LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it.",
        "name": "net.UDPConn.LocalAddr",
        "params": [],
        "path": "go/net/index#UDPConn.LocalAddr",
        "syntax": "func (c *UDPConn) LocalAddr() Addr",
        "type": "net"
    },
    "UDPConn.Read": {
        "descr": "Read implements the Conn Read method.",
        "name": "net.UDPConn.Read",
        "params": [],
        "path": "go/net/index#UDPConn.Read",
        "syntax": "func (c *UDPConn) Read(b []byte) (int, error)",
        "type": "net"
    },
    "UDPConn.ReadFrom": {
        "descr": "ReadFrom implements the PacketConn ReadFrom method.",
        "name": "net.UDPConn.ReadFrom",
        "params": [],
        "path": "go/net/index#UDPConn.ReadFrom",
        "syntax": "func (c *UDPConn) ReadFrom(b []byte) (int, Addr, error)",
        "type": "net"
    },
    "UDPConn.ReadFromUDP": {
        "descr": "ReadFromUDP acts like ReadFrom but returns a UDPAddr.",
        "name": "net.UDPConn.ReadFromUDP",
        "params": [],
        "path": "go/net/index#UDPConn.ReadFromUDP",
        "syntax": "func (c *UDPConn) ReadFromUDP(b []byte) (int, *UDPAddr, error)",
        "type": "net"
    },
    "UDPConn.ReadMsgUDP": {
        "descr": "ReadMsgUDP reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message.",
        "name": "net.UDPConn.ReadMsgUDP",
        "params": [],
        "path": "go/net/index#UDPConn.ReadMsgUDP",
        "syntax": "func (c *UDPConn) ReadMsgUDP(b, oob []byte) (n, oobn, flags int, addr *UDPAddr, err error)",
        "type": "net"
    },
    "UDPConn.RemoteAddr": {
        "descr": "RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it.",
        "name": "net.UDPConn.RemoteAddr",
        "params": [],
        "path": "go/net/index#UDPConn.RemoteAddr",
        "syntax": "func (c *UDPConn) RemoteAddr() Addr",
        "type": "net"
    },
    "UDPConn.SetDeadline": {
        "descr": "SetDeadline implements the Conn SetDeadline method.",
        "name": "net.UDPConn.SetDeadline",
        "params": [],
        "path": "go/net/index#UDPConn.SetDeadline",
        "syntax": "func (c *UDPConn) SetDeadline(t time.Time) error",
        "type": "net"
    },
    "UDPConn.SetReadBuffer": {
        "descr": "SetReadBuffer sets the size of the operating system's receive buffer associated with the connection.",
        "name": "net.UDPConn.SetReadBuffer",
        "params": [],
        "path": "go/net/index#UDPConn.SetReadBuffer",
        "syntax": "func (c *UDPConn) SetReadBuffer(bytes int) error",
        "type": "net"
    },
    "UDPConn.SetReadDeadline": {
        "descr": "SetReadDeadline implements the Conn SetReadDeadline method.",
        "name": "net.UDPConn.SetReadDeadline",
        "params": [],
        "path": "go/net/index#UDPConn.SetReadDeadline",
        "syntax": "func (c *UDPConn) SetReadDeadline(t time.Time) error",
        "type": "net"
    },
    "UDPConn.SetWriteBuffer": {
        "descr": "SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection.",
        "name": "net.UDPConn.SetWriteBuffer",
        "params": [],
        "path": "go/net/index#UDPConn.SetWriteBuffer",
        "syntax": "func (c *UDPConn) SetWriteBuffer(bytes int) error",
        "type": "net"
    },
    "UDPConn.SetWriteDeadline": {
        "descr": "SetWriteDeadline implements the Conn SetWriteDeadline method.",
        "name": "net.UDPConn.SetWriteDeadline",
        "params": [],
        "path": "go/net/index#UDPConn.SetWriteDeadline",
        "syntax": "func (c *UDPConn) SetWriteDeadline(t time.Time) error",
        "type": "net"
    },
    "UDPConn.SyscallConn": {
        "descr": "SyscallConn returns a raw network connection. This implements the syscall.Conn interface.",
        "name": "net.UDPConn.SyscallConn",
        "params": [],
        "path": "go/net/index#UDPConn.SyscallConn",
        "syntax": "func (c *UDPConn) SyscallConn() (syscall.RawConn, error)",
        "type": "net"
    },
    "UDPConn.Write": {
        "descr": "Write implements the Conn Write method.",
        "name": "net.UDPConn.Write",
        "params": [],
        "path": "go/net/index#UDPConn.Write",
        "syntax": "func (c *UDPConn) Write(b []byte) (int, error)",
        "type": "net"
    },
    "UDPConn.WriteMsgUDP": {
        "descr": "WriteMsgUDP writes a message to addr via c if c isn't connected, or to c's remote address if c is connected (in which case addr must be nil). The payload is copied from b and the associated out-of-band data is copied from oob. It returns the number of payload and out-of-band bytes written.",
        "name": "net.UDPConn.WriteMsgUDP",
        "params": [],
        "path": "go/net/index#UDPConn.WriteMsgUDP",
        "syntax": "func (c *UDPConn) WriteMsgUDP(b, oob []byte, addr *UDPAddr) (n, oobn int, err error)",
        "type": "net"
    },
    "UDPConn.WriteTo": {
        "descr": "WriteTo implements the PacketConn WriteTo method.",
        "name": "net.UDPConn.WriteTo",
        "params": [],
        "path": "go/net/index#UDPConn.WriteTo",
        "syntax": "func (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error)",
        "type": "net"
    },
    "UDPConn.WriteToUDP": {
        "descr": "WriteToUDP acts like WriteTo but takes a UDPAddr.",
        "name": "net.UDPConn.WriteToUDP",
        "params": [],
        "path": "go/net/index#UDPConn.WriteToUDP",
        "syntax": "func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error)",
        "type": "net"
    },
    "Ucred": {
        "descr": "",
        "name": "syscall.Ucred",
        "params": [],
        "path": "go/syscall/index#Ucred",
        "syntax": "type Ucred struct { Pid int32 Uid uint32 Gid uint32 }",
        "type": "syscall"
    },
    "Uint": {
        "descr": "Uint defines a uint flag with specified name, default value, and usage string. The return value is the address of a uint variable that stores the value of the flag.",
        "name": "flag.Uint",
        "params": [],
        "path": "go/flag/index#Uint",
        "syntax": "func Uint(name string, value uint, usage string) *uint",
        "type": "flag"
    },
    "Uint64": {
        "descr": "Uint64 defines a uint64 flag with specified name, default value, and usage string. The return value is the address of a uint64 variable that stores the value of the flag.",
        "name": "flag.Uint64",
        "params": [],
        "path": "go/flag/index#Uint64",
        "syntax": "func Uint64(name string, value uint64, usage string) *uint64",
        "type": "flag"
    },
    "Uint64Var": {
        "descr": "Uint64Var defines a uint64 flag with specified name, default value, and usage string. The argument p points to a uint64 variable in which to store the value of the flag.",
        "name": "flag.Uint64Var",
        "params": [],
        "path": "go/flag/index#Uint64Var",
        "syntax": "func Uint64Var(p *uint64, name string, value uint64, usage string)",
        "type": "flag"
    },
    "UintVar": {
        "descr": "UintVar defines a uint flag with specified name, default value, and usage string. The argument p points to a uint variable in which to store the value of the flag.",
        "name": "flag.UintVar",
        "params": [],
        "path": "go/flag/index#UintVar",
        "syntax": "func UintVar(p *uint, name string, value uint, usage string)",
        "type": "flag"
    },
    "Umask": {
        "descr": "",
        "name": "syscall.Umask",
        "params": [],
        "path": "go/syscall/index#Umask",
        "syntax": "func Umask(mask int) (oldmask int)",
        "type": "syscall"
    },
    "Uname": {
        "descr": "",
        "name": "syscall.Uname",
        "params": [],
        "path": "go/syscall/index#Uname",
        "syntax": "func Uname(buf *Utsname) (err error)",
        "type": "syscall"
    },
    "UnescapeString": {
        "descr": "UnescapeString unescapes entities like \"&lt;\" to become \"<\". It unescapes a larger range of entities than EscapeString escapes. For example, \"&aacute;\" unescapes to \"\", as does \"&#225;\" and \"&#xE1;\". UnescapeString(EscapeString(s)) == s always holds, but the converse isn't always true.",
        "name": "html.UnescapeString",
        "params": [],
        "path": "go/html/index#UnescapeString",
        "syntax": "func UnescapeString(s string) string",
        "type": "html"
    },
    "Uniform": {
        "descr": "Uniform is an infinite-sized Image of uniform color. It implements the color.Color, color.Model, and Image interfaces.",
        "name": "image.Uniform",
        "params": [],
        "path": "go/image/index#Uniform",
        "syntax": "type Uniform struct { C color.Color }",
        "type": "image"
    },
    "Uniform.At": {
        "descr": "",
        "name": "image.Uniform.At",
        "params": [],
        "path": "go/image/index#Uniform.At",
        "syntax": "func (c *Uniform) At(x, y int) color.Color",
        "type": "image"
    },
    "Uniform.Bounds": {
        "descr": "",
        "name": "image.Uniform.Bounds",
        "params": [],
        "path": "go/image/index#Uniform.Bounds",
        "syntax": "func (c *Uniform) Bounds() Rectangle",
        "type": "image"
    },
    "Uniform.ColorModel": {
        "descr": "",
        "name": "image.Uniform.ColorModel",
        "params": [],
        "path": "go/image/index#Uniform.ColorModel",
        "syntax": "func (c *Uniform) ColorModel() color.Model",
        "type": "image"
    },
    "Uniform.Convert": {
        "descr": "",
        "name": "image.Uniform.Convert",
        "params": [],
        "path": "go/image/index#Uniform.Convert",
        "syntax": "func (c *Uniform) Convert(color.Color) color.Color",
        "type": "image"
    },
    "Uniform.Opaque": {
        "descr": "Opaque scans the entire image and reports whether it is fully opaque.",
        "name": "image.Uniform.Opaque",
        "params": [],
        "path": "go/image/index#Uniform.Opaque",
        "syntax": "func (c *Uniform) Opaque() bool",
        "type": "image"
    },
    "Uniform.RGBA": {
        "descr": "",
        "name": "image.Uniform.RGBA",
        "params": [],
        "path": "go/image/index#Uniform.RGBA",
        "syntax": "func (c *Uniform) RGBA() (r, g, b, a uint32)",
        "type": "image"
    },
    "Unix": {
        "descr": "Unix returns the local Time corresponding to the given Unix time, sec seconds and nsec nanoseconds since January 1, 1970 UTC. It is valid to pass nsec outside the range [0, 999999999]. Not all sec values have a corresponding time value. One such value is 1<<63-1 (the largest int64 value).",
        "name": "time.Unix",
        "params": [],
        "path": "go/time/index#Unix",
        "syntax": "func Unix(sec int64, nsec int64) Time",
        "type": "time"
    },
    "UnixAddr": {
        "descr": "UnixAddr represents the address of a Unix domain socket end point.",
        "name": "net.UnixAddr",
        "params": [],
        "path": "go/net/index#UnixAddr",
        "syntax": "type UnixAddr struct { Name string Net string }",
        "type": "net"
    },
    "UnixAddr.Network": {
        "descr": "Network returns the address's network name, \"unix\", \"unixgram\" or \"unixpacket\".",
        "name": "net.UnixAddr.Network",
        "params": [],
        "path": "go/net/index#UnixAddr.Network",
        "syntax": "func (a *UnixAddr) Network() string",
        "type": "net"
    },
    "UnixAddr.String": {
        "descr": "",
        "name": "net.UnixAddr.String",
        "params": [],
        "path": "go/net/index#UnixAddr.String",
        "syntax": "func (a *UnixAddr) String() string",
        "type": "net"
    },
    "UnixConn": {
        "descr": "UnixConn is an implementation of the Conn interface for connections to Unix domain sockets.",
        "name": "net.UnixConn",
        "params": [],
        "path": "go/net/index#UnixConn",
        "syntax": "type UnixConn struct { // contains filtered or unexported fields }",
        "type": "net"
    },
    "UnixConn.Close": {
        "descr": "Close closes the connection.",
        "name": "net.UnixConn.Close",
        "params": [],
        "path": "go/net/index#UnixConn.Close",
        "syntax": "func (c *UnixConn) Close() error",
        "type": "net"
    },
    "UnixConn.CloseRead": {
        "descr": "CloseRead shuts down the reading side of the Unix domain connection. Most callers should just use Close.",
        "name": "net.UnixConn.CloseRead",
        "params": [],
        "path": "go/net/index#UnixConn.CloseRead",
        "syntax": "func (c *UnixConn) CloseRead() error",
        "type": "net"
    },
    "UnixConn.CloseWrite": {
        "descr": "CloseWrite shuts down the writing side of the Unix domain connection. Most callers should just use Close.",
        "name": "net.UnixConn.CloseWrite",
        "params": [],
        "path": "go/net/index#UnixConn.CloseWrite",
        "syntax": "func (c *UnixConn) CloseWrite() error",
        "type": "net"
    },
    "UnixConn.File": {
        "descr": "File returns a copy of the underlying os.File It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.",
        "name": "net.UnixConn.File",
        "params": [],
        "path": "go/net/index#UnixConn.File",
        "syntax": "func (c *UnixConn) File() (f *os.File, err error)",
        "type": "net"
    },
    "UnixConn.LocalAddr": {
        "descr": "LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it.",
        "name": "net.UnixConn.LocalAddr",
        "params": [],
        "path": "go/net/index#UnixConn.LocalAddr",
        "syntax": "func (c *UnixConn) LocalAddr() Addr",
        "type": "net"
    },
    "UnixConn.Read": {
        "descr": "Read implements the Conn Read method.",
        "name": "net.UnixConn.Read",
        "params": [],
        "path": "go/net/index#UnixConn.Read",
        "syntax": "func (c *UnixConn) Read(b []byte) (int, error)",
        "type": "net"
    },
    "UnixConn.ReadFrom": {
        "descr": "ReadFrom implements the PacketConn ReadFrom method.",
        "name": "net.UnixConn.ReadFrom",
        "params": [],
        "path": "go/net/index#UnixConn.ReadFrom",
        "syntax": "func (c *UnixConn) ReadFrom(b []byte) (int, Addr, error)",
        "type": "net"
    },
    "UnixConn.ReadFromUnix": {
        "descr": "ReadFromUnix acts like ReadFrom but returns a UnixAddr.",
        "name": "net.UnixConn.ReadFromUnix",
        "params": [],
        "path": "go/net/index#UnixConn.ReadFromUnix",
        "syntax": "func (c *UnixConn) ReadFromUnix(b []byte) (int, *UnixAddr, error)",
        "type": "net"
    },
    "UnixConn.ReadMsgUnix": {
        "descr": "ReadMsgUnix reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message.",
        "name": "net.UnixConn.ReadMsgUnix",
        "params": [],
        "path": "go/net/index#UnixConn.ReadMsgUnix",
        "syntax": "func (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err error)",
        "type": "net"
    },
    "UnixConn.RemoteAddr": {
        "descr": "RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it.",
        "name": "net.UnixConn.RemoteAddr",
        "params": [],
        "path": "go/net/index#UnixConn.RemoteAddr",
        "syntax": "func (c *UnixConn) RemoteAddr() Addr",
        "type": "net"
    },
    "UnixConn.SetDeadline": {
        "descr": "SetDeadline implements the Conn SetDeadline method.",
        "name": "net.UnixConn.SetDeadline",
        "params": [],
        "path": "go/net/index#UnixConn.SetDeadline",
        "syntax": "func (c *UnixConn) SetDeadline(t time.Time) error",
        "type": "net"
    },
    "UnixConn.SetReadBuffer": {
        "descr": "SetReadBuffer sets the size of the operating system's receive buffer associated with the connection.",
        "name": "net.UnixConn.SetReadBuffer",
        "params": [],
        "path": "go/net/index#UnixConn.SetReadBuffer",
        "syntax": "func (c *UnixConn) SetReadBuffer(bytes int) error",
        "type": "net"
    },
    "UnixConn.SetReadDeadline": {
        "descr": "SetReadDeadline implements the Conn SetReadDeadline method.",
        "name": "net.UnixConn.SetReadDeadline",
        "params": [],
        "path": "go/net/index#UnixConn.SetReadDeadline",
        "syntax": "func (c *UnixConn) SetReadDeadline(t time.Time) error",
        "type": "net"
    },
    "UnixConn.SetWriteBuffer": {
        "descr": "SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection.",
        "name": "net.UnixConn.SetWriteBuffer",
        "params": [],
        "path": "go/net/index#UnixConn.SetWriteBuffer",
        "syntax": "func (c *UnixConn) SetWriteBuffer(bytes int) error",
        "type": "net"
    },
    "UnixConn.SetWriteDeadline": {
        "descr": "SetWriteDeadline implements the Conn SetWriteDeadline method.",
        "name": "net.UnixConn.SetWriteDeadline",
        "params": [],
        "path": "go/net/index#UnixConn.SetWriteDeadline",
        "syntax": "func (c *UnixConn) SetWriteDeadline(t time.Time) error",
        "type": "net"
    },
    "UnixConn.SyscallConn": {
        "descr": "SyscallConn returns a raw network connection. This implements the syscall.Conn interface.",
        "name": "net.UnixConn.SyscallConn",
        "params": [],
        "path": "go/net/index#UnixConn.SyscallConn",
        "syntax": "func (c *UnixConn) SyscallConn() (syscall.RawConn, error)",
        "type": "net"
    },
    "UnixConn.Write": {
        "descr": "Write implements the Conn Write method.",
        "name": "net.UnixConn.Write",
        "params": [],
        "path": "go/net/index#UnixConn.Write",
        "syntax": "func (c *UnixConn) Write(b []byte) (int, error)",
        "type": "net"
    },
    "UnixConn.WriteMsgUnix": {
        "descr": "WriteMsgUnix writes a message to addr via c, copying the payload from b and the associated out-of-band data from oob. It returns the number of payload and out-of-band bytes written.",
        "name": "net.UnixConn.WriteMsgUnix",
        "params": [],
        "path": "go/net/index#UnixConn.WriteMsgUnix",
        "syntax": "func (c *UnixConn) WriteMsgUnix(b, oob []byte, addr *UnixAddr) (n, oobn int, err error)",
        "type": "net"
    },
    "UnixConn.WriteTo": {
        "descr": "WriteTo implements the PacketConn WriteTo method.",
        "name": "net.UnixConn.WriteTo",
        "params": [],
        "path": "go/net/index#UnixConn.WriteTo",
        "syntax": "func (c *UnixConn) WriteTo(b []byte, addr Addr) (int, error)",
        "type": "net"
    },
    "UnixConn.WriteToUnix": {
        "descr": "WriteToUnix acts like WriteTo but takes a UnixAddr.",
        "name": "net.UnixConn.WriteToUnix",
        "params": [],
        "path": "go/net/index#UnixConn.WriteToUnix",
        "syntax": "func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (int, error)",
        "type": "net"
    },
    "UnixCredentials": {
        "descr": "UnixCredentials encodes credentials into a socket control message for sending to another process. This can be used for authentication.",
        "name": "syscall.UnixCredentials",
        "params": [],
        "path": "go/syscall/index#UnixCredentials",
        "syntax": "func UnixCredentials(ucred *Ucred) []byte",
        "type": "syscall"
    },
    "UnixListener": {
        "descr": "UnixListener is a Unix domain socket listener. Clients should typically use variables of type Listener instead of assuming Unix domain sockets.",
        "name": "net.UnixListener",
        "params": [],
        "path": "go/net/index#UnixListener",
        "syntax": "type UnixListener struct { // contains filtered or unexported fields }",
        "type": "net"
    },
    "UnixListener.Accept": {
        "descr": "Accept implements the Accept method in the Listener interface. Returned connections will be of type *UnixConn.",
        "name": "net.UnixListener.Accept",
        "params": [],
        "path": "go/net/index#UnixListener.Accept",
        "syntax": "func (l *UnixListener) Accept() (Conn, error)",
        "type": "net"
    },
    "UnixListener.AcceptUnix": {
        "descr": "AcceptUnix accepts the next incoming call and returns the new connection.",
        "name": "net.UnixListener.AcceptUnix",
        "params": [],
        "path": "go/net/index#UnixListener.AcceptUnix",
        "syntax": "func (l *UnixListener) AcceptUnix() (*UnixConn, error)",
        "type": "net"
    },
    "UnixListener.Addr": {
        "descr": "Addr returns the listener's network address. The Addr returned is shared by all invocations of Addr, so do not modify it.",
        "name": "net.UnixListener.Addr",
        "params": [],
        "path": "go/net/index#UnixListener.Addr",
        "syntax": "func (l *UnixListener) Addr() Addr",
        "type": "net"
    },
    "UnixListener.Close": {
        "descr": "Close stops listening on the Unix address. Already accepted connections are not closed.",
        "name": "net.UnixListener.Close",
        "params": [],
        "path": "go/net/index#UnixListener.Close",
        "syntax": "func (l *UnixListener) Close() error",
        "type": "net"
    },
    "UnixListener.File": {
        "descr": "File returns a copy of the underlying os.File. It is the caller's responsibility to close f when finished. Closing l does not affect f, and closing f does not affect l.",
        "name": "net.UnixListener.File",
        "params": [],
        "path": "go/net/index#UnixListener.File",
        "syntax": "func (l *UnixListener) File() (f *os.File, err error)",
        "type": "net"
    },
    "UnixListener.SetDeadline": {
        "descr": "SetDeadline sets the deadline associated with the listener. A zero time value disables the deadline.",
        "name": "net.UnixListener.SetDeadline",
        "params": [],
        "path": "go/net/index#UnixListener.SetDeadline",
        "syntax": "func (l *UnixListener) SetDeadline(t time.Time) error",
        "type": "net"
    },
    "UnixListener.SetUnlinkOnClose": {
        "descr": "SetUnlinkOnClose sets whether the underlying socket file should be removed from the file system when the listener is closed.",
        "name": "net.UnixListener.SetUnlinkOnClose",
        "params": [],
        "path": "go/net/index#UnixListener.SetUnlinkOnClose",
        "syntax": "func (l *UnixListener) SetUnlinkOnClose(unlink bool)",
        "type": "net"
    },
    "UnixListener.SyscallConn": {
        "descr": "SyscallConn returns a raw network connection. This implements the syscall.Conn interface.",
        "name": "net.UnixListener.SyscallConn",
        "params": [],
        "path": "go/net/index#UnixListener.SyscallConn",
        "syntax": "func (l *UnixListener) SyscallConn() (syscall.RawConn, error)",
        "type": "net"
    },
    "UnixRights": {
        "descr": "UnixRights encodes a set of open file descriptors into a socket control message for sending to another process.",
        "name": "syscall.UnixRights",
        "params": [],
        "path": "go/syscall/index#UnixRights",
        "syntax": "func UnixRights(fds ...int) []byte",
        "type": "syscall"
    },
    "UnknownNetworkError": {
        "descr": "",
        "name": "net.UnknownNetworkError",
        "params": [],
        "path": "go/net/index#UnknownNetworkError",
        "syntax": "type UnknownNetworkError string",
        "type": "net"
    },
    "UnknownNetworkError.Error": {
        "descr": "",
        "name": "net.UnknownNetworkError.Error",
        "params": [],
        "path": "go/net/index#UnknownNetworkError.Error",
        "syntax": "func (e UnknownNetworkError) Error() string",
        "type": "net"
    },
    "UnknownNetworkError.Temporary": {
        "descr": "",
        "name": "net.UnknownNetworkError.Temporary",
        "params": [],
        "path": "go/net/index#UnknownNetworkError.Temporary",
        "syntax": "func (e UnknownNetworkError) Temporary() bool",
        "type": "net"
    },
    "UnknownNetworkError.Timeout": {
        "descr": "",
        "name": "net.UnknownNetworkError.Timeout",
        "params": [],
        "path": "go/net/index#UnknownNetworkError.Timeout",
        "syntax": "func (e UnknownNetworkError) Timeout() bool",
        "type": "net"
    },
    "Unlink": {
        "descr": "",
        "name": "syscall.Unlink",
        "params": [],
        "path": "go/syscall/index#Unlink",
        "syntax": "func Unlink(path string) error",
        "type": "syscall"
    },
    "Unlinkat": {
        "descr": "",
        "name": "syscall.Unlinkat",
        "params": [],
        "path": "go/syscall/index#Unlinkat",
        "syntax": "func Unlinkat(dirfd int, path string) error",
        "type": "syscall"
    },
    "UnlockOSThread": {
        "descr": "UnlockOSThread undoes an earlier call to LockOSThread. If this drops the number of active LockOSThread calls on the calling goroutine to zero, it unwires the calling goroutine from its fixed operating system thread. If there are no active LockOSThread calls, this is a no-op.",
        "name": "runtime.UnlockOSThread",
        "params": [],
        "path": "go/runtime/index#UnlockOSThread",
        "syntax": "func UnlockOSThread()",
        "type": "runtime"
    },
    "Unmount": {
        "descr": "",
        "name": "syscall.Unmount",
        "params": [],
        "path": "go/syscall/index#Unmount",
        "syntax": "func Unmount(target string, flags int) (err error)",
        "type": "syscall"
    },
    "Unquote": {
        "descr": "Unquote interprets s as a single-quoted, double-quoted, or backquoted Go string literal, returning the string value that s quotes. (If s is single-quoted, it would be a Go character literal; Unquote returns the corresponding one-character string.)",
        "name": "strconv.Unquote",
        "params": [],
        "path": "go/strconv/index#Unquote",
        "syntax": "func Unquote(s string) (string, error)",
        "type": "strconv"
    },
    "UnquoteChar": {
        "descr": "UnquoteChar decodes the first character or byte in the escaped string or character literal represented by the string s. It returns four values:",
        "name": "strconv.UnquoteChar",
        "params": [],
        "path": "go/strconv/index#UnquoteChar",
        "syntax": "func UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string, err error)",
        "type": "strconv"
    },
    "UnquoteUsage": {
        "descr": "UnquoteUsage extracts a back-quoted name from the usage string for a flag and returns it and the un-quoted usage. Given \"a `name` to show\" it returns (\"name\", \"a name to show\"). If there are no back quotes, the name is an educated guess of the type of the flag's value, or the empty string if the flag is boolean.",
        "name": "flag.UnquoteUsage",
        "params": [],
        "path": "go/flag/index#UnquoteUsage",
        "syntax": "func UnquoteUsage(flag *Flag) (name string, usage string)",
        "type": "flag"
    },
    "Unsetenv": {
        "descr": "",
        "name": "syscall.Unsetenv",
        "params": [],
        "path": "go/syscall/index#Unsetenv",
        "syntax": "func Unsetenv(key string) error",
        "type": "syscall"
    },
    "Unshare": {
        "descr": "",
        "name": "syscall.Unshare",
        "params": [],
        "path": "go/syscall/index#Unshare",
        "syntax": "func Unshare(flags int) (err error)",
        "type": "syscall"
    },
    "Until": {
        "descr": "Until returns the duration until t. It is shorthand for t.Sub(time.Now()).",
        "name": "time.Until",
        "params": [],
        "path": "go/time/index#Until",
        "syntax": "func Until(t Time) Duration",
        "type": "time"
    },
    "UserCacheDir": {
        "descr": "UserCacheDir returns the default root directory to use for user-specific cached data. Users should create their own application-specific subdirectory within this one and use that.",
        "name": "os.UserCacheDir",
        "params": [],
        "path": "go/os/index#UserCacheDir",
        "syntax": "func UserCacheDir() (string, error)",
        "type": "os"
    },
    "Ustat": {
        "descr": "",
        "name": "syscall.Ustat",
        "params": [],
        "path": "go/syscall/index#Ustat",
        "syntax": "func Ustat(dev int, ubuf *Ustat_t) (err error)",
        "type": "syscall"
    },
    "Ustat_t": {
        "descr": "",
        "name": "syscall.Ustat_t",
        "params": [],
        "path": "go/syscall/index#Ustat_t",
        "syntax": "type Ustat_t struct { Tfree int32 Pad_cgo_0 [4]byte Tinode uint64 Fname [6]int8 Fpack [6]int8 Pad_cgo_1 [4]byte }",
        "type": "syscall"
    },
    "Utimbuf": {
        "descr": "",
        "name": "syscall.Utimbuf",
        "params": [],
        "path": "go/syscall/index#Utimbuf",
        "syntax": "type Utimbuf struct { Actime int64 Modtime int64 }",
        "type": "syscall"
    },
    "Utime": {
        "descr": "",
        "name": "syscall.Utime",
        "params": [],
        "path": "go/syscall/index#Utime",
        "syntax": "func Utime(path string, buf *Utimbuf) (err error)",
        "type": "syscall"
    },
    "Utimes": {
        "descr": "",
        "name": "syscall.Utimes",
        "params": [],
        "path": "go/syscall/index#Utimes",
        "syntax": "func Utimes(path string, tv []Timeval) (err error)",
        "type": "syscall"
    },
    "UtimesNano": {
        "descr": "",
        "name": "syscall.UtimesNano",
        "params": [],
        "path": "go/syscall/index#UtimesNano",
        "syntax": "func UtimesNano(path string, ts []Timespec) (err error)",
        "type": "syscall"
    },
    "Utsname": {
        "descr": "",
        "name": "syscall.Utsname",
        "params": [],
        "path": "go/syscall/index#Utsname",
        "syntax": "type Utsname struct { Sysname [65]int8 Nodename [65]int8 Release [65]int8 Version [65]int8 Machine [65]int8 Domainname [65]int8 }",
        "type": "syscall"
    },
    "Value": {
        "descr": "Value is the reflection interface to a Go value.",
        "name": "reflect.Value",
        "params": [],
        "path": "go/reflect/index#Value",
        "syntax": "type Value struct { // contains filtered or unexported fields }",
        "type": "reflect"
    },
    "Value.Addr": {
        "descr": "Addr returns a pointer value representing the address of v. It panics if CanAddr() returns false. Addr is typically used to obtain a pointer to a struct field or slice element in order to call a method that requires a pointer receiver.",
        "name": "reflect.Value.Addr",
        "params": [],
        "path": "go/reflect/index#Value.Addr",
        "syntax": "func (v Value) Addr() Value",
        "type": "reflect"
    },
    "Value.Bool": {
        "descr": "Bool returns v's underlying value. It panics if v's kind is not Bool.",
        "name": "reflect.Value.Bool",
        "params": [],
        "path": "go/reflect/index#Value.Bool",
        "syntax": "func (v Value) Bool() bool",
        "type": "reflect"
    },
    "Value.Bytes": {
        "descr": "Bytes returns v's underlying value. It panics if v's underlying value is not a slice of bytes.",
        "name": "reflect.Value.Bytes",
        "params": [],
        "path": "go/reflect/index#Value.Bytes",
        "syntax": "func (v Value) Bytes() []byte",
        "type": "reflect"
    },
    "Value.Call": {
        "descr": "Call calls the function v with the input arguments in. For example, if len(in) == 3, v.Call(in) represents the Go call v(in[0], in[1], in[2]). Call panics if v's Kind is not Func. It returns the output results as Values. As in Go, each input argument must be assignable to the type of the function's corresponding input parameter. If v is a variadic function, Call creates the variadic slice parameter itself, copying in the corresponding values.",
        "name": "reflect.Value.Call",
        "params": [],
        "path": "go/reflect/index#Value.Call",
        "syntax": "func (v Value) Call(in []Value) []Value",
        "type": "reflect"
    },
    "Value.CallSlice": {
        "descr": "CallSlice calls the variadic function v with the input arguments in, assigning the slice in[len(in)-1] to v's final variadic argument. For example, if len(in) == 3, v.CallSlice(in) represents the Go call v(in[0], in[1], in[2]...). CallSlice panics if v's Kind is not Func or if v is not variadic. It returns the output results as Values. As in Go, each input argument must be assignable to the type of the function's corresponding input parameter.",
        "name": "reflect.Value.CallSlice",
        "params": [],
        "path": "go/reflect/index#Value.CallSlice",
        "syntax": "func (v Value) CallSlice(in []Value) []Value",
        "type": "reflect"
    },
    "Value.CanAddr": {
        "descr": "CanAddr reports whether the value's address can be obtained with Addr. Such values are called addressable. A value is addressable if it is an element of a slice, an element of an addressable array, a field of an addressable struct, or the result of dereferencing a pointer. If CanAddr returns false, calling Addr will panic.",
        "name": "reflect.Value.CanAddr",
        "params": [],
        "path": "go/reflect/index#Value.CanAddr",
        "syntax": "func (v Value) CanAddr() bool",
        "type": "reflect"
    },
    "Value.CanInterface": {
        "descr": "CanInterface reports whether Interface can be used without panicking.",
        "name": "reflect.Value.CanInterface",
        "params": [],
        "path": "go/reflect/index#Value.CanInterface",
        "syntax": "func (v Value) CanInterface() bool",
        "type": "reflect"
    },
    "Value.CanSet": {
        "descr": "CanSet reports whether the value of v can be changed. A Value can be changed only if it is addressable and was not obtained by the use of unexported struct fields. If CanSet returns false, calling Set or any type-specific setter (e.g., SetBool, SetInt) will panic.",
        "name": "reflect.Value.CanSet",
        "params": [],
        "path": "go/reflect/index#Value.CanSet",
        "syntax": "func (v Value) CanSet() bool",
        "type": "reflect"
    },
    "Value.Cap": {
        "descr": "Cap returns v's capacity. It panics if v's Kind is not Array, Chan, or Slice.",
        "name": "reflect.Value.Cap",
        "params": [],
        "path": "go/reflect/index#Value.Cap",
        "syntax": "func (v Value) Cap() int",
        "type": "reflect"
    },
    "Value.Close": {
        "descr": "Close closes the channel v. It panics if v's Kind is not Chan.",
        "name": "reflect.Value.Close",
        "params": [],
        "path": "go/reflect/index#Value.Close",
        "syntax": "func (v Value) Close()",
        "type": "reflect"
    },
    "Value.Complex": {
        "descr": "Complex returns v's underlying value, as a complex128. It panics if v's Kind is not Complex64 or Complex128",
        "name": "reflect.Value.Complex",
        "params": [],
        "path": "go/reflect/index#Value.Complex",
        "syntax": "func (v Value) Complex() complex128",
        "type": "reflect"
    },
    "Value.Convert": {
        "descr": "Convert returns the value v converted to type t. If the usual Go conversion rules do not allow conversion of the value v to type t, Convert panics.",
        "name": "reflect.Value.Convert",
        "params": [],
        "path": "go/reflect/index#Value.Convert",
        "syntax": "func (v Value) Convert(t Type) Value",
        "type": "reflect"
    },
    "Value.Elem": {
        "descr": "Elem returns the value that the interface v contains or that the pointer v points to. It panics if v's Kind is not Interface or Ptr. It returns the zero Value if v is nil.",
        "name": "reflect.Value.Elem",
        "params": [],
        "path": "go/reflect/index#Value.Elem",
        "syntax": "func (v Value) Elem() Value",
        "type": "reflect"
    },
    "Value.Field": {
        "descr": "Field returns the i'th field of the struct v. It panics if v's Kind is not Struct or i is out of range.",
        "name": "reflect.Value.Field",
        "params": [],
        "path": "go/reflect/index#Value.Field",
        "syntax": "func (v Value) Field(i int) Value",
        "type": "reflect"
    },
    "Value.FieldByIndex": {
        "descr": "FieldByIndex returns the nested field corresponding to index. It panics if v's Kind is not struct.",
        "name": "reflect.Value.FieldByIndex",
        "params": [],
        "path": "go/reflect/index#Value.FieldByIndex",
        "syntax": "func (v Value) FieldByIndex(index []int) Value",
        "type": "reflect"
    },
    "Value.FieldByName": {
        "descr": "FieldByName returns the struct field with the given name. It returns the zero Value if no field was found. It panics if v's Kind is not struct.",
        "name": "reflect.Value.FieldByName",
        "params": [],
        "path": "go/reflect/index#Value.FieldByName",
        "syntax": "func (v Value) FieldByName(name string) Value",
        "type": "reflect"
    },
    "Value.FieldByNameFunc": {
        "descr": "FieldByNameFunc returns the struct field with a name that satisfies the match function. It panics if v's Kind is not struct. It returns the zero Value if no field was found.",
        "name": "reflect.Value.FieldByNameFunc",
        "params": [],
        "path": "go/reflect/index#Value.FieldByNameFunc",
        "syntax": "func (v Value) FieldByNameFunc(match func(string) bool) Value",
        "type": "reflect"
    },
    "Value.Float": {
        "descr": "Float returns v's underlying value, as a float64. It panics if v's Kind is not Float32 or Float64",
        "name": "reflect.Value.Float",
        "params": [],
        "path": "go/reflect/index#Value.Float",
        "syntax": "func (v Value) Float() float64",
        "type": "reflect"
    },
    "Value.Index": {
        "descr": "Index returns v's i'th element. It panics if v's Kind is not Array, Slice, or String or i is out of range.",
        "name": "reflect.Value.Index",
        "params": [],
        "path": "go/reflect/index#Value.Index",
        "syntax": "func (v Value) Index(i int) Value",
        "type": "reflect"
    },
    "Value.Int": {
        "descr": "Int returns v's underlying value, as an int64. It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64.",
        "name": "reflect.Value.Int",
        "params": [],
        "path": "go/reflect/index#Value.Int",
        "syntax": "func (v Value) Int() int64",
        "type": "reflect"
    },
    "Value.Interface": {
        "descr": "Interface returns v's current value as an interface{}. It is equivalent to:",
        "name": "reflect.Value.Interface",
        "params": [],
        "path": "go/reflect/index#Value.Interface",
        "syntax": "func (v Value) Interface() (i interface{})",
        "type": "reflect"
    },
    "Value.InterfaceData": {
        "descr": "InterfaceData returns the interface v's value as a uintptr pair. It panics if v's Kind is not Interface.",
        "name": "reflect.Value.InterfaceData",
        "params": [],
        "path": "go/reflect/index#Value.InterfaceData",
        "syntax": "func (v Value) InterfaceData() [2]uintptr",
        "type": "reflect"
    },
    "Value.IsNil": {
        "descr": "IsNil reports whether its argument v is nil. The argument must be a chan, func, interface, map, pointer, or slice value; if it is not, IsNil panics. Note that IsNil is not always equivalent to a regular comparison with nil in Go. For example, if v was created by calling ValueOf with an uninitialized interface variable i, i==nil will be true but v.IsNil will panic as v will be the zero Value.",
        "name": "reflect.Value.IsNil",
        "params": [],
        "path": "go/reflect/index#Value.IsNil",
        "syntax": "func (v Value) IsNil() bool",
        "type": "reflect"
    },
    "Value.IsValid": {
        "descr": "IsValid reports whether v represents a value. It returns false if v is the zero Value. If IsValid returns false, all other methods except String panic. Most functions and methods never return an invalid value. If one does, its documentation states the conditions explicitly.",
        "name": "reflect.Value.IsValid",
        "params": [],
        "path": "go/reflect/index#Value.IsValid",
        "syntax": "func (v Value) IsValid() bool",
        "type": "reflect"
    },
    "Value.Kind": {
        "descr": "Kind returns v's Kind. If v is the zero Value (IsValid returns false), Kind returns Invalid.",
        "name": "reflect.Value.Kind",
        "params": [],
        "path": "go/reflect/index#Value.Kind",
        "syntax": "func (v Value) Kind() Kind",
        "type": "reflect"
    },
    "Value.Len": {
        "descr": "Len returns v's length. It panics if v's Kind is not Array, Chan, Map, Slice, or String.",
        "name": "reflect.Value.Len",
        "params": [],
        "path": "go/reflect/index#Value.Len",
        "syntax": "func (v Value) Len() int",
        "type": "reflect"
    },
    "Value.MapIndex": {
        "descr": "MapIndex returns the value associated with key in the map v. It panics if v's Kind is not Map. It returns the zero Value if key is not found in the map or if v represents a nil map. As in Go, the key's value must be assignable to the map's key type.",
        "name": "reflect.Value.MapIndex",
        "params": [],
        "path": "go/reflect/index#Value.MapIndex",
        "syntax": "func (v Value) MapIndex(key Value) Value",
        "type": "reflect"
    },
    "Value.MapKeys": {
        "descr": "MapKeys returns a slice containing all the keys present in the map, in unspecified order. It panics if v's Kind is not Map. It returns an empty slice if v represents a nil map.",
        "name": "reflect.Value.MapKeys",
        "params": [],
        "path": "go/reflect/index#Value.MapKeys",
        "syntax": "func (v Value) MapKeys() []Value",
        "type": "reflect"
    },
    "Value.Method": {
        "descr": "Method returns a function value corresponding to v's i'th method. The arguments to a Call on the returned function should not include a receiver; the returned function will always use v as the receiver. Method panics if i is out of range or if v is a nil interface value.",
        "name": "reflect.Value.Method",
        "params": [],
        "path": "go/reflect/index#Value.Method",
        "syntax": "func (v Value) Method(i int) Value",
        "type": "reflect"
    },
    "Value.MethodByName": {
        "descr": "MethodByName returns a function value corresponding to the method of v with the given name. The arguments to a Call on the returned function should not include a receiver; the returned function will always use v as the receiver. It returns the zero Value if no method was found.",
        "name": "reflect.Value.MethodByName",
        "params": [],
        "path": "go/reflect/index#Value.MethodByName",
        "syntax": "func (v Value) MethodByName(name string) Value",
        "type": "reflect"
    },
    "Value.NumField": {
        "descr": "NumField returns the number of fields in the struct v. It panics if v's Kind is not Struct.",
        "name": "reflect.Value.NumField",
        "params": [],
        "path": "go/reflect/index#Value.NumField",
        "syntax": "func (v Value) NumField() int",
        "type": "reflect"
    },
    "Value.NumMethod": {
        "descr": "NumMethod returns the number of exported methods in the value's method set.",
        "name": "reflect.Value.NumMethod",
        "params": [],
        "path": "go/reflect/index#Value.NumMethod",
        "syntax": "func (v Value) NumMethod() int",
        "type": "reflect"
    },
    "Value.OverflowComplex": {
        "descr": "OverflowComplex reports whether the complex128 x cannot be represented by v's type. It panics if v's Kind is not Complex64 or Complex128.",
        "name": "reflect.Value.OverflowComplex",
        "params": [],
        "path": "go/reflect/index#Value.OverflowComplex",
        "syntax": "func (v Value) OverflowComplex(x complex128) bool",
        "type": "reflect"
    },
    "Value.OverflowFloat": {
        "descr": "OverflowFloat reports whether the float64 x cannot be represented by v's type. It panics if v's Kind is not Float32 or Float64.",
        "name": "reflect.Value.OverflowFloat",
        "params": [],
        "path": "go/reflect/index#Value.OverflowFloat",
        "syntax": "func (v Value) OverflowFloat(x float64) bool",
        "type": "reflect"
    },
    "Value.OverflowInt": {
        "descr": "OverflowInt reports whether the int64 x cannot be represented by v's type. It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64.",
        "name": "reflect.Value.OverflowInt",
        "params": [],
        "path": "go/reflect/index#Value.OverflowInt",
        "syntax": "func (v Value) OverflowInt(x int64) bool",
        "type": "reflect"
    },
    "Value.OverflowUint": {
        "descr": "OverflowUint reports whether the uint64 x cannot be represented by v's type. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.",
        "name": "reflect.Value.OverflowUint",
        "params": [],
        "path": "go/reflect/index#Value.OverflowUint",
        "syntax": "func (v Value) OverflowUint(x uint64) bool",
        "type": "reflect"
    },
    "Value.Pointer": {
        "descr": "Pointer returns v's value as a uintptr. It returns uintptr instead of unsafe.Pointer so that code using reflect cannot obtain unsafe.Pointers without importing the unsafe package explicitly. It panics if v's Kind is not Chan, Func, Map, Ptr, Slice, or UnsafePointer.",
        "name": "reflect.Value.Pointer",
        "params": [],
        "path": "go/reflect/index#Value.Pointer",
        "syntax": "func (v Value) Pointer() uintptr",
        "type": "reflect"
    },
    "Value.Recv": {
        "descr": "Recv receives and returns a value from the channel v. It panics if v's Kind is not Chan. The receive blocks until a value is ready. The boolean value ok is true if the value x corresponds to a send on the channel, false if it is a zero value received because the channel is closed.",
        "name": "reflect.Value.Recv",
        "params": [],
        "path": "go/reflect/index#Value.Recv",
        "syntax": "func (v Value) Recv() (x Value, ok bool)",
        "type": "reflect"
    },
    "Value.Send": {
        "descr": "Send sends x on the channel v. It panics if v's kind is not Chan or if x's type is not the same type as v's element type. As in Go, x's value must be assignable to the channel's element type.",
        "name": "reflect.Value.Send",
        "params": [],
        "path": "go/reflect/index#Value.Send",
        "syntax": "func (v Value) Send(x Value)",
        "type": "reflect"
    },
    "Value.Set": {
        "descr": "Set assigns x to the value v. It panics if CanSet returns false. As in Go, x's value must be assignable to v's type.",
        "name": "reflect.Value.Set",
        "params": [],
        "path": "go/reflect/index#Value.Set",
        "syntax": "func (v Value) Set(x Value)",
        "type": "reflect"
    },
    "Value.SetBool": {
        "descr": "SetBool sets v's underlying value. It panics if v's Kind is not Bool or if CanSet() is false.",
        "name": "reflect.Value.SetBool",
        "params": [],
        "path": "go/reflect/index#Value.SetBool",
        "syntax": "func (v Value) SetBool(x bool)",
        "type": "reflect"
    },
    "Value.SetBytes": {
        "descr": "SetBytes sets v's underlying value. It panics if v's underlying value is not a slice of bytes.",
        "name": "reflect.Value.SetBytes",
        "params": [],
        "path": "go/reflect/index#Value.SetBytes",
        "syntax": "func (v Value) SetBytes(x []byte)",
        "type": "reflect"
    },
    "Value.SetCap": {
        "descr": "SetCap sets v's capacity to n. It panics if v's Kind is not Slice or if n is smaller than the length or greater than the capacity of the slice.",
        "name": "reflect.Value.SetCap",
        "params": [],
        "path": "go/reflect/index#Value.SetCap",
        "syntax": "func (v Value) SetCap(n int)",
        "type": "reflect"
    },
    "Value.SetComplex": {
        "descr": "SetComplex sets v's underlying value to x. It panics if v's Kind is not Complex64 or Complex128, or if CanSet() is false.",
        "name": "reflect.Value.SetComplex",
        "params": [],
        "path": "go/reflect/index#Value.SetComplex",
        "syntax": "func (v Value) SetComplex(x complex128)",
        "type": "reflect"
    },
    "Value.SetFloat": {
        "descr": "SetFloat sets v's underlying value to x. It panics if v's Kind is not Float32 or Float64, or if CanSet() is false.",
        "name": "reflect.Value.SetFloat",
        "params": [],
        "path": "go/reflect/index#Value.SetFloat",
        "syntax": "func (v Value) SetFloat(x float64)",
        "type": "reflect"
    },
    "Value.SetInt": {
        "descr": "SetInt sets v's underlying value to x. It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64, or if CanSet() is false.",
        "name": "reflect.Value.SetInt",
        "params": [],
        "path": "go/reflect/index#Value.SetInt",
        "syntax": "func (v Value) SetInt(x int64)",
        "type": "reflect"
    },
    "Value.SetLen": {
        "descr": "SetLen sets v's length to n. It panics if v's Kind is not Slice or if n is negative or greater than the capacity of the slice.",
        "name": "reflect.Value.SetLen",
        "params": [],
        "path": "go/reflect/index#Value.SetLen",
        "syntax": "func (v Value) SetLen(n int)",
        "type": "reflect"
    },
    "Value.SetMapIndex": {
        "descr": "SetMapIndex sets the value associated with key in the map v to val. It panics if v's Kind is not Map. If val is the zero Value, SetMapIndex deletes the key from the map. Otherwise if v holds a nil map, SetMapIndex will panic. As in Go, key's value must be assignable to the map's key type, and val's value must be assignable to the map's value type.",
        "name": "reflect.Value.SetMapIndex",
        "params": [],
        "path": "go/reflect/index#Value.SetMapIndex",
        "syntax": "func (v Value) SetMapIndex(key, val Value)",
        "type": "reflect"
    },
    "Value.SetPointer": {
        "descr": "SetPointer sets the unsafe.Pointer value v to x. It panics if v's Kind is not UnsafePointer.",
        "name": "reflect.Value.SetPointer",
        "params": [],
        "path": "go/reflect/index#Value.SetPointer",
        "syntax": "func (v Value) SetPointer(x unsafe.Pointer)",
        "type": "reflect"
    },
    "Value.SetString": {
        "descr": "SetString sets v's underlying value to x. It panics if v's Kind is not String or if CanSet() is false.",
        "name": "reflect.Value.SetString",
        "params": [],
        "path": "go/reflect/index#Value.SetString",
        "syntax": "func (v Value) SetString(x string)",
        "type": "reflect"
    },
    "Value.SetUint": {
        "descr": "SetUint sets v's underlying value to x. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64, or if CanSet() is false.",
        "name": "reflect.Value.SetUint",
        "params": [],
        "path": "go/reflect/index#Value.SetUint",
        "syntax": "func (v Value) SetUint(x uint64)",
        "type": "reflect"
    },
    "Value.Slice": {
        "descr": "Slice returns v[i:j]. It panics if v's Kind is not Array, Slice or String, or if v is an unaddressable array, or if the indexes are out of bounds.",
        "name": "reflect.Value.Slice",
        "params": [],
        "path": "go/reflect/index#Value.Slice",
        "syntax": "func (v Value) Slice(i, j int) Value",
        "type": "reflect"
    },
    "Value.Slice3": {
        "descr": "Slice3 is the 3-index form of the slice operation: it returns v[i:j:k]. It panics if v's Kind is not Array or Slice, or if v is an unaddressable array, or if the indexes are out of bounds.",
        "name": "reflect.Value.Slice3",
        "params": [],
        "path": "go/reflect/index#Value.Slice3",
        "syntax": "func (v Value) Slice3(i, j, k int) Value",
        "type": "reflect"
    },
    "Value.String": {
        "descr": "String returns the string v's underlying value, as a string. String is a special case because of Go's String method convention. Unlike the other getters, it does not panic if v's Kind is not String. Instead, it returns a string of the form \"<T value>\" where T is v's type. The fmt package treats Values specially. It does not call their String method implicitly but instead prints the concrete values they hold.",
        "name": "reflect.Value.String",
        "params": [],
        "path": "go/reflect/index#Value.String",
        "syntax": "func (v Value) String() string",
        "type": "reflect"
    },
    "Value.TryRecv": {
        "descr": "TryRecv attempts to receive a value from the channel v but will not block. It panics if v's Kind is not Chan. If the receive delivers a value, x is the transferred value and ok is true. If the receive cannot finish without blocking, x is the zero Value and ok is false. If the channel is closed, x is the zero value for the channel's element type and ok is false.",
        "name": "reflect.Value.TryRecv",
        "params": [],
        "path": "go/reflect/index#Value.TryRecv",
        "syntax": "func (v Value) TryRecv() (x Value, ok bool)",
        "type": "reflect"
    },
    "Value.TrySend": {
        "descr": "TrySend attempts to send x on the channel v but will not block. It panics if v's Kind is not Chan. It reports whether the value was sent. As in Go, x's value must be assignable to the channel's element type.",
        "name": "reflect.Value.TrySend",
        "params": [],
        "path": "go/reflect/index#Value.TrySend",
        "syntax": "func (v Value) TrySend(x Value) bool",
        "type": "reflect"
    },
    "Value.Type": {
        "descr": "Type returns v's type.",
        "name": "reflect.Value.Type",
        "params": [],
        "path": "go/reflect/index#Value.Type",
        "syntax": "func (v Value) Type() Type",
        "type": "reflect"
    },
    "Value.Uint": {
        "descr": "Uint returns v's underlying value, as a uint64. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.",
        "name": "reflect.Value.Uint",
        "params": [],
        "path": "go/reflect/index#Value.Uint",
        "syntax": "func (v Value) Uint() uint64",
        "type": "reflect"
    },
    "Value.UnsafeAddr": {
        "descr": "UnsafeAddr returns a pointer to v's data. It is for advanced clients that also import the \"unsafe\" package. It panics if v is not addressable.",
        "name": "reflect.Value.UnsafeAddr",
        "params": [],
        "path": "go/reflect/index#Value.UnsafeAddr",
        "syntax": "func (v Value) UnsafeAddr() uintptr",
        "type": "reflect"
    },
    "ValueError": {
        "descr": "A ValueError occurs when a Value method is invoked on a Value that does not support it. Such cases are documented in the description of each method.",
        "name": "reflect.ValueError",
        "params": [],
        "path": "go/reflect/index#ValueError",
        "syntax": "type ValueError struct { Method string Kind Kind }",
        "type": "reflect"
    },
    "ValueError.Error": {
        "descr": "",
        "name": "reflect.ValueError.Error",
        "params": [],
        "path": "go/reflect/index#ValueError.Error",
        "syntax": "func (e *ValueError) Error() string",
        "type": "reflect"
    },
    "ValueOf": {
        "descr": "ValueOf returns a new Value initialized to the concrete value stored in the interface i. ValueOf(nil) returns the zero Value.",
        "name": "reflect.ValueOf",
        "params": [],
        "path": "go/reflect/index#ValueOf",
        "syntax": "func ValueOf(i interface{}) Value",
        "type": "reflect"
    },
    "Var": {
        "descr": "Var defines a flag with the specified name and usage string. The type and value of the flag are represented by the first argument, of type Value, which typically holds a user-defined implementation of Value. For instance, the caller could create a flag that turns a comma-separated string into a slice of strings by giving the slice the methods of Value; in particular, Set would decompose the comma-separated string into the slice.",
        "name": "flag.Var",
        "params": [],
        "path": "go/flag/index#Var",
        "syntax": "func Var(value Value, name string, usage string)",
        "type": "flag"
    },
    "Verbose": {
        "descr": "Verbose reports whether the -test.v flag is set.",
        "name": "testing.Verbose",
        "params": [],
        "path": "go/testing/index#Verbose",
        "syntax": "func Verbose() bool",
        "type": "testing"
    },
    "Version": {
        "descr": "Version returns the Go tree's version string. It is either the commit hash and date at the time of the build or, when possible, a release tag like \"go1.3\".",
        "name": "runtime.Version",
        "params": [],
        "path": "go/runtime/index#Version",
        "syntax": "func Version() string",
        "type": "runtime"
    },
    "Visit": {
        "descr": "Visit visits the command-line flags in lexicographical order, calling fn for each. It visits only those flags that have been set.",
        "name": "flag.Visit",
        "params": [],
        "path": "go/flag/index#Visit",
        "syntax": "func Visit(fn func(*Flag))",
        "type": "flag"
    },
    "VisitAll": {
        "descr": "VisitAll visits the command-line flags in lexicographical order, calling fn for each. It visits all flags, even those not set.",
        "name": "flag.VisitAll",
        "params": [],
        "path": "go/flag/index#VisitAll",
        "syntax": "func VisitAll(fn func(*Flag))",
        "type": "flag"
    },
    "Wait4": {
        "descr": "",
        "name": "syscall.Wait4",
        "params": [],
        "path": "go/syscall/index#Wait4",
        "syntax": "func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, err error)",
        "type": "syscall"
    },
    "WaitGroup": {
        "descr": "A WaitGroup waits for a collection of goroutines to finish. The main goroutine calls Add to set the number of goroutines to wait for. Then each of the goroutines runs and calls Done when finished. At the same time, Wait can be used to block until all goroutines have finished.",
        "name": "sync.WaitGroup",
        "params": [],
        "path": "go/sync/index#WaitGroup",
        "syntax": "type WaitGroup struct { // contains filtered or unexported fields }",
        "type": "sync"
    },
    "WaitGroup.Add": {
        "descr": "Add adds delta, which may be negative, to the WaitGroup counter. If the counter becomes zero, all goroutines blocked on Wait are released. If the counter goes negative, Add panics.",
        "name": "sync.WaitGroup.Add",
        "params": [],
        "path": "go/sync/index#WaitGroup.Add",
        "syntax": "func (wg *WaitGroup) Add(delta int)",
        "type": "sync"
    },
    "WaitGroup.Done": {
        "descr": "Done decrements the WaitGroup counter by one.",
        "name": "sync.WaitGroup.Done",
        "params": [],
        "path": "go/sync/index#WaitGroup.Done",
        "syntax": "func (wg *WaitGroup) Done()",
        "type": "sync"
    },
    "WaitGroup.Wait": {
        "descr": "Wait blocks until the WaitGroup counter is zero.",
        "name": "sync.WaitGroup.Wait",
        "params": [],
        "path": "go/sync/index#WaitGroup.Wait",
        "syntax": "func (wg *WaitGroup) Wait()",
        "type": "sync"
    },
    "WaitStatus": {
        "descr": "",
        "name": "syscall.WaitStatus",
        "params": [],
        "path": "go/syscall/index#WaitStatus",
        "syntax": "type WaitStatus uint32",
        "type": "syscall"
    },
    "WaitStatus.Continued": {
        "descr": "",
        "name": "syscall.WaitStatus.Continued",
        "params": [],
        "path": "go/syscall/index#WaitStatus.Continued",
        "syntax": "func (w WaitStatus) Continued() bool",
        "type": "syscall"
    },
    "WaitStatus.CoreDump": {
        "descr": "",
        "name": "syscall.WaitStatus.CoreDump",
        "params": [],
        "path": "go/syscall/index#WaitStatus.CoreDump",
        "syntax": "func (w WaitStatus) CoreDump() bool",
        "type": "syscall"
    },
    "WaitStatus.ExitStatus": {
        "descr": "",
        "name": "syscall.WaitStatus.ExitStatus",
        "params": [],
        "path": "go/syscall/index#WaitStatus.ExitStatus",
        "syntax": "func (w WaitStatus) ExitStatus() int",
        "type": "syscall"
    },
    "WaitStatus.Exited": {
        "descr": "",
        "name": "syscall.WaitStatus.Exited",
        "params": [],
        "path": "go/syscall/index#WaitStatus.Exited",
        "syntax": "func (w WaitStatus) Exited() bool",
        "type": "syscall"
    },
    "WaitStatus.Signal": {
        "descr": "",
        "name": "syscall.WaitStatus.Signal",
        "params": [],
        "path": "go/syscall/index#WaitStatus.Signal",
        "syntax": "func (w WaitStatus) Signal() Signal",
        "type": "syscall"
    },
    "WaitStatus.Signaled": {
        "descr": "",
        "name": "syscall.WaitStatus.Signaled",
        "params": [],
        "path": "go/syscall/index#WaitStatus.Signaled",
        "syntax": "func (w WaitStatus) Signaled() bool",
        "type": "syscall"
    },
    "WaitStatus.StopSignal": {
        "descr": "",
        "name": "syscall.WaitStatus.StopSignal",
        "params": [],
        "path": "go/syscall/index#WaitStatus.StopSignal",
        "syntax": "func (w WaitStatus) StopSignal() Signal",
        "type": "syscall"
    },
    "WaitStatus.Stopped": {
        "descr": "",
        "name": "syscall.WaitStatus.Stopped",
        "params": [],
        "path": "go/syscall/index#WaitStatus.Stopped",
        "syntax": "func (w WaitStatus) Stopped() bool",
        "type": "syscall"
    },
    "WaitStatus.TrapCause": {
        "descr": "",
        "name": "syscall.WaitStatus.TrapCause",
        "params": [],
        "path": "go/syscall/index#WaitStatus.TrapCause",
        "syntax": "func (w WaitStatus) TrapCause() int",
        "type": "syscall"
    },
    "Weekday": {
        "descr": "A Weekday specifies a day of the week (Sunday = 0, ...).",
        "name": "time.Weekday",
        "params": [],
        "path": "go/time/index#Weekday",
        "syntax": "type Weekday int",
        "type": "time"
    },
    "Weekday.String": {
        "descr": "String returns the English name of the day (\"Sunday\", \"Monday\", ...).",
        "name": "time.Weekday.String",
        "params": [],
        "path": "go/time/index#Weekday.String",
        "syntax": "func (d Weekday) String() string",
        "type": "time"
    },
    "WithCancel": {
        "descr": "WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.",
        "name": "context.WithCancel",
        "params": [],
        "path": "go/context/index#WithCancel",
        "syntax": "func WithCancel(parent Context) (ctx Context, cancel CancelFunc)",
        "type": "context"
    },
    "WithDeadline": {
        "descr": "WithDeadline returns a copy of the parent context with the deadline adjusted to be no later than d. If the parent's deadline is already earlier than d, WithDeadline(parent, d) is semantically equivalent to parent. The returned context's Done channel is closed when the deadline expires, when the returned cancel function is called, or when the parent context's Done channel is closed, whichever happens first.",
        "name": "context.WithDeadline",
        "params": [],
        "path": "go/context/index#WithDeadline",
        "syntax": "func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)",
        "type": "context"
    },
    "WithTimeout": {
        "descr": "WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).",
        "name": "context.WithTimeout",
        "params": [],
        "path": "go/context/index#WithTimeout",
        "syntax": "func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)",
        "type": "context"
    },
    "WithValue": {
        "descr": "WithValue returns a copy of parent in which the value associated with key is val.",
        "name": "context.WithValue",
        "params": [],
        "path": "go/context/index#WithValue",
        "syntax": "func WithValue(parent Context, key, val interface{}) Context",
        "type": "context"
    },
    "WordDecoder": {
        "descr": "A WordDecoder decodes MIME headers containing RFC 2047 encoded-words.",
        "name": "mime.WordDecoder",
        "params": [],
        "path": "go/mime/index#WordDecoder",
        "syntax": "type WordDecoder struct { // CharsetReader, if non-nil, defines a function to generate // charset-conversion readers, converting from the provided // charset into UTF-8. // Charsets are always lower-case. utf-8, iso-8859-1 and us-ascii charsets // are handled by default. // One of the CharsetReader's result values must be non-nil. CharsetReader func(charset string, input io.Reader) (io.Reader, error) }",
        "type": "mime"
    },
    "WordDecoder.Decode": {
        "descr": "Decode decodes an RFC 2047 encoded-word.",
        "name": "mime.WordDecoder.Decode",
        "params": [],
        "path": "go/mime/index#WordDecoder.Decode",
        "syntax": "func (d *WordDecoder) Decode(word string) (string, error)",
        "type": "mime"
    },
    "WordDecoder.DecodeHeader": {
        "descr": "DecodeHeader decodes all encoded-words of the given string. It returns an error if and only if CharsetReader of d returns an error.",
        "name": "mime.WordDecoder.DecodeHeader",
        "params": [],
        "path": "go/mime/index#WordDecoder.DecodeHeader",
        "syntax": "func (d *WordDecoder) DecodeHeader(header string) (string, error)",
        "type": "mime"
    },
    "WordEncoder": {
        "descr": "A WordEncoder is an RFC 2047 encoded-word encoder.",
        "name": "mime.WordEncoder",
        "params": [],
        "path": "go/mime/index#WordEncoder",
        "syntax": "type WordEncoder byte",
        "type": "mime"
    },
    "WordEncoder.Encode": {
        "descr": "Encode returns the encoded-word form of s. If s is ASCII without special characters, it is returned unchanged. The provided charset is the IANA charset name of s. It is case insensitive.",
        "name": "mime.WordEncoder.Encode",
        "params": [],
        "path": "go/mime/index#WordEncoder.Encode",
        "syntax": "func (e WordEncoder) Encode(charset, s string) string",
        "type": "mime"
    },
    "Write": {
        "descr": "",
        "name": "syscall.Write",
        "params": [],
        "path": "go/syscall/index#Write",
        "syntax": "func Write(fd int, p []byte) (n int, err error)",
        "type": "syscall"
    },
    "WriteCloser": {
        "descr": "WriteCloser is the interface that groups the basic Write and Close methods.",
        "name": "io.WriteCloser",
        "params": [],
        "path": "go/io/index#WriteCloser",
        "syntax": "type WriteCloser interface { Writer Closer }",
        "type": "io"
    },
    "WriteSeeker": {
        "descr": "WriteSeeker is the interface that groups the basic Write and Seek methods.",
        "name": "io.WriteSeeker",
        "params": [],
        "path": "go/io/index#WriteSeeker",
        "syntax": "type WriteSeeker interface { Writer Seeker }",
        "type": "io"
    },
    "WriteString": {
        "descr": "WriteString writes the contents of the string s to w, which accepts a slice of bytes. If w implements a WriteString method, it is invoked directly. Otherwise, w.Write is called exactly once.",
        "name": "io.WriteString",
        "params": [],
        "path": "go/io/index#WriteString",
        "syntax": "func WriteString(w Writer, s string) (n int, err error)",
        "type": "io"
    },
    "Writer": {
        "descr": "Writer is the interface that wraps the basic Write method.",
        "name": "io.Writer",
        "params": [],
        "path": "go/io/index#Writer",
        "syntax": "type Writer interface { Write(p []byte) (n int, err error) }",
        "type": "io"
    },
    "Writer.Available": {
        "descr": "Available returns how many bytes are unused in the buffer.",
        "name": "bufio.Writer.Available",
        "params": [],
        "path": "go/bufio/index#Writer.Available",
        "syntax": "func (b *Writer) Available() int",
        "type": "bufio"
    },
    "Writer.Buffered": {
        "descr": "Buffered returns the number of bytes that have been written into the current buffer.",
        "name": "bufio.Writer.Buffered",
        "params": [],
        "path": "go/bufio/index#Writer.Buffered",
        "syntax": "func (b *Writer) Buffered() int",
        "type": "bufio"
    },
    "Writer.Flush": {
        "descr": "Flush writes any buffered data to the underlying io.Writer.",
        "name": "bufio.Writer.Flush",
        "params": [],
        "path": "go/bufio/index#Writer.Flush",
        "syntax": "func (b *Writer) Flush() error",
        "type": "bufio"
    },
    "Writer.ReadFrom": {
        "descr": "ReadFrom implements io.ReaderFrom. If the underlying writer supports the ReadFrom method, and b has no buffered data yet, this calls the underlying ReadFrom without buffering.",
        "name": "bufio.Writer.ReadFrom",
        "params": [],
        "path": "go/bufio/index#Writer.ReadFrom",
        "syntax": "func (b *Writer) ReadFrom(r io.Reader) (n int64, err error)",
        "type": "bufio"
    },
    "Writer.Reset": {
        "descr": "Reset discards any unflushed buffered data, clears any error, and resets b to write its output to w.",
        "name": "bufio.Writer.Reset",
        "params": [],
        "path": "go/bufio/index#Writer.Reset",
        "syntax": "func (b *Writer) Reset(w io.Writer)",
        "type": "bufio"
    },
    "Writer.Size": {
        "descr": "Size returns the size of the underlying buffer in bytes.",
        "name": "bufio.Writer.Size",
        "params": [],
        "path": "go/bufio/index#Writer.Size",
        "syntax": "func (b *Writer) Size() int",
        "type": "bufio"
    },
    "Writer.Write": {
        "descr": "Write writes the contents of p into the buffer. It returns the number of bytes written. If nn < len(p), it also returns an error explaining why the write is short.",
        "name": "bufio.Writer.Write",
        "params": [],
        "path": "go/bufio/index#Writer.Write",
        "syntax": "func (b *Writer) Write(p []byte) (nn int, err error)",
        "type": "bufio"
    },
    "Writer.WriteByte": {
        "descr": "WriteByte writes a single byte.",
        "name": "bufio.Writer.WriteByte",
        "params": [],
        "path": "go/bufio/index#Writer.WriteByte",
        "syntax": "func (b *Writer) WriteByte(c byte) error",
        "type": "bufio"
    },
    "Writer.WriteRune": {
        "descr": "WriteRune writes a single Unicode code point, returning the number of bytes written and any error.",
        "name": "bufio.Writer.WriteRune",
        "params": [],
        "path": "go/bufio/index#Writer.WriteRune",
        "syntax": "func (b *Writer) WriteRune(r rune) (size int, err error)",
        "type": "bufio"
    },
    "Writer.WriteString": {
        "descr": "WriteString writes a string. It returns the number of bytes written. If the count is less than len(s), it also returns an error explaining why the write is short.",
        "name": "bufio.Writer.WriteString",
        "params": [],
        "path": "go/bufio/index#Writer.WriteString",
        "syntax": "func (b *Writer) WriteString(s string) (int, error)",
        "type": "bufio"
    },
    "WriterAt": {
        "descr": "WriterAt is the interface that wraps the basic WriteAt method.",
        "name": "io.WriterAt",
        "params": [],
        "path": "go/io/index#WriterAt",
        "syntax": "type WriterAt interface { WriteAt(p []byte, off int64) (n int, err error) }",
        "type": "io"
    },
    "WriterTo": {
        "descr": "WriterTo is the interface that wraps the WriteTo method.",
        "name": "io.WriterTo",
        "params": [],
        "path": "go/io/index#WriterTo",
        "syntax": "type WriterTo interface { WriteTo(w Writer) (n int64, err error) }",
        "type": "io"
    },
    "Y0": {
        "descr": "Y0 returns the order-zero Bessel function of the second kind.",
        "name": "math.Y0",
        "params": [],
        "path": "go/math/index#Y0",
        "syntax": "func Y0(x float64) float64",
        "type": "math"
    },
    "Y1": {
        "descr": "Y1 returns the order-one Bessel function of the second kind.",
        "name": "math.Y1",
        "params": [],
        "path": "go/math/index#Y1",
        "syntax": "func Y1(x float64) float64",
        "type": "math"
    },
    "YCbCr": {
        "descr": "YCbCr is an in-memory image of Y'CbCr colors. There is one Y sample per pixel, but each Cb and Cr sample can span one or more pixels. YStride is the Y slice index delta between vertically adjacent pixels. CStride is the Cb and Cr slice index delta between vertically adjacent pixels that map to separate chroma samples. It is not an absolute requirement, but YStride and len(Y) are typically multiples of 8, and:",
        "name": "image.YCbCr",
        "params": [],
        "path": "go/image/index#YCbCr",
        "syntax": "For 4:4:4, CStride == YStride/1 && len(Cb) == len(Cr) == len(Y)/1. For 4:2:2, CStride == YStride/2 && len(Cb) == len(Cr) == len(Y)/2. For 4:2:0, CStride == YStride/2 && len(Cb) == len(Cr) == len(Y)/4. For 4:4:0, CStride == YStride/1 && len(Cb) == len(Cr) == len(Y)/2. For 4:1:1, CStride == YStride/4 && len(Cb) == len(Cr) == len(Y)/4. For 4:1:0, CStride == YStride/4 && len(Cb) == len(Cr) == len(Y)/8.",
        "type": "image"
    },
    "YCbCr.At": {
        "descr": "",
        "name": "image.YCbCr.At",
        "params": [],
        "path": "go/image/index#YCbCr.At",
        "syntax": "func (p *YCbCr) At(x, y int) color.Color",
        "type": "image"
    },
    "YCbCr.Bounds": {
        "descr": "",
        "name": "image.YCbCr.Bounds",
        "params": [],
        "path": "go/image/index#YCbCr.Bounds",
        "syntax": "func (p *YCbCr) Bounds() Rectangle",
        "type": "image"
    },
    "YCbCr.COffset": {
        "descr": "COffset returns the index of the first element of Cb or Cr that corresponds to the pixel at (x, y).",
        "name": "image.YCbCr.COffset",
        "params": [],
        "path": "go/image/index#YCbCr.COffset",
        "syntax": "func (p *YCbCr) COffset(x, y int) int",
        "type": "image"
    },
    "YCbCr.ColorModel": {
        "descr": "",
        "name": "image.YCbCr.ColorModel",
        "params": [],
        "path": "go/image/index#YCbCr.ColorModel",
        "syntax": "func (p *YCbCr) ColorModel() color.Model",
        "type": "image"
    },
    "YCbCr.Opaque": {
        "descr": "",
        "name": "image.YCbCr.Opaque",
        "params": [],
        "path": "go/image/index#YCbCr.Opaque",
        "syntax": "func (p *YCbCr) Opaque() bool",
        "type": "image"
    },
    "YCbCr.SubImage": {
        "descr": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.",
        "name": "image.YCbCr.SubImage",
        "params": [],
        "path": "go/image/index#YCbCr.SubImage",
        "syntax": "func (p *YCbCr) SubImage(r Rectangle) Image",
        "type": "image"
    },
    "YCbCr.YCbCrAt": {
        "descr": "",
        "name": "image.YCbCr.YCbCrAt",
        "params": [],
        "path": "go/image/index#YCbCr.YCbCrAt",
        "syntax": "func (p *YCbCr) YCbCrAt(x, y int) color.YCbCr",
        "type": "image"
    },
    "YCbCr.YOffset": {
        "descr": "YOffset returns the index of the first element of Y that corresponds to the pixel at (x, y).",
        "name": "image.YCbCr.YOffset",
        "params": [],
        "path": "go/image/index#YCbCr.YOffset",
        "syntax": "func (p *YCbCr) YOffset(x, y int) int",
        "type": "image"
    },
    "YCbCrSubsampleRatio": {
        "descr": "YCbCrSubsampleRatio is the chroma subsample ratio used in a YCbCr image.",
        "name": "image.YCbCrSubsampleRatio",
        "params": [],
        "path": "go/image/index#YCbCrSubsampleRatio",
        "syntax": "type YCbCrSubsampleRatio int",
        "type": "image"
    },
    "YCbCrSubsampleRatio.String": {
        "descr": "",
        "name": "image.YCbCrSubsampleRatio.String",
        "params": [],
        "path": "go/image/index#YCbCrSubsampleRatio.String",
        "syntax": "func (s YCbCrSubsampleRatio) String() string",
        "type": "image"
    },
    "Yn": {
        "descr": "Yn returns the order-n Bessel function of the second kind.",
        "name": "math.Yn",
        "params": [],
        "path": "go/math/index#Yn",
        "syntax": "func Yn(n int, x float64) float64",
        "type": "math"
    },
    "Zero": {
        "descr": "Zero returns a Value representing the zero value for the specified type. The result is different from the zero value of the Value struct, which represents no value at all. For example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0. The returned value is neither addressable nor settable.",
        "name": "reflect.Zero",
        "params": [],
        "path": "go/reflect/index#Zero",
        "syntax": "func Zero(typ Type) Value",
        "type": "reflect"
    },
    "adler32.Checksum": {
        "descr": "Checksum returns the Adler-32 checksum of data.",
        "name": "adler32.Checksum",
        "params": [],
        "path": "go/hash/adler32/index#Checksum",
        "syntax": "func Checksum(data []byte) uint32",
        "type": "hash"
    },
    "adler32.New": {
        "descr": "New returns a new hash.Hash32 computing the Adler-32 checksum. Its Sum method will lay the value out in big-endian byte order. The returned Hash32 also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.",
        "name": "adler32.New",
        "params": [],
        "path": "go/hash/adler32/index#New",
        "syntax": "func New() hash.Hash32",
        "type": "hash"
    },
    "aes.KeySizeError": {
        "descr": "",
        "name": "aes.KeySizeError",
        "params": [],
        "path": "go/crypto/aes/index#KeySizeError",
        "syntax": "type KeySizeError int",
        "type": "crypto"
    },
    "aes.KeySizeError.Error": {
        "descr": "",
        "name": "aes.KeySizeError.Error",
        "params": [],
        "path": "go/crypto/aes/index#KeySizeError.Error",
        "syntax": "func (k KeySizeError) Error() string",
        "type": "crypto"
    },
    "aes.NewCipher": {
        "descr": "NewCipher creates and returns a new cipher.Block. The key argument should be the AES key, either 16, 24, or 32 bytes to select AES-128, AES-192, or AES-256.",
        "name": "aes.NewCipher",
        "params": [],
        "path": "go/crypto/aes/index#NewCipher",
        "syntax": "func NewCipher(key []byte) (cipher.Block, error)",
        "type": "crypto"
    },
    "append": {
        "descr": "The append built-in function appends elements to the end of a slice. If it has sufficient capacity, the destination is resliced to accommodate the new elements. If it does not, a new underlying array will be allocated. Append returns the updated slice. It is therefore necessary to store the result of append, often in the variable holding the slice itself:",
        "name": "builtin.append",
        "params": [],
        "path": "go/builtin/index#append",
        "syntax": "func append(slice []Type, elems ...Type) []Type",
        "type": "builtin"
    },
    "ascii85.CorruptInputError": {
        "descr": "",
        "name": "ascii85.CorruptInputError",
        "params": [],
        "path": "go/encoding/ascii85/index#CorruptInputError",
        "syntax": "type CorruptInputError int64",
        "type": "encoding"
    },
    "ascii85.CorruptInputError.Error": {
        "descr": "",
        "name": "ascii85.CorruptInputError.Error",
        "params": [],
        "path": "go/encoding/ascii85/index#CorruptInputError.Error",
        "syntax": "func (e CorruptInputError) Error() string",
        "type": "encoding"
    },
    "ascii85.Decode": {
        "descr": "Decode decodes src into dst, returning both the number of bytes written to dst and the number consumed from src. If src contains invalid ascii85 data, Decode will return the number of bytes successfully written and a CorruptInputError. Decode ignores space and control characters in src. Often, ascii85-encoded data is wrapped in <~ and ~> symbols. Decode expects these to have been stripped by the caller.",
        "name": "ascii85.Decode",
        "params": [],
        "path": "go/encoding/ascii85/index#Decode",
        "syntax": "func Decode(dst, src []byte, flush bool) (ndst, nsrc int, err error)",
        "type": "encoding"
    },
    "ascii85.Encode": {
        "descr": "Encode encodes src into at most MaxEncodedLen(len(src)) bytes of dst, returning the actual number of bytes written.",
        "name": "ascii85.Encode",
        "params": [],
        "path": "go/encoding/ascii85/index#Encode",
        "syntax": "func Encode(dst, src []byte) int",
        "type": "encoding"
    },
    "ascii85.MaxEncodedLen": {
        "descr": "MaxEncodedLen returns the maximum length of an encoding of n source bytes.",
        "name": "ascii85.MaxEncodedLen",
        "params": [],
        "path": "go/encoding/ascii85/index#MaxEncodedLen",
        "syntax": "func MaxEncodedLen(n int) int",
        "type": "encoding"
    },
    "ascii85.NewDecoder": {
        "descr": "NewDecoder constructs a new ascii85 stream decoder.",
        "name": "ascii85.NewDecoder",
        "params": [],
        "path": "go/encoding/ascii85/index#NewDecoder",
        "syntax": "func NewDecoder(r io.Reader) io.Reader",
        "type": "encoding"
    },
    "ascii85.NewEncoder": {
        "descr": "NewEncoder returns a new ascii85 stream encoder. Data written to the returned writer will be encoded and then written to w. Ascii85 encodings operate in 32-bit blocks; when finished writing, the caller must Close the returned encoder to flush any trailing partial block.",
        "name": "ascii85.NewEncoder",
        "params": [],
        "path": "go/encoding/ascii85/index#NewEncoder",
        "syntax": "func NewEncoder(w io.Writer) io.WriteCloser",
        "type": "encoding"
    },
    "asn1.BitString": {
        "descr": "BitString is the structure to use when you want an ASN.1 BIT STRING type. A bit string is padded up to the nearest byte in memory and the number of valid bits is recorded. Padding bits will be zero.",
        "name": "asn1.BitString",
        "params": [],
        "path": "go/encoding/asn1/index#BitString",
        "syntax": "type BitString struct { Bytes []byte // bits packed into bytes. BitLength int // length in bits. }",
        "type": "encoding"
    },
    "asn1.BitString.At": {
        "descr": "At returns the bit at the given index. If the index is out of range it returns false.",
        "name": "asn1.BitString.At",
        "params": [],
        "path": "go/encoding/asn1/index#BitString.At",
        "syntax": "func (b BitString) At(i int) int",
        "type": "encoding"
    },
    "asn1.BitString.RightAlign": {
        "descr": "RightAlign returns a slice where the padding bits are at the beginning. The slice may share memory with the BitString.",
        "name": "asn1.BitString.RightAlign",
        "params": [],
        "path": "go/encoding/asn1/index#BitString.RightAlign",
        "syntax": "func (b BitString) RightAlign() []byte",
        "type": "encoding"
    },
    "asn1.Enumerated": {
        "descr": "An Enumerated is represented as a plain int.",
        "name": "asn1.Enumerated",
        "params": [],
        "path": "go/encoding/asn1/index#Enumerated",
        "syntax": "type Enumerated int",
        "type": "encoding"
    },
    "asn1.Flag": {
        "descr": "A Flag accepts any data and is set to true if present.",
        "name": "asn1.Flag",
        "params": [],
        "path": "go/encoding/asn1/index#Flag",
        "syntax": "type Flag bool",
        "type": "encoding"
    },
    "asn1.Marshal": {
        "descr": "Marshal returns the ASN.1 encoding of val.",
        "name": "asn1.Marshal",
        "params": [],
        "path": "go/encoding/asn1/index#Marshal",
        "syntax": "func Marshal(val interface{}) ([]byte, error)",
        "type": "encoding"
    },
    "asn1.MarshalWithParams": {
        "descr": "MarshalWithParams allows field parameters to be specified for the top-level element. The form of the params is the same as the field tags.",
        "name": "asn1.MarshalWithParams",
        "params": [],
        "path": "go/encoding/asn1/index#MarshalWithParams",
        "syntax": "func MarshalWithParams(val interface{}, params string) ([]byte, error)",
        "type": "encoding"
    },
    "asn1.ObjectIdentifier": {
        "descr": "An ObjectIdentifier represents an ASN.1 OBJECT IDENTIFIER.",
        "name": "asn1.ObjectIdentifier",
        "params": [],
        "path": "go/encoding/asn1/index#ObjectIdentifier",
        "syntax": "type ObjectIdentifier []int",
        "type": "encoding"
    },
    "asn1.ObjectIdentifier.Equal": {
        "descr": "Equal reports whether oi and other represent the same identifier.",
        "name": "asn1.ObjectIdentifier.Equal",
        "params": [],
        "path": "go/encoding/asn1/index#ObjectIdentifier.Equal",
        "syntax": "func (oi ObjectIdentifier) Equal(other ObjectIdentifier) bool",
        "type": "encoding"
    },
    "asn1.ObjectIdentifier.String": {
        "descr": "",
        "name": "asn1.ObjectIdentifier.String",
        "params": [],
        "path": "go/encoding/asn1/index#ObjectIdentifier.String",
        "syntax": "func (oi ObjectIdentifier) String() string",
        "type": "encoding"
    },
    "asn1.RawContent": {
        "descr": "RawContent is used to signal that the undecoded, DER data needs to be preserved for a struct. To use it, the first field of the struct must have this type. It's an error for any of the other fields to have this type.",
        "name": "asn1.RawContent",
        "params": [],
        "path": "go/encoding/asn1/index#RawContent",
        "syntax": "type RawContent []byte",
        "type": "encoding"
    },
    "asn1.RawValue": {
        "descr": "A RawValue represents an undecoded ASN.1 object.",
        "name": "asn1.RawValue",
        "params": [],
        "path": "go/encoding/asn1/index#RawValue",
        "syntax": "type RawValue struct { Class, Tag int IsCompound bool Bytes []byte FullBytes []byte // includes the tag and length }",
        "type": "encoding"
    },
    "asn1.StructuralError": {
        "descr": "A StructuralError suggests that the ASN.1 data is valid, but the Go type which is receiving it doesn't match.",
        "name": "asn1.StructuralError",
        "params": [],
        "path": "go/encoding/asn1/index#StructuralError",
        "syntax": "type StructuralError struct { Msg string }",
        "type": "encoding"
    },
    "asn1.StructuralError.Error": {
        "descr": "",
        "name": "asn1.StructuralError.Error",
        "params": [],
        "path": "go/encoding/asn1/index#StructuralError.Error",
        "syntax": "func (e StructuralError) Error() string",
        "type": "encoding"
    },
    "asn1.SyntaxError": {
        "descr": "A SyntaxError suggests that the ASN.1 data is invalid.",
        "name": "asn1.SyntaxError",
        "params": [],
        "path": "go/encoding/asn1/index#SyntaxError",
        "syntax": "type SyntaxError struct { Msg string }",
        "type": "encoding"
    },
    "asn1.SyntaxError.Error": {
        "descr": "",
        "name": "asn1.SyntaxError.Error",
        "params": [],
        "path": "go/encoding/asn1/index#SyntaxError.Error",
        "syntax": "func (e SyntaxError) Error() string",
        "type": "encoding"
    },
    "asn1.Unmarshal": {
        "descr": "Unmarshal parses the DER-encoded ASN.1 data structure b and uses the reflect package to fill in an arbitrary value pointed at by val. Because Unmarshal uses the reflect package, the structs being written to must use upper case field names.",
        "name": "asn1.Unmarshal",
        "params": [],
        "path": "go/encoding/asn1/index#Unmarshal",
        "syntax": "func Unmarshal(b []byte, val interface{}) (rest []byte, err error)",
        "type": "encoding"
    },
    "asn1.UnmarshalWithParams": {
        "descr": "UnmarshalWithParams allows field parameters to be specified for the top-level element. The form of the params is the same as the field tags.",
        "name": "asn1.UnmarshalWithParams",
        "params": [],
        "path": "go/encoding/asn1/index#UnmarshalWithParams",
        "syntax": "func UnmarshalWithParams(b []byte, val interface{}, params string) (rest []byte, err error)",
        "type": "encoding"
    },
    "ast.ArrayType": {
        "descr": "An ArrayType node represents an array or slice type.",
        "name": "ast.ArrayType",
        "params": [],
        "path": "go/go/ast/index#ArrayType",
        "syntax": "type ArrayType struct { Lbrack token.Pos // position of \"[\" Len Expr // Ellipsis node for [...]T array types, nil for slice types Elt Expr // element type }",
        "type": "go"
    },
    "ast.ArrayType.End": {
        "descr": "",
        "name": "ast.ArrayType.End",
        "params": [],
        "path": "go/go/ast/index#ArrayType.End",
        "syntax": "func (x *ArrayType) End() token.Pos",
        "type": "go"
    },
    "ast.ArrayType.Pos": {
        "descr": "",
        "name": "ast.ArrayType.Pos",
        "params": [],
        "path": "go/go/ast/index#ArrayType.Pos",
        "syntax": "func (x *ArrayType) Pos() token.Pos",
        "type": "go"
    },
    "ast.AssignStmt": {
        "descr": "An AssignStmt node represents an assignment or a short variable declaration.",
        "name": "ast.AssignStmt",
        "params": [],
        "path": "go/go/ast/index#AssignStmt",
        "syntax": "type AssignStmt struct { Lhs []Expr TokPos token.Pos // position of Tok Tok token.Token // assignment token, DEFINE Rhs []Expr }",
        "type": "go"
    },
    "ast.AssignStmt.End": {
        "descr": "",
        "name": "ast.AssignStmt.End",
        "params": [],
        "path": "go/go/ast/index#AssignStmt.End",
        "syntax": "func (s *AssignStmt) End() token.Pos",
        "type": "go"
    },
    "ast.AssignStmt.Pos": {
        "descr": "",
        "name": "ast.AssignStmt.Pos",
        "params": [],
        "path": "go/go/ast/index#AssignStmt.Pos",
        "syntax": "func (s *AssignStmt) Pos() token.Pos",
        "type": "go"
    },
    "ast.BadDecl": {
        "descr": "A BadDecl node is a placeholder for declarations containing syntax errors for which no correct declaration nodes can be created.",
        "name": "ast.BadDecl",
        "params": [],
        "path": "go/go/ast/index#BadDecl",
        "syntax": "type BadDecl struct { From, To token.Pos // position range of bad declaration }",
        "type": "go"
    },
    "ast.BadDecl.End": {
        "descr": "",
        "name": "ast.BadDecl.End",
        "params": [],
        "path": "go/go/ast/index#BadDecl.End",
        "syntax": "func (d *BadDecl) End() token.Pos",
        "type": "go"
    },
    "ast.BadDecl.Pos": {
        "descr": "",
        "name": "ast.BadDecl.Pos",
        "params": [],
        "path": "go/go/ast/index#BadDecl.Pos",
        "syntax": "func (d *BadDecl) Pos() token.Pos",
        "type": "go"
    },
    "ast.BadExpr": {
        "descr": "A BadExpr node is a placeholder for expressions containing syntax errors for which no correct expression nodes can be created.",
        "name": "ast.BadExpr",
        "params": [],
        "path": "go/go/ast/index#BadExpr",
        "syntax": "type BadExpr struct { From, To token.Pos // position range of bad expression }",
        "type": "go"
    },
    "ast.BadExpr.End": {
        "descr": "",
        "name": "ast.BadExpr.End",
        "params": [],
        "path": "go/go/ast/index#BadExpr.End",
        "syntax": "func (x *BadExpr) End() token.Pos",
        "type": "go"
    },
    "ast.BadExpr.Pos": {
        "descr": "",
        "name": "ast.BadExpr.Pos",
        "params": [],
        "path": "go/go/ast/index#BadExpr.Pos",
        "syntax": "func (x *BadExpr) Pos() token.Pos",
        "type": "go"
    },
    "ast.BadStmt": {
        "descr": "A BadStmt node is a placeholder for statements containing syntax errors for which no correct statement nodes can be created.",
        "name": "ast.BadStmt",
        "params": [],
        "path": "go/go/ast/index#BadStmt",
        "syntax": "type BadStmt struct { From, To token.Pos // position range of bad statement }",
        "type": "go"
    },
    "ast.BadStmt.End": {
        "descr": "",
        "name": "ast.BadStmt.End",
        "params": [],
        "path": "go/go/ast/index#BadStmt.End",
        "syntax": "func (s *BadStmt) End() token.Pos",
        "type": "go"
    },
    "ast.BadStmt.Pos": {
        "descr": "",
        "name": "ast.BadStmt.Pos",
        "params": [],
        "path": "go/go/ast/index#BadStmt.Pos",
        "syntax": "func (s *BadStmt) Pos() token.Pos",
        "type": "go"
    },
    "ast.BasicLit": {
        "descr": "A BasicLit node represents a literal of basic type.",
        "name": "ast.BasicLit",
        "params": [],
        "path": "go/go/ast/index#BasicLit",
        "syntax": "type BasicLit struct { ValuePos token.Pos // literal position Kind token.Token // token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING Value string // literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\\x7f', \"foo\" or `\\m\\n\\o` }",
        "type": "go"
    },
    "ast.BasicLit.End": {
        "descr": "",
        "name": "ast.BasicLit.End",
        "params": [],
        "path": "go/go/ast/index#BasicLit.End",
        "syntax": "func (x *BasicLit) End() token.Pos",
        "type": "go"
    },
    "ast.BasicLit.Pos": {
        "descr": "",
        "name": "ast.BasicLit.Pos",
        "params": [],
        "path": "go/go/ast/index#BasicLit.Pos",
        "syntax": "func (x *BasicLit) Pos() token.Pos",
        "type": "go"
    },
    "ast.BinaryExpr": {
        "descr": "A BinaryExpr node represents a binary expression.",
        "name": "ast.BinaryExpr",
        "params": [],
        "path": "go/go/ast/index#BinaryExpr",
        "syntax": "type BinaryExpr struct { X Expr // left operand OpPos token.Pos // position of Op Op token.Token // operator Y Expr // right operand }",
        "type": "go"
    },
    "ast.BinaryExpr.End": {
        "descr": "",
        "name": "ast.BinaryExpr.End",
        "params": [],
        "path": "go/go/ast/index#BinaryExpr.End",
        "syntax": "func (x *BinaryExpr) End() token.Pos",
        "type": "go"
    },
    "ast.BinaryExpr.Pos": {
        "descr": "",
        "name": "ast.BinaryExpr.Pos",
        "params": [],
        "path": "go/go/ast/index#BinaryExpr.Pos",
        "syntax": "func (x *BinaryExpr) Pos() token.Pos",
        "type": "go"
    },
    "ast.BlockStmt": {
        "descr": "A BlockStmt node represents a braced statement list.",
        "name": "ast.BlockStmt",
        "params": [],
        "path": "go/go/ast/index#BlockStmt",
        "syntax": "type BlockStmt struct { Lbrace token.Pos // position of \"{\" List []Stmt Rbrace token.Pos // position of \"}\" }",
        "type": "go"
    },
    "ast.BlockStmt.End": {
        "descr": "",
        "name": "ast.BlockStmt.End",
        "params": [],
        "path": "go/go/ast/index#BlockStmt.End",
        "syntax": "func (s *BlockStmt) End() token.Pos",
        "type": "go"
    },
    "ast.BlockStmt.Pos": {
        "descr": "",
        "name": "ast.BlockStmt.Pos",
        "params": [],
        "path": "go/go/ast/index#BlockStmt.Pos",
        "syntax": "func (s *BlockStmt) Pos() token.Pos",
        "type": "go"
    },
    "ast.BranchStmt": {
        "descr": "A BranchStmt node represents a break, continue, goto, or fallthrough statement.",
        "name": "ast.BranchStmt",
        "params": [],
        "path": "go/go/ast/index#BranchStmt",
        "syntax": "type BranchStmt struct { TokPos token.Pos // position of Tok Tok token.Token // keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH) Label *Ident // label name; or nil }",
        "type": "go"
    },
    "ast.BranchStmt.End": {
        "descr": "",
        "name": "ast.BranchStmt.End",
        "params": [],
        "path": "go/go/ast/index#BranchStmt.End",
        "syntax": "func (s *BranchStmt) End() token.Pos",
        "type": "go"
    },
    "ast.BranchStmt.Pos": {
        "descr": "",
        "name": "ast.BranchStmt.Pos",
        "params": [],
        "path": "go/go/ast/index#BranchStmt.Pos",
        "syntax": "func (s *BranchStmt) Pos() token.Pos",
        "type": "go"
    },
    "ast.CallExpr": {
        "descr": "A CallExpr node represents an expression followed by an argument list.",
        "name": "ast.CallExpr",
        "params": [],
        "path": "go/go/ast/index#CallExpr",
        "syntax": "type CallExpr struct { Fun Expr // function expression Lparen token.Pos // position of \"(\" Args []Expr // function arguments; or nil Ellipsis token.Pos // position of \"...\" (token.NoPos if there is no \"...\") Rparen token.Pos // position of \")\" }",
        "type": "go"
    },
    "ast.CallExpr.End": {
        "descr": "",
        "name": "ast.CallExpr.End",
        "params": [],
        "path": "go/go/ast/index#CallExpr.End",
        "syntax": "func (x *CallExpr) End() token.Pos",
        "type": "go"
    },
    "ast.CallExpr.Pos": {
        "descr": "",
        "name": "ast.CallExpr.Pos",
        "params": [],
        "path": "go/go/ast/index#CallExpr.Pos",
        "syntax": "func (x *CallExpr) Pos() token.Pos",
        "type": "go"
    },
    "ast.CaseClause": {
        "descr": "A CaseClause represents a case of an expression or type switch statement.",
        "name": "ast.CaseClause",
        "params": [],
        "path": "go/go/ast/index#CaseClause",
        "syntax": "type CaseClause struct { Case token.Pos // position of \"case\" or \"default\" keyword List []Expr // list of expressions or types; nil means default case Colon token.Pos // position of \":\" Body []Stmt // statement list; or nil }",
        "type": "go"
    },
    "ast.CaseClause.End": {
        "descr": "",
        "name": "ast.CaseClause.End",
        "params": [],
        "path": "go/go/ast/index#CaseClause.End",
        "syntax": "func (s *CaseClause) End() token.Pos",
        "type": "go"
    },
    "ast.CaseClause.Pos": {
        "descr": "",
        "name": "ast.CaseClause.Pos",
        "params": [],
        "path": "go/go/ast/index#CaseClause.Pos",
        "syntax": "func (s *CaseClause) Pos() token.Pos",
        "type": "go"
    },
    "ast.ChanDir": {
        "descr": "The direction of a channel type is indicated by a bit mask including one or both of the following constants.",
        "name": "ast.ChanDir",
        "params": [],
        "path": "go/go/ast/index#ChanDir",
        "syntax": "type ChanDir int",
        "type": "go"
    },
    "ast.ChanType": {
        "descr": "A ChanType node represents a channel type.",
        "name": "ast.ChanType",
        "params": [],
        "path": "go/go/ast/index#ChanType",
        "syntax": "type ChanType struct { Begin token.Pos // position of \"chan\" keyword or \"<-\" (whichever comes first) Arrow token.Pos // position of \"<-\" (token.NoPos if there is no \"<-\");\n or  added in Go 1.1 Dir ChanDir // channel direction Value Expr // value type });",
        "type": "go"
    },
    "ast.ChanType.End": {
        "descr": "",
        "name": "ast.ChanType.End",
        "params": [],
        "path": "go/go/ast/index#ChanType.End",
        "syntax": "func (x *ChanType) End() token.Pos",
        "type": "go"
    },
    "ast.ChanType.Pos": {
        "descr": "",
        "name": "ast.ChanType.Pos",
        "params": [],
        "path": "go/go/ast/index#ChanType.Pos",
        "syntax": "func (x *ChanType) Pos() token.Pos",
        "type": "go"
    },
    "ast.CommClause": {
        "descr": "A CommClause node represents a case of a select statement.",
        "name": "ast.CommClause",
        "params": [],
        "path": "go/go/ast/index#CommClause",
        "syntax": "type CommClause struct { Case token.Pos // position of \"case\" or \"default\" keyword Comm Stmt // send or receive statement; nil means default case Colon token.Pos // position of \":\" Body []Stmt // statement list; or nil }",
        "type": "go"
    },
    "ast.CommClause.End": {
        "descr": "",
        "name": "ast.CommClause.End",
        "params": [],
        "path": "go/go/ast/index#CommClause.End",
        "syntax": "func (s *CommClause) End() token.Pos",
        "type": "go"
    },
    "ast.CommClause.Pos": {
        "descr": "",
        "name": "ast.CommClause.Pos",
        "params": [],
        "path": "go/go/ast/index#CommClause.Pos",
        "syntax": "func (s *CommClause) Pos() token.Pos",
        "type": "go"
    },
    "ast.Comment": {
        "descr": "A Comment node represents a single //-style or /*-style comment.",
        "name": "ast.Comment",
        "params": [],
        "path": "go/go/ast/index#Comment",
        "syntax": "type Comment struct { Slash token.Pos // position of \"/\" starting the comment Text string // comment text (excluding '\\n' for //-style comments) }",
        "type": "go"
    },
    "ast.Comment.End": {
        "descr": "",
        "name": "ast.Comment.End",
        "params": [],
        "path": "go/go/ast/index#Comment.End",
        "syntax": "func (c *Comment) End() token.Pos",
        "type": "go"
    },
    "ast.Comment.Pos": {
        "descr": "",
        "name": "ast.Comment.Pos",
        "params": [],
        "path": "go/go/ast/index#Comment.Pos",
        "syntax": "func (c *Comment) Pos() token.Pos",
        "type": "go"
    },
    "ast.CommentGroup": {
        "descr": "A CommentGroup represents a sequence of comments with no other tokens and no empty lines between.",
        "name": "ast.CommentGroup",
        "params": [],
        "path": "go/go/ast/index#CommentGroup",
        "syntax": "type CommentGroup struct { List []*Comment // len(List) > 0 }",
        "type": "go"
    },
    "ast.CommentGroup.End": {
        "descr": "",
        "name": "ast.CommentGroup.End",
        "params": [],
        "path": "go/go/ast/index#CommentGroup.End",
        "syntax": "func (g *CommentGroup) End() token.Pos",
        "type": "go"
    },
    "ast.CommentGroup.Pos": {
        "descr": "",
        "name": "ast.CommentGroup.Pos",
        "params": [],
        "path": "go/go/ast/index#CommentGroup.Pos",
        "syntax": "func (g *CommentGroup) Pos() token.Pos",
        "type": "go"
    },
    "ast.CommentGroup.Text": {
        "descr": "Text returns the text of the comment. Comment markers (//, /*, and */), the first space of a line comment, and leading and trailing empty lines are removed. Multiple empty lines are reduced to one, and trailing space on lines is trimmed. Unless the result is empty, it is newline-terminated.",
        "name": "ast.CommentGroup.Text",
        "params": [],
        "path": "go/go/ast/index#CommentGroup.Text",
        "syntax": "func (g *CommentGroup) Text() string",
        "type": "go"
    },
    "ast.CommentMap": {
        "descr": "A CommentMap maps an AST node to a list of comment groups associated with it. See NewCommentMap for a description of the association.",
        "name": "ast.CommentMap",
        "params": [],
        "path": "go/go/ast/index#CommentMap",
        "syntax": "type CommentMap map[Node][]*CommentGroup",
        "type": "go"
    },
    "ast.CommentMap.Comments": {
        "descr": "Comments returns the list of comment groups in the comment map. The result is sorted in source order.",
        "name": "ast.CommentMap.Comments",
        "params": [],
        "path": "go/go/ast/index#CommentMap.Comments",
        "syntax": "func (cmap CommentMap) Comments() []*CommentGroup",
        "type": "go"
    },
    "ast.CommentMap.Filter": {
        "descr": "Filter returns a new comment map consisting of only those entries of cmap for which a corresponding node exists in the AST specified by node.",
        "name": "ast.CommentMap.Filter",
        "params": [],
        "path": "go/go/ast/index#CommentMap.Filter",
        "syntax": "func (cmap CommentMap) Filter(node Node) CommentMap",
        "type": "go"
    },
    "ast.CommentMap.String": {
        "descr": "",
        "name": "ast.CommentMap.String",
        "params": [],
        "path": "go/go/ast/index#CommentMap.String",
        "syntax": "func (cmap CommentMap) String() string",
        "type": "go"
    },
    "ast.CommentMap.Update": {
        "descr": "Update replaces an old node in the comment map with the new node and returns the new node. Comments that were associated with the old node are associated with the new node.",
        "name": "ast.CommentMap.Update",
        "params": [],
        "path": "go/go/ast/index#CommentMap.Update",
        "syntax": "func (cmap CommentMap) Update(old, new Node) Node",
        "type": "go"
    },
    "ast.CompositeLit": {
        "descr": "A CompositeLit node represents a composite literal.",
        "name": "ast.CompositeLit",
        "params": [],
        "path": "go/go/ast/index#CompositeLit",
        "syntax": "type CompositeLit struct { Type Expr // literal type; or nil Lbrace token.Pos // position of \"{\" Elts []Expr // list of composite elements; or nil Rbrace token.Pos // position of \"}\" Incomplete bool // true if (source) expressions are missing in the Elts list; added in Go 1.11 }",
        "type": "go"
    },
    "ast.CompositeLit.End": {
        "descr": "",
        "name": "ast.CompositeLit.End",
        "params": [],
        "path": "go/go/ast/index#CompositeLit.End",
        "syntax": "func (x *CompositeLit) End() token.Pos",
        "type": "go"
    },
    "ast.CompositeLit.Pos": {
        "descr": "",
        "name": "ast.CompositeLit.Pos",
        "params": [],
        "path": "go/go/ast/index#CompositeLit.Pos",
        "syntax": "func (x *CompositeLit) Pos() token.Pos",
        "type": "go"
    },
    "ast.Decl": {
        "descr": "All declaration nodes implement the Decl interface.",
        "name": "ast.Decl",
        "params": [],
        "path": "go/go/ast/index#Decl",
        "syntax": "type Decl interface { Node // contains filtered or unexported methods }",
        "type": "go"
    },
    "ast.DeclStmt": {
        "descr": "A DeclStmt node represents a declaration in a statement list.",
        "name": "ast.DeclStmt",
        "params": [],
        "path": "go/go/ast/index#DeclStmt",
        "syntax": "type DeclStmt struct { Decl Decl // *GenDecl with CONST, TYPE, or VAR token }",
        "type": "go"
    },
    "ast.DeclStmt.End": {
        "descr": "",
        "name": "ast.DeclStmt.End",
        "params": [],
        "path": "go/go/ast/index#DeclStmt.End",
        "syntax": "func (s *DeclStmt) End() token.Pos",
        "type": "go"
    },
    "ast.DeclStmt.Pos": {
        "descr": "",
        "name": "ast.DeclStmt.Pos",
        "params": [],
        "path": "go/go/ast/index#DeclStmt.Pos",
        "syntax": "func (s *DeclStmt) Pos() token.Pos",
        "type": "go"
    },
    "ast.DeferStmt": {
        "descr": "A DeferStmt node represents a defer statement.",
        "name": "ast.DeferStmt",
        "params": [],
        "path": "go/go/ast/index#DeferStmt",
        "syntax": "type DeferStmt struct { Defer token.Pos // position of \"defer\" keyword Call *CallExpr }",
        "type": "go"
    },
    "ast.DeferStmt.End": {
        "descr": "",
        "name": "ast.DeferStmt.End",
        "params": [],
        "path": "go/go/ast/index#DeferStmt.End",
        "syntax": "func (s *DeferStmt) End() token.Pos",
        "type": "go"
    },
    "ast.DeferStmt.Pos": {
        "descr": "",
        "name": "ast.DeferStmt.Pos",
        "params": [],
        "path": "go/go/ast/index#DeferStmt.Pos",
        "syntax": "func (s *DeferStmt) Pos() token.Pos",
        "type": "go"
    },
    "ast.Ellipsis": {
        "descr": "An Ellipsis node stands for the \"...\" type in a parameter list or the \"...\" length in an array type.",
        "name": "ast.Ellipsis",
        "params": [],
        "path": "go/go/ast/index#Ellipsis",
        "syntax": "type Ellipsis struct { Ellipsis token.Pos // position of \"...\" Elt Expr // ellipsis element type (parameter lists only);\n or  or nil });",
        "type": "go"
    },
    "ast.Ellipsis.End": {
        "descr": "",
        "name": "ast.Ellipsis.End",
        "params": [],
        "path": "go/go/ast/index#Ellipsis.End",
        "syntax": "func (x *Ellipsis) End() token.Pos",
        "type": "go"
    },
    "ast.Ellipsis.Pos": {
        "descr": "",
        "name": "ast.Ellipsis.Pos",
        "params": [],
        "path": "go/go/ast/index#Ellipsis.Pos",
        "syntax": "func (x *Ellipsis) Pos() token.Pos",
        "type": "go"
    },
    "ast.EmptyStmt": {
        "descr": "An EmptyStmt node represents an empty statement. The \"position\" of the empty statement is the position of the immediately following (explicit or implicit) semicolon.",
        "name": "ast.EmptyStmt",
        "params": [],
        "path": "go/go/ast/index#EmptyStmt",
        "syntax": "type EmptyStmt struct { Semicolon token.Pos // position of following \";\" Implicit bool // if set, \";\" was omitted in the source; added in Go 1.5 }",
        "type": "go"
    },
    "ast.EmptyStmt.End": {
        "descr": "",
        "name": "ast.EmptyStmt.End",
        "params": [],
        "path": "go/go/ast/index#EmptyStmt.End",
        "syntax": "func (s *EmptyStmt) End() token.Pos",
        "type": "go"
    },
    "ast.EmptyStmt.Pos": {
        "descr": "",
        "name": "ast.EmptyStmt.Pos",
        "params": [],
        "path": "go/go/ast/index#EmptyStmt.Pos",
        "syntax": "func (s *EmptyStmt) Pos() token.Pos",
        "type": "go"
    },
    "ast.Expr": {
        "descr": "All expression nodes implement the Expr interface.",
        "name": "ast.Expr",
        "params": [],
        "path": "go/go/ast/index#Expr",
        "syntax": "type Expr interface { Node // contains filtered or unexported methods }",
        "type": "go"
    },
    "ast.ExprStmt": {
        "descr": "An ExprStmt node represents a (stand-alone) expression in a statement list.",
        "name": "ast.ExprStmt",
        "params": [],
        "path": "go/go/ast/index#ExprStmt",
        "syntax": "type ExprStmt struct { X Expr // expression }",
        "type": "go"
    },
    "ast.ExprStmt.End": {
        "descr": "",
        "name": "ast.ExprStmt.End",
        "params": [],
        "path": "go/go/ast/index#ExprStmt.End",
        "syntax": "func (s *ExprStmt) End() token.Pos",
        "type": "go"
    },
    "ast.ExprStmt.Pos": {
        "descr": "",
        "name": "ast.ExprStmt.Pos",
        "params": [],
        "path": "go/go/ast/index#ExprStmt.Pos",
        "syntax": "func (s *ExprStmt) Pos() token.Pos",
        "type": "go"
    },
    "ast.Field": {
        "descr": "A Field represents a Field declaration list in a struct type, a method list in an interface type, or a parameter/result declaration in a signature. Field.Names is nil for unnamed parameters (parameter lists which only contain types) and embedded struct fields. In the latter case, the field name is the type name.",
        "name": "ast.Field",
        "params": [],
        "path": "go/go/ast/index#Field",
        "syntax": "type Field struct { Doc *CommentGroup // associated documentation; or nil Names []*Ident // field/method/parameter names; or nil Type Expr // field/method/parameter type Tag *BasicLit // field tag; or nil Comment *CommentGroup // line comments; or nil }",
        "type": "go"
    },
    "ast.Field.End": {
        "descr": "",
        "name": "ast.Field.End",
        "params": [],
        "path": "go/go/ast/index#Field.End",
        "syntax": "func (f *Field) End() token.Pos",
        "type": "go"
    },
    "ast.Field.Pos": {
        "descr": "",
        "name": "ast.Field.Pos",
        "params": [],
        "path": "go/go/ast/index#Field.Pos",
        "syntax": "func (f *Field) Pos() token.Pos",
        "type": "go"
    },
    "ast.FieldFilter": {
        "descr": "A FieldFilter may be provided to Fprint to control the output.",
        "name": "ast.FieldFilter",
        "params": [],
        "path": "go/go/ast/index#FieldFilter",
        "syntax": "type FieldFilter func(name string, value reflect.Value) bool",
        "type": "go"
    },
    "ast.FieldList": {
        "descr": "A FieldList represents a list of Fields, enclosed by parentheses or braces.",
        "name": "ast.FieldList",
        "params": [],
        "path": "go/go/ast/index#FieldList",
        "syntax": "type FieldList struct { Opening token.Pos // position of opening parenthesis/brace, if any List []*Field // field list; or nil Closing token.Pos // position of closing parenthesis/brace, if any }",
        "type": "go"
    },
    "ast.FieldList.End": {
        "descr": "",
        "name": "ast.FieldList.End",
        "params": [],
        "path": "go/go/ast/index#FieldList.End",
        "syntax": "func (f *FieldList) End() token.Pos",
        "type": "go"
    },
    "ast.FieldList.NumFields": {
        "descr": "NumFields returns the number of parameters or struct fields represented by a FieldList.",
        "name": "ast.FieldList.NumFields",
        "params": [],
        "path": "go/go/ast/index#FieldList.NumFields",
        "syntax": "func (f *FieldList) NumFields() int",
        "type": "go"
    },
    "ast.FieldList.Pos": {
        "descr": "",
        "name": "ast.FieldList.Pos",
        "params": [],
        "path": "go/go/ast/index#FieldList.Pos",
        "syntax": "func (f *FieldList) Pos() token.Pos",
        "type": "go"
    },
    "ast.File": {
        "descr": "A File node represents a Go source file.",
        "name": "ast.File",
        "params": [],
        "path": "go/go/ast/index#File",
        "syntax": "type File struct { Doc *CommentGroup // associated documentation; or nil Package token.Pos // position of \"package\" keyword Name *Ident // package name Decls []Decl // top-level declarations; or nil Scope *Scope // package scope (this file only) Imports []*ImportSpec // imports in this file Unresolved []*Ident // unresolved identifiers in this file Comments []*CommentGroup // list of all comments in the source file }",
        "type": "go"
    },
    "ast.File.End": {
        "descr": "",
        "name": "ast.File.End",
        "params": [],
        "path": "go/go/ast/index#File.End",
        "syntax": "func (f *File) End() token.Pos",
        "type": "go"
    },
    "ast.File.Pos": {
        "descr": "",
        "name": "ast.File.Pos",
        "params": [],
        "path": "go/go/ast/index#File.Pos",
        "syntax": "func (f *File) Pos() token.Pos",
        "type": "go"
    },
    "ast.FileExports": {
        "descr": "FileExports trims the AST for a Go source file in place such that only exported nodes remain: all top-level identifiers which are not exported and their associated information (such as type, initial value, or function body) are removed. Non-exported fields and methods of exported types are stripped. The File.Comments list is not changed.",
        "name": "ast.FileExports",
        "params": [],
        "path": "go/go/ast/index#FileExports",
        "syntax": "func FileExports(src *File) bool",
        "type": "go"
    },
    "ast.Filter": {
        "descr": "",
        "name": "ast.Filter",
        "params": [],
        "path": "go/go/ast/index#Filter",
        "syntax": "type Filter func(string) bool",
        "type": "go"
    },
    "ast.FilterDecl": {
        "descr": "FilterDecl trims the AST for a Go declaration in place by removing all names (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f.",
        "name": "ast.FilterDecl",
        "params": [],
        "path": "go/go/ast/index#FilterDecl",
        "syntax": "func FilterDecl(decl Decl, f Filter) bool",
        "type": "go"
    },
    "ast.FilterFile": {
        "descr": "FilterFile trims the AST for a Go file in place by removing all names from top-level declarations (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. If the declaration is empty afterwards, the declaration is removed from the AST. Import declarations are always removed. The File.Comments list is not changed.",
        "name": "ast.FilterFile",
        "params": [],
        "path": "go/go/ast/index#FilterFile",
        "syntax": "func FilterFile(src *File, f Filter) bool",
        "type": "go"
    },
    "ast.FilterPackage": {
        "descr": "FilterPackage trims the AST for a Go package in place by removing all names from top-level declarations (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. If the declaration is empty afterwards, the declaration is removed from the AST. The pkg.Files list is not changed, so that file names and top-level package comments don't get lost.",
        "name": "ast.FilterPackage",
        "params": [],
        "path": "go/go/ast/index#FilterPackage",
        "syntax": "func FilterPackage(pkg *Package, f Filter) bool",
        "type": "go"
    },
    "ast.ForStmt": {
        "descr": "A ForStmt represents a for statement.",
        "name": "ast.ForStmt",
        "params": [],
        "path": "go/go/ast/index#ForStmt",
        "syntax": "type ForStmt struct { For token.Pos // position of \"for\" keyword Init Stmt // initialization statement; or nil Cond Expr // condition; or nil Post Stmt // post iteration statement; or nil Body *BlockStmt }",
        "type": "go"
    },
    "ast.ForStmt.End": {
        "descr": "",
        "name": "ast.ForStmt.End",
        "params": [],
        "path": "go/go/ast/index#ForStmt.End",
        "syntax": "func (s *ForStmt) End() token.Pos",
        "type": "go"
    },
    "ast.ForStmt.Pos": {
        "descr": "",
        "name": "ast.ForStmt.Pos",
        "params": [],
        "path": "go/go/ast/index#ForStmt.Pos",
        "syntax": "func (s *ForStmt) Pos() token.Pos",
        "type": "go"
    },
    "ast.Fprint": {
        "descr": "Fprint prints the (sub-)tree starting at AST node x to w. If fset != nil, position information is interpreted relative to that file set. Otherwise positions are printed as integer values (file set specific offsets).",
        "name": "ast.Fprint",
        "params": [],
        "path": "go/go/ast/index#Fprint",
        "syntax": "func Fprint(w io.Writer, fset *token.FileSet, x interface{}, f FieldFilter) error",
        "type": "go"
    },
    "ast.FuncDecl": {
        "descr": "A FuncDecl node represents a function declaration.",
        "name": "ast.FuncDecl",
        "params": [],
        "path": "go/go/ast/index#FuncDecl",
        "syntax": "type FuncDecl struct { Doc *CommentGroup // associated documentation; or nil Recv *FieldList // receiver (methods);\n or  or nil (functions) Name *Ident // function/method name Type *FuncType // function signature: parameters, results, and position of \"func\" keyword Body *BlockStmt // function body; or nil for external (non-Go) function });",
        "type": "go"
    },
    "ast.FuncDecl.End": {
        "descr": "",
        "name": "ast.FuncDecl.End",
        "params": [],
        "path": "go/go/ast/index#FuncDecl.End",
        "syntax": "func (d *FuncDecl) End() token.Pos",
        "type": "go"
    },
    "ast.FuncDecl.Pos": {
        "descr": "",
        "name": "ast.FuncDecl.Pos",
        "params": [],
        "path": "go/go/ast/index#FuncDecl.Pos",
        "syntax": "func (d *FuncDecl) Pos() token.Pos",
        "type": "go"
    },
    "ast.FuncLit": {
        "descr": "A FuncLit node represents a function literal.",
        "name": "ast.FuncLit",
        "params": [],
        "path": "go/go/ast/index#FuncLit",
        "syntax": "type FuncLit struct { Type *FuncType // function type Body *BlockStmt // function body }",
        "type": "go"
    },
    "ast.FuncLit.End": {
        "descr": "",
        "name": "ast.FuncLit.End",
        "params": [],
        "path": "go/go/ast/index#FuncLit.End",
        "syntax": "func (x *FuncLit) End() token.Pos",
        "type": "go"
    },
    "ast.FuncLit.Pos": {
        "descr": "",
        "name": "ast.FuncLit.Pos",
        "params": [],
        "path": "go/go/ast/index#FuncLit.Pos",
        "syntax": "func (x *FuncLit) Pos() token.Pos",
        "type": "go"
    },
    "ast.FuncType": {
        "descr": "A FuncType node represents a function type.",
        "name": "ast.FuncType",
        "params": [],
        "path": "go/go/ast/index#FuncType",
        "syntax": "type FuncType struct { Func token.Pos // position of \"func\" keyword (token.NoPos if there is no \"func\") Params *FieldList // (incoming) parameters; non-nil Results *FieldList // (outgoing) results; or nil }",
        "type": "go"
    },
    "ast.FuncType.End": {
        "descr": "",
        "name": "ast.FuncType.End",
        "params": [],
        "path": "go/go/ast/index#FuncType.End",
        "syntax": "func (x *FuncType) End() token.Pos",
        "type": "go"
    },
    "ast.FuncType.Pos": {
        "descr": "",
        "name": "ast.FuncType.Pos",
        "params": [],
        "path": "go/go/ast/index#FuncType.Pos",
        "syntax": "func (x *FuncType) Pos() token.Pos",
        "type": "go"
    },
    "ast.GenDecl": {
        "descr": "A GenDecl node (generic declaration node) represents an import, constant, type or variable declaration. A valid Lparen position (Lparen.IsValid()) indicates a parenthesized declaration.",
        "name": "ast.GenDecl",
        "params": [],
        "path": "go/go/ast/index#GenDecl",
        "syntax": "token.IMPORT *ImportSpec token.CONST *ValueSpec token.TYPE *TypeSpec token.VAR *ValueSpec",
        "type": "go"
    },
    "ast.GenDecl.End": {
        "descr": "",
        "name": "ast.GenDecl.End",
        "params": [],
        "path": "go/go/ast/index#GenDecl.End",
        "syntax": "func (d *GenDecl) End() token.Pos",
        "type": "go"
    },
    "ast.GenDecl.Pos": {
        "descr": "",
        "name": "ast.GenDecl.Pos",
        "params": [],
        "path": "go/go/ast/index#GenDecl.Pos",
        "syntax": "func (d *GenDecl) Pos() token.Pos",
        "type": "go"
    },
    "ast.GoStmt": {
        "descr": "A GoStmt node represents a go statement.",
        "name": "ast.GoStmt",
        "params": [],
        "path": "go/go/ast/index#GoStmt",
        "syntax": "type GoStmt struct { Go token.Pos // position of \"go\" keyword Call *CallExpr }",
        "type": "go"
    },
    "ast.GoStmt.End": {
        "descr": "",
        "name": "ast.GoStmt.End",
        "params": [],
        "path": "go/go/ast/index#GoStmt.End",
        "syntax": "func (s *GoStmt) End() token.Pos",
        "type": "go"
    },
    "ast.GoStmt.Pos": {
        "descr": "",
        "name": "ast.GoStmt.Pos",
        "params": [],
        "path": "go/go/ast/index#GoStmt.Pos",
        "syntax": "func (s *GoStmt) Pos() token.Pos",
        "type": "go"
    },
    "ast.Ident": {
        "descr": "An Ident node represents an identifier.",
        "name": "ast.Ident",
        "params": [],
        "path": "go/go/ast/index#Ident",
        "syntax": "type Ident struct { NamePos token.Pos // identifier position Name string // identifier name Obj *Object // denoted object; or nil }",
        "type": "go"
    },
    "ast.Ident.End": {
        "descr": "",
        "name": "ast.Ident.End",
        "params": [],
        "path": "go/go/ast/index#Ident.End",
        "syntax": "func (x *Ident) End() token.Pos",
        "type": "go"
    },
    "ast.Ident.IsExported": {
        "descr": "IsExported reports whether id is an exported Go symbol (that is, whether it begins with an uppercase letter).",
        "name": "ast.Ident.IsExported",
        "params": [],
        "path": "go/go/ast/index#Ident.IsExported",
        "syntax": "func (id *Ident) IsExported() bool",
        "type": "go"
    },
    "ast.Ident.Pos": {
        "descr": "",
        "name": "ast.Ident.Pos",
        "params": [],
        "path": "go/go/ast/index#Ident.Pos",
        "syntax": "func (x *Ident) Pos() token.Pos",
        "type": "go"
    },
    "ast.Ident.String": {
        "descr": "",
        "name": "ast.Ident.String",
        "params": [],
        "path": "go/go/ast/index#Ident.String",
        "syntax": "func (id *Ident) String() string",
        "type": "go"
    },
    "ast.IfStmt": {
        "descr": "An IfStmt node represents an if statement.",
        "name": "ast.IfStmt",
        "params": [],
        "path": "go/go/ast/index#IfStmt",
        "syntax": "type IfStmt struct { If token.Pos // position of \"if\" keyword Init Stmt // initialization statement; or nil Cond Expr // condition Body *BlockStmt Else Stmt // else branch; or nil }",
        "type": "go"
    },
    "ast.IfStmt.End": {
        "descr": "",
        "name": "ast.IfStmt.End",
        "params": [],
        "path": "go/go/ast/index#IfStmt.End",
        "syntax": "func (s *IfStmt) End() token.Pos",
        "type": "go"
    },
    "ast.IfStmt.Pos": {
        "descr": "",
        "name": "ast.IfStmt.Pos",
        "params": [],
        "path": "go/go/ast/index#IfStmt.Pos",
        "syntax": "func (s *IfStmt) Pos() token.Pos",
        "type": "go"
    },
    "ast.ImportSpec": {
        "descr": "An ImportSpec node represents a single package import.",
        "name": "ast.ImportSpec",
        "params": [],
        "path": "go/go/ast/index#ImportSpec",
        "syntax": "type ImportSpec struct { Doc *CommentGroup // associated documentation; or nil Name *Ident // local package name (including \".\");\n or  or nil Path *BasicLit // import path Comment *CommentGroup // line comments; or nil EndPos token.Pos // end of spec (overrides Path.Pos if nonzero) });",
        "type": "go"
    },
    "ast.ImportSpec.End": {
        "descr": "",
        "name": "ast.ImportSpec.End",
        "params": [],
        "path": "go/go/ast/index#ImportSpec.End",
        "syntax": "func (s *ImportSpec) End() token.Pos",
        "type": "go"
    },
    "ast.ImportSpec.Pos": {
        "descr": "",
        "name": "ast.ImportSpec.Pos",
        "params": [],
        "path": "go/go/ast/index#ImportSpec.Pos",
        "syntax": "func (s *ImportSpec) Pos() token.Pos",
        "type": "go"
    },
    "ast.Importer": {
        "descr": "An Importer resolves import paths to package Objects. The imports map records the packages already imported, indexed by package id (canonical import path). An Importer must determine the canonical import path and check the map to see if it is already present in the imports map. If so, the Importer can return the map entry. Otherwise, the Importer should load the package data for the given path into a new *Object (pkg), record pkg in the imports map, and then return pkg.",
        "name": "ast.Importer",
        "params": [],
        "path": "go/go/ast/index#Importer",
        "syntax": "type Importer func(imports map[string]*Object, path string) (pkg *Object, err error)",
        "type": "go"
    },
    "ast.IncDecStmt": {
        "descr": "An IncDecStmt node represents an increment or decrement statement.",
        "name": "ast.IncDecStmt",
        "params": [],
        "path": "go/go/ast/index#IncDecStmt",
        "syntax": "type IncDecStmt struct { X Expr TokPos token.Pos // position of Tok Tok token.Token // INC or DEC }",
        "type": "go"
    },
    "ast.IncDecStmt.End": {
        "descr": "",
        "name": "ast.IncDecStmt.End",
        "params": [],
        "path": "go/go/ast/index#IncDecStmt.End",
        "syntax": "func (s *IncDecStmt) End() token.Pos",
        "type": "go"
    },
    "ast.IncDecStmt.Pos": {
        "descr": "",
        "name": "ast.IncDecStmt.Pos",
        "params": [],
        "path": "go/go/ast/index#IncDecStmt.Pos",
        "syntax": "func (s *IncDecStmt) Pos() token.Pos",
        "type": "go"
    },
    "ast.IndexExpr": {
        "descr": "An IndexExpr node represents an expression followed by an index.",
        "name": "ast.IndexExpr",
        "params": [],
        "path": "go/go/ast/index#IndexExpr",
        "syntax": "type IndexExpr struct { X Expr // expression Lbrack token.Pos // position of \"[\" Index Expr // index expression Rbrack token.Pos // position of \"]\" }",
        "type": "go"
    },
    "ast.IndexExpr.End": {
        "descr": "",
        "name": "ast.IndexExpr.End",
        "params": [],
        "path": "go/go/ast/index#IndexExpr.End",
        "syntax": "func (x *IndexExpr) End() token.Pos",
        "type": "go"
    },
    "ast.IndexExpr.Pos": {
        "descr": "",
        "name": "ast.IndexExpr.Pos",
        "params": [],
        "path": "go/go/ast/index#IndexExpr.Pos",
        "syntax": "func (x *IndexExpr) Pos() token.Pos",
        "type": "go"
    },
    "ast.Inspect": {
        "descr": "Inspect traverses an AST in depth-first order: It starts by calling f(node); node must not be nil. If f returns true, Inspect invokes f recursively for each of the non-nil children of node, followed by a call of f(nil).",
        "name": "ast.Inspect",
        "params": [],
        "path": "go/go/ast/index#Inspect",
        "syntax": "func Inspect(node Node, f func(Node) bool)",
        "type": "go"
    },
    "ast.InterfaceType": {
        "descr": "An InterfaceType node represents an interface type.",
        "name": "ast.InterfaceType",
        "params": [],
        "path": "go/go/ast/index#InterfaceType",
        "syntax": "type InterfaceType struct { Interface token.Pos // position of \"interface\" keyword Methods *FieldList // list of methods Incomplete bool // true if (source) methods are missing in the Methods list }",
        "type": "go"
    },
    "ast.InterfaceType.End": {
        "descr": "",
        "name": "ast.InterfaceType.End",
        "params": [],
        "path": "go/go/ast/index#InterfaceType.End",
        "syntax": "func (x *InterfaceType) End() token.Pos",
        "type": "go"
    },
    "ast.InterfaceType.Pos": {
        "descr": "",
        "name": "ast.InterfaceType.Pos",
        "params": [],
        "path": "go/go/ast/index#InterfaceType.Pos",
        "syntax": "func (x *InterfaceType) Pos() token.Pos",
        "type": "go"
    },
    "ast.IsExported": {
        "descr": "IsExported reports whether name is an exported Go symbol (that is, whether it begins with an upper-case letter).",
        "name": "ast.IsExported",
        "params": [],
        "path": "go/go/ast/index#IsExported",
        "syntax": "func IsExported(name string) bool",
        "type": "go"
    },
    "ast.KeyValueExpr": {
        "descr": "A KeyValueExpr node represents (key : value) pairs in composite literals.",
        "name": "ast.KeyValueExpr",
        "params": [],
        "path": "go/go/ast/index#KeyValueExpr",
        "syntax": "type KeyValueExpr struct { Key Expr Colon token.Pos // position of \":\" Value Expr }",
        "type": "go"
    },
    "ast.KeyValueExpr.End": {
        "descr": "",
        "name": "ast.KeyValueExpr.End",
        "params": [],
        "path": "go/go/ast/index#KeyValueExpr.End",
        "syntax": "func (x *KeyValueExpr) End() token.Pos",
        "type": "go"
    },
    "ast.KeyValueExpr.Pos": {
        "descr": "",
        "name": "ast.KeyValueExpr.Pos",
        "params": [],
        "path": "go/go/ast/index#KeyValueExpr.Pos",
        "syntax": "func (x *KeyValueExpr) Pos() token.Pos",
        "type": "go"
    },
    "ast.LabeledStmt": {
        "descr": "A LabeledStmt node represents a labeled statement.",
        "name": "ast.LabeledStmt",
        "params": [],
        "path": "go/go/ast/index#LabeledStmt",
        "syntax": "type LabeledStmt struct { Label *Ident Colon token.Pos // position of \":\" Stmt Stmt }",
        "type": "go"
    },
    "ast.LabeledStmt.End": {
        "descr": "",
        "name": "ast.LabeledStmt.End",
        "params": [],
        "path": "go/go/ast/index#LabeledStmt.End",
        "syntax": "func (s *LabeledStmt) End() token.Pos",
        "type": "go"
    },
    "ast.LabeledStmt.Pos": {
        "descr": "",
        "name": "ast.LabeledStmt.Pos",
        "params": [],
        "path": "go/go/ast/index#LabeledStmt.Pos",
        "syntax": "func (s *LabeledStmt) Pos() token.Pos",
        "type": "go"
    },
    "ast.MapType": {
        "descr": "A MapType node represents a map type.",
        "name": "ast.MapType",
        "params": [],
        "path": "go/go/ast/index#MapType",
        "syntax": "type MapType struct { Map token.Pos // position of \"map\" keyword Key Expr Value Expr }",
        "type": "go"
    },
    "ast.MapType.End": {
        "descr": "",
        "name": "ast.MapType.End",
        "params": [],
        "path": "go/go/ast/index#MapType.End",
        "syntax": "func (x *MapType) End() token.Pos",
        "type": "go"
    },
    "ast.MapType.Pos": {
        "descr": "",
        "name": "ast.MapType.Pos",
        "params": [],
        "path": "go/go/ast/index#MapType.Pos",
        "syntax": "func (x *MapType) Pos() token.Pos",
        "type": "go"
    },
    "ast.MergeMode": {
        "descr": "The MergeMode flags control the behavior of MergePackageFiles.",
        "name": "ast.MergeMode",
        "params": [],
        "path": "go/go/ast/index#MergeMode",
        "syntax": "type MergeMode uint",
        "type": "go"
    },
    "ast.MergePackageFiles": {
        "descr": "MergePackageFiles creates a file AST by merging the ASTs of the files belonging to a package. The mode flags control merging behavior.",
        "name": "ast.MergePackageFiles",
        "params": [],
        "path": "go/go/ast/index#MergePackageFiles",
        "syntax": "func MergePackageFiles(pkg *Package, mode MergeMode) *File",
        "type": "go"
    },
    "ast.NewCommentMap": {
        "descr": "NewCommentMap creates a new comment map by associating comment groups of the comments list with the nodes of the AST specified by node.",
        "name": "ast.NewCommentMap",
        "params": [],
        "path": "go/go/ast/index#NewCommentMap",
        "syntax": "func NewCommentMap(fset *token.FileSet, node Node, comments []*CommentGroup) CommentMap",
        "type": "go"
    },
    "ast.NewIdent": {
        "descr": "NewIdent creates a new Ident without position. Useful for ASTs generated by code other than the Go parser.",
        "name": "ast.NewIdent",
        "params": [],
        "path": "go/go/ast/index#NewIdent",
        "syntax": "func NewIdent(name string) *Ident",
        "type": "go"
    },
    "ast.NewObj": {
        "descr": "NewObj creates a new object of a given kind and name.",
        "name": "ast.NewObj",
        "params": [],
        "path": "go/go/ast/index#NewObj",
        "syntax": "func NewObj(kind ObjKind, name string) *Object",
        "type": "go"
    },
    "ast.NewPackage": {
        "descr": "NewPackage creates a new Package node from a set of File nodes. It resolves unresolved identifiers across files and updates each file's Unresolved list accordingly. If a non-nil importer and universe scope are provided, they are used to resolve identifiers not declared in any of the package files. Any remaining unresolved identifiers are reported as undeclared. If the files belong to different packages, one package name is selected and files with different package names are reported and then ignored. The result is a package node and a scanner.ErrorList if there were errors.",
        "name": "ast.NewPackage",
        "params": [],
        "path": "go/go/ast/index#NewPackage",
        "syntax": "func NewPackage(fset *token.FileSet, files map[string]*File, importer Importer, universe *Scope) (*Package, error)",
        "type": "go"
    },
    "ast.NewScope": {
        "descr": "NewScope creates a new scope nested in the outer scope.",
        "name": "ast.NewScope",
        "params": [],
        "path": "go/go/ast/index#NewScope",
        "syntax": "func NewScope(outer *Scope) *Scope",
        "type": "go"
    },
    "ast.Node": {
        "descr": "All node types implement the Node interface.",
        "name": "ast.Node",
        "params": [],
        "path": "go/go/ast/index#Node",
        "syntax": "type Node interface { Pos() token.Pos // position of first character belonging to the node End() token.Pos // position of first character immediately after the node }",
        "type": "go"
    },
    "ast.NotNilFilter": {
        "descr": "NotNilFilter returns true for field values that are not nil; it returns false otherwise.",
        "name": "ast.NotNilFilter",
        "params": [],
        "path": "go/go/ast/index#NotNilFilter",
        "syntax": "func NotNilFilter(_ string, v reflect.Value) bool",
        "type": "go"
    },
    "ast.ObjKind": {
        "descr": "ObjKind describes what an object represents.",
        "name": "ast.ObjKind",
        "params": [],
        "path": "go/go/ast/index#ObjKind",
        "syntax": "type ObjKind int",
        "type": "go"
    },
    "ast.ObjKind.String": {
        "descr": "",
        "name": "ast.ObjKind.String",
        "params": [],
        "path": "go/go/ast/index#ObjKind.String",
        "syntax": "func (kind ObjKind) String() string",
        "type": "go"
    },
    "ast.Object": {
        "descr": "An Object describes a named language entity such as a package, constant, type, variable, function (incl. methods), or label.",
        "name": "ast.Object",
        "params": [],
        "path": "go/go/ast/index#Object",
        "syntax": "Kind Data type Data value Pkg *Scope package scope Con int iota for the respective declaration",
        "type": "go"
    },
    "ast.Object.Pos": {
        "descr": "Pos computes the source position of the declaration of an object name. The result may be an invalid position if it cannot be computed (obj.Decl may be nil or not correct).",
        "name": "ast.Object.Pos",
        "params": [],
        "path": "go/go/ast/index#Object.Pos",
        "syntax": "func (obj *Object) Pos() token.Pos",
        "type": "go"
    },
    "ast.Package": {
        "descr": "A Package node represents a set of source files collectively building a Go package.",
        "name": "ast.Package",
        "params": [],
        "path": "go/go/ast/index#Package",
        "syntax": "type Package struct { Name string // package name Scope *Scope // package scope across all files Imports map[string]*Object // map of package id -> package object Files map[string]*File // Go source files by filename }",
        "type": "go"
    },
    "ast.Package.End": {
        "descr": "",
        "name": "ast.Package.End",
        "params": [],
        "path": "go/go/ast/index#Package.End",
        "syntax": "func (p *Package) End() token.Pos",
        "type": "go"
    },
    "ast.Package.Pos": {
        "descr": "",
        "name": "ast.Package.Pos",
        "params": [],
        "path": "go/go/ast/index#Package.Pos",
        "syntax": "func (p *Package) Pos() token.Pos",
        "type": "go"
    },
    "ast.PackageExports": {
        "descr": "PackageExports trims the AST for a Go package in place such that only exported nodes remain. The pkg.Files list is not changed, so that file names and top-level package comments don't get lost.",
        "name": "ast.PackageExports",
        "params": [],
        "path": "go/go/ast/index#PackageExports",
        "syntax": "func PackageExports(pkg *Package) bool",
        "type": "go"
    },
    "ast.ParenExpr": {
        "descr": "A ParenExpr node represents a parenthesized expression.",
        "name": "ast.ParenExpr",
        "params": [],
        "path": "go/go/ast/index#ParenExpr",
        "syntax": "type ParenExpr struct { Lparen token.Pos // position of \"(\" X Expr // parenthesized expression Rparen token.Pos // position of \")\" }",
        "type": "go"
    },
    "ast.ParenExpr.End": {
        "descr": "",
        "name": "ast.ParenExpr.End",
        "params": [],
        "path": "go/go/ast/index#ParenExpr.End",
        "syntax": "func (x *ParenExpr) End() token.Pos",
        "type": "go"
    },
    "ast.ParenExpr.Pos": {
        "descr": "",
        "name": "ast.ParenExpr.Pos",
        "params": [],
        "path": "go/go/ast/index#ParenExpr.Pos",
        "syntax": "func (x *ParenExpr) Pos() token.Pos",
        "type": "go"
    },
    "ast.Print": {
        "descr": "Print prints x to standard output, skipping nil fields. Print(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter).",
        "name": "ast.Print",
        "params": [],
        "path": "go/go/ast/index#Print",
        "syntax": "func Print(fset *token.FileSet, x interface{}) error",
        "type": "go"
    },
    "ast.RangeStmt": {
        "descr": "A RangeStmt represents a for statement with a range clause.",
        "name": "ast.RangeStmt",
        "params": [],
        "path": "go/go/ast/index#RangeStmt",
        "syntax": "type RangeStmt struct { For token.Pos // position of \"for\" keyword Key, Value Expr // Key, Value may be nil TokPos token.Pos // position of Tok; invalid if Key == nil Tok token.Token // ILLEGAL if Key == nil, ASSIGN, DEFINE X Expr // value to range over Body *BlockStmt }",
        "type": "go"
    },
    "ast.RangeStmt.End": {
        "descr": "",
        "name": "ast.RangeStmt.End",
        "params": [],
        "path": "go/go/ast/index#RangeStmt.End",
        "syntax": "func (s *RangeStmt) End() token.Pos",
        "type": "go"
    },
    "ast.RangeStmt.Pos": {
        "descr": "",
        "name": "ast.RangeStmt.Pos",
        "params": [],
        "path": "go/go/ast/index#RangeStmt.Pos",
        "syntax": "func (s *RangeStmt) Pos() token.Pos",
        "type": "go"
    },
    "ast.ReturnStmt": {
        "descr": "A ReturnStmt node represents a return statement.",
        "name": "ast.ReturnStmt",
        "params": [],
        "path": "go/go/ast/index#ReturnStmt",
        "syntax": "type ReturnStmt struct { Return token.Pos // position of \"return\" keyword Results []Expr // result expressions; or nil }",
        "type": "go"
    },
    "ast.ReturnStmt.End": {
        "descr": "",
        "name": "ast.ReturnStmt.End",
        "params": [],
        "path": "go/go/ast/index#ReturnStmt.End",
        "syntax": "func (s *ReturnStmt) End() token.Pos",
        "type": "go"
    },
    "ast.ReturnStmt.Pos": {
        "descr": "",
        "name": "ast.ReturnStmt.Pos",
        "params": [],
        "path": "go/go/ast/index#ReturnStmt.Pos",
        "syntax": "func (s *ReturnStmt) Pos() token.Pos",
        "type": "go"
    },
    "ast.Scope": {
        "descr": "A Scope maintains the set of named language entities declared in the scope and a link to the immediately surrounding (outer) scope.",
        "name": "ast.Scope",
        "params": [],
        "path": "go/go/ast/index#Scope",
        "syntax": "type Scope struct { Outer *Scope Objects map[string]*Object }",
        "type": "go"
    },
    "ast.Scope.Insert": {
        "descr": "Insert attempts to insert a named object obj into the scope s. If the scope already contains an object alt with the same name, Insert leaves the scope unchanged and returns alt. Otherwise it inserts obj and returns nil.",
        "name": "ast.Scope.Insert",
        "params": [],
        "path": "go/go/ast/index#Scope.Insert",
        "syntax": "func (s *Scope) Insert(obj *Object) (alt *Object)",
        "type": "go"
    },
    "ast.Scope.Lookup": {
        "descr": "Lookup returns the object with the given name if it is found in scope s, otherwise it returns nil. Outer scopes are ignored.",
        "name": "ast.Scope.Lookup",
        "params": [],
        "path": "go/go/ast/index#Scope.Lookup",
        "syntax": "func (s *Scope) Lookup(name string) *Object",
        "type": "go"
    },
    "ast.Scope.String": {
        "descr": "Debugging support",
        "name": "ast.Scope.String",
        "params": [],
        "path": "go/go/ast/index#Scope.String",
        "syntax": "func (s *Scope) String() string",
        "type": "go"
    },
    "ast.SelectStmt": {
        "descr": "An SelectStmt node represents a select statement.",
        "name": "ast.SelectStmt",
        "params": [],
        "path": "go/go/ast/index#SelectStmt",
        "syntax": "type SelectStmt struct { Select token.Pos // position of \"select\" keyword Body *BlockStmt // CommClauses only }",
        "type": "go"
    },
    "ast.SelectStmt.End": {
        "descr": "",
        "name": "ast.SelectStmt.End",
        "params": [],
        "path": "go/go/ast/index#SelectStmt.End",
        "syntax": "func (s *SelectStmt) End() token.Pos",
        "type": "go"
    },
    "ast.SelectStmt.Pos": {
        "descr": "",
        "name": "ast.SelectStmt.Pos",
        "params": [],
        "path": "go/go/ast/index#SelectStmt.Pos",
        "syntax": "func (s *SelectStmt) Pos() token.Pos",
        "type": "go"
    },
    "ast.SelectorExpr": {
        "descr": "A SelectorExpr node represents an expression followed by a selector.",
        "name": "ast.SelectorExpr",
        "params": [],
        "path": "go/go/ast/index#SelectorExpr",
        "syntax": "type SelectorExpr struct { X Expr // expression Sel *Ident // field selector }",
        "type": "go"
    },
    "ast.SelectorExpr.End": {
        "descr": "",
        "name": "ast.SelectorExpr.End",
        "params": [],
        "path": "go/go/ast/index#SelectorExpr.End",
        "syntax": "func (x *SelectorExpr) End() token.Pos",
        "type": "go"
    },
    "ast.SelectorExpr.Pos": {
        "descr": "",
        "name": "ast.SelectorExpr.Pos",
        "params": [],
        "path": "go/go/ast/index#SelectorExpr.Pos",
        "syntax": "func (x *SelectorExpr) Pos() token.Pos",
        "type": "go"
    },
    "ast.SendStmt": {
        "descr": "A SendStmt node represents a send statement.",
        "name": "ast.SendStmt",
        "params": [],
        "path": "go/go/ast/index#SendStmt",
        "syntax": "type SendStmt struct { Chan Expr Arrow token.Pos // position of \"<-\" Value Expr }",
        "type": "go"
    },
    "ast.SendStmt.End": {
        "descr": "",
        "name": "ast.SendStmt.End",
        "params": [],
        "path": "go/go/ast/index#SendStmt.End",
        "syntax": "func (s *SendStmt) End() token.Pos",
        "type": "go"
    },
    "ast.SendStmt.Pos": {
        "descr": "",
        "name": "ast.SendStmt.Pos",
        "params": [],
        "path": "go/go/ast/index#SendStmt.Pos",
        "syntax": "func (s *SendStmt) Pos() token.Pos",
        "type": "go"
    },
    "ast.SliceExpr": {
        "descr": "An SliceExpr node represents an expression followed by slice indices.",
        "name": "ast.SliceExpr",
        "params": [],
        "path": "go/go/ast/index#SliceExpr",
        "syntax": "type SliceExpr struct { X Expr // expression Lbrack token.Pos // position of \"[\" Low Expr // begin of slice range; or nil High Expr // end of slice range; or nil Max Expr // maximum capacity of slice; or nil; added in Go 1.2 Slice3 bool // true if 3-index slice (2 colons present);\n or  added in Go 1.2 Rbrack token.Pos // position of \"]\" });",
        "type": "go"
    },
    "ast.SliceExpr.End": {
        "descr": "",
        "name": "ast.SliceExpr.End",
        "params": [],
        "path": "go/go/ast/index#SliceExpr.End",
        "syntax": "func (x *SliceExpr) End() token.Pos",
        "type": "go"
    },
    "ast.SliceExpr.Pos": {
        "descr": "",
        "name": "ast.SliceExpr.Pos",
        "params": [],
        "path": "go/go/ast/index#SliceExpr.Pos",
        "syntax": "func (x *SliceExpr) Pos() token.Pos",
        "type": "go"
    },
    "ast.SortImports": {
        "descr": "SortImports sorts runs of consecutive import lines in import blocks in f. It also removes duplicate imports when it is possible to do so without data loss.",
        "name": "ast.SortImports",
        "params": [],
        "path": "go/go/ast/index#SortImports",
        "syntax": "func SortImports(fset *token.FileSet, f *File)",
        "type": "go"
    },
    "ast.Spec": {
        "descr": "The Spec type stands for any of *ImportSpec, *ValueSpec, and *TypeSpec.",
        "name": "ast.Spec",
        "params": [],
        "path": "go/go/ast/index#Spec",
        "syntax": "type Spec interface { Node // contains filtered or unexported methods }",
        "type": "go"
    },
    "ast.StarExpr": {
        "descr": "A StarExpr node represents an expression of the form \"*\" Expression. Semantically it could be a unary \"*\" expression, or a pointer type.",
        "name": "ast.StarExpr",
        "params": [],
        "path": "go/go/ast/index#StarExpr",
        "syntax": "type StarExpr struct { Star token.Pos // position of \"*\" X Expr // operand }",
        "type": "go"
    },
    "ast.StarExpr.End": {
        "descr": "",
        "name": "ast.StarExpr.End",
        "params": [],
        "path": "go/go/ast/index#StarExpr.End",
        "syntax": "func (x *StarExpr) End() token.Pos",
        "type": "go"
    },
    "ast.StarExpr.Pos": {
        "descr": "",
        "name": "ast.StarExpr.Pos",
        "params": [],
        "path": "go/go/ast/index#StarExpr.Pos",
        "syntax": "func (x *StarExpr) Pos() token.Pos",
        "type": "go"
    },
    "ast.Stmt": {
        "descr": "All statement nodes implement the Stmt interface.",
        "name": "ast.Stmt",
        "params": [],
        "path": "go/go/ast/index#Stmt",
        "syntax": "type Stmt interface { Node // contains filtered or unexported methods }",
        "type": "go"
    },
    "ast.StructType": {
        "descr": "A StructType node represents a struct type.",
        "name": "ast.StructType",
        "params": [],
        "path": "go/go/ast/index#StructType",
        "syntax": "type StructType struct { Struct token.Pos // position of \"struct\" keyword Fields *FieldList // list of field declarations Incomplete bool // true if (source) fields are missing in the Fields list }",
        "type": "go"
    },
    "ast.StructType.End": {
        "descr": "",
        "name": "ast.StructType.End",
        "params": [],
        "path": "go/go/ast/index#StructType.End",
        "syntax": "func (x *StructType) End() token.Pos",
        "type": "go"
    },
    "ast.StructType.Pos": {
        "descr": "",
        "name": "ast.StructType.Pos",
        "params": [],
        "path": "go/go/ast/index#StructType.Pos",
        "syntax": "func (x *StructType) Pos() token.Pos",
        "type": "go"
    },
    "ast.SwitchStmt": {
        "descr": "A SwitchStmt node represents an expression switch statement.",
        "name": "ast.SwitchStmt",
        "params": [],
        "path": "go/go/ast/index#SwitchStmt",
        "syntax": "type SwitchStmt struct { Switch token.Pos // position of \"switch\" keyword Init Stmt // initialization statement; or nil Tag Expr // tag expression; or nil Body *BlockStmt // CaseClauses only }",
        "type": "go"
    },
    "ast.SwitchStmt.End": {
        "descr": "",
        "name": "ast.SwitchStmt.End",
        "params": [],
        "path": "go/go/ast/index#SwitchStmt.End",
        "syntax": "func (s *SwitchStmt) End() token.Pos",
        "type": "go"
    },
    "ast.SwitchStmt.Pos": {
        "descr": "",
        "name": "ast.SwitchStmt.Pos",
        "params": [],
        "path": "go/go/ast/index#SwitchStmt.Pos",
        "syntax": "func (s *SwitchStmt) Pos() token.Pos",
        "type": "go"
    },
    "ast.TypeAssertExpr": {
        "descr": "A TypeAssertExpr node represents an expression followed by a type assertion.",
        "name": "ast.TypeAssertExpr",
        "params": [],
        "path": "go/go/ast/index#TypeAssertExpr",
        "syntax": "type TypeAssertExpr struct { X Expr // expression Lparen token.Pos // position of \"(\"; added in Go 1.2 Type Expr // asserted type; nil means type switch X.(type) Rparen token.Pos // position of \")\"; added in Go 1.2 }",
        "type": "go"
    },
    "ast.TypeAssertExpr.End": {
        "descr": "",
        "name": "ast.TypeAssertExpr.End",
        "params": [],
        "path": "go/go/ast/index#TypeAssertExpr.End",
        "syntax": "func (x *TypeAssertExpr) End() token.Pos",
        "type": "go"
    },
    "ast.TypeAssertExpr.Pos": {
        "descr": "",
        "name": "ast.TypeAssertExpr.Pos",
        "params": [],
        "path": "go/go/ast/index#TypeAssertExpr.Pos",
        "syntax": "func (x *TypeAssertExpr) Pos() token.Pos",
        "type": "go"
    },
    "ast.TypeSpec": {
        "descr": "A TypeSpec node represents a type declaration (TypeSpec production).",
        "name": "ast.TypeSpec",
        "params": [],
        "path": "go/go/ast/index#TypeSpec",
        "syntax": "type TypeSpec struct { Doc *CommentGroup // associated documentation; or nil Name *Ident // type name Assign token.Pos // position of '=', if any; added in Go 1.9 Type Expr // *Ident, *ParenExpr, *SelectorExpr, *StarExpr, or any of the *XxxTypes Comment *CommentGroup // line comments; or nil }",
        "type": "go"
    },
    "ast.TypeSpec.End": {
        "descr": "",
        "name": "ast.TypeSpec.End",
        "params": [],
        "path": "go/go/ast/index#TypeSpec.End",
        "syntax": "func (s *TypeSpec) End() token.Pos",
        "type": "go"
    },
    "ast.TypeSpec.Pos": {
        "descr": "",
        "name": "ast.TypeSpec.Pos",
        "params": [],
        "path": "go/go/ast/index#TypeSpec.Pos",
        "syntax": "func (s *TypeSpec) Pos() token.Pos",
        "type": "go"
    },
    "ast.TypeSwitchStmt": {
        "descr": "An TypeSwitchStmt node represents a type switch statement.",
        "name": "ast.TypeSwitchStmt",
        "params": [],
        "path": "go/go/ast/index#TypeSwitchStmt",
        "syntax": "type TypeSwitchStmt struct { Switch token.Pos // position of \"switch\" keyword Init Stmt // initialization statement; or nil Assign Stmt // x := y.(type) or y.(type) Body *BlockStmt // CaseClauses only }",
        "type": "go"
    },
    "ast.TypeSwitchStmt.End": {
        "descr": "",
        "name": "ast.TypeSwitchStmt.End",
        "params": [],
        "path": "go/go/ast/index#TypeSwitchStmt.End",
        "syntax": "func (s *TypeSwitchStmt) End() token.Pos",
        "type": "go"
    },
    "ast.TypeSwitchStmt.Pos": {
        "descr": "",
        "name": "ast.TypeSwitchStmt.Pos",
        "params": [],
        "path": "go/go/ast/index#TypeSwitchStmt.Pos",
        "syntax": "func (s *TypeSwitchStmt) Pos() token.Pos",
        "type": "go"
    },
    "ast.UnaryExpr": {
        "descr": "A UnaryExpr node represents a unary expression. Unary \"*\" expressions are represented via StarExpr nodes.",
        "name": "ast.UnaryExpr",
        "params": [],
        "path": "go/go/ast/index#UnaryExpr",
        "syntax": "type UnaryExpr struct { OpPos token.Pos // position of Op Op token.Token // operator X Expr // operand }",
        "type": "go"
    },
    "ast.UnaryExpr.End": {
        "descr": "",
        "name": "ast.UnaryExpr.End",
        "params": [],
        "path": "go/go/ast/index#UnaryExpr.End",
        "syntax": "func (x *UnaryExpr) End() token.Pos",
        "type": "go"
    },
    "ast.UnaryExpr.Pos": {
        "descr": "",
        "name": "ast.UnaryExpr.Pos",
        "params": [],
        "path": "go/go/ast/index#UnaryExpr.Pos",
        "syntax": "func (x *UnaryExpr) Pos() token.Pos",
        "type": "go"
    },
    "ast.ValueSpec": {
        "descr": "A ValueSpec node represents a constant or variable declaration (ConstSpec or VarSpec production).",
        "name": "ast.ValueSpec",
        "params": [],
        "path": "go/go/ast/index#ValueSpec",
        "syntax": "type ValueSpec struct { Doc *CommentGroup // associated documentation; or nil Names []*Ident // value names (len(Names) > 0) Type Expr // value type; or nil Values []Expr // initial values; or nil Comment *CommentGroup // line comments; or nil }",
        "type": "go"
    },
    "ast.ValueSpec.End": {
        "descr": "",
        "name": "ast.ValueSpec.End",
        "params": [],
        "path": "go/go/ast/index#ValueSpec.End",
        "syntax": "func (s *ValueSpec) End() token.Pos",
        "type": "go"
    },
    "ast.ValueSpec.Pos": {
        "descr": "",
        "name": "ast.ValueSpec.Pos",
        "params": [],
        "path": "go/go/ast/index#ValueSpec.Pos",
        "syntax": "func (s *ValueSpec) Pos() token.Pos",
        "type": "go"
    },
    "ast.Visitor": {
        "descr": "A Visitor's Visit method is invoked for each node encountered by Walk. If the result visitor w is not nil, Walk visits each of the children of node with the visitor w, followed by a call of w.Visit(nil).",
        "name": "ast.Visitor",
        "params": [],
        "path": "go/go/ast/index#Visitor",
        "syntax": "type Visitor interface { Visit(node Node) (w Visitor) }",
        "type": "go"
    },
    "ast.Walk": {
        "descr": "Walk traverses an AST in depth-first order: It starts by calling v.Visit(node); node must not be nil. If the visitor w returned by v.Visit(node) is not nil, Walk is invoked recursively with visitor w for each of the non-nil children of node, followed by a call of w.Visit(nil).",
        "name": "ast.Walk",
        "params": [],
        "path": "go/go/ast/index#Walk",
        "syntax": "func Walk(v Visitor, node Node)",
        "type": "go"
    },
    "atomic.AddInt32": {
        "descr": "AddInt32 atomically adds delta to *addr and returns the new value.",
        "name": "atomic.AddInt32",
        "params": [],
        "path": "go/sync/atomic/index#AddInt32",
        "syntax": "func AddInt32(addr *int32, delta int32) (new int32)",
        "type": "sync"
    },
    "atomic.AddInt64": {
        "descr": "AddInt64 atomically adds delta to *addr and returns the new value.",
        "name": "atomic.AddInt64",
        "params": [],
        "path": "go/sync/atomic/index#AddInt64",
        "syntax": "func AddInt64(addr *int64, delta int64) (new int64)",
        "type": "sync"
    },
    "atomic.AddUint32": {
        "descr": "AddUint32 atomically adds delta to *addr and returns the new value. To subtract a signed positive constant value c from x, do AddUint32(&x, ^uint32(c-1)). In particular, to decrement x, do AddUint32(&x, ^uint32(0)).",
        "name": "atomic.AddUint32",
        "params": [],
        "path": "go/sync/atomic/index#AddUint32",
        "syntax": "func AddUint32(addr *uint32, delta uint32) (new uint32)",
        "type": "sync"
    },
    "atomic.AddUint64": {
        "descr": "AddUint64 atomically adds delta to *addr and returns the new value. To subtract a signed positive constant value c from x, do AddUint64(&x, ^uint64(c-1)). In particular, to decrement x, do AddUint64(&x, ^uint64(0)).",
        "name": "atomic.AddUint64",
        "params": [],
        "path": "go/sync/atomic/index#AddUint64",
        "syntax": "func AddUint64(addr *uint64, delta uint64) (new uint64)",
        "type": "sync"
    },
    "atomic.AddUintptr": {
        "descr": "AddUintptr atomically adds delta to *addr and returns the new value.",
        "name": "atomic.AddUintptr",
        "params": [],
        "path": "go/sync/atomic/index#AddUintptr",
        "syntax": "func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)",
        "type": "sync"
    },
    "atomic.CompareAndSwapInt32": {
        "descr": "CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value.",
        "name": "atomic.CompareAndSwapInt32",
        "params": [],
        "path": "go/sync/atomic/index#CompareAndSwapInt32",
        "syntax": "func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)",
        "type": "sync"
    },
    "atomic.CompareAndSwapInt64": {
        "descr": "CompareAndSwapInt64 executes the compare-and-swap operation for an int64 value.",
        "name": "atomic.CompareAndSwapInt64",
        "params": [],
        "path": "go/sync/atomic/index#CompareAndSwapInt64",
        "syntax": "func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)",
        "type": "sync"
    },
    "atomic.CompareAndSwapPointer": {
        "descr": "CompareAndSwapPointer executes the compare-and-swap operation for a unsafe.Pointer value.",
        "name": "atomic.CompareAndSwapPointer",
        "params": [],
        "path": "go/sync/atomic/index#CompareAndSwapPointer",
        "syntax": "func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)",
        "type": "sync"
    },
    "atomic.CompareAndSwapUint32": {
        "descr": "CompareAndSwapUint32 executes the compare-and-swap operation for a uint32 value.",
        "name": "atomic.CompareAndSwapUint32",
        "params": [],
        "path": "go/sync/atomic/index#CompareAndSwapUint32",
        "syntax": "func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)",
        "type": "sync"
    },
    "atomic.CompareAndSwapUint64": {
        "descr": "CompareAndSwapUint64 executes the compare-and-swap operation for a uint64 value.",
        "name": "atomic.CompareAndSwapUint64",
        "params": [],
        "path": "go/sync/atomic/index#CompareAndSwapUint64",
        "syntax": "func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)",
        "type": "sync"
    },
    "atomic.CompareAndSwapUintptr": {
        "descr": "CompareAndSwapUintptr executes the compare-and-swap operation for a uintptr value.",
        "name": "atomic.CompareAndSwapUintptr",
        "params": [],
        "path": "go/sync/atomic/index#CompareAndSwapUintptr",
        "syntax": "func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)",
        "type": "sync"
    },
    "atomic.LoadInt32": {
        "descr": "LoadInt32 atomically loads *addr.",
        "name": "atomic.LoadInt32",
        "params": [],
        "path": "go/sync/atomic/index#LoadInt32",
        "syntax": "func LoadInt32(addr *int32) (val int32)",
        "type": "sync"
    },
    "atomic.LoadInt64": {
        "descr": "LoadInt64 atomically loads *addr.",
        "name": "atomic.LoadInt64",
        "params": [],
        "path": "go/sync/atomic/index#LoadInt64",
        "syntax": "func LoadInt64(addr *int64) (val int64)",
        "type": "sync"
    },
    "atomic.LoadPointer": {
        "descr": "LoadPointer atomically loads *addr.",
        "name": "atomic.LoadPointer",
        "params": [],
        "path": "go/sync/atomic/index#LoadPointer",
        "syntax": "func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)",
        "type": "sync"
    },
    "atomic.LoadUint32": {
        "descr": "LoadUint32 atomically loads *addr.",
        "name": "atomic.LoadUint32",
        "params": [],
        "path": "go/sync/atomic/index#LoadUint32",
        "syntax": "func LoadUint32(addr *uint32) (val uint32)",
        "type": "sync"
    },
    "atomic.LoadUint64": {
        "descr": "LoadUint64 atomically loads *addr.",
        "name": "atomic.LoadUint64",
        "params": [],
        "path": "go/sync/atomic/index#LoadUint64",
        "syntax": "func LoadUint64(addr *uint64) (val uint64)",
        "type": "sync"
    },
    "atomic.LoadUintptr": {
        "descr": "LoadUintptr atomically loads *addr.",
        "name": "atomic.LoadUintptr",
        "params": [],
        "path": "go/sync/atomic/index#LoadUintptr",
        "syntax": "func LoadUintptr(addr *uintptr) (val uintptr)",
        "type": "sync"
    },
    "atomic.StoreInt32": {
        "descr": "StoreInt32 atomically stores val into *addr.",
        "name": "atomic.StoreInt32",
        "params": [],
        "path": "go/sync/atomic/index#StoreInt32",
        "syntax": "func StoreInt32(addr *int32, val int32)",
        "type": "sync"
    },
    "atomic.StoreInt64": {
        "descr": "StoreInt64 atomically stores val into *addr.",
        "name": "atomic.StoreInt64",
        "params": [],
        "path": "go/sync/atomic/index#StoreInt64",
        "syntax": "func StoreInt64(addr *int64, val int64)",
        "type": "sync"
    },
    "atomic.StorePointer": {
        "descr": "StorePointer atomically stores val into *addr.",
        "name": "atomic.StorePointer",
        "params": [],
        "path": "go/sync/atomic/index#StorePointer",
        "syntax": "func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)",
        "type": "sync"
    },
    "atomic.StoreUint32": {
        "descr": "StoreUint32 atomically stores val into *addr.",
        "name": "atomic.StoreUint32",
        "params": [],
        "path": "go/sync/atomic/index#StoreUint32",
        "syntax": "func StoreUint32(addr *uint32, val uint32)",
        "type": "sync"
    },
    "atomic.StoreUint64": {
        "descr": "StoreUint64 atomically stores val into *addr.",
        "name": "atomic.StoreUint64",
        "params": [],
        "path": "go/sync/atomic/index#StoreUint64",
        "syntax": "func StoreUint64(addr *uint64, val uint64)",
        "type": "sync"
    },
    "atomic.StoreUintptr": {
        "descr": "StoreUintptr atomically stores val into *addr.",
        "name": "atomic.StoreUintptr",
        "params": [],
        "path": "go/sync/atomic/index#StoreUintptr",
        "syntax": "func StoreUintptr(addr *uintptr, val uintptr)",
        "type": "sync"
    },
    "atomic.SwapInt32": {
        "descr": "SwapInt32 atomically stores new into *addr and returns the previous *addr value.",
        "name": "atomic.SwapInt32",
        "params": [],
        "path": "go/sync/atomic/index#SwapInt32",
        "syntax": "func SwapInt32(addr *int32, new int32) (old int32)",
        "type": "sync"
    },
    "atomic.SwapInt64": {
        "descr": "SwapInt64 atomically stores new into *addr and returns the previous *addr value.",
        "name": "atomic.SwapInt64",
        "params": [],
        "path": "go/sync/atomic/index#SwapInt64",
        "syntax": "func SwapInt64(addr *int64, new int64) (old int64)",
        "type": "sync"
    },
    "atomic.SwapPointer": {
        "descr": "SwapPointer atomically stores new into *addr and returns the previous *addr value.",
        "name": "atomic.SwapPointer",
        "params": [],
        "path": "go/sync/atomic/index#SwapPointer",
        "syntax": "func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)",
        "type": "sync"
    },
    "atomic.SwapUint32": {
        "descr": "SwapUint32 atomically stores new into *addr and returns the previous *addr value.",
        "name": "atomic.SwapUint32",
        "params": [],
        "path": "go/sync/atomic/index#SwapUint32",
        "syntax": "func SwapUint32(addr *uint32, new uint32) (old uint32)",
        "type": "sync"
    },
    "atomic.SwapUint64": {
        "descr": "SwapUint64 atomically stores new into *addr and returns the previous *addr value.",
        "name": "atomic.SwapUint64",
        "params": [],
        "path": "go/sync/atomic/index#SwapUint64",
        "syntax": "func SwapUint64(addr *uint64, new uint64) (old uint64)",
        "type": "sync"
    },
    "atomic.SwapUintptr": {
        "descr": "SwapUintptr atomically stores new into *addr and returns the previous *addr value.",
        "name": "atomic.SwapUintptr",
        "params": [],
        "path": "go/sync/atomic/index#SwapUintptr",
        "syntax": "func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)",
        "type": "sync"
    },
    "atomic.Value": {
        "descr": "A Value provides an atomic load and store of a consistently typed value. The zero value for a Value returns nil from Load. Once Store has been called, a Value must not be copied.",
        "name": "atomic.Value",
        "params": [],
        "path": "go/sync/atomic/index#Value",
        "syntax": "type Value struct { // contains filtered or unexported fields }",
        "type": "sync"
    },
    "atomic.Value.Load": {
        "descr": "Load returns the value set by the most recent Store. It returns nil if there has been no call to Store for this Value.",
        "name": "atomic.Value.Load",
        "params": [],
        "path": "go/sync/atomic/index#Value.Load",
        "syntax": "func (v *Value) Load() (x interface{})",
        "type": "sync"
    },
    "atomic.Value.Store": {
        "descr": "Store sets the value of the Value to x. All calls to Store for a given Value must use values of the same concrete type. Store of an inconsistent type panics, as does Store(nil).",
        "name": "atomic.Value.Store",
        "params": [],
        "path": "go/sync/atomic/index#Value.Store",
        "syntax": "func (v *Value) Store(x interface{})",
        "type": "sync"
    },
    "base32.CorruptInputError": {
        "descr": "",
        "name": "base32.CorruptInputError",
        "params": [],
        "path": "go/encoding/base32/index#CorruptInputError",
        "syntax": "type CorruptInputError int64",
        "type": "encoding"
    },
    "base32.CorruptInputError.Error": {
        "descr": "",
        "name": "base32.CorruptInputError.Error",
        "params": [],
        "path": "go/encoding/base32/index#CorruptInputError.Error",
        "syntax": "func (e CorruptInputError) Error() string",
        "type": "encoding"
    },
    "base32.Encoding": {
        "descr": "An Encoding is a radix 32 encoding/decoding scheme, defined by a 32-character alphabet. The most common is the \"base32\" encoding introduced for SASL GSSAPI and standardized in RFC 4648. The alternate \"base32hex\" encoding is used in DNSSEC.",
        "name": "base32.Encoding",
        "params": [],
        "path": "go/encoding/base32/index#Encoding",
        "syntax": "type Encoding struct { // contains filtered or unexported fields }",
        "type": "encoding"
    },
    "base32.Encoding.Decode": {
        "descr": "Decode decodes src using the encoding enc. It writes at most DecodedLen(len(src)) bytes to dst and returns the number of bytes written. If src contains invalid base32 data, it will return the number of bytes successfully written and CorruptInputError. New line characters (\\r and \\n) are ignored.",
        "name": "base32.Encoding.Decode",
        "params": [],
        "path": "go/encoding/base32/index#Encoding.Decode",
        "syntax": "func (enc *Encoding) Decode(dst, src []byte) (n int, err error)",
        "type": "encoding"
    },
    "base32.Encoding.DecodeString": {
        "descr": "DecodeString returns the bytes represented by the base32 string s.",
        "name": "base32.Encoding.DecodeString",
        "params": [],
        "path": "go/encoding/base32/index#Encoding.DecodeString",
        "syntax": "func (enc *Encoding) DecodeString(s string) ([]byte, error)",
        "type": "encoding"
    },
    "base32.Encoding.DecodedLen": {
        "descr": "DecodedLen returns the maximum length in bytes of the decoded data corresponding to n bytes of base32-encoded data.",
        "name": "base32.Encoding.DecodedLen",
        "params": [],
        "path": "go/encoding/base32/index#Encoding.DecodedLen",
        "syntax": "func (enc *Encoding) DecodedLen(n int) int",
        "type": "encoding"
    },
    "base32.Encoding.Encode": {
        "descr": "Encode encodes src using the encoding enc, writing EncodedLen(len(src)) bytes to dst.",
        "name": "base32.Encoding.Encode",
        "params": [],
        "path": "go/encoding/base32/index#Encoding.Encode",
        "syntax": "func (enc *Encoding) Encode(dst, src []byte)",
        "type": "encoding"
    },
    "base32.Encoding.EncodeToString": {
        "descr": "EncodeToString returns the base32 encoding of src.",
        "name": "base32.Encoding.EncodeToString",
        "params": [],
        "path": "go/encoding/base32/index#Encoding.EncodeToString",
        "syntax": "func (enc *Encoding) EncodeToString(src []byte) string",
        "type": "encoding"
    },
    "base32.Encoding.EncodedLen": {
        "descr": "EncodedLen returns the length in bytes of the base32 encoding of an input buffer of length n.",
        "name": "base32.Encoding.EncodedLen",
        "params": [],
        "path": "go/encoding/base32/index#Encoding.EncodedLen",
        "syntax": "func (enc *Encoding) EncodedLen(n int) int",
        "type": "encoding"
    },
    "base32.Encoding.WithPadding": {
        "descr": "WithPadding creates a new encoding identical to enc except with a specified padding character, or NoPadding to disable padding. The padding character must not be '\\r' or '\\n', must not be contained in the encoding's alphabet and must be a rune equal or below '\\xff'.",
        "name": "base32.Encoding.WithPadding",
        "params": [],
        "path": "go/encoding/base32/index#Encoding.WithPadding",
        "syntax": "func (enc Encoding) WithPadding(padding rune) *Encoding",
        "type": "encoding"
    },
    "base32.NewDecoder": {
        "descr": "NewDecoder constructs a new base32 stream decoder.",
        "name": "base32.NewDecoder",
        "params": [],
        "path": "go/encoding/base32/index#NewDecoder",
        "syntax": "func NewDecoder(enc *Encoding, r io.Reader) io.Reader",
        "type": "encoding"
    },
    "base32.NewEncoder": {
        "descr": "NewEncoder returns a new base32 stream encoder. Data written to the returned writer will be encoded using enc and then written to w. Base32 encodings operate in 5-byte blocks; when finished writing, the caller must Close the returned encoder to flush any partially written blocks.",
        "name": "base32.NewEncoder",
        "params": [],
        "path": "go/encoding/base32/index#NewEncoder",
        "syntax": "func NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser",
        "type": "encoding"
    },
    "base32.NewEncoding": {
        "descr": "NewEncoding returns a new Encoding defined by the given alphabet, which must be a 32-byte string.",
        "name": "base32.NewEncoding",
        "params": [],
        "path": "go/encoding/base32/index#NewEncoding",
        "syntax": "func NewEncoding(encoder string) *Encoding",
        "type": "encoding"
    },
    "base64.CorruptInputError": {
        "descr": "",
        "name": "base64.CorruptInputError",
        "params": [],
        "path": "go/encoding/base64/index#CorruptInputError",
        "syntax": "type CorruptInputError int64",
        "type": "encoding"
    },
    "base64.CorruptInputError.Error": {
        "descr": "",
        "name": "base64.CorruptInputError.Error",
        "params": [],
        "path": "go/encoding/base64/index#CorruptInputError.Error",
        "syntax": "func (e CorruptInputError) Error() string",
        "type": "encoding"
    },
    "base64.Encoding": {
        "descr": "An Encoding is a radix 64 encoding/decoding scheme, defined by a 64-character alphabet. The most common encoding is the \"base64\" encoding defined in RFC 4648 and used in MIME (RFC 2045) and PEM (RFC 1421). RFC 4648 also defines an alternate encoding, which is the standard encoding with - and _ substituted for + and /.",
        "name": "base64.Encoding",
        "params": [],
        "path": "go/encoding/base64/index#Encoding",
        "syntax": "type Encoding struct { // contains filtered or unexported fields }",
        "type": "encoding"
    },
    "base64.Encoding.Decode": {
        "descr": "Decode decodes src using the encoding enc. It writes at most DecodedLen(len(src)) bytes to dst and returns the number of bytes written. If src contains invalid base64 data, it will return the number of bytes successfully written and CorruptInputError. New line characters (\\r and \\n) are ignored.",
        "name": "base64.Encoding.Decode",
        "params": [],
        "path": "go/encoding/base64/index#Encoding.Decode",
        "syntax": "func (enc *Encoding) Decode(dst, src []byte) (n int, err error)",
        "type": "encoding"
    },
    "base64.Encoding.DecodeString": {
        "descr": "DecodeString returns the bytes represented by the base64 string s.",
        "name": "base64.Encoding.DecodeString",
        "params": [],
        "path": "go/encoding/base64/index#Encoding.DecodeString",
        "syntax": "func (enc *Encoding) DecodeString(s string) ([]byte, error)",
        "type": "encoding"
    },
    "base64.Encoding.DecodedLen": {
        "descr": "DecodedLen returns the maximum length in bytes of the decoded data corresponding to n bytes of base64-encoded data.",
        "name": "base64.Encoding.DecodedLen",
        "params": [],
        "path": "go/encoding/base64/index#Encoding.DecodedLen",
        "syntax": "func (enc *Encoding) DecodedLen(n int) int",
        "type": "encoding"
    },
    "base64.Encoding.Encode": {
        "descr": "Encode encodes src using the encoding enc, writing EncodedLen(len(src)) bytes to dst.",
        "name": "base64.Encoding.Encode",
        "params": [],
        "path": "go/encoding/base64/index#Encoding.Encode",
        "syntax": "func (enc *Encoding) Encode(dst, src []byte)",
        "type": "encoding"
    },
    "base64.Encoding.EncodeToString": {
        "descr": "EncodeToString returns the base64 encoding of src.",
        "name": "base64.Encoding.EncodeToString",
        "params": [],
        "path": "go/encoding/base64/index#Encoding.EncodeToString",
        "syntax": "func (enc *Encoding) EncodeToString(src []byte) string",
        "type": "encoding"
    },
    "base64.Encoding.EncodedLen": {
        "descr": "EncodedLen returns the length in bytes of the base64 encoding of an input buffer of length n.",
        "name": "base64.Encoding.EncodedLen",
        "params": [],
        "path": "go/encoding/base64/index#Encoding.EncodedLen",
        "syntax": "func (enc *Encoding) EncodedLen(n int) int",
        "type": "encoding"
    },
    "base64.Encoding.Strict": {
        "descr": "Strict creates a new encoding identical to enc except with strict decoding enabled. In this mode, the decoder requires that trailing padding bits are zero, as described in RFC 4648 section 3.5.",
        "name": "base64.Encoding.Strict",
        "params": [],
        "path": "go/encoding/base64/index#Encoding.Strict",
        "syntax": "func (enc Encoding) Strict() *Encoding",
        "type": "encoding"
    },
    "base64.Encoding.WithPadding": {
        "descr": "WithPadding creates a new encoding identical to enc except with a specified padding character, or NoPadding to disable padding. The padding character must not be '\\r' or '\\n', must not be contained in the encoding's alphabet and must be a rune equal or below '\\xff'.",
        "name": "base64.Encoding.WithPadding",
        "params": [],
        "path": "go/encoding/base64/index#Encoding.WithPadding",
        "syntax": "func (enc Encoding) WithPadding(padding rune) *Encoding",
        "type": "encoding"
    },
    "base64.NewDecoder": {
        "descr": "NewDecoder constructs a new base64 stream decoder.",
        "name": "base64.NewDecoder",
        "params": [],
        "path": "go/encoding/base64/index#NewDecoder",
        "syntax": "func NewDecoder(enc *Encoding, r io.Reader) io.Reader",
        "type": "encoding"
    },
    "base64.NewEncoder": {
        "descr": "NewEncoder returns a new base64 stream encoder. Data written to the returned writer will be encoded using enc and then written to w. Base64 encodings operate in 4-byte blocks; when finished writing, the caller must Close the returned encoder to flush any partially written blocks.",
        "name": "base64.NewEncoder",
        "params": [],
        "path": "go/encoding/base64/index#NewEncoder",
        "syntax": "func NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser",
        "type": "encoding"
    },
    "base64.NewEncoding": {
        "descr": "NewEncoding returns a new padded Encoding defined by the given alphabet, which must be a 64-byte string that does not contain the padding character or CR / LF ('\\r', '\\n'). The resulting Encoding uses the default padding character ('='), which may be changed or disabled via WithPadding.",
        "name": "base64.NewEncoding",
        "params": [],
        "path": "go/encoding/base64/index#NewEncoding",
        "syntax": "func NewEncoding(encoder string) *Encoding",
        "type": "encoding"
    },
    "big.Accuracy": {
        "descr": "Accuracy describes the rounding error produced by the most recent operation that generated a Float value, relative to the exact value.",
        "name": "big.Accuracy",
        "params": [],
        "path": "go/math/big/index#Accuracy",
        "syntax": "type Accuracy int8",
        "type": "math/big"
    },
    "big.Accuracy.String": {
        "descr": "",
        "name": "big.Accuracy.String",
        "params": [],
        "path": "go/math/big/index#Accuracy.String",
        "syntax": "func (i Accuracy) String() string",
        "type": "math/big"
    },
    "big.ErrNaN": {
        "descr": "An ErrNaN panic is raised by a Float operation that would lead to a NaN under IEEE-754 rules. An ErrNaN implements the error interface.",
        "name": "big.ErrNaN",
        "params": [],
        "path": "go/math/big/index#ErrNaN",
        "syntax": "type ErrNaN struct { // contains filtered or unexported fields }",
        "type": "math/big"
    },
    "big.ErrNaN.Error": {
        "descr": "",
        "name": "big.ErrNaN.Error",
        "params": [],
        "path": "go/math/big/index#ErrNaN.Error",
        "syntax": "func (err ErrNaN) Error() string",
        "type": "math/big"
    },
    "big.Float": {
        "descr": "A nonzero finite Float represents a multi-precision floating point number",
        "name": "big.Float",
        "params": [],
        "path": "go/math/big/index#Float",
        "syntax": "sign  mantissa  2**exponent",
        "type": "math/big"
    },
    "big.Float.Abs": {
        "descr": "Abs sets z to the (possibly rounded) value |x| (the absolute value of x) and returns z.",
        "name": "big.Float.Abs",
        "params": [],
        "path": "go/math/big/index#Float.Abs",
        "syntax": "func (z *Float) Abs(x *Float) *Float",
        "type": "math/big"
    },
    "big.Float.Acc": {
        "descr": "Acc returns the accuracy of x produced by the most recent operation.",
        "name": "big.Float.Acc",
        "params": [],
        "path": "go/math/big/index#Float.Acc",
        "syntax": "func (x *Float) Acc() Accuracy",
        "type": "math/big"
    },
    "big.Float.Add": {
        "descr": "Add sets z to the rounded sum x+y and returns z. If z's precision is 0, it is changed to the larger of x's or y's precision before the operation. Rounding is performed according to z's precision and rounding mode; and z's accuracy reports the result error relative to the exact (not rounded) result. Add panics with ErrNaN if x and y are infinities with opposite signs. The value of z is undefined in that case.",
        "name": "big.Float.Add",
        "params": [],
        "path": "go/math/big/index#Float.Add",
        "syntax": "func (z *Float) Add(x, y *Float) *Float",
        "type": "math/big"
    },
    "big.Float.Append": {
        "descr": "Append appends to buf the string form of the floating-point number x, as generated by x.Text, and returns the extended buffer.",
        "name": "big.Float.Append",
        "params": [],
        "path": "go/math/big/index#Float.Append",
        "syntax": "func (x *Float) Append(buf []byte, fmt byte, prec int) []byte",
        "type": "math/big"
    },
    "big.Float.Cmp": {
        "descr": "Cmp compares x and y and returns:",
        "name": "big.Float.Cmp",
        "params": [],
        "path": "go/math/big/index#Float.Cmp",
        "syntax": "func (x *Float) Cmp(y *Float) int",
        "type": "math/big"
    },
    "big.Float.Copy": {
        "descr": "Copy sets z to x, with the same precision, rounding mode, and accuracy as x, and returns z. x is not changed even if z and x are the same.",
        "name": "big.Float.Copy",
        "params": [],
        "path": "go/math/big/index#Float.Copy",
        "syntax": "func (z *Float) Copy(x *Float) *Float",
        "type": "math/big"
    },
    "big.Float.Float32": {
        "descr": "Float32 returns the float32 value nearest to x. If x is too small to be represented by a float32 (|x| < math.SmallestNonzeroFloat32), the result is (0, Below) or (-0, Above), respectively, depending on the sign of x. If x is too large to be represented by a float32 (|x| > math.MaxFloat32), the result is (+Inf, Above) or (-Inf, Below), depending on the sign of x.",
        "name": "big.Float.Float32",
        "params": [],
        "path": "go/math/big/index#Float.Float32",
        "syntax": "func (x *Float) Float32() (float32, Accuracy)",
        "type": "math/big"
    },
    "big.Float.Float64": {
        "descr": "Float64 returns the float64 value nearest to x. If x is too small to be represented by a float64 (|x| < math.SmallestNonzeroFloat64), the result is (0, Below) or (-0, Above), respectively, depending on the sign of x. If x is too large to be represented by a float64 (|x| > math.MaxFloat64), the result is (+Inf, Above) or (-Inf, Below), depending on the sign of x.",
        "name": "big.Float.Float64",
        "params": [],
        "path": "go/math/big/index#Float.Float64",
        "syntax": "func (x *Float) Float64() (float64, Accuracy)",
        "type": "math/big"
    },
    "big.Float.Format": {
        "descr": "Format implements fmt.Formatter. It accepts all the regular formats for floating-point numbers ('b', 'e', 'E', 'f', 'F', 'g', 'G') as well as 'p' and 'v'. See (*Float).Text for the interpretation of 'p'. The 'v' format is handled like 'g'. Format also supports specification of the minimum precision in digits, the output field width, as well as the format flags '+' and ' ' for sign control, '0' for space or zero padding, and '-' for left or right justification. See the fmt package for details.",
        "name": "big.Float.Format",
        "params": [],
        "path": "go/math/big/index#Float.Format",
        "syntax": "func (x *Float) Format(s fmt.State, format rune)",
        "type": "math/big"
    },
    "big.Float.GobDecode": {
        "descr": "GobDecode implements the gob.GobDecoder interface. The result is rounded per the precision and rounding mode of z unless z's precision is 0, in which case z is set exactly to the decoded value.",
        "name": "big.Float.GobDecode",
        "params": [],
        "path": "go/math/big/index#Float.GobDecode",
        "syntax": "func (z *Float) GobDecode(buf []byte) error",
        "type": "math/big"
    },
    "big.Float.GobEncode": {
        "descr": "GobEncode implements the gob.GobEncoder interface. The Float value and all its attributes (precision, rounding mode, accuracy) are marshaled.",
        "name": "big.Float.GobEncode",
        "params": [],
        "path": "go/math/big/index#Float.GobEncode",
        "syntax": "func (x *Float) GobEncode() ([]byte, error)",
        "type": "math/big"
    },
    "big.Float.Int": {
        "descr": "Int returns the result of truncating x towards zero; or nil if x is an infinity. The result is Exact if x.IsInt(); otherwise it is Below for x > 0, and Above for x < 0. If a non-nil *Int argument z is provided, Int stores the result in z instead of allocating a new Int.",
        "name": "big.Float.Int",
        "params": [],
        "path": "go/math/big/index#Float.Int",
        "syntax": "func (x *Float) Int(z *Int) (*Int, Accuracy)",
        "type": "math/big"
    },
    "big.Float.Int64": {
        "descr": "Int64 returns the integer resulting from truncating x towards zero. If math.MinInt64 <= x <= math.MaxInt64, the result is Exact if x is an integer, and Above (x < 0) or Below (x > 0) otherwise. The result is (math.MinInt64, Above) for x < math.MinInt64, and (math.MaxInt64, Below) for x > math.MaxInt64.",
        "name": "big.Float.Int64",
        "params": [],
        "path": "go/math/big/index#Float.Int64",
        "syntax": "func (x *Float) Int64() (int64, Accuracy)",
        "type": "math/big"
    },
    "big.Float.IsInf": {
        "descr": "IsInf reports whether x is +Inf or -Inf.",
        "name": "big.Float.IsInf",
        "params": [],
        "path": "go/math/big/index#Float.IsInf",
        "syntax": "func (x *Float) IsInf() bool",
        "type": "math/big"
    },
    "big.Float.IsInt": {
        "descr": "IsInt reports whether x is an integer. Inf values are not integers.",
        "name": "big.Float.IsInt",
        "params": [],
        "path": "go/math/big/index#Float.IsInt",
        "syntax": "func (x *Float) IsInt() bool",
        "type": "math/big"
    },
    "big.Float.MantExp": {
        "descr": "MantExp breaks x into its mantissa and exponent components and returns the exponent. If a non-nil mant argument is provided its value is set to the mantissa of x, with the same precision and rounding mode as x. The components satisfy x == mant  2**exp, with 0.5 <= |mant| < 1.0. Calling MantExp with a nil argument is an efficient way to get the exponent of the receiver.",
        "name": "big.Float.MantExp",
        "params": [],
        "path": "go/math/big/index#Float.MantExp",
        "syntax": "func (x *Float) MantExp(mant *Float) (exp int)",
        "type": "math/big"
    },
    "big.Float.MarshalText": {
        "descr": "MarshalText implements the encoding.TextMarshaler interface. Only the Float value is marshaled (in full precision), other attributes such as precision or accuracy are ignored.",
        "name": "big.Float.MarshalText",
        "params": [],
        "path": "go/math/big/index#Float.MarshalText",
        "syntax": "func (x *Float) MarshalText() (text []byte, err error)",
        "type": "math/big"
    },
    "big.Float.MinPrec": {
        "descr": "MinPrec returns the minimum precision required to represent x exactly (i.e., the smallest prec before x.SetPrec(prec) would start rounding x). The result is 0 for |x| == 0 and |x| == Inf.",
        "name": "big.Float.MinPrec",
        "params": [],
        "path": "go/math/big/index#Float.MinPrec",
        "syntax": "func (x *Float) MinPrec() uint",
        "type": "math/big"
    },
    "big.Float.Mode": {
        "descr": "Mode returns the rounding mode of x.",
        "name": "big.Float.Mode",
        "params": [],
        "path": "go/math/big/index#Float.Mode",
        "syntax": "func (x *Float) Mode() RoundingMode",
        "type": "math/big"
    },
    "big.Float.Mul": {
        "descr": "Mul sets z to the rounded product x*y and returns z. Precision, rounding, and accuracy reporting are as for Add. Mul panics with ErrNaN if one operand is zero and the other operand an infinity. The value of z is undefined in that case.",
        "name": "big.Float.Mul",
        "params": [],
        "path": "go/math/big/index#Float.Mul",
        "syntax": "func (z *Float) Mul(x, y *Float) *Float",
        "type": "math/big"
    },
    "big.Float.Neg": {
        "descr": "Neg sets z to the (possibly rounded) value of x with its sign negated, and returns z.",
        "name": "big.Float.Neg",
        "params": [],
        "path": "go/math/big/index#Float.Neg",
        "syntax": "func (z *Float) Neg(x *Float) *Float",
        "type": "math/big"
    },
    "big.Float.Parse": {
        "descr": "Parse parses s which must contain a text representation of a floating- point number with a mantissa in the given conversion base (the exponent is always a decimal number), or a string representing an infinite value.",
        "name": "big.Float.Parse",
        "params": [],
        "path": "go/math/big/index#Float.Parse",
        "syntax": "func (z *Float) Parse(s string, base int) (f *Float, b int, err error)",
        "type": "math/big"
    },
    "big.Float.Prec": {
        "descr": "Prec returns the mantissa precision of x in bits. The result may be 0 for |x| == 0 and |x| == Inf.",
        "name": "big.Float.Prec",
        "params": [],
        "path": "go/math/big/index#Float.Prec",
        "syntax": "func (x *Float) Prec() uint",
        "type": "math/big"
    },
    "big.Float.Quo": {
        "descr": "Quo sets z to the rounded quotient x/y and returns z. Precision, rounding, and accuracy reporting are as for Add. Quo panics with ErrNaN if both operands are zero or infinities. The value of z is undefined in that case.",
        "name": "big.Float.Quo",
        "params": [],
        "path": "go/math/big/index#Float.Quo",
        "syntax": "func (z *Float) Quo(x, y *Float) *Float",
        "type": "math/big"
    },
    "big.Float.Rat": {
        "descr": "Rat returns the rational number corresponding to x; or nil if x is an infinity. The result is Exact if x is not an Inf. If a non-nil *Rat argument z is provided, Rat stores the result in z instead of allocating a new Rat.",
        "name": "big.Float.Rat",
        "params": [],
        "path": "go/math/big/index#Float.Rat",
        "syntax": "func (x *Float) Rat(z *Rat) (*Rat, Accuracy)",
        "type": "math/big"
    },
    "big.Float.Scan": {
        "descr": "Scan is a support routine for fmt.Scanner; it sets z to the value of the scanned number. It accepts formats whose verbs are supported by fmt.Scan for floating point values, which are: 'b' (binary), 'e', 'E', 'f', 'F', 'g' and 'G'. Scan doesn't handle Inf.",
        "name": "big.Float.Scan",
        "params": [],
        "path": "go/math/big/index#Float.Scan",
        "syntax": "func (z *Float) Scan(s fmt.ScanState, ch rune) error",
        "type": "math/big"
    },
    "big.Float.Set": {
        "descr": "Set sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the precision of x before setting z (and rounding will have no effect). Rounding is performed according to z's precision and rounding mode; and z's accuracy reports the result error relative to the exact (not rounded) result.",
        "name": "big.Float.Set",
        "params": [],
        "path": "go/math/big/index#Float.Set",
        "syntax": "func (z *Float) Set(x *Float) *Float",
        "type": "math/big"
    },
    "big.Float.SetFloat64": {
        "descr": "SetFloat64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 53 (and rounding will have no effect). SetFloat64 panics with ErrNaN if x is a NaN.",
        "name": "big.Float.SetFloat64",
        "params": [],
        "path": "go/math/big/index#Float.SetFloat64",
        "syntax": "func (z *Float) SetFloat64(x float64) *Float",
        "type": "math/big"
    },
    "big.Float.SetInf": {
        "descr": "SetInf sets z to the infinite Float -Inf if signbit is set, or +Inf if signbit is not set, and returns z. The precision of z is unchanged and the result is always Exact.",
        "name": "big.Float.SetInf",
        "params": [],
        "path": "go/math/big/index#Float.SetInf",
        "syntax": "func (z *Float) SetInf(signbit bool) *Float",
        "type": "math/big"
    },
    "big.Float.SetInt": {
        "descr": "SetInt sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the larger of x.BitLen() or 64 (and rounding will have no effect).",
        "name": "big.Float.SetInt",
        "params": [],
        "path": "go/math/big/index#Float.SetInt",
        "syntax": "func (z *Float) SetInt(x *Int) *Float",
        "type": "math/big"
    },
    "big.Float.SetInt64": {
        "descr": "SetInt64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 64 (and rounding will have no effect).",
        "name": "big.Float.SetInt64",
        "params": [],
        "path": "go/math/big/index#Float.SetInt64",
        "syntax": "func (z *Float) SetInt64(x int64) *Float",
        "type": "math/big"
    },
    "big.Float.SetMantExp": {
        "descr": "SetMantExp sets z to mant  2**exp and and returns z. The result z has the same precision and rounding mode as mant. SetMantExp is an inverse of MantExp but does not require 0.5 <= |mant| < 1.0. Specifically:",
        "name": "big.Float.SetMantExp",
        "params": [],
        "path": "go/math/big/index#Float.SetMantExp",
        "syntax": "func (z *Float) SetMantExp(mant *Float, exp int) *Float",
        "type": "math/big"
    },
    "big.Float.SetMode": {
        "descr": "SetMode sets z's rounding mode to mode and returns an exact z. z remains unchanged otherwise. z.SetMode(z.Mode()) is a cheap way to set z's accuracy to Exact.",
        "name": "big.Float.SetMode",
        "params": [],
        "path": "go/math/big/index#Float.SetMode",
        "syntax": "func (z *Float) SetMode(mode RoundingMode) *Float",
        "type": "math/big"
    },
    "big.Float.SetPrec": {
        "descr": "SetPrec sets z's precision to prec and returns the (possibly) rounded value of z. Rounding occurs according to z's rounding mode if the mantissa cannot be represented in prec bits without loss of precision. SetPrec(0) maps all finite values to 0; infinite values remain unchanged. If prec > MaxPrec, it is set to MaxPrec.",
        "name": "big.Float.SetPrec",
        "params": [],
        "path": "go/math/big/index#Float.SetPrec",
        "syntax": "func (z *Float) SetPrec(prec uint) *Float",
        "type": "math/big"
    },
    "big.Float.SetRat": {
        "descr": "SetRat sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the largest of a.BitLen(), b.BitLen(), or 64; with x = a/b.",
        "name": "big.Float.SetRat",
        "params": [],
        "path": "go/math/big/index#Float.SetRat",
        "syntax": "func (z *Float) SetRat(x *Rat) *Float",
        "type": "math/big"
    },
    "big.Float.SetString": {
        "descr": "SetString sets z to the value of s and returns z and a boolean indicating success. s must be a floating-point number of the same format as accepted by Parse, with base argument 0. The entire string (not just a prefix) must be valid for success. If the operation failed, the value of z is undefined but the returned value is nil.",
        "name": "big.Float.SetString",
        "params": [],
        "path": "go/math/big/index#Float.SetString",
        "syntax": "func (z *Float) SetString(s string) (*Float, bool)",
        "type": "math/big"
    },
    "big.Float.SetUint64": {
        "descr": "SetUint64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 64 (and rounding will have no effect).",
        "name": "big.Float.SetUint64",
        "params": [],
        "path": "go/math/big/index#Float.SetUint64",
        "syntax": "func (z *Float) SetUint64(x uint64) *Float",
        "type": "math/big"
    },
    "big.Float.Sign": {
        "descr": "Sign returns:",
        "name": "big.Float.Sign",
        "params": [],
        "path": "go/math/big/index#Float.Sign",
        "syntax": "func (x *Float) Sign() int",
        "type": "math/big"
    },
    "big.Float.Signbit": {
        "descr": "Signbit returns true if x is negative or negative zero.",
        "name": "big.Float.Signbit",
        "params": [],
        "path": "go/math/big/index#Float.Signbit",
        "syntax": "func (x *Float) Signbit() bool",
        "type": "math/big"
    },
    "big.Float.Sqrt": {
        "descr": "Sqrt sets z to the rounded square root of x, and returns it.",
        "name": "big.Float.Sqrt",
        "params": [],
        "path": "go/math/big/index#Float.Sqrt",
        "syntax": "func (z *Float) Sqrt(x *Float) *Float",
        "type": "math/big"
    },
    "big.Float.String": {
        "descr": "String formats x like x.Text('g', 10). (String must be called explicitly, Float.Format does not support %s verb.)",
        "name": "big.Float.String",
        "params": [],
        "path": "go/math/big/index#Float.String",
        "syntax": "func (x *Float) String() string",
        "type": "math/big"
    },
    "big.Float.Sub": {
        "descr": "Sub sets z to the rounded difference x-y and returns z. Precision, rounding, and accuracy reporting are as for Add. Sub panics with ErrNaN if x and y are infinities with equal signs. The value of z is undefined in that case.",
        "name": "big.Float.Sub",
        "params": [],
        "path": "go/math/big/index#Float.Sub",
        "syntax": "func (z *Float) Sub(x, y *Float) *Float",
        "type": "math/big"
    },
    "big.Float.Text": {
        "descr": "Text converts the floating-point number x to a string according to the given format and precision prec. The format is one of:",
        "name": "big.Float.Text",
        "params": [],
        "path": "go/math/big/index#Float.Text",
        "syntax": "func (x *Float) Text(format byte, prec int) string",
        "type": "math/big"
    },
    "big.Float.Uint64": {
        "descr": "Uint64 returns the unsigned integer resulting from truncating x towards zero. If 0 <= x <= math.MaxUint64, the result is Exact if x is an integer and Below otherwise. The result is (0, Above) for x < 0, and (math.MaxUint64, Below) for x > math.MaxUint64.",
        "name": "big.Float.Uint64",
        "params": [],
        "path": "go/math/big/index#Float.Uint64",
        "syntax": "func (x *Float) Uint64() (uint64, Accuracy)",
        "type": "math/big"
    },
    "big.Float.UnmarshalText": {
        "descr": "UnmarshalText implements the encoding.TextUnmarshaler interface. The result is rounded per the precision and rounding mode of z. If z's precision is 0, it is changed to 64 before rounding takes effect.",
        "name": "big.Float.UnmarshalText",
        "params": [],
        "path": "go/math/big/index#Float.UnmarshalText",
        "syntax": "func (z *Float) UnmarshalText(text []byte) error",
        "type": "math/big"
    },
    "big.Int": {
        "descr": "An Int represents a signed multi-precision integer. The zero value for an Int represents the value 0.",
        "name": "big.Int",
        "params": [],
        "path": "go/math/big/index#Int",
        "syntax": "type Int struct { // contains filtered or unexported fields }",
        "type": "math/big"
    },
    "big.Int.Abs": {
        "descr": "Abs sets z to |x| (the absolute value of x) and returns z.",
        "name": "big.Int.Abs",
        "params": [],
        "path": "go/math/big/index#Int.Abs",
        "syntax": "func (z *Int) Abs(x *Int) *Int",
        "type": "math/big"
    },
    "big.Int.Add": {
        "descr": "Add sets z to the sum x+y and returns z.",
        "name": "big.Int.Add",
        "params": [],
        "path": "go/math/big/index#Int.Add",
        "syntax": "func (z *Int) Add(x, y *Int) *Int",
        "type": "math/big"
    },
    "big.Int.And": {
        "descr": "And sets z = x & y and returns z.",
        "name": "big.Int.And",
        "params": [],
        "path": "go/math/big/index#Int.And",
        "syntax": "func (z *Int) And(x, y *Int) *Int",
        "type": "math/big"
    },
    "big.Int.AndNot": {
        "descr": "AndNot sets z = x &^ y and returns z.",
        "name": "big.Int.AndNot",
        "params": [],
        "path": "go/math/big/index#Int.AndNot",
        "syntax": "func (z *Int) AndNot(x, y *Int) *Int",
        "type": "math/big"
    },
    "big.Int.Append": {
        "descr": "Append appends the string representation of x, as generated by x.Text(base), to buf and returns the extended buffer.",
        "name": "big.Int.Append",
        "params": [],
        "path": "go/math/big/index#Int.Append",
        "syntax": "func (x *Int) Append(buf []byte, base int) []byte",
        "type": "math/big"
    },
    "big.Int.Binomial": {
        "descr": "Binomial sets z to the binomial coefficient of (n, k) and returns z.",
        "name": "big.Int.Binomial",
        "params": [],
        "path": "go/math/big/index#Int.Binomial",
        "syntax": "func (z *Int) Binomial(n, k int64) *Int",
        "type": "math/big"
    },
    "big.Int.Bit": {
        "descr": "Bit returns the value of the i'th bit of x. That is, it returns (x>>i)&1. The bit index i must be >= 0.",
        "name": "big.Int.Bit",
        "params": [],
        "path": "go/math/big/index#Int.Bit",
        "syntax": "func (x *Int) Bit(i int) uint",
        "type": "math/big"
    },
    "big.Int.BitLen": {
        "descr": "BitLen returns the length of the absolute value of x in bits. The bit length of 0 is 0.",
        "name": "big.Int.BitLen",
        "params": [],
        "path": "go/math/big/index#Int.BitLen",
        "syntax": "func (x *Int) BitLen() int",
        "type": "math/big"
    },
    "big.Int.Bits": {
        "descr": "Bits provides raw (unchecked but fast) access to x by returning its absolute value as a little-endian Word slice. The result and x share the same underlying array. Bits is intended to support implementation of missing low-level Int functionality outside this package; it should be avoided otherwise.",
        "name": "big.Int.Bits",
        "params": [],
        "path": "go/math/big/index#Int.Bits",
        "syntax": "func (x *Int) Bits() []Word",
        "type": "math/big"
    },
    "big.Int.Bytes": {
        "descr": "Bytes returns the absolute value of x as a big-endian byte slice.",
        "name": "big.Int.Bytes",
        "params": [],
        "path": "go/math/big/index#Int.Bytes",
        "syntax": "func (x *Int) Bytes() []byte",
        "type": "math/big"
    },
    "big.Int.Cmp": {
        "descr": "Cmp compares x and y and returns:",
        "name": "big.Int.Cmp",
        "params": [],
        "path": "go/math/big/index#Int.Cmp",
        "syntax": "func (x *Int) Cmp(y *Int) (r int)",
        "type": "math/big"
    },
    "big.Int.CmpAbs": {
        "descr": "CmpAbs compares the absolute values of x and y and returns:",
        "name": "big.Int.CmpAbs",
        "params": [],
        "path": "go/math/big/index#Int.CmpAbs",
        "syntax": "func (x *Int) CmpAbs(y *Int) int",
        "type": "math/big"
    },
    "big.Int.Div": {
        "descr": "Div sets z to the quotient x/y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Div implements Euclidean division (unlike Go); see DivMod for more details.",
        "name": "big.Int.Div",
        "params": [],
        "path": "go/math/big/index#Int.Div",
        "syntax": "func (z *Int) Div(x, y *Int) *Int",
        "type": "math/big"
    },
    "big.Int.DivMod": {
        "descr": "DivMod sets z to the quotient x div y and m to the modulus x mod y and returns the pair (z, m) for y != 0. If y == 0, a division-by-zero run-time panic occurs.",
        "name": "big.Int.DivMod",
        "params": [],
        "path": "go/math/big/index#Int.DivMod",
        "syntax": "func (z *Int) DivMod(x, y, m *Int) (*Int, *Int)",
        "type": "math/big"
    },
    "big.Int.Exp": {
        "descr": "Exp sets z = x**y mod |m| (i.e. the sign of m is ignored), and returns z. If m == nil or m == 0, z = x**y unless y <= 0 then z = 1.",
        "name": "big.Int.Exp",
        "params": [],
        "path": "go/math/big/index#Int.Exp",
        "syntax": "func (z *Int) Exp(x, y, m *Int) *Int",
        "type": "math/big"
    },
    "big.Int.Format": {
        "descr": "Format implements fmt.Formatter. It accepts the formats 'b' (binary), 'o' (octal), 'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal). Also supported are the full suite of package fmt's format flags for integral types, including '+' and ' ' for sign control, '#' for leading zero in octal and for hexadecimal, a leading \"0x\" or \"0X\" for \"%#x\" and \"%#X\" respectively, specification of minimum digits precision, output field width, space or zero padding, and '-' for left or right justification.",
        "name": "big.Int.Format",
        "params": [],
        "path": "go/math/big/index#Int.Format",
        "syntax": "func (x *Int) Format(s fmt.State, ch rune)",
        "type": "math/big"
    },
    "big.Int.GCD": {
        "descr": "GCD sets z to the greatest common divisor of a and b, which both must be > 0, and returns z. If x or y are not nil, GCD sets their value such that z = a*x + b*y. If either a or b is <= 0, GCD sets z = x = y = 0.",
        "name": "big.Int.GCD",
        "params": [],
        "path": "go/math/big/index#Int.GCD",
        "syntax": "func (z *Int) GCD(x, y, a, b *Int) *Int",
        "type": "math/big"
    },
    "big.Int.GobDecode": {
        "descr": "GobDecode implements the gob.GobDecoder interface.",
        "name": "big.Int.GobDecode",
        "params": [],
        "path": "go/math/big/index#Int.GobDecode",
        "syntax": "func (z *Int) GobDecode(buf []byte) error",
        "type": "math/big"
    },
    "big.Int.GobEncode": {
        "descr": "GobEncode implements the gob.GobEncoder interface.",
        "name": "big.Int.GobEncode",
        "params": [],
        "path": "go/math/big/index#Int.GobEncode",
        "syntax": "func (x *Int) GobEncode() ([]byte, error)",
        "type": "math/big"
    },
    "big.Int.Int64": {
        "descr": "Int64 returns the int64 representation of x. If x cannot be represented in an int64, the result is undefined.",
        "name": "big.Int.Int64",
        "params": [],
        "path": "go/math/big/index#Int.Int64",
        "syntax": "func (x *Int) Int64() int64",
        "type": "math/big"
    },
    "big.Int.IsInt64": {
        "descr": "IsInt64 reports whether x can be represented as an int64.",
        "name": "big.Int.IsInt64",
        "params": [],
        "path": "go/math/big/index#Int.IsInt64",
        "syntax": "func (x *Int) IsInt64() bool",
        "type": "math/big"
    },
    "big.Int.IsUint64": {
        "descr": "IsUint64 reports whether x can be represented as a uint64.",
        "name": "big.Int.IsUint64",
        "params": [],
        "path": "go/math/big/index#Int.IsUint64",
        "syntax": "func (x *Int) IsUint64() bool",
        "type": "math/big"
    },
    "big.Int.Lsh": {
        "descr": "Lsh sets z = x << n and returns z.",
        "name": "big.Int.Lsh",
        "params": [],
        "path": "go/math/big/index#Int.Lsh",
        "syntax": "func (z *Int) Lsh(x *Int, n uint) *Int",
        "type": "math/big"
    },
    "big.Int.MarshalJSON": {
        "descr": "MarshalJSON implements the json.Marshaler interface.",
        "name": "big.Int.MarshalJSON",
        "params": [],
        "path": "go/math/big/index#Int.MarshalJSON",
        "syntax": "func (x *Int) MarshalJSON() ([]byte, error)",
        "type": "math/big"
    },
    "big.Int.MarshalText": {
        "descr": "MarshalText implements the encoding.TextMarshaler interface.",
        "name": "big.Int.MarshalText",
        "params": [],
        "path": "go/math/big/index#Int.MarshalText",
        "syntax": "func (x *Int) MarshalText() (text []byte, err error)",
        "type": "math/big"
    },
    "big.Int.Mod": {
        "descr": "Mod sets z to the modulus x%y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Mod implements Euclidean modulus (unlike Go); see DivMod for more details.",
        "name": "big.Int.Mod",
        "params": [],
        "path": "go/math/big/index#Int.Mod",
        "syntax": "func (z *Int) Mod(x, y *Int) *Int",
        "type": "math/big"
    },
    "big.Int.ModInverse": {
        "descr": "ModInverse sets z to the multiplicative inverse of g in the ring /n and returns z. If g and n are not relatively prime, g has no multiplicative inverse in the ring /n. In this case, z is unchanged and the return value is nil.",
        "name": "big.Int.ModInverse",
        "params": [],
        "path": "go/math/big/index#Int.ModInverse",
        "syntax": "func (z *Int) ModInverse(g, n *Int) *Int",
        "type": "math/big"
    },
    "big.Int.ModSqrt": {
        "descr": "ModSqrt sets z to a square root of x mod p if such a square root exists, and returns z. The modulus p must be an odd prime. If x is not a square mod p, ModSqrt leaves z unchanged and returns nil. This function panics if p is not an odd integer.",
        "name": "big.Int.ModSqrt",
        "params": [],
        "path": "go/math/big/index#Int.ModSqrt",
        "syntax": "func (z *Int) ModSqrt(x, p *Int) *Int",
        "type": "math/big"
    },
    "big.Int.Mul": {
        "descr": "Mul sets z to the product x*y and returns z.",
        "name": "big.Int.Mul",
        "params": [],
        "path": "go/math/big/index#Int.Mul",
        "syntax": "func (z *Int) Mul(x, y *Int) *Int",
        "type": "math/big"
    },
    "big.Int.MulRange": {
        "descr": "MulRange sets z to the product of all integers in the range [a, b] inclusively and returns z. If a > b (empty range), the result is 1.",
        "name": "big.Int.MulRange",
        "params": [],
        "path": "go/math/big/index#Int.MulRange",
        "syntax": "func (z *Int) MulRange(a, b int64) *Int",
        "type": "math/big"
    },
    "big.Int.Neg": {
        "descr": "Neg sets z to -x and returns z.",
        "name": "big.Int.Neg",
        "params": [],
        "path": "go/math/big/index#Int.Neg",
        "syntax": "func (z *Int) Neg(x *Int) *Int",
        "type": "math/big"
    },
    "big.Int.Not": {
        "descr": "Not sets z = ^x and returns z.",
        "name": "big.Int.Not",
        "params": [],
        "path": "go/math/big/index#Int.Not",
        "syntax": "func (z *Int) Not(x *Int) *Int",
        "type": "math/big"
    },
    "big.Int.Or": {
        "descr": "Or sets z = x | y and returns z.",
        "name": "big.Int.Or",
        "params": [],
        "path": "go/math/big/index#Int.Or",
        "syntax": "func (z *Int) Or(x, y *Int) *Int",
        "type": "math/big"
    },
    "big.Int.ProbablyPrime": {
        "descr": "ProbablyPrime reports whether x is probably prime, applying the Miller-Rabin test with n pseudorandomly chosen bases as well as a Baillie-PSW test.",
        "name": "big.Int.ProbablyPrime",
        "params": [],
        "path": "go/math/big/index#Int.ProbablyPrime",
        "syntax": "func (x *Int) ProbablyPrime(n int) bool",
        "type": "math/big"
    },
    "big.Int.Quo": {
        "descr": "Quo sets z to the quotient x/y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Quo implements truncated division (like Go); see QuoRem for more details.",
        "name": "big.Int.Quo",
        "params": [],
        "path": "go/math/big/index#Int.Quo",
        "syntax": "func (z *Int) Quo(x, y *Int) *Int",
        "type": "math/big"
    },
    "big.Int.QuoRem": {
        "descr": "QuoRem sets z to the quotient x/y and r to the remainder x%y and returns the pair (z, r) for y != 0. If y == 0, a division-by-zero run-time panic occurs.",
        "name": "big.Int.QuoRem",
        "params": [],
        "path": "go/math/big/index#Int.QuoRem",
        "syntax": "func (z *Int) QuoRem(x, y, r *Int) (*Int, *Int)",
        "type": "math/big"
    },
    "big.Int.Rand": {
        "descr": "Rand sets z to a pseudo-random number in [0, n) and returns z.",
        "name": "big.Int.Rand",
        "params": [],
        "path": "go/math/big/index#Int.Rand",
        "syntax": "func (z *Int) Rand(rnd *rand.Rand, n *Int) *Int",
        "type": "math/big"
    },
    "big.Int.Rem": {
        "descr": "Rem sets z to the remainder x%y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Rem implements truncated modulus (like Go); see QuoRem for more details.",
        "name": "big.Int.Rem",
        "params": [],
        "path": "go/math/big/index#Int.Rem",
        "syntax": "func (z *Int) Rem(x, y *Int) *Int",
        "type": "math/big"
    },
    "big.Int.Rsh": {
        "descr": "Rsh sets z = x >> n and returns z.",
        "name": "big.Int.Rsh",
        "params": [],
        "path": "go/math/big/index#Int.Rsh",
        "syntax": "func (z *Int) Rsh(x *Int, n uint) *Int",
        "type": "math/big"
    },
    "big.Int.Scan": {
        "descr": "Scan is a support routine for fmt.Scanner; it sets z to the value of the scanned number. It accepts the formats 'b' (binary), 'o' (octal), 'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal).",
        "name": "big.Int.Scan",
        "params": [],
        "path": "go/math/big/index#Int.Scan",
        "syntax": "func (z *Int) Scan(s fmt.ScanState, ch rune) error",
        "type": "math/big"
    },
    "big.Int.Set": {
        "descr": "Set sets z to x and returns z.",
        "name": "big.Int.Set",
        "params": [],
        "path": "go/math/big/index#Int.Set",
        "syntax": "func (z *Int) Set(x *Int) *Int",
        "type": "math/big"
    },
    "big.Int.SetBit": {
        "descr": "SetBit sets z to x, with x's i'th bit set to b (0 or 1). That is, if b is 1 SetBit sets z = x | (1 << i); if b is 0 SetBit sets z = x &^ (1 << i). If b is not 0 or 1, SetBit will panic.",
        "name": "big.Int.SetBit",
        "params": [],
        "path": "go/math/big/index#Int.SetBit",
        "syntax": "func (z *Int) SetBit(x *Int, i int, b uint) *Int",
        "type": "math/big"
    },
    "big.Int.SetBits": {
        "descr": "SetBits provides raw (unchecked but fast) access to z by setting its value to abs, interpreted as a little-endian Word slice, and returning z. The result and abs share the same underlying array. SetBits is intended to support implementation of missing low-level Int functionality outside this package; it should be avoided otherwise.",
        "name": "big.Int.SetBits",
        "params": [],
        "path": "go/math/big/index#Int.SetBits",
        "syntax": "func (z *Int) SetBits(abs []Word) *Int",
        "type": "math/big"
    },
    "big.Int.SetBytes": {
        "descr": "SetBytes interprets buf as the bytes of a big-endian unsigned integer, sets z to that value, and returns z.",
        "name": "big.Int.SetBytes",
        "params": [],
        "path": "go/math/big/index#Int.SetBytes",
        "syntax": "func (z *Int) SetBytes(buf []byte) *Int",
        "type": "math/big"
    },
    "big.Int.SetInt64": {
        "descr": "SetInt64 sets z to x and returns z.",
        "name": "big.Int.SetInt64",
        "params": [],
        "path": "go/math/big/index#Int.SetInt64",
        "syntax": "func (z *Int) SetInt64(x int64) *Int",
        "type": "math/big"
    },
    "big.Int.SetString": {
        "descr": "SetString sets z to the value of s, interpreted in the given base, and returns z and a boolean indicating success. The entire string (not just a prefix) must be valid for success. If SetString fails, the value of z is undefined but the returned value is nil.",
        "name": "big.Int.SetString",
        "params": [],
        "path": "go/math/big/index#Int.SetString",
        "syntax": "func (z *Int) SetString(s string, base int) (*Int, bool)",
        "type": "math/big"
    },
    "big.Int.SetUint64": {
        "descr": "SetUint64 sets z to x and returns z.",
        "name": "big.Int.SetUint64",
        "params": [],
        "path": "go/math/big/index#Int.SetUint64",
        "syntax": "func (z *Int) SetUint64(x uint64) *Int",
        "type": "math/big"
    },
    "big.Int.Sign": {
        "descr": "Sign returns:",
        "name": "big.Int.Sign",
        "params": [],
        "path": "go/math/big/index#Int.Sign",
        "syntax": "func (x *Int) Sign() int",
        "type": "math/big"
    },
    "big.Int.Sqrt": {
        "descr": "Sqrt sets z to x, the largest integer such that z  x, and returns z. It panics if x is negative.",
        "name": "big.Int.Sqrt",
        "params": [],
        "path": "go/math/big/index#Int.Sqrt",
        "syntax": "func (z *Int) Sqrt(x *Int) *Int",
        "type": "math/big"
    },
    "big.Int.String": {
        "descr": "",
        "name": "big.Int.String",
        "params": [],
        "path": "go/math/big/index#Int.String",
        "syntax": "func (x *Int) String() string",
        "type": "math/big"
    },
    "big.Int.Sub": {
        "descr": "Sub sets z to the difference x-y and returns z.",
        "name": "big.Int.Sub",
        "params": [],
        "path": "go/math/big/index#Int.Sub",
        "syntax": "func (z *Int) Sub(x, y *Int) *Int",
        "type": "math/big"
    },
    "big.Int.Text": {
        "descr": "Text returns the string representation of x in the given base. Base must be between 2 and 62, inclusive. The result uses the lower-case letters 'a' to 'z' for digit values 10 to 35, and the upper-case letters 'A' to 'Z' for digit values 36 to 61. No prefix (such as \"0x\") is added to the string.",
        "name": "big.Int.Text",
        "params": [],
        "path": "go/math/big/index#Int.Text",
        "syntax": "func (x *Int) Text(base int) string",
        "type": "math/big"
    },
    "big.Int.Uint64": {
        "descr": "Uint64 returns the uint64 representation of x. If x cannot be represented in a uint64, the result is undefined.",
        "name": "big.Int.Uint64",
        "params": [],
        "path": "go/math/big/index#Int.Uint64",
        "syntax": "func (x *Int) Uint64() uint64",
        "type": "math/big"
    },
    "big.Int.UnmarshalJSON": {
        "descr": "UnmarshalJSON implements the json.Unmarshaler interface.",
        "name": "big.Int.UnmarshalJSON",
        "params": [],
        "path": "go/math/big/index#Int.UnmarshalJSON",
        "syntax": "func (z *Int) UnmarshalJSON(text []byte) error",
        "type": "math/big"
    },
    "big.Int.UnmarshalText": {
        "descr": "UnmarshalText implements the encoding.TextUnmarshaler interface.",
        "name": "big.Int.UnmarshalText",
        "params": [],
        "path": "go/math/big/index#Int.UnmarshalText",
        "syntax": "func (z *Int) UnmarshalText(text []byte) error",
        "type": "math/big"
    },
    "big.Int.Xor": {
        "descr": "Xor sets z = x ^ y and returns z.",
        "name": "big.Int.Xor",
        "params": [],
        "path": "go/math/big/index#Int.Xor",
        "syntax": "func (z *Int) Xor(x, y *Int) *Int",
        "type": "math/big"
    },
    "big.Jacobi": {
        "descr": "Jacobi returns the Jacobi symbol (x/y), either +1, -1, or 0. The y argument must be an odd integer.",
        "name": "big.Jacobi",
        "params": [],
        "path": "go/math/big/index#Jacobi",
        "syntax": "func Jacobi(x, y *Int) int",
        "type": "math/big"
    },
    "big.NewFloat": {
        "descr": "NewFloat allocates and returns a new Float set to x, with precision 53 and rounding mode ToNearestEven. NewFloat panics with ErrNaN if x is a NaN.",
        "name": "big.NewFloat",
        "params": [],
        "path": "go/math/big/index#NewFloat",
        "syntax": "func NewFloat(x float64) *Float",
        "type": "math/big"
    },
    "big.NewInt": {
        "descr": "NewInt allocates and returns a new Int set to x.",
        "name": "big.NewInt",
        "params": [],
        "path": "go/math/big/index#NewInt",
        "syntax": "func NewInt(x int64) *Int",
        "type": "math/big"
    },
    "big.NewRat": {
        "descr": "NewRat creates a new Rat with numerator a and denominator b.",
        "name": "big.NewRat",
        "params": [],
        "path": "go/math/big/index#NewRat",
        "syntax": "func NewRat(a, b int64) *Rat",
        "type": "math/big"
    },
    "big.ParseFloat": {
        "descr": "ParseFloat is like f.Parse(s, base) with f set to the given precision and rounding mode.",
        "name": "big.ParseFloat",
        "params": [],
        "path": "go/math/big/index#ParseFloat",
        "syntax": "func ParseFloat(s string, base int, prec uint, mode RoundingMode) (f *Float, b int, err error)",
        "type": "math/big"
    },
    "big.Rat": {
        "descr": "A Rat represents a quotient a/b of arbitrary precision. The zero value for a Rat represents the value 0.",
        "name": "big.Rat",
        "params": [],
        "path": "go/math/big/index#Rat",
        "syntax": "type Rat struct { // contains filtered or unexported fields }",
        "type": "math/big"
    },
    "big.Rat.Abs": {
        "descr": "Abs sets z to |x| (the absolute value of x) and returns z.",
        "name": "big.Rat.Abs",
        "params": [],
        "path": "go/math/big/index#Rat.Abs",
        "syntax": "func (z *Rat) Abs(x *Rat) *Rat",
        "type": "math/big"
    },
    "big.Rat.Add": {
        "descr": "Add sets z to the sum x+y and returns z.",
        "name": "big.Rat.Add",
        "params": [],
        "path": "go/math/big/index#Rat.Add",
        "syntax": "func (z *Rat) Add(x, y *Rat) *Rat",
        "type": "math/big"
    },
    "big.Rat.Cmp": {
        "descr": "Cmp compares x and y and returns:",
        "name": "big.Rat.Cmp",
        "params": [],
        "path": "go/math/big/index#Rat.Cmp",
        "syntax": "func (x *Rat) Cmp(y *Rat) int",
        "type": "math/big"
    },
    "big.Rat.Denom": {
        "descr": "Denom returns the denominator of x; it is always > 0. The result is a reference to x's denominator; it may change if a new value is assigned to x, and vice versa.",
        "name": "big.Rat.Denom",
        "params": [],
        "path": "go/math/big/index#Rat.Denom",
        "syntax": "func (x *Rat) Denom() *Int",
        "type": "math/big"
    },
    "big.Rat.Float32": {
        "descr": "Float32 returns the nearest float32 value for x and a bool indicating whether f represents x exactly. If the magnitude of x is too large to be represented by a float32, f is an infinity and exact is false. The sign of f always matches the sign of x, even if f == 0.",
        "name": "big.Rat.Float32",
        "params": [],
        "path": "go/math/big/index#Rat.Float32",
        "syntax": "func (x *Rat) Float32() (f float32, exact bool)",
        "type": "math/big"
    },
    "big.Rat.Float64": {
        "descr": "Float64 returns the nearest float64 value for x and a bool indicating whether f represents x exactly. If the magnitude of x is too large to be represented by a float64, f is an infinity and exact is false. The sign of f always matches the sign of x, even if f == 0.",
        "name": "big.Rat.Float64",
        "params": [],
        "path": "go/math/big/index#Rat.Float64",
        "syntax": "func (x *Rat) Float64() (f float64, exact bool)",
        "type": "math/big"
    },
    "big.Rat.FloatString": {
        "descr": "FloatString returns a string representation of x in decimal form with prec digits of precision after the decimal point. The last digit is rounded to nearest, with halves rounded away from zero.",
        "name": "big.Rat.FloatString",
        "params": [],
        "path": "go/math/big/index#Rat.FloatString",
        "syntax": "func (x *Rat) FloatString(prec int) string",
        "type": "math/big"
    },
    "big.Rat.GobDecode": {
        "descr": "GobDecode implements the gob.GobDecoder interface.",
        "name": "big.Rat.GobDecode",
        "params": [],
        "path": "go/math/big/index#Rat.GobDecode",
        "syntax": "func (z *Rat) GobDecode(buf []byte) error",
        "type": "math/big"
    },
    "big.Rat.GobEncode": {
        "descr": "GobEncode implements the gob.GobEncoder interface.",
        "name": "big.Rat.GobEncode",
        "params": [],
        "path": "go/math/big/index#Rat.GobEncode",
        "syntax": "func (x *Rat) GobEncode() ([]byte, error)",
        "type": "math/big"
    },
    "big.Rat.Inv": {
        "descr": "Inv sets z to 1/x and returns z.",
        "name": "big.Rat.Inv",
        "params": [],
        "path": "go/math/big/index#Rat.Inv",
        "syntax": "func (z *Rat) Inv(x *Rat) *Rat",
        "type": "math/big"
    },
    "big.Rat.IsInt": {
        "descr": "IsInt reports whether the denominator of x is 1.",
        "name": "big.Rat.IsInt",
        "params": [],
        "path": "go/math/big/index#Rat.IsInt",
        "syntax": "func (x *Rat) IsInt() bool",
        "type": "math/big"
    },
    "big.Rat.MarshalText": {
        "descr": "MarshalText implements the encoding.TextMarshaler interface.",
        "name": "big.Rat.MarshalText",
        "params": [],
        "path": "go/math/big/index#Rat.MarshalText",
        "syntax": "func (x *Rat) MarshalText() (text []byte, err error)",
        "type": "math/big"
    },
    "big.Rat.Mul": {
        "descr": "Mul sets z to the product x*y and returns z.",
        "name": "big.Rat.Mul",
        "params": [],
        "path": "go/math/big/index#Rat.Mul",
        "syntax": "func (z *Rat) Mul(x, y *Rat) *Rat",
        "type": "math/big"
    },
    "big.Rat.Neg": {
        "descr": "Neg sets z to -x and returns z.",
        "name": "big.Rat.Neg",
        "params": [],
        "path": "go/math/big/index#Rat.Neg",
        "syntax": "func (z *Rat) Neg(x *Rat) *Rat",
        "type": "math/big"
    },
    "big.Rat.Num": {
        "descr": "Num returns the numerator of x; it may be <= 0. The result is a reference to x's numerator; it may change if a new value is assigned to x, and vice versa. The sign of the numerator corresponds to the sign of x.",
        "name": "big.Rat.Num",
        "params": [],
        "path": "go/math/big/index#Rat.Num",
        "syntax": "func (x *Rat) Num() *Int",
        "type": "math/big"
    },
    "big.Rat.Quo": {
        "descr": "Quo sets z to the quotient x/y and returns z. If y == 0, a division-by-zero run-time panic occurs.",
        "name": "big.Rat.Quo",
        "params": [],
        "path": "go/math/big/index#Rat.Quo",
        "syntax": "func (z *Rat) Quo(x, y *Rat) *Rat",
        "type": "math/big"
    },
    "big.Rat.RatString": {
        "descr": "RatString returns a string representation of x in the form \"a/b\" if b != 1, and in the form \"a\" if b == 1.",
        "name": "big.Rat.RatString",
        "params": [],
        "path": "go/math/big/index#Rat.RatString",
        "syntax": "func (x *Rat) RatString() string",
        "type": "math/big"
    },
    "big.Rat.Scan": {
        "descr": "Scan is a support routine for fmt.Scanner. It accepts the formats 'e', 'E', 'f', 'F', 'g', 'G', and 'v'. All formats are equivalent.",
        "name": "big.Rat.Scan",
        "params": [],
        "path": "go/math/big/index#Rat.Scan",
        "syntax": "func (z *Rat) Scan(s fmt.ScanState, ch rune) error",
        "type": "math/big"
    },
    "big.Rat.Set": {
        "descr": "Set sets z to x (by making a copy of x) and returns z.",
        "name": "big.Rat.Set",
        "params": [],
        "path": "go/math/big/index#Rat.Set",
        "syntax": "func (z *Rat) Set(x *Rat) *Rat",
        "type": "math/big"
    },
    "big.Rat.SetFloat64": {
        "descr": "SetFloat64 sets z to exactly f and returns z. If f is not finite, SetFloat returns nil.",
        "name": "big.Rat.SetFloat64",
        "params": [],
        "path": "go/math/big/index#Rat.SetFloat64",
        "syntax": "func (z *Rat) SetFloat64(f float64) *Rat",
        "type": "math/big"
    },
    "big.Rat.SetFrac": {
        "descr": "SetFrac sets z to a/b and returns z.",
        "name": "big.Rat.SetFrac",
        "params": [],
        "path": "go/math/big/index#Rat.SetFrac",
        "syntax": "func (z *Rat) SetFrac(a, b *Int) *Rat",
        "type": "math/big"
    },
    "big.Rat.SetFrac64": {
        "descr": "SetFrac64 sets z to a/b and returns z.",
        "name": "big.Rat.SetFrac64",
        "params": [],
        "path": "go/math/big/index#Rat.SetFrac64",
        "syntax": "func (z *Rat) SetFrac64(a, b int64) *Rat",
        "type": "math/big"
    },
    "big.Rat.SetInt": {
        "descr": "SetInt sets z to x (by making a copy of x) and returns z.",
        "name": "big.Rat.SetInt",
        "params": [],
        "path": "go/math/big/index#Rat.SetInt",
        "syntax": "func (z *Rat) SetInt(x *Int) *Rat",
        "type": "math/big"
    },
    "big.Rat.SetInt64": {
        "descr": "SetInt64 sets z to x and returns z.",
        "name": "big.Rat.SetInt64",
        "params": [],
        "path": "go/math/big/index#Rat.SetInt64",
        "syntax": "func (z *Rat) SetInt64(x int64) *Rat",
        "type": "math/big"
    },
    "big.Rat.SetString": {
        "descr": "SetString sets z to the value of s and returns z and a boolean indicating success. s can be given as a fraction \"a/b\" or as a floating-point number optionally followed by an exponent. The entire string (not just a prefix) must be valid for success. If the operation failed, the value of z is undefined but the returned value is nil.",
        "name": "big.Rat.SetString",
        "params": [],
        "path": "go/math/big/index#Rat.SetString",
        "syntax": "func (z *Rat) SetString(s string) (*Rat, bool)",
        "type": "math/big"
    },
    "big.Rat.Sign": {
        "descr": "Sign returns:",
        "name": "big.Rat.Sign",
        "params": [],
        "path": "go/math/big/index#Rat.Sign",
        "syntax": "func (x *Rat) Sign() int",
        "type": "math/big"
    },
    "big.Rat.String": {
        "descr": "String returns a string representation of x in the form \"a/b\" (even if b == 1).",
        "name": "big.Rat.String",
        "params": [],
        "path": "go/math/big/index#Rat.String",
        "syntax": "func (x *Rat) String() string",
        "type": "math/big"
    },
    "big.Rat.Sub": {
        "descr": "Sub sets z to the difference x-y and returns z.",
        "name": "big.Rat.Sub",
        "params": [],
        "path": "go/math/big/index#Rat.Sub",
        "syntax": "func (z *Rat) Sub(x, y *Rat) *Rat",
        "type": "math/big"
    },
    "big.Rat.UnmarshalText": {
        "descr": "UnmarshalText implements the encoding.TextUnmarshaler interface.",
        "name": "big.Rat.UnmarshalText",
        "params": [],
        "path": "go/math/big/index#Rat.UnmarshalText",
        "syntax": "func (z *Rat) UnmarshalText(text []byte) error",
        "type": "math/big"
    },
    "big.RoundingMode": {
        "descr": "RoundingMode determines how a Float value is rounded to the desired precision. Rounding may change the Float value; the rounding error is described by the Float's Accuracy.",
        "name": "big.RoundingMode",
        "params": [],
        "path": "go/math/big/index#RoundingMode",
        "syntax": "type RoundingMode byte",
        "type": "math/big"
    },
    "big.RoundingMode.String": {
        "descr": "",
        "name": "big.RoundingMode.String",
        "params": [],
        "path": "go/math/big/index#RoundingMode.String",
        "syntax": "func (i RoundingMode) String() string",
        "type": "math/big"
    },
    "big.Word": {
        "descr": "A Word represents a single digit of a multi-precision unsigned integer.",
        "name": "big.Word",
        "params": [],
        "path": "go/math/big/index#Word",
        "syntax": "type Word uint",
        "type": "math/big"
    },
    "binary.ByteOrder": {
        "descr": "A ByteOrder specifies how to convert byte sequences into 16-, 32-, or 64-bit unsigned integers.",
        "name": "binary.ByteOrder",
        "params": [],
        "path": "go/encoding/binary/index#ByteOrder",
        "syntax": "type ByteOrder interface { Uint16([]byte) uint16 Uint32([]byte) uint32 Uint64([]byte) uint64 PutUint16([]byte, uint16) PutUint32([]byte, uint32) PutUint64([]byte, uint64) String() string }",
        "type": "encoding"
    },
    "binary.PutUvarint": {
        "descr": "PutUvarint encodes a uint64 into buf and returns the number of bytes written. If the buffer is too small, PutUvarint will panic.",
        "name": "binary.PutUvarint",
        "params": [],
        "path": "go/encoding/binary/index#PutUvarint",
        "syntax": "func PutUvarint(buf []byte, x uint64) int",
        "type": "encoding"
    },
    "binary.PutVarint": {
        "descr": "PutVarint encodes an int64 into buf and returns the number of bytes written. If the buffer is too small, PutVarint will panic.",
        "name": "binary.PutVarint",
        "params": [],
        "path": "go/encoding/binary/index#PutVarint",
        "syntax": "func PutVarint(buf []byte, x int64) int",
        "type": "encoding"
    },
    "binary.Read": {
        "descr": "Read reads structured binary data from r into data. Data must be a pointer to a fixed-size value or a slice of fixed-size values. Bytes read from r are decoded using the specified byte order and written to successive fields of the data. When decoding boolean values, a zero byte is decoded as false, and any other non-zero byte is decoded as true. When reading into structs, the field data for fields with blank (_) field names is skipped; i.e., blank field names may be used for padding. When reading into a struct, all non-blank fields must be exported or Read may panic.",
        "name": "binary.Read",
        "params": [],
        "path": "go/encoding/binary/index#Read",
        "syntax": "func Read(r io.Reader, order ByteOrder, data interface{}) error",
        "type": "encoding"
    },
    "binary.ReadUvarint": {
        "descr": "ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64.",
        "name": "binary.ReadUvarint",
        "params": [],
        "path": "go/encoding/binary/index#ReadUvarint",
        "syntax": "func ReadUvarint(r io.ByteReader) (uint64, error)",
        "type": "encoding"
    },
    "binary.ReadVarint": {
        "descr": "ReadVarint reads an encoded signed integer from r and returns it as an int64.",
        "name": "binary.ReadVarint",
        "params": [],
        "path": "go/encoding/binary/index#ReadVarint",
        "syntax": "func ReadVarint(r io.ByteReader) (int64, error)",
        "type": "encoding"
    },
    "binary.Size": {
        "descr": "Size returns how many bytes Write would generate to encode the value v, which must be a fixed-size value or a slice of fixed-size values, or a pointer to such data. If v is neither of these, Size returns -1.",
        "name": "binary.Size",
        "params": [],
        "path": "go/encoding/binary/index#Size",
        "syntax": "func Size(v interface{}) int",
        "type": "encoding"
    },
    "binary.Uvarint": {
        "descr": "Uvarint decodes a uint64 from buf and returns that value and the number of bytes read (> 0). If an error occurred, the value is 0 and the number of bytes n is <= 0 meaning:",
        "name": "binary.Uvarint",
        "params": [],
        "path": "go/encoding/binary/index#Uvarint",
        "syntax": "func Uvarint(buf []byte) (uint64, int)",
        "type": "encoding"
    },
    "binary.Varint": {
        "descr": "Varint decodes an int64 from buf and returns that value and the number of bytes read (> 0). If an error occurred, the value is 0 and the number of bytes n is <= 0 with the following meaning:",
        "name": "binary.Varint",
        "params": [],
        "path": "go/encoding/binary/index#Varint",
        "syntax": "func Varint(buf []byte) (int64, int)",
        "type": "encoding"
    },
    "binary.Write": {
        "descr": "Write writes the binary representation of data into w. Data must be a fixed-size value or a slice of fixed-size values, or a pointer to such data. Boolean values encode as one byte: 1 for true, and 0 for false. Bytes written to w are encoded using the specified byte order and read from successive fields of the data. When writing structs, zero values are written for fields with blank (_) field names.",
        "name": "binary.Write",
        "params": [],
        "path": "go/encoding/binary/index#Write",
        "syntax": "func Write(w io.Writer, order ByteOrder, data interface{}) error",
        "type": "encoding"
    },
    "bits.LeadingZeros": {
        "descr": "LeadingZeros returns the number of leading zero bits in x; the result is UintSize for x == 0.",
        "name": "bits.LeadingZeros",
        "params": [],
        "path": "go/math/bits/index#LeadingZeros",
        "syntax": "func LeadingZeros(x uint) int",
        "type": "math/bits"
    },
    "bits.LeadingZeros16": {
        "descr": "LeadingZeros16 returns the number of leading zero bits in x; the result is 16 for x == 0.",
        "name": "bits.LeadingZeros16",
        "params": [],
        "path": "go/math/bits/index#LeadingZeros16",
        "syntax": "func LeadingZeros16(x uint16) int",
        "type": "math/bits"
    },
    "bits.LeadingZeros32": {
        "descr": "LeadingZeros32 returns the number of leading zero bits in x; the result is 32 for x == 0.",
        "name": "bits.LeadingZeros32",
        "params": [],
        "path": "go/math/bits/index#LeadingZeros32",
        "syntax": "func LeadingZeros32(x uint32) int",
        "type": "math/bits"
    },
    "bits.LeadingZeros64": {
        "descr": "LeadingZeros64 returns the number of leading zero bits in x; the result is 64 for x == 0.",
        "name": "bits.LeadingZeros64",
        "params": [],
        "path": "go/math/bits/index#LeadingZeros64",
        "syntax": "func LeadingZeros64(x uint64) int",
        "type": "math/bits"
    },
    "bits.LeadingZeros8": {
        "descr": "LeadingZeros8 returns the number of leading zero bits in x; the result is 8 for x == 0.",
        "name": "bits.LeadingZeros8",
        "params": [],
        "path": "go/math/bits/index#LeadingZeros8",
        "syntax": "func LeadingZeros8(x uint8) int",
        "type": "math/bits"
    },
    "bits.Len": {
        "descr": "Len returns the minimum number of bits required to represent x; the result is 0 for x == 0.",
        "name": "bits.Len",
        "params": [],
        "path": "go/math/bits/index#Len",
        "syntax": "func Len(x uint) int",
        "type": "math/bits"
    },
    "bits.Len16": {
        "descr": "Len16 returns the minimum number of bits required to represent x; the result is 0 for x == 0.",
        "name": "bits.Len16",
        "params": [],
        "path": "go/math/bits/index#Len16",
        "syntax": "func Len16(x uint16) (n int)",
        "type": "math/bits"
    },
    "bits.Len32": {
        "descr": "Len32 returns the minimum number of bits required to represent x; the result is 0 for x == 0.",
        "name": "bits.Len32",
        "params": [],
        "path": "go/math/bits/index#Len32",
        "syntax": "func Len32(x uint32) (n int)",
        "type": "math/bits"
    },
    "bits.Len64": {
        "descr": "Len64 returns the minimum number of bits required to represent x; the result is 0 for x == 0.",
        "name": "bits.Len64",
        "params": [],
        "path": "go/math/bits/index#Len64",
        "syntax": "func Len64(x uint64) (n int)",
        "type": "math/bits"
    },
    "bits.Len8": {
        "descr": "Len8 returns the minimum number of bits required to represent x; the result is 0 for x == 0.",
        "name": "bits.Len8",
        "params": [],
        "path": "go/math/bits/index#Len8",
        "syntax": "func Len8(x uint8) int",
        "type": "math/bits"
    },
    "bits.OnesCount": {
        "descr": "OnesCount returns the number of one bits (\"population count\") in x.",
        "name": "bits.OnesCount",
        "params": [],
        "path": "go/math/bits/index#OnesCount",
        "syntax": "func OnesCount(x uint) int",
        "type": "math/bits"
    },
    "bits.OnesCount16": {
        "descr": "OnesCount16 returns the number of one bits (\"population count\") in x.",
        "name": "bits.OnesCount16",
        "params": [],
        "path": "go/math/bits/index#OnesCount16",
        "syntax": "func OnesCount16(x uint16) int",
        "type": "math/bits"
    },
    "bits.OnesCount32": {
        "descr": "OnesCount32 returns the number of one bits (\"population count\") in x.",
        "name": "bits.OnesCount32",
        "params": [],
        "path": "go/math/bits/index#OnesCount32",
        "syntax": "func OnesCount32(x uint32) int",
        "type": "math/bits"
    },
    "bits.OnesCount64": {
        "descr": "OnesCount64 returns the number of one bits (\"population count\") in x.",
        "name": "bits.OnesCount64",
        "params": [],
        "path": "go/math/bits/index#OnesCount64",
        "syntax": "func OnesCount64(x uint64) int",
        "type": "math/bits"
    },
    "bits.OnesCount8": {
        "descr": "OnesCount8 returns the number of one bits (\"population count\") in x.",
        "name": "bits.OnesCount8",
        "params": [],
        "path": "go/math/bits/index#OnesCount8",
        "syntax": "func OnesCount8(x uint8) int",
        "type": "math/bits"
    },
    "bits.Reverse": {
        "descr": "Reverse returns the value of x with its bits in reversed order.",
        "name": "bits.Reverse",
        "params": [],
        "path": "go/math/bits/index#Reverse",
        "syntax": "func Reverse(x uint) uint",
        "type": "math/bits"
    },
    "bits.Reverse16": {
        "descr": "Reverse16 returns the value of x with its bits in reversed order.",
        "name": "bits.Reverse16",
        "params": [],
        "path": "go/math/bits/index#Reverse16",
        "syntax": "func Reverse16(x uint16) uint16",
        "type": "math/bits"
    },
    "bits.Reverse32": {
        "descr": "Reverse32 returns the value of x with its bits in reversed order.",
        "name": "bits.Reverse32",
        "params": [],
        "path": "go/math/bits/index#Reverse32",
        "syntax": "func Reverse32(x uint32) uint32",
        "type": "math/bits"
    },
    "bits.Reverse64": {
        "descr": "Reverse64 returns the value of x with its bits in reversed order.",
        "name": "bits.Reverse64",
        "params": [],
        "path": "go/math/bits/index#Reverse64",
        "syntax": "func Reverse64(x uint64) uint64",
        "type": "math/bits"
    },
    "bits.Reverse8": {
        "descr": "Reverse8 returns the value of x with its bits in reversed order.",
        "name": "bits.Reverse8",
        "params": [],
        "path": "go/math/bits/index#Reverse8",
        "syntax": "func Reverse8(x uint8) uint8",
        "type": "math/bits"
    },
    "bits.ReverseBytes": {
        "descr": "ReverseBytes returns the value of x with its bytes in reversed order.",
        "name": "bits.ReverseBytes",
        "params": [],
        "path": "go/math/bits/index#ReverseBytes",
        "syntax": "func ReverseBytes(x uint) uint",
        "type": "math/bits"
    },
    "bits.ReverseBytes16": {
        "descr": "ReverseBytes16 returns the value of x with its bytes in reversed order.",
        "name": "bits.ReverseBytes16",
        "params": [],
        "path": "go/math/bits/index#ReverseBytes16",
        "syntax": "func ReverseBytes16(x uint16) uint16",
        "type": "math/bits"
    },
    "bits.ReverseBytes32": {
        "descr": "ReverseBytes32 returns the value of x with its bytes in reversed order.",
        "name": "bits.ReverseBytes32",
        "params": [],
        "path": "go/math/bits/index#ReverseBytes32",
        "syntax": "func ReverseBytes32(x uint32) uint32",
        "type": "math/bits"
    },
    "bits.ReverseBytes64": {
        "descr": "ReverseBytes64 returns the value of x with its bytes in reversed order.",
        "name": "bits.ReverseBytes64",
        "params": [],
        "path": "go/math/bits/index#ReverseBytes64",
        "syntax": "func ReverseBytes64(x uint64) uint64",
        "type": "math/bits"
    },
    "bits.RotateLeft": {
        "descr": "RotateLeft returns the value of x rotated left by (k mod UintSize) bits. To rotate x right by k bits, call RotateLeft(x, -k).",
        "name": "bits.RotateLeft",
        "params": [],
        "path": "go/math/bits/index#RotateLeft",
        "syntax": "func RotateLeft(x uint, k int) uint",
        "type": "math/bits"
    },
    "bits.RotateLeft16": {
        "descr": "RotateLeft16 returns the value of x rotated left by (k mod 16) bits. To rotate x right by k bits, call RotateLeft16(x, -k).",
        "name": "bits.RotateLeft16",
        "params": [],
        "path": "go/math/bits/index#RotateLeft16",
        "syntax": "func RotateLeft16(x uint16, k int) uint16",
        "type": "math/bits"
    },
    "bits.RotateLeft32": {
        "descr": "RotateLeft32 returns the value of x rotated left by (k mod 32) bits. To rotate x right by k bits, call RotateLeft32(x, -k).",
        "name": "bits.RotateLeft32",
        "params": [],
        "path": "go/math/bits/index#RotateLeft32",
        "syntax": "func RotateLeft32(x uint32, k int) uint32",
        "type": "math/bits"
    },
    "bits.RotateLeft64": {
        "descr": "RotateLeft64 returns the value of x rotated left by (k mod 64) bits. To rotate x right by k bits, call RotateLeft64(x, -k).",
        "name": "bits.RotateLeft64",
        "params": [],
        "path": "go/math/bits/index#RotateLeft64",
        "syntax": "func RotateLeft64(x uint64, k int) uint64",
        "type": "math/bits"
    },
    "bits.RotateLeft8": {
        "descr": "RotateLeft8 returns the value of x rotated left by (k mod 8) bits. To rotate x right by k bits, call RotateLeft8(x, -k).",
        "name": "bits.RotateLeft8",
        "params": [],
        "path": "go/math/bits/index#RotateLeft8",
        "syntax": "func RotateLeft8(x uint8, k int) uint8",
        "type": "math/bits"
    },
    "bits.TrailingZeros": {
        "descr": "TrailingZeros returns the number of trailing zero bits in x; the result is UintSize for x == 0.",
        "name": "bits.TrailingZeros",
        "params": [],
        "path": "go/math/bits/index#TrailingZeros",
        "syntax": "func TrailingZeros(x uint) int",
        "type": "math/bits"
    },
    "bits.TrailingZeros16": {
        "descr": "TrailingZeros16 returns the number of trailing zero bits in x; the result is 16 for x == 0.",
        "name": "bits.TrailingZeros16",
        "params": [],
        "path": "go/math/bits/index#TrailingZeros16",
        "syntax": "func TrailingZeros16(x uint16) (n int)",
        "type": "math/bits"
    },
    "bits.TrailingZeros32": {
        "descr": "TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0.",
        "name": "bits.TrailingZeros32",
        "params": [],
        "path": "go/math/bits/index#TrailingZeros32",
        "syntax": "func TrailingZeros32(x uint32) int",
        "type": "math/bits"
    },
    "bits.TrailingZeros64": {
        "descr": "TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0.",
        "name": "bits.TrailingZeros64",
        "params": [],
        "path": "go/math/bits/index#TrailingZeros64",
        "syntax": "func TrailingZeros64(x uint64) int",
        "type": "math/bits"
    },
    "bits.TrailingZeros8": {
        "descr": "TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0.",
        "name": "bits.TrailingZeros8",
        "params": [],
        "path": "go/math/bits/index#TrailingZeros8",
        "syntax": "func TrailingZeros8(x uint8) int",
        "type": "math/bits"
    },
    "bool": {
        "descr": "bool is the set of boolean values, true and false.",
        "name": "builtin.bool",
        "params": [],
        "path": "go/builtin/index#bool",
        "syntax": "type bool bool",
        "type": "builtin"
    },
    "bufio": {
        "descr": "Errors returned by Scanner.",
        "name": "bufio",
        "params": [],
        "path": "go/bufio/index#pkg-variables",
        "syntax": "var ( ErrInvalidUnreadByte = errors.New(\"bufio: invalid use of UnreadByte\") ErrInvalidUnreadRune = errors.New(\"bufio: invalid use of UnreadRune\") ErrBufferFull = errors.New(\"bufio: buffer full\") ErrNegativeCount = errors.New(\"bufio: negative count\") )",
        "type": "bufio"
    },
    "bufio.NewReadWriter": {
        "descr": "NewReadWriter allocates a new ReadWriter that dispatches to r and w.",
        "name": "bufio.NewReadWriter",
        "params": [],
        "path": "go/bufio/index#NewReadWriter",
        "syntax": "func NewReadWriter(r *Reader, w *Writer) *ReadWriter",
        "type": "bufio"
    },
    "bufio.NewReader": {
        "descr": "NewReader returns a new Reader whose buffer has the default size.",
        "name": "bufio.NewReader",
        "params": [],
        "path": "go/bufio/index#NewReader",
        "syntax": "func NewReader(rd io.Reader) *Reader",
        "type": "bufio"
    },
    "bufio.NewReaderSize": {
        "descr": "NewReaderSize returns a new Reader whose buffer has at least the specified size. If the argument io.Reader is already a Reader with large enough size, it returns the underlying Reader.",
        "name": "bufio.NewReaderSize",
        "params": [],
        "path": "go/bufio/index#NewReaderSize",
        "syntax": "func NewReaderSize(rd io.Reader, size int) *Reader",
        "type": "bufio"
    },
    "bufio.NewScanner": {
        "descr": "NewScanner returns a new Scanner to read from r. The split function defaults to ScanLines.",
        "name": "bufio.NewScanner",
        "params": [],
        "path": "go/bufio/index#NewScanner",
        "syntax": "func NewScanner(r io.Reader) *Scanner",
        "type": "bufio"
    },
    "bufio.NewWriter": {
        "descr": "NewWriter returns a new Writer whose buffer has the default size.",
        "name": "bufio.NewWriter",
        "params": [],
        "path": "go/bufio/index#NewWriter",
        "syntax": "func NewWriter(w io.Writer) *Writer",
        "type": "bufio"
    },
    "bufio.NewWriterSize": {
        "descr": "NewWriterSize returns a new Writer whose buffer has at least the specified size. If the argument io.Writer is already a Writer with large enough size, it returns the underlying Writer.",
        "name": "bufio.NewWriterSize",
        "params": [],
        "path": "go/bufio/index#NewWriterSize",
        "syntax": "func NewWriterSize(w io.Writer, size int) *Writer",
        "type": "bufio"
    },
    "bufio.ReadWriter": {
        "descr": "ReadWriter stores pointers to a Reader and a Writer. It implements io.ReadWriter.",
        "name": "bufio.ReadWriter",
        "params": [],
        "path": "go/bufio/index#ReadWriter",
        "syntax": "type ReadWriter struct { *Reader *Writer }",
        "type": "bufio"
    },
    "bufio.Reader": {
        "descr": "Reader implements buffering for an io.Reader object.",
        "name": "bufio.Reader",
        "params": [],
        "path": "go/bufio/index#Reader",
        "syntax": "type Reader struct { // contains filtered or unexported fields }",
        "type": "bufio"
    },
    "bufio.Reader.Buffered": {
        "descr": "Buffered returns the number of bytes that can be read from the current buffer.",
        "name": "bufio.Reader.Buffered",
        "params": [],
        "path": "go/bufio/index#Reader.Buffered",
        "syntax": "func (b *Reader) Buffered() int",
        "type": "bufio"
    },
    "bufio.Reader.Discard": {
        "descr": "Discard skips the next n bytes, returning the number of bytes discarded.",
        "name": "bufio.Reader.Discard",
        "params": [],
        "path": "go/bufio/index#Reader.Discard",
        "syntax": "func (b *Reader) Discard(n int) (discarded int, err error)",
        "type": "bufio"
    },
    "bufio.Reader.Peek": {
        "descr": "Peek returns the next n bytes without advancing the reader. The bytes stop being valid at the next read call. If Peek returns fewer than n bytes, it also returns an error explaining why the read is short. The error is ErrBufferFull if n is larger than b's buffer size.",
        "name": "bufio.Reader.Peek",
        "params": [],
        "path": "go/bufio/index#Reader.Peek",
        "syntax": "func (b *Reader) Peek(n int) ([]byte, error)",
        "type": "bufio"
    },
    "bufio.Reader.Read": {
        "descr": "Read reads data into p. It returns the number of bytes read into p. The bytes are taken from at most one Read on the underlying Reader, hence n may be less than len(p). At EOF, the count will be zero and err will be io.EOF.",
        "name": "bufio.Reader.Read",
        "params": [],
        "path": "go/bufio/index#Reader.Read",
        "syntax": "func (b *Reader) Read(p []byte) (n int, err error)",
        "type": "bufio"
    },
    "bufio.Reader.ReadByte": {
        "descr": "ReadByte reads and returns a single byte. If no byte is available, returns an error.",
        "name": "bufio.Reader.ReadByte",
        "params": [],
        "path": "go/bufio/index#Reader.ReadByte",
        "syntax": "func (b *Reader) ReadByte() (byte, error)",
        "type": "bufio"
    },
    "bufio.Reader.ReadBytes": {
        "descr": "ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient.",
        "name": "bufio.Reader.ReadBytes",
        "params": [],
        "path": "go/bufio/index#Reader.ReadBytes",
        "syntax": "func (b *Reader) ReadBytes(delim byte) ([]byte, error)",
        "type": "bufio"
    },
    "bufio.Reader.ReadLine": {
        "descr": "ReadLine is a low-level line-reading primitive. Most callers should use ReadBytes('\\n') or ReadString('\\n') instead or use a Scanner.",
        "name": "bufio.Reader.ReadLine",
        "params": [],
        "path": "go/bufio/index#Reader.ReadLine",
        "syntax": "func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)",
        "type": "bufio"
    },
    "bufio.Reader.ReadRune": {
        "descr": "ReadRune reads a single UTF-8 encoded Unicode character and returns the rune and its size in bytes. If the encoded rune is invalid, it consumes one byte and returns unicode.ReplacementChar (U+FFFD) with a size of 1.",
        "name": "bufio.Reader.ReadRune",
        "params": [],
        "path": "go/bufio/index#Reader.ReadRune",
        "syntax": "func (b *Reader) ReadRune() (r rune, size int, err error)",
        "type": "bufio"
    },
    "bufio.Reader.ReadSlice": {
        "descr": "ReadSlice reads until the first occurrence of delim in the input, returning a slice pointing at the bytes in the buffer. The bytes stop being valid at the next read. If ReadSlice encounters an error before finding a delimiter, it returns all the data in the buffer and the error itself (often io.EOF). ReadSlice fails with error ErrBufferFull if the buffer fills without a delim. Because the data returned from ReadSlice will be overwritten by the next I/O operation, most clients should use ReadBytes or ReadString instead. ReadSlice returns err != nil if and only if line does not end in delim.",
        "name": "bufio.Reader.ReadSlice",
        "params": [],
        "path": "go/bufio/index#Reader.ReadSlice",
        "syntax": "func (b *Reader) ReadSlice(delim byte) (line []byte, err error)",
        "type": "bufio"
    },
    "bufio.Reader.ReadString": {
        "descr": "ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient.",
        "name": "bufio.Reader.ReadString",
        "params": [],
        "path": "go/bufio/index#Reader.ReadString",
        "syntax": "func (b *Reader) ReadString(delim byte) (string, error)",
        "type": "bufio"
    },
    "bufio.Reader.Reset": {
        "descr": "Reset discards any buffered data, resets all state, and switches the buffered reader to read from r.",
        "name": "bufio.Reader.Reset",
        "params": [],
        "path": "go/bufio/index#Reader.Reset",
        "syntax": "func (b *Reader) Reset(r io.Reader)",
        "type": "bufio"
    },
    "bufio.Reader.Size": {
        "descr": "Size returns the size of the underlying buffer in bytes.",
        "name": "bufio.Reader.Size",
        "params": [],
        "path": "go/bufio/index#Reader.Size",
        "syntax": "func (r *Reader) Size() int",
        "type": "bufio"
    },
    "bufio.Reader.UnreadByte": {
        "descr": "UnreadByte unreads the last byte. Only the most recently read byte can be unread.",
        "name": "bufio.Reader.UnreadByte",
        "params": [],
        "path": "go/bufio/index#Reader.UnreadByte",
        "syntax": "func (b *Reader) UnreadByte() error",
        "type": "bufio"
    },
    "bufio.Reader.UnreadRune": {
        "descr": "UnreadRune unreads the last rune. If the most recent read operation on the buffer was not a ReadRune, UnreadRune returns an error. (In this regard it is stricter than UnreadByte, which will unread the last byte from any read operation.)",
        "name": "bufio.Reader.UnreadRune",
        "params": [],
        "path": "go/bufio/index#Reader.UnreadRune",
        "syntax": "func (b *Reader) UnreadRune() error",
        "type": "bufio"
    },
    "bufio.Reader.WriteTo": {
        "descr": "WriteTo implements io.WriterTo. This may make multiple calls to the Read method of the underlying Reader. If the underlying reader supports the WriteTo method, this calls the underlying WriteTo without buffering.",
        "name": "bufio.Reader.WriteTo",
        "params": [],
        "path": "go/bufio/index#Reader.WriteTo",
        "syntax": "func (b *Reader) WriteTo(w io.Writer) (n int64, err error)",
        "type": "bufio"
    },
    "bufio.ScanBytes": {
        "descr": "ScanBytes is a split function for a Scanner that returns each byte as a token.",
        "name": "bufio.ScanBytes",
        "params": [],
        "path": "go/bufio/index#ScanBytes",
        "syntax": "func ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)",
        "type": "bufio"
    },
    "bufio.ScanLines": {
        "descr": "ScanLines is a split function for a Scanner that returns each line of text, stripped of any trailing end-of-line marker. The returned line may be empty. The end-of-line marker is one optional carriage return followed by one mandatory newline. In regular expression notation, it is `\\r?\\n`. The last non-empty line of input will be returned even if it has no newline.",
        "name": "bufio.ScanLines",
        "params": [],
        "path": "go/bufio/index#ScanLines",
        "syntax": "func ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error)",
        "type": "bufio"
    },
    "bufio.ScanRunes": {
        "descr": "ScanRunes is a split function for a Scanner that returns each UTF-8-encoded rune as a token. The sequence of runes returned is equivalent to that from a range loop over the input as a string, which means that erroneous UTF-8 encodings translate to U+FFFD = \"\\xef\\xbf\\xbd\". Because of the Scan interface, this makes it impossible for the client to distinguish correctly encoded replacement runes from encoding errors.",
        "name": "bufio.ScanRunes",
        "params": [],
        "path": "go/bufio/index#ScanRunes",
        "syntax": "func ScanRunes(data []byte, atEOF bool) (advance int, token []byte, err error)",
        "type": "bufio"
    },
    "bufio.ScanWords": {
        "descr": "ScanWords is a split function for a Scanner that returns each space-separated word of text, with surrounding spaces deleted. It will never return an empty string. The definition of space is set by unicode.IsSpace.",
        "name": "bufio.ScanWords",
        "params": [],
        "path": "go/bufio/index#ScanWords",
        "syntax": "func ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error)",
        "type": "bufio"
    },
    "bufio.Scanner": {
        "descr": "Scanner provides a convenient interface for reading data such as a file of newline-delimited lines of text. Successive calls to the Scan method will step through the 'tokens' of a file, skipping the bytes between the tokens. The specification of a token is defined by a split function of type SplitFunc; the default split function breaks the input into lines with line termination stripped. Split functions are defined in this package for scanning a file into lines, bytes, UTF-8-encoded runes, and space-delimited words. The client may instead provide a custom split function.",
        "name": "bufio.Scanner",
        "params": [],
        "path": "go/bufio/index#Scanner",
        "syntax": "type Scanner struct { // contains filtered or unexported fields }",
        "type": "bufio"
    },
    "bufio.Scanner.Buffer": {
        "descr": "Buffer sets the initial buffer to use when scanning and the maximum size of buffer that may be allocated during scanning. The maximum token size is the larger of max and cap(buf). If max <= cap(buf), Scan will use this buffer only and do no allocation.",
        "name": "bufio.Scanner.Buffer",
        "params": [],
        "path": "go/bufio/index#Scanner.Buffer",
        "syntax": "func (s *Scanner) Buffer(buf []byte, max int)",
        "type": "bufio"
    },
    "bufio.Scanner.Bytes": {
        "descr": "Bytes returns the most recent token generated by a call to Scan. The underlying array may point to data that will be overwritten by a subsequent call to Scan. It does no allocation.",
        "name": "bufio.Scanner.Bytes",
        "params": [],
        "path": "go/bufio/index#Scanner.Bytes",
        "syntax": "func (s *Scanner) Bytes() []byte",
        "type": "bufio"
    },
    "bufio.Scanner.Err": {
        "descr": "Err returns the first non-EOF error that was encountered by the Scanner.",
        "name": "bufio.Scanner.Err",
        "params": [],
        "path": "go/bufio/index#Scanner.Err",
        "syntax": "func (s *Scanner) Err() error",
        "type": "bufio"
    },
    "bufio.Scanner.Scan": {
        "descr": "Scan advances the Scanner to the next token, which will then be available through the Bytes or Text method. It returns false when the scan stops, either by reaching the end of the input or an error. After Scan returns false, the Err method will return any error that occurred during scanning, except that if it was io.EOF, Err will return nil. Scan panics if the split function returns too many empty tokens without advancing the input. This is a common error mode for scanners.",
        "name": "bufio.Scanner.Scan",
        "params": [],
        "path": "go/bufio/index#Scanner.Scan",
        "syntax": "func (s *Scanner) Scan() bool",
        "type": "bufio"
    },
    "bufio.Scanner.Split": {
        "descr": "Split sets the split function for the Scanner. The default split function is ScanLines.",
        "name": "bufio.Scanner.Split",
        "params": [],
        "path": "go/bufio/index#Scanner.Split",
        "syntax": "func (s *Scanner) Split(split SplitFunc)",
        "type": "bufio"
    },
    "bufio.Scanner.Text": {
        "descr": "Text returns the most recent token generated by a call to Scan as a newly allocated string holding its bytes.",
        "name": "bufio.Scanner.Text",
        "params": [],
        "path": "go/bufio/index#Scanner.Text",
        "syntax": "func (s *Scanner) Text() string",
        "type": "bufio"
    },
    "bufio.SplitFunc": {
        "descr": "SplitFunc is the signature of the split function used to tokenize the input. The arguments are an initial substring of the remaining unprocessed data and a flag, atEOF, that reports whether the Reader has no more data to give. The return values are the number of bytes to advance the input and the next token to return to the user, if any, plus an error, if any.",
        "name": "bufio.SplitFunc",
        "params": [],
        "path": "go/bufio/index#SplitFunc",
        "syntax": "type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)",
        "type": "bufio"
    },
    "bufio.Writer": {
        "descr": "Writer implements buffering for an io.Writer object. If an error occurs writing to a Writer, no more data will be accepted and all subsequent writes, and Flush, will return the error. After all data has been written, the client should call the Flush method to guarantee all data has been forwarded to the underlying io.Writer.",
        "name": "bufio.Writer",
        "params": [],
        "path": "go/bufio/index#Writer",
        "syntax": "type Writer struct { // contains filtered or unexported fields }",
        "type": "bufio"
    },
    "bufio.Writer.Available": {
        "descr": "Available returns how many bytes are unused in the buffer.",
        "name": "bufio.Writer.Available",
        "params": [],
        "path": "go/bufio/index#Writer.Available",
        "syntax": "func (b *Writer) Available() int",
        "type": "bufio"
    },
    "bufio.Writer.Buffered": {
        "descr": "Buffered returns the number of bytes that have been written into the current buffer.",
        "name": "bufio.Writer.Buffered",
        "params": [],
        "path": "go/bufio/index#Writer.Buffered",
        "syntax": "func (b *Writer) Buffered() int",
        "type": "bufio"
    },
    "bufio.Writer.Flush": {
        "descr": "Flush writes any buffered data to the underlying io.Writer.",
        "name": "bufio.Writer.Flush",
        "params": [],
        "path": "go/bufio/index#Writer.Flush",
        "syntax": "func (b *Writer) Flush() error",
        "type": "bufio"
    },
    "bufio.Writer.ReadFrom": {
        "descr": "ReadFrom implements io.ReaderFrom. If the underlying writer supports the ReadFrom method, and b has no buffered data yet, this calls the underlying ReadFrom without buffering.",
        "name": "bufio.Writer.ReadFrom",
        "params": [],
        "path": "go/bufio/index#Writer.ReadFrom",
        "syntax": "func (b *Writer) ReadFrom(r io.Reader) (n int64, err error)",
        "type": "bufio"
    },
    "bufio.Writer.Reset": {
        "descr": "Reset discards any unflushed buffered data, clears any error, and resets b to write its output to w.",
        "name": "bufio.Writer.Reset",
        "params": [],
        "path": "go/bufio/index#Writer.Reset",
        "syntax": "func (b *Writer) Reset(w io.Writer)",
        "type": "bufio"
    },
    "bufio.Writer.Size": {
        "descr": "Size returns the size of the underlying buffer in bytes.",
        "name": "bufio.Writer.Size",
        "params": [],
        "path": "go/bufio/index#Writer.Size",
        "syntax": "func (b *Writer) Size() int",
        "type": "bufio"
    },
    "bufio.Writer.Write": {
        "descr": "Write writes the contents of p into the buffer. It returns the number of bytes written. If nn < len(p), it also returns an error explaining why the write is short.",
        "name": "bufio.Writer.Write",
        "params": [],
        "path": "go/bufio/index#Writer.Write",
        "syntax": "func (b *Writer) Write(p []byte) (nn int, err error)",
        "type": "bufio"
    },
    "bufio.Writer.WriteByte": {
        "descr": "WriteByte writes a single byte.",
        "name": "bufio.Writer.WriteByte",
        "params": [],
        "path": "go/bufio/index#Writer.WriteByte",
        "syntax": "func (b *Writer) WriteByte(c byte) error",
        "type": "bufio"
    },
    "bufio.Writer.WriteRune": {
        "descr": "WriteRune writes a single Unicode code point, returning the number of bytes written and any error.",
        "name": "bufio.Writer.WriteRune",
        "params": [],
        "path": "go/bufio/index#Writer.WriteRune",
        "syntax": "func (b *Writer) WriteRune(r rune) (size int, err error)",
        "type": "bufio"
    },
    "bufio.Writer.WriteString": {
        "descr": "WriteString writes a string. It returns the number of bytes written. If the count is less than len(s), it also returns an error explaining why the write is short.",
        "name": "bufio.Writer.WriteString",
        "params": [],
        "path": "go/bufio/index#Writer.WriteString",
        "syntax": "func (b *Writer) WriteString(s string) (int, error)",
        "type": "bufio"
    },
    "build.ArchChar": {
        "descr": "ArchChar returns \"?\" and an error. In earlier versions of Go, the returned string was used to derive the compiler and linker tool names, the default object file suffix, and the default linker output name. As of Go 1.5, those strings no longer vary by architecture; they are compile, link, .o, and a.out, respectively.",
        "name": "build.ArchChar",
        "params": [],
        "path": "go/go/build/index#ArchChar",
        "syntax": "func ArchChar(goarch string) (string, error)",
        "type": "go"
    },
    "build.Context": {
        "descr": "A Context specifies the supporting context for a build.",
        "name": "build.Context",
        "params": [],
        "path": "go/go/build/index#Context",
        "syntax": "type Context struct { GOARCH string // target architecture GOOS string // target operating system GOROOT string // Go root GOPATH string // Go path CgoEnabled bool // whether cgo can be used UseAllFiles bool // use files regardless of +build lines, file names Compiler string // compiler to assume when computing target paths // The build and release tags specify build constraints // that should be considered satisfied when processing +build lines. // Clients creating a new context may customize BuildTags, which // defaults to empty, but it is usually an error to customize ReleaseTags, // which defaults to the list of Go releases the current release is compatible with. // In addition to the BuildTags and ReleaseTags, build constraints // consider the values of GOARCH and GOOS as satisfied tags. BuildTags []string ReleaseTags []string // Go 1.1 // The install suffix specifies a suffix to use in the name of the installation // directory. By default it is empty, but custom builds that need to keep // their outputs separate can set InstallSuffix to do so. For example, when // using the race detector, the go command uses InstallSuffix = \"race\", so // that on a Linux/386 system, packages are written to a directory named // \"linux_386_race\" instead of the usual \"linux_386\". InstallSuffix string // Go 1.1 // JoinPath joins the sequence of path fragments into a single path. // If JoinPath is nil, Import uses filepath.Join. JoinPath func(elem ...string) string // SplitPathList splits the path list into a slice of individual paths. // If SplitPathList is nil, Import uses filepath.SplitList. SplitPathList func(list string) []string // IsAbsPath reports whether path is an absolute path. // If IsAbsPath is nil, Import uses filepath.IsAbs. IsAbsPath func(path string) bool // IsDir reports whether the path names a directory. // If IsDir is nil, Import calls os.Stat and uses the result's IsDir method. IsDir func(path string) bool // HasSubdir reports whether dir is lexically a subdirectory of // root, perhaps multiple levels below. It does not try to check // whether dir exists. // If so, HasSubdir sets rel to a slash-separated path that // can be joined to root to produce a path equivalent to dir. // If HasSubdir is nil, Import uses an implementation built on // filepath.EvalSymlinks. HasSubdir func(root, dir string) (rel string, ok bool) // ReadDir returns a slice of os.FileInfo, sorted by Name, // describing the content of the named directory. // If ReadDir is nil, Import uses ioutil.ReadDir. ReadDir func(dir string) ([]os.FileInfo, error) // OpenFile opens a file (not a directory) for reading. // If OpenFile is nil, Import uses os.Open. OpenFile func(path string) (io.ReadCloser, error) }",
        "type": "go"
    },
    "build.Context.Import": {
        "descr": "Import returns details about the Go package named by the import path, interpreting local import paths relative to the srcDir directory. If the path is a local import path naming a package that can be imported using a standard import path, the returned package will set p.ImportPath to that path.",
        "name": "build.Context.Import",
        "params": [],
        "path": "go/go/build/index#Context.Import",
        "syntax": "func (ctxt *Context) Import(path string, srcDir string, mode ImportMode) (*Package, error)",
        "type": "go"
    },
    "build.Context.ImportDir": {
        "descr": "ImportDir is like Import but processes the Go package found in the named directory.",
        "name": "build.Context.ImportDir",
        "params": [],
        "path": "go/go/build/index#Context.ImportDir",
        "syntax": "func (ctxt *Context) ImportDir(dir string, mode ImportMode) (*Package, error)",
        "type": "go"
    },
    "build.Context.MatchFile": {
        "descr": "MatchFile reports whether the file with the given name in the given directory matches the context and would be included in a Package created by ImportDir of that directory.",
        "name": "build.Context.MatchFile",
        "params": [],
        "path": "go/go/build/index#Context.MatchFile",
        "syntax": "func (ctxt *Context) MatchFile(dir, name string) (match bool, err error)",
        "type": "go"
    },
    "build.Context.SrcDirs": {
        "descr": "SrcDirs returns a list of package source root directories. It draws from the current Go root and Go path but omits directories that do not exist.",
        "name": "build.Context.SrcDirs",
        "params": [],
        "path": "go/go/build/index#Context.SrcDirs",
        "syntax": "func (ctxt *Context) SrcDirs() []string",
        "type": "go"
    },
    "build.Import": {
        "descr": "Import is shorthand for Default.Import.",
        "name": "build.Import",
        "params": [],
        "path": "go/go/build/index#Import",
        "syntax": "func Import(path, srcDir string, mode ImportMode) (*Package, error)",
        "type": "go"
    },
    "build.ImportDir": {
        "descr": "ImportDir is shorthand for Default.ImportDir.",
        "name": "build.ImportDir",
        "params": [],
        "path": "go/go/build/index#ImportDir",
        "syntax": "func ImportDir(dir string, mode ImportMode) (*Package, error)",
        "type": "go"
    },
    "build.ImportMode": {
        "descr": "An ImportMode controls the behavior of the Import method.",
        "name": "build.ImportMode",
        "params": [],
        "path": "go/go/build/index#ImportMode",
        "syntax": "type ImportMode uint",
        "type": "go"
    },
    "build.IsLocalImport": {
        "descr": "IsLocalImport reports whether the import path is a local import path, like \".\", \"..\", \"./foo\", or \"../foo\".",
        "name": "build.IsLocalImport",
        "params": [],
        "path": "go/go/build/index#IsLocalImport",
        "syntax": "func IsLocalImport(path string) bool",
        "type": "go"
    },
    "build.MultiplePackageError": {
        "descr": "MultiplePackageError describes a directory containing multiple buildable Go source files for multiple packages.",
        "name": "build.MultiplePackageError",
        "params": [],
        "path": "go/go/build/index#MultiplePackageError",
        "syntax": "type MultiplePackageError struct { Dir string // directory containing files Packages []string // package names found Files []string // corresponding files: Files[i] declares package Packages[i] }",
        "type": "go"
    },
    "build.MultiplePackageError.Error": {
        "descr": "",
        "name": "build.MultiplePackageError.Error",
        "params": [],
        "path": "go/go/build/index#MultiplePackageError.Error",
        "syntax": "func (e *MultiplePackageError) Error() string",
        "type": "go"
    },
    "build.NoGoError": {
        "descr": "NoGoError is the error used by Import to describe a directory containing no buildable Go source files. (It may still contain test files, files hidden by build tags, and so on.)",
        "name": "build.NoGoError",
        "params": [],
        "path": "go/go/build/index#NoGoError",
        "syntax": "type NoGoError struct { Dir string }",
        "type": "go"
    },
    "build.NoGoError.Error": {
        "descr": "",
        "name": "build.NoGoError.Error",
        "params": [],
        "path": "go/go/build/index#NoGoError.Error",
        "syntax": "func (e *NoGoError) Error() string",
        "type": "go"
    },
    "build.Package": {
        "descr": "A Package describes the Go package found in a directory.",
        "name": "build.Package",
        "params": [],
        "path": "go/go/build/index#Package",
        "syntax": "type Package struct { Dir string // directory containing package sources Name string // package name ImportComment string // path in import comment on package statement; added in Go 1.4 Doc string // documentation synopsis ImportPath string // import path of package (\"\" if unknown) Root string // root of Go tree where this package lives SrcRoot string // package source root directory (\"\" if unknown) PkgRoot string // package install root directory (\"\" if unknown) PkgTargetRoot string // architecture dependent install root directory (\"\" if unknown);\n or  added in Go 1.5 BinDir string // command install directory (\"\" if unknown) Goroot bool // package found in Go root PkgObj string // installed .a file AllTags []string // tags that can influence file selection in this directory; added in Go 1.2 ConflictDir string // this directory shadows Dir in $GOPATH; added in Go 1.2 BinaryOnly bool // cannot be rebuilt from source (has //go:binary-only-package comment);\n or  added in Go 1.7 // Source files GoFiles []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles) CgoFiles []string // .go source files that import \"C\" IgnoredGoFiles []string // .go source files ignored for this build; added in Go 1.1 InvalidGoFiles []string // .go source files with detected problems (parse error, wrong package name, and so on);\n or  added in Go 1.6 CFiles []string // .c source files CXXFiles []string // .cc, .cpp and .cxx source files; added in Go 1.2 MFiles []string // .m (Objective-C) source files; added in Go 1.3 HFiles []string // .h, .hh, .hpp and .hxx source files FFiles []string // .f, .F, .for and .f90 Fortran source files; added in Go 1.7 SFiles []string // .s source files SwigFiles []string // .swig files; added in Go 1.1 SwigCXXFiles []string // .swigcxx files; added in Go 1.1 SysoFiles []string // .syso system object files to add to archive // Cgo directives CgoCFLAGS []string // Cgo CFLAGS directives CgoCPPFLAGS []string // Cgo CPPFLAGS directives; added in Go 1.2 CgoCXXFLAGS []string // Cgo CXXFLAGS directives; added in Go 1.2 CgoFFLAGS []string // Cgo FFLAGS directives; added in Go 1.7 CgoLDFLAGS []string // Cgo LDFLAGS directives CgoPkgConfig []string // Cgo pkg-config directives // Dependency information Imports []string // import paths from GoFiles, CgoFiles ImportPos map[string][]token.Position // line information for Imports // Test information TestGoFiles []string // _test.go files in package TestImports []string // import paths from TestGoFiles TestImportPos map[string][]token.Position // line information for TestImports XTestGoFiles []string // _test.go files outside package XTestImports []string // import paths from XTestGoFiles XTestImportPos map[string][]token.Position // line information for XTestImports });",
        "type": "go"
    },
    "build.Package.IsCommand": {
        "descr": "IsCommand reports whether the package is considered a command to be installed (not just a library). Packages named \"main\" are treated as commands.",
        "name": "build.Package.IsCommand",
        "params": [],
        "path": "go/go/build/index#Package.IsCommand",
        "syntax": "func (p *Package) IsCommand() bool",
        "type": "go"
    },
    "builtin": {
        "descr": "nil is a predeclared identifier representing the zero value for a pointer, channel, func, interface, map, or slice type.",
        "name": "builtin",
        "params": [],
        "path": "go/builtin/index#pkg-variables",
        "syntax": "var nil Type // Type must be a pointer, channel, func, interface, map, or slice type",
        "type": "builtin"
    },
    "builtin.ComplexType": {
        "descr": "ComplexType is here for the purposes of documentation only. It is a stand-in for either complex type: complex64 or complex128.",
        "name": "builtin.ComplexType",
        "params": [],
        "path": "go/builtin/index#ComplexType",
        "syntax": "type ComplexType complex64",
        "type": "builtin"
    },
    "builtin.FloatType": {
        "descr": "FloatType is here for the purposes of documentation only. It is a stand-in for either float type: float32 or float64.",
        "name": "builtin.FloatType",
        "params": [],
        "path": "go/builtin/index#FloatType",
        "syntax": "type FloatType float32",
        "type": "builtin"
    },
    "builtin.IntegerType": {
        "descr": "IntegerType is here for the purposes of documentation only. It is a stand-in for any integer type: int, uint, int8 etc.",
        "name": "builtin.IntegerType",
        "params": [],
        "path": "go/builtin/index#IntegerType",
        "syntax": "type IntegerType int",
        "type": "builtin"
    },
    "builtin.Type": {
        "descr": "Type is here for the purposes of documentation only. It is a stand-in for any Go type, but represents the same type for any given function invocation.",
        "name": "builtin.Type",
        "params": [],
        "path": "go/builtin/index#Type",
        "syntax": "type Type int",
        "type": "builtin"
    },
    "builtin.Type1": {
        "descr": "Type1 is here for the purposes of documentation only. It is a stand-in for any Go type, but represents the same type for any given function invocation.",
        "name": "builtin.Type1",
        "params": [],
        "path": "go/builtin/index#Type1",
        "syntax": "type Type1 int",
        "type": "builtin"
    },
    "builtin.append": {
        "descr": "The append built-in function appends elements to the end of a slice. If it has sufficient capacity, the destination is resliced to accommodate the new elements. If it does not, a new underlying array will be allocated. Append returns the updated slice. It is therefore necessary to store the result of append, often in the variable holding the slice itself:",
        "name": "builtin.append",
        "params": [],
        "path": "go/builtin/index#append",
        "syntax": "func append(slice []Type, elems ...Type) []Type",
        "type": "builtin"
    },
    "builtin.bool": {
        "descr": "bool is the set of boolean values, true and false.",
        "name": "builtin.bool",
        "params": [],
        "path": "go/builtin/index#bool",
        "syntax": "type bool bool",
        "type": "builtin"
    },
    "builtin.byte": {
        "descr": "byte is an alias for uint8 and is equivalent to uint8 in all ways. It is used, by convention, to distinguish byte values from 8-bit unsigned integer values.",
        "name": "builtin.byte",
        "params": [],
        "path": "go/builtin/index#byte",
        "syntax": "type byte = uint8",
        "type": "builtin"
    },
    "builtin.cap": {
        "descr": "The cap built-in function returns the capacity of v, according to its type:",
        "name": "builtin.cap",
        "params": [],
        "path": "go/builtin/index#cap",
        "syntax": "func cap(v Type) int",
        "type": "builtin"
    },
    "builtin.close": {
        "descr": "The close built-in function closes a channel, which must be either bidirectional or send-only. It should be executed only by the sender, never the receiver, and has the effect of shutting down the channel after the last sent value is received. After the last value has been received from a closed channel c, any receive from c will succeed without blocking, returning the zero value for the channel element. The form",
        "name": "builtin.close",
        "params": [],
        "path": "go/builtin/index#close",
        "syntax": "func close(c chan<- Type)",
        "type": "builtin"
    },
    "builtin.complex": {
        "descr": "The complex built-in function constructs a complex value from two floating-point values. The real and imaginary parts must be of the same size, either float32 or float64 (or assignable to them), and the return value will be the corresponding complex type (complex64 for float32, complex128 for float64).",
        "name": "builtin.complex",
        "params": [],
        "path": "go/builtin/index#complex",
        "syntax": "func complex(r, i FloatType) ComplexType",
        "type": "builtin"
    },
    "builtin.complex128": {
        "descr": "complex128 is the set of all complex numbers with float64 real and imaginary parts.",
        "name": "builtin.complex128",
        "params": [],
        "path": "go/builtin/index#complex128",
        "syntax": "type complex128 complex128",
        "type": "builtin"
    },
    "builtin.complex64": {
        "descr": "complex64 is the set of all complex numbers with float32 real and imaginary parts.",
        "name": "builtin.complex64",
        "params": [],
        "path": "go/builtin/index#complex64",
        "syntax": "type complex64 complex64",
        "type": "builtin"
    },
    "builtin.copy": {
        "descr": "The copy built-in function copies elements from a source slice into a destination slice. (As a special case, it also will copy bytes from a string to a slice of bytes.) The source and destination may overlap. Copy returns the number of elements copied, which will be the minimum of len(src) and len(dst).",
        "name": "builtin.copy",
        "params": [],
        "path": "go/builtin/index#copy",
        "syntax": "func copy(dst, src []Type) int",
        "type": "builtin"
    },
    "builtin.delete": {
        "descr": "The delete built-in function deletes the element with the specified key (m[key]) from the map. If m is nil or there is no such element, delete is a no-op.",
        "name": "builtin.delete",
        "params": [],
        "path": "go/builtin/index#delete",
        "syntax": "func delete(m map[Type]Type1, key Type)",
        "type": "builtin"
    },
    "builtin.error": {
        "descr": "The error built-in interface type is the conventional interface for representing an error condition, with the nil value representing no error.",
        "name": "builtin.error",
        "params": [],
        "path": "go/builtin/index#error",
        "syntax": "type error interface { Error() string }",
        "type": "builtin"
    },
    "builtin.float32": {
        "descr": "float32 is the set of all IEEE-754 32-bit floating-point numbers.",
        "name": "builtin.float32",
        "params": [],
        "path": "go/builtin/index#float32",
        "syntax": "type float32 float32",
        "type": "builtin"
    },
    "builtin.float64": {
        "descr": "float64 is the set of all IEEE-754 64-bit floating-point numbers.",
        "name": "builtin.float64",
        "params": [],
        "path": "go/builtin/index#float64",
        "syntax": "type float64 float64",
        "type": "builtin"
    },
    "builtin.imag": {
        "descr": "The imag built-in function returns the imaginary part of the complex number c. The return value will be floating point type corresponding to the type of c.",
        "name": "builtin.imag",
        "params": [],
        "path": "go/builtin/index#imag",
        "syntax": "func imag(c ComplexType) FloatType",
        "type": "builtin"
    },
    "builtin.int": {
        "descr": "int is a signed integer type that is at least 32 bits in size. It is a distinct type, however, and not an alias for, say, int32.",
        "name": "builtin.int",
        "params": [],
        "path": "go/builtin/index#int",
        "syntax": "type int int",
        "type": "builtin"
    },
    "builtin.int16": {
        "descr": "int16 is the set of all signed 16-bit integers. Range: -32768 through 32767.",
        "name": "builtin.int16",
        "params": [],
        "path": "go/builtin/index#int16",
        "syntax": "type int16 int16",
        "type": "builtin"
    },
    "builtin.int32": {
        "descr": "int32 is the set of all signed 32-bit integers. Range: -2147483648 through 2147483647.",
        "name": "builtin.int32",
        "params": [],
        "path": "go/builtin/index#int32",
        "syntax": "type int32 int32",
        "type": "builtin"
    },
    "builtin.int64": {
        "descr": "int64 is the set of all signed 64-bit integers. Range: -9223372036854775808 through 9223372036854775807.",
        "name": "builtin.int64",
        "params": [],
        "path": "go/builtin/index#int64",
        "syntax": "type int64 int64",
        "type": "builtin"
    },
    "builtin.int8": {
        "descr": "int8 is the set of all signed 8-bit integers. Range: -128 through 127.",
        "name": "builtin.int8",
        "params": [],
        "path": "go/builtin/index#int8",
        "syntax": "type int8 int8",
        "type": "builtin"
    },
    "builtin.len": {
        "descr": "The len built-in function returns the length of v, according to its type:",
        "name": "builtin.len",
        "params": [],
        "path": "go/builtin/index#len",
        "syntax": "func len(v Type) int",
        "type": "builtin"
    },
    "builtin.make": {
        "descr": "The make built-in function allocates and initializes an object of type slice, map, or chan (only). Like new, the first argument is a type, not a value. Unlike new, make's return type is the same as the type of its argument, not a pointer to it. The specification of the result depends on the type:",
        "name": "builtin.make",
        "params": [],
        "path": "go/builtin/index#make",
        "syntax": "func make(t Type, size ...IntegerType) Type",
        "type": "builtin"
    },
    "builtin.new": {
        "descr": "The new built-in function allocates memory. The first argument is a type, not a value, and the value returned is a pointer to a newly allocated zero value of that type.",
        "name": "builtin.new",
        "params": [],
        "path": "go/builtin/index#new",
        "syntax": "func new(Type) *Type",
        "type": "builtin"
    },
    "builtin.panic": {
        "descr": "The panic built-in function stops normal execution of the current goroutine. When a function F calls panic, normal execution of F stops immediately. Any functions whose execution was deferred by F are run in the usual way, and then F returns to its caller. To the caller G, the invocation of F then behaves like a call to panic, terminating G's execution and running any deferred functions. This continues until all functions in the executing goroutine have stopped, in reverse order. At that point, the program is terminated and the error condition is reported, including the value of the argument to panic. This termination sequence is called panicking and can be controlled by the built-in function recover.",
        "name": "builtin.panic",
        "params": [],
        "path": "go/builtin/index#panic",
        "syntax": "func panic(v interface{})",
        "type": "builtin"
    },
    "builtin.print": {
        "descr": "The print built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Print is useful for bootstrapping and debugging; it is not guaranteed to stay in the language.",
        "name": "builtin.print",
        "params": [],
        "path": "go/builtin/index#print",
        "syntax": "func print(args ...Type)",
        "type": "builtin"
    },
    "builtin.println": {
        "descr": "The println built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Spaces are always added between arguments and a newline is appended. Println is useful for bootstrapping and debugging; it is not guaranteed to stay in the language.",
        "name": "builtin.println",
        "params": [],
        "path": "go/builtin/index#println",
        "syntax": "func println(args ...Type)",
        "type": "builtin"
    },
    "builtin.real": {
        "descr": "The real built-in function returns the real part of the complex number c. The return value will be floating point type corresponding to the type of c.",
        "name": "builtin.real",
        "params": [],
        "path": "go/builtin/index#real",
        "syntax": "func real(c ComplexType) FloatType",
        "type": "builtin"
    },
    "builtin.recover": {
        "descr": "The recover built-in function allows a program to manage behavior of a panicking goroutine. Executing a call to recover inside a deferred function (but not any function called by it) stops the panicking sequence by restoring normal execution and retrieves the error value passed to the call of panic. If recover is called outside the deferred function it will not stop a panicking sequence. In this case, or when the goroutine is not panicking, or if the argument supplied to panic was nil, recover returns nil. Thus the return value from recover reports whether the goroutine is panicking.",
        "name": "builtin.recover",
        "params": [],
        "path": "go/builtin/index#recover",
        "syntax": "func recover() interface{}",
        "type": "builtin"
    },
    "builtin.rune": {
        "descr": "rune is an alias for int32 and is equivalent to int32 in all ways. It is used, by convention, to distinguish character values from integer values.",
        "name": "builtin.rune",
        "params": [],
        "path": "go/builtin/index#rune",
        "syntax": "type rune = int32",
        "type": "builtin"
    },
    "builtin.string": {
        "descr": "string is the set of all strings of 8-bit bytes, conventionally but not necessarily representing UTF-8-encoded text. A string may be empty, but not nil. Values of string type are immutable.",
        "name": "builtin.string",
        "params": [],
        "path": "go/builtin/index#string",
        "syntax": "type string string",
        "type": "builtin"
    },
    "builtin.uint": {
        "descr": "uint is an unsigned integer type that is at least 32 bits in size. It is a distinct type, however, and not an alias for, say, uint32.",
        "name": "builtin.uint",
        "params": [],
        "path": "go/builtin/index#uint",
        "syntax": "type uint uint",
        "type": "builtin"
    },
    "builtin.uint16": {
        "descr": "uint16 is the set of all unsigned 16-bit integers. Range: 0 through 65535.",
        "name": "builtin.uint16",
        "params": [],
        "path": "go/builtin/index#uint16",
        "syntax": "type uint16 uint16",
        "type": "builtin"
    },
    "builtin.uint32": {
        "descr": "uint32 is the set of all unsigned 32-bit integers. Range: 0 through 4294967295.",
        "name": "builtin.uint32",
        "params": [],
        "path": "go/builtin/index#uint32",
        "syntax": "type uint32 uint32",
        "type": "builtin"
    },
    "builtin.uint64": {
        "descr": "uint64 is the set of all unsigned 64-bit integers. Range: 0 through 18446744073709551615.",
        "name": "builtin.uint64",
        "params": [],
        "path": "go/builtin/index#uint64",
        "syntax": "type uint64 uint64",
        "type": "builtin"
    },
    "builtin.uint8": {
        "descr": "uint8 is the set of all unsigned 8-bit integers. Range: 0 through 255.",
        "name": "builtin.uint8",
        "params": [],
        "path": "go/builtin/index#uint8",
        "syntax": "type uint8 uint8",
        "type": "builtin"
    },
    "builtin.uintptr": {
        "descr": "uintptr is an integer type that is large enough to hold the bit pattern of any pointer.",
        "name": "builtin.uintptr",
        "params": [],
        "path": "go/builtin/index#uintptr",
        "syntax": "type uintptr uintptr",
        "type": "builtin"
    },
    "byte": {
        "descr": "byte is an alias for uint8 and is equivalent to uint8 in all ways. It is used, by convention, to distinguish byte values from 8-bit unsigned integer values.",
        "name": "builtin.byte",
        "params": [],
        "path": "go/builtin/index#byte",
        "syntax": "type byte = uint8",
        "type": "builtin"
    },
    "bytes": {
        "descr": "ErrTooLarge is passed to panic if memory cannot be allocated to store data in a buffer.",
        "name": "bytes",
        "params": [],
        "path": "go/bytes/index#pkg-variables",
        "syntax": "var ErrTooLarge = errors.New(\"bytes.Buffer: too large\")",
        "type": "bytes"
    },
    "bytes.Buffer": {
        "descr": "A Buffer is a variable-sized buffer of bytes with Read and Write methods. The zero value for Buffer is an empty buffer ready to use.",
        "name": "bytes.Buffer",
        "params": [],
        "path": "go/bytes/index#Buffer",
        "syntax": "type Buffer struct { // contains filtered or unexported fields }",
        "type": "bytes"
    },
    "bytes.Buffer.Bytes": {
        "descr": "Bytes returns a slice of length b.Len() holding the unread portion of the buffer. The slice is valid for use only until the next buffer modification (that is, only until the next call to a method like Read, Write, Reset, or Truncate). The slice aliases the buffer content at least until the next buffer modification, so immediate changes to the slice will affect the result of future reads.",
        "name": "bytes.Buffer.Bytes",
        "params": [],
        "path": "go/bytes/index#Buffer.Bytes",
        "syntax": "func (b *Buffer) Bytes() []byte",
        "type": "bytes"
    },
    "bytes.Buffer.Cap": {
        "descr": "Cap returns the capacity of the buffer's underlying byte slice, that is, the total space allocated for the buffer's data.",
        "name": "bytes.Buffer.Cap",
        "params": [],
        "path": "go/bytes/index#Buffer.Cap",
        "syntax": "func (b *Buffer) Cap() int",
        "type": "bytes"
    },
    "bytes.Buffer.Grow": {
        "descr": "Grow grows the buffer's capacity, if necessary, to guarantee space for another n bytes. After Grow(n), at least n bytes can be written to the buffer without another allocation. If n is negative, Grow will panic. If the buffer can't grow it will panic with ErrTooLarge.",
        "name": "bytes.Buffer.Grow",
        "params": [],
        "path": "go/bytes/index#Buffer.Grow",
        "syntax": "func (b *Buffer) Grow(n int)",
        "type": "bytes"
    },
    "bytes.Buffer.Len": {
        "descr": "Len returns the number of bytes of the unread portion of the buffer; b.Len() == len(b.Bytes()).",
        "name": "bytes.Buffer.Len",
        "params": [],
        "path": "go/bytes/index#Buffer.Len",
        "syntax": "func (b *Buffer) Len() int",
        "type": "bytes"
    },
    "bytes.Buffer.Next": {
        "descr": "Next returns a slice containing the next n bytes from the buffer, advancing the buffer as if the bytes had been returned by Read. If there are fewer than n bytes in the buffer, Next returns the entire buffer. The slice is only valid until the next call to a read or write method.",
        "name": "bytes.Buffer.Next",
        "params": [],
        "path": "go/bytes/index#Buffer.Next",
        "syntax": "func (b *Buffer) Next(n int) []byte",
        "type": "bytes"
    },
    "bytes.Buffer.Read": {
        "descr": "Read reads the next len(p) bytes from the buffer or until the buffer is drained. The return value n is the number of bytes read. If the buffer has no data to return, err is io.EOF (unless len(p) is zero); otherwise it is nil.",
        "name": "bytes.Buffer.Read",
        "params": [],
        "path": "go/bytes/index#Buffer.Read",
        "syntax": "func (b *Buffer) Read(p []byte) (n int, err error)",
        "type": "bytes"
    },
    "bytes.Buffer.ReadByte": {
        "descr": "ReadByte reads and returns the next byte from the buffer. If no byte is available, it returns error io.EOF.",
        "name": "bytes.Buffer.ReadByte",
        "params": [],
        "path": "go/bytes/index#Buffer.ReadByte",
        "syntax": "func (b *Buffer) ReadByte() (byte, error)",
        "type": "bytes"
    },
    "bytes.Buffer.ReadBytes": {
        "descr": "ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim.",
        "name": "bytes.Buffer.ReadBytes",
        "params": [],
        "path": "go/bytes/index#Buffer.ReadBytes",
        "syntax": "func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)",
        "type": "bytes"
    },
    "bytes.Buffer.ReadFrom": {
        "descr": "ReadFrom reads data from r until EOF and appends it to the buffer, growing the buffer as needed. The return value n is the number of bytes read. Any error except io.EOF encountered during the read is also returned. If the buffer becomes too large, ReadFrom will panic with ErrTooLarge.",
        "name": "bytes.Buffer.ReadFrom",
        "params": [],
        "path": "go/bytes/index#Buffer.ReadFrom",
        "syntax": "func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)",
        "type": "bytes"
    },
    "bytes.Buffer.ReadRune": {
        "descr": "ReadRune reads and returns the next UTF-8-encoded Unicode code point from the buffer. If no bytes are available, the error returned is io.EOF. If the bytes are an erroneous UTF-8 encoding, it consumes one byte and returns U+FFFD, 1.",
        "name": "bytes.Buffer.ReadRune",
        "params": [],
        "path": "go/bytes/index#Buffer.ReadRune",
        "syntax": "func (b *Buffer) ReadRune() (r rune, size int, err error)",
        "type": "bytes"
    },
    "bytes.Buffer.ReadString": {
        "descr": "ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim.",
        "name": "bytes.Buffer.ReadString",
        "params": [],
        "path": "go/bytes/index#Buffer.ReadString",
        "syntax": "func (b *Buffer) ReadString(delim byte) (line string, err error)",
        "type": "bytes"
    },
    "bytes.Buffer.Reset": {
        "descr": "Reset resets the buffer to be empty, but it retains the underlying storage for use by future writes. Reset is the same as Truncate(0).",
        "name": "bytes.Buffer.Reset",
        "params": [],
        "path": "go/bytes/index#Buffer.Reset",
        "syntax": "func (b *Buffer) Reset()",
        "type": "bytes"
    },
    "bytes.Buffer.String": {
        "descr": "String returns the contents of the unread portion of the buffer as a string. If the Buffer is a nil pointer, it returns \"<nil>\".",
        "name": "bytes.Buffer.String",
        "params": [],
        "path": "go/bytes/index#Buffer.String",
        "syntax": "func (b *Buffer) String() string",
        "type": "bytes"
    },
    "bytes.Buffer.Truncate": {
        "descr": "Truncate discards all but the first n unread bytes from the buffer but continues to use the same allocated storage. It panics if n is negative or greater than the length of the buffer.",
        "name": "bytes.Buffer.Truncate",
        "params": [],
        "path": "go/bytes/index#Buffer.Truncate",
        "syntax": "func (b *Buffer) Truncate(n int)",
        "type": "bytes"
    },
    "bytes.Buffer.UnreadByte": {
        "descr": "UnreadByte unreads the last byte returned by the most recent successful read operation that read at least one byte. If a write has happened since the last read, if the last read returned an error, or if the read read zero bytes, UnreadByte returns an error.",
        "name": "bytes.Buffer.UnreadByte",
        "params": [],
        "path": "go/bytes/index#Buffer.UnreadByte",
        "syntax": "func (b *Buffer) UnreadByte() error",
        "type": "bytes"
    },
    "bytes.Buffer.UnreadRune": {
        "descr": "UnreadRune unreads the last rune returned by ReadRune. If the most recent read or write operation on the buffer was not a successful ReadRune, UnreadRune returns an error. (In this regard it is stricter than UnreadByte, which will unread the last byte from any read operation.)",
        "name": "bytes.Buffer.UnreadRune",
        "params": [],
        "path": "go/bytes/index#Buffer.UnreadRune",
        "syntax": "func (b *Buffer) UnreadRune() error",
        "type": "bytes"
    },
    "bytes.Buffer.Write": {
        "descr": "Write appends the contents of p to the buffer, growing the buffer as needed. The return value n is the length of p; err is always nil. If the buffer becomes too large, Write will panic with ErrTooLarge.",
        "name": "bytes.Buffer.Write",
        "params": [],
        "path": "go/bytes/index#Buffer.Write",
        "syntax": "func (b *Buffer) Write(p []byte) (n int, err error)",
        "type": "bytes"
    },
    "bytes.Buffer.WriteByte": {
        "descr": "WriteByte appends the byte c to the buffer, growing the buffer as needed. The returned error is always nil, but is included to match bufio.Writer's WriteByte. If the buffer becomes too large, WriteByte will panic with ErrTooLarge.",
        "name": "bytes.Buffer.WriteByte",
        "params": [],
        "path": "go/bytes/index#Buffer.WriteByte",
        "syntax": "func (b *Buffer) WriteByte(c byte) error",
        "type": "bytes"
    },
    "bytes.Buffer.WriteRune": {
        "descr": "WriteRune appends the UTF-8 encoding of Unicode code point r to the buffer, returning its length and an error, which is always nil but is included to match bufio.Writer's WriteRune. The buffer is grown as needed; if it becomes too large, WriteRune will panic with ErrTooLarge.",
        "name": "bytes.Buffer.WriteRune",
        "params": [],
        "path": "go/bytes/index#Buffer.WriteRune",
        "syntax": "func (b *Buffer) WriteRune(r rune) (n int, err error)",
        "type": "bytes"
    },
    "bytes.Buffer.WriteString": {
        "descr": "WriteString appends the contents of s to the buffer, growing the buffer as needed. The return value n is the length of s; err is always nil. If the buffer becomes too large, WriteString will panic with ErrTooLarge.",
        "name": "bytes.Buffer.WriteString",
        "params": [],
        "path": "go/bytes/index#Buffer.WriteString",
        "syntax": "func (b *Buffer) WriteString(s string) (n int, err error)",
        "type": "bytes"
    },
    "bytes.Buffer.WriteTo": {
        "descr": "WriteTo writes data to w until the buffer is drained or an error occurs. The return value n is the number of bytes written; it always fits into an int, but it is int64 to match the io.WriterTo interface. Any error encountered during the write is also returned.",
        "name": "bytes.Buffer.WriteTo",
        "params": [],
        "path": "go/bytes/index#Buffer.WriteTo",
        "syntax": "func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)",
        "type": "bytes"
    },
    "bytes.Compare": {
        "descr": "Compare returns an integer comparing two byte slices lexicographically. The result will be 0 if a==b, -1 if a < b, and +1 if a > b. A nil argument is equivalent to an empty slice.",
        "name": "bytes.Compare",
        "params": [],
        "path": "go/bytes/index#Compare",
        "syntax": "func Compare(a, b []byte) int",
        "type": "bytes"
    },
    "bytes.Contains": {
        "descr": "Contains reports whether subslice is within b.",
        "name": "bytes.Contains",
        "params": [],
        "path": "go/bytes/index#Contains",
        "syntax": "func Contains(b, subslice []byte) bool",
        "type": "bytes"
    },
    "bytes.ContainsAny": {
        "descr": "ContainsAny reports whether any of the UTF-8-encoded code points in chars are within b.",
        "name": "bytes.ContainsAny",
        "params": [],
        "path": "go/bytes/index#ContainsAny",
        "syntax": "func ContainsAny(b []byte, chars string) bool",
        "type": "bytes"
    },
    "bytes.ContainsRune": {
        "descr": "ContainsRune reports whether the rune is contained in the UTF-8-encoded byte slice b.",
        "name": "bytes.ContainsRune",
        "params": [],
        "path": "go/bytes/index#ContainsRune",
        "syntax": "func ContainsRune(b []byte, r rune) bool",
        "type": "bytes"
    },
    "bytes.Count": {
        "descr": "Count counts the number of non-overlapping instances of sep in s. If sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s.",
        "name": "bytes.Count",
        "params": [],
        "path": "go/bytes/index#Count",
        "syntax": "func Count(s, sep []byte) int",
        "type": "bytes"
    },
    "bytes.Equal": {
        "descr": "Equal returns a boolean reporting whether a and b are the same length and contain the same bytes. A nil argument is equivalent to an empty slice.",
        "name": "bytes.Equal",
        "params": [],
        "path": "go/bytes/index#Equal",
        "syntax": "func Equal(a, b []byte) bool",
        "type": "bytes"
    },
    "bytes.EqualFold": {
        "descr": "EqualFold reports whether s and t, interpreted as UTF-8 strings, are equal under Unicode case-folding.",
        "name": "bytes.EqualFold",
        "params": [],
        "path": "go/bytes/index#EqualFold",
        "syntax": "func EqualFold(s, t []byte) bool",
        "type": "bytes"
    },
    "bytes.Fields": {
        "descr": "Fields interprets s as a sequence of UTF-8-encoded code points. It splits the slice s around each instance of one or more consecutive white space characters, as defined by unicode.IsSpace, returning a slice of subslices of s or an empty slice if s contains only white space.",
        "name": "bytes.Fields",
        "params": [],
        "path": "go/bytes/index#Fields",
        "syntax": "func Fields(s []byte) [][]byte",
        "type": "bytes"
    },
    "bytes.FieldsFunc": {
        "descr": "FieldsFunc interprets s as a sequence of UTF-8-encoded code points. It splits the slice s at each run of code points c satisfying f(c) and returns a slice of subslices of s. If all code points in s satisfy f(c), or len(s) == 0, an empty slice is returned. FieldsFunc makes no guarantees about the order in which it calls f(c). If f does not return consistent results for a given c, FieldsFunc may crash.",
        "name": "bytes.FieldsFunc",
        "params": [],
        "path": "go/bytes/index#FieldsFunc",
        "syntax": "func FieldsFunc(s []byte, f func(rune) bool) [][]byte",
        "type": "bytes"
    },
    "bytes.HasPrefix": {
        "descr": "HasPrefix tests whether the byte slice s begins with prefix.",
        "name": "bytes.HasPrefix",
        "params": [],
        "path": "go/bytes/index#HasPrefix",
        "syntax": "func HasPrefix(s, prefix []byte) bool",
        "type": "bytes"
    },
    "bytes.HasSuffix": {
        "descr": "HasSuffix tests whether the byte slice s ends with suffix.",
        "name": "bytes.HasSuffix",
        "params": [],
        "path": "go/bytes/index#HasSuffix",
        "syntax": "func HasSuffix(s, suffix []byte) bool",
        "type": "bytes"
    },
    "bytes.Index": {
        "descr": "Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.",
        "name": "bytes.Index",
        "params": [],
        "path": "go/bytes/index#Index",
        "syntax": "func Index(s, sep []byte) int",
        "type": "bytes"
    },
    "bytes.IndexAny": {
        "descr": "IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the first occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common.",
        "name": "bytes.IndexAny",
        "params": [],
        "path": "go/bytes/index#IndexAny",
        "syntax": "func IndexAny(s []byte, chars string) int",
        "type": "bytes"
    },
    "bytes.IndexByte": {
        "descr": "IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b.",
        "name": "bytes.IndexByte",
        "params": [],
        "path": "go/bytes/index#IndexByte",
        "syntax": "func IndexByte(b []byte, c byte) int",
        "type": "bytes"
    },
    "bytes.IndexFunc": {
        "descr": "IndexFunc interprets s as a sequence of UTF-8-encoded code points. It returns the byte index in s of the first Unicode code point satisfying f(c), or -1 if none do.",
        "name": "bytes.IndexFunc",
        "params": [],
        "path": "go/bytes/index#IndexFunc",
        "syntax": "func IndexFunc(s []byte, f func(r rune) bool) int",
        "type": "bytes"
    },
    "bytes.IndexRune": {
        "descr": "IndexRune interprets s as a sequence of UTF-8-encoded code points. It returns the byte index of the first occurrence in s of the given rune. It returns -1 if rune is not present in s. If r is utf8.RuneError, it returns the first instance of any invalid UTF-8 byte sequence.",
        "name": "bytes.IndexRune",
        "params": [],
        "path": "go/bytes/index#IndexRune",
        "syntax": "func IndexRune(s []byte, r rune) int",
        "type": "bytes"
    },
    "bytes.Join": {
        "descr": "Join concatenates the elements of s to create a new byte slice. The separator sep is placed between elements in the resulting slice.",
        "name": "bytes.Join",
        "params": [],
        "path": "go/bytes/index#Join",
        "syntax": "func Join(s [][]byte, sep []byte) []byte",
        "type": "bytes"
    },
    "bytes.LastIndex": {
        "descr": "LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.",
        "name": "bytes.LastIndex",
        "params": [],
        "path": "go/bytes/index#LastIndex",
        "syntax": "func LastIndex(s, sep []byte) int",
        "type": "bytes"
    },
    "bytes.LastIndexAny": {
        "descr": "LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the last occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common.",
        "name": "bytes.LastIndexAny",
        "params": [],
        "path": "go/bytes/index#LastIndexAny",
        "syntax": "func LastIndexAny(s []byte, chars string) int",
        "type": "bytes"
    },
    "bytes.LastIndexByte": {
        "descr": "LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.",
        "name": "bytes.LastIndexByte",
        "params": [],
        "path": "go/bytes/index#LastIndexByte",
        "syntax": "func LastIndexByte(s []byte, c byte) int",
        "type": "bytes"
    },
    "bytes.LastIndexFunc": {
        "descr": "LastIndexFunc interprets s as a sequence of UTF-8-encoded code points. It returns the byte index in s of the last Unicode code point satisfying f(c), or -1 if none do.",
        "name": "bytes.LastIndexFunc",
        "params": [],
        "path": "go/bytes/index#LastIndexFunc",
        "syntax": "func LastIndexFunc(s []byte, f func(r rune) bool) int",
        "type": "bytes"
    },
    "bytes.Map": {
        "descr": "Map returns a copy of the byte slice s with all its characters modified according to the mapping function. If mapping returns a negative value, the character is dropped from the byte slice with no replacement. The characters in s and the output are interpreted as UTF-8-encoded code points.",
        "name": "bytes.Map",
        "params": [],
        "path": "go/bytes/index#Map",
        "syntax": "func Map(mapping func(r rune) rune, s []byte) []byte",
        "type": "bytes"
    },
    "bytes.NewBuffer": {
        "descr": "NewBuffer creates and initializes a new Buffer using buf as its initial contents. The new Buffer takes ownership of buf, and the caller should not use buf after this call. NewBuffer is intended to prepare a Buffer to read existing data. It can also be used to size the internal buffer for writing. To do that, buf should have the desired capacity but a length of zero.",
        "name": "bytes.NewBuffer",
        "params": [],
        "path": "go/bytes/index#NewBuffer",
        "syntax": "func NewBuffer(buf []byte) *Buffer",
        "type": "bytes"
    },
    "bytes.NewBufferString": {
        "descr": "NewBufferString creates and initializes a new Buffer using string s as its initial contents. It is intended to prepare a buffer to read an existing string.",
        "name": "bytes.NewBufferString",
        "params": [],
        "path": "go/bytes/index#NewBufferString",
        "syntax": "func NewBufferString(s string) *Buffer",
        "type": "bytes"
    },
    "bytes.NewReader": {
        "descr": "NewReader returns a new Reader reading from b.",
        "name": "bytes.NewReader",
        "params": [],
        "path": "go/bytes/index#NewReader",
        "syntax": "func NewReader(b []byte) *Reader",
        "type": "bytes"
    },
    "bytes.Reader": {
        "descr": "A Reader implements the io.Reader, io.ReaderAt, io.WriterTo, io.Seeker, io.ByteScanner, and io.RuneScanner interfaces by reading from a byte slice. Unlike a Buffer, a Reader is read-only and supports seeking.",
        "name": "bytes.Reader",
        "params": [],
        "path": "go/bytes/index#Reader",
        "syntax": "type Reader struct { // contains filtered or unexported fields }",
        "type": "bytes"
    },
    "bytes.Reader.Len": {
        "descr": "Len returns the number of bytes of the unread portion of the slice.",
        "name": "bytes.Reader.Len",
        "params": [],
        "path": "go/bytes/index#Reader.Len",
        "syntax": "func (r *Reader) Len() int",
        "type": "bytes"
    },
    "bytes.Reader.Read": {
        "descr": "Read implements the io.Reader interface.",
        "name": "bytes.Reader.Read",
        "params": [],
        "path": "go/bytes/index#Reader.Read",
        "syntax": "func (r *Reader) Read(b []byte) (n int, err error)",
        "type": "bytes"
    },
    "bytes.Reader.ReadAt": {
        "descr": "ReadAt implements the io.ReaderAt interface.",
        "name": "bytes.Reader.ReadAt",
        "params": [],
        "path": "go/bytes/index#Reader.ReadAt",
        "syntax": "func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)",
        "type": "bytes"
    },
    "bytes.Reader.ReadByte": {
        "descr": "ReadByte implements the io.ByteReader interface.",
        "name": "bytes.Reader.ReadByte",
        "params": [],
        "path": "go/bytes/index#Reader.ReadByte",
        "syntax": "func (r *Reader) ReadByte() (byte, error)",
        "type": "bytes"
    },
    "bytes.Reader.ReadRune": {
        "descr": "ReadRune implements the io.RuneReader interface.",
        "name": "bytes.Reader.ReadRune",
        "params": [],
        "path": "go/bytes/index#Reader.ReadRune",
        "syntax": "func (r *Reader) ReadRune() (ch rune, size int, err error)",
        "type": "bytes"
    },
    "bytes.Reader.Reset": {
        "descr": "Reset resets the Reader to be reading from b.",
        "name": "bytes.Reader.Reset",
        "params": [],
        "path": "go/bytes/index#Reader.Reset",
        "syntax": "func (r *Reader) Reset(b []byte)",
        "type": "bytes"
    },
    "bytes.Reader.Seek": {
        "descr": "Seek implements the io.Seeker interface.",
        "name": "bytes.Reader.Seek",
        "params": [],
        "path": "go/bytes/index#Reader.Seek",
        "syntax": "func (r *Reader) Seek(offset int64, whence int) (int64, error)",
        "type": "bytes"
    },
    "bytes.Reader.Size": {
        "descr": "Size returns the original length of the underlying byte slice. Size is the number of bytes available for reading via ReadAt. The returned value is always the same and is not affected by calls to any other method.",
        "name": "bytes.Reader.Size",
        "params": [],
        "path": "go/bytes/index#Reader.Size",
        "syntax": "func (r *Reader) Size() int64",
        "type": "bytes"
    },
    "bytes.Reader.UnreadByte": {
        "descr": "UnreadByte complements ReadByte in implementing the io.ByteScanner interface.",
        "name": "bytes.Reader.UnreadByte",
        "params": [],
        "path": "go/bytes/index#Reader.UnreadByte",
        "syntax": "func (r *Reader) UnreadByte() error",
        "type": "bytes"
    },
    "bytes.Reader.UnreadRune": {
        "descr": "UnreadRune complements ReadRune in implementing the io.RuneScanner interface.",
        "name": "bytes.Reader.UnreadRune",
        "params": [],
        "path": "go/bytes/index#Reader.UnreadRune",
        "syntax": "func (r *Reader) UnreadRune() error",
        "type": "bytes"
    },
    "bytes.Reader.WriteTo": {
        "descr": "WriteTo implements the io.WriterTo interface.",
        "name": "bytes.Reader.WriteTo",
        "params": [],
        "path": "go/bytes/index#Reader.WriteTo",
        "syntax": "func (r *Reader) WriteTo(w io.Writer) (n int64, err error)",
        "type": "bytes"
    },
    "bytes.Repeat": {
        "descr": "Repeat returns a new byte slice consisting of count copies of b.",
        "name": "bytes.Repeat",
        "params": [],
        "path": "go/bytes/index#Repeat",
        "syntax": "func Repeat(b []byte, count int) []byte",
        "type": "bytes"
    },
    "bytes.Replace": {
        "descr": "Replace returns a copy of the slice s with the first n non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the slice and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune slice. If n < 0, there is no limit on the number of replacements.",
        "name": "bytes.Replace",
        "params": [],
        "path": "go/bytes/index#Replace",
        "syntax": "func Replace(s, old, new []byte, n int) []byte",
        "type": "bytes"
    },
    "bytes.Runes": {
        "descr": "Runes interprets s as a sequence of UTF-8-encoded code points. It returns a slice of runes (Unicode code points) equivalent to s.",
        "name": "bytes.Runes",
        "params": [],
        "path": "go/bytes/index#Runes",
        "syntax": "func Runes(s []byte) []rune",
        "type": "bytes"
    },
    "bytes.Split": {
        "descr": "Split slices s into all subslices separated by sep and returns a slice of the subslices between those separators. If sep is empty, Split splits after each UTF-8 sequence. It is equivalent to SplitN with a count of -1.",
        "name": "bytes.Split",
        "params": [],
        "path": "go/bytes/index#Split",
        "syntax": "func Split(s, sep []byte) [][]byte",
        "type": "bytes"
    },
    "bytes.SplitAfter": {
        "descr": "SplitAfter slices s into all subslices after each instance of sep and returns a slice of those subslices. If sep is empty, SplitAfter splits after each UTF-8 sequence. It is equivalent to SplitAfterN with a count of -1.",
        "name": "bytes.SplitAfter",
        "params": [],
        "path": "go/bytes/index#SplitAfter",
        "syntax": "func SplitAfter(s, sep []byte) [][]byte",
        "type": "bytes"
    },
    "bytes.SplitAfterN": {
        "descr": "SplitAfterN slices s into subslices after each instance of sep and returns a slice of those subslices. If sep is empty, SplitAfterN splits after each UTF-8 sequence. The count determines the number of subslices to return:",
        "name": "bytes.SplitAfterN",
        "params": [],
        "path": "go/bytes/index#SplitAfterN",
        "syntax": "func SplitAfterN(s, sep []byte, n int) [][]byte",
        "type": "bytes"
    },
    "bytes.SplitN": {
        "descr": "SplitN slices s into subslices separated by sep and returns a slice of the subslices between those separators. If sep is empty, SplitN splits after each UTF-8 sequence. The count determines the number of subslices to return:",
        "name": "bytes.SplitN",
        "params": [],
        "path": "go/bytes/index#SplitN",
        "syntax": "func SplitN(s, sep []byte, n int) [][]byte",
        "type": "bytes"
    },
    "bytes.Title": {
        "descr": "Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin words mapped to their title case.",
        "name": "bytes.Title",
        "params": [],
        "path": "go/bytes/index#Title",
        "syntax": "func Title(s []byte) []byte",
        "type": "bytes"
    },
    "bytes.ToLower": {
        "descr": "ToLower treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case.",
        "name": "bytes.ToLower",
        "params": [],
        "path": "go/bytes/index#ToLower",
        "syntax": "func ToLower(s []byte) []byte",
        "type": "bytes"
    },
    "bytes.ToLowerSpecial": {
        "descr": "ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case, giving priority to the special casing rules.",
        "name": "bytes.ToLowerSpecial",
        "params": [],
        "path": "go/bytes/index#ToLowerSpecial",
        "syntax": "func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte",
        "type": "bytes"
    },
    "bytes.ToTitle": {
        "descr": "ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case.",
        "name": "bytes.ToTitle",
        "params": [],
        "path": "go/bytes/index#ToTitle",
        "syntax": "func ToTitle(s []byte) []byte",
        "type": "bytes"
    },
    "bytes.ToTitleSpecial": {
        "descr": "ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case, giving priority to the special casing rules.",
        "name": "bytes.ToTitleSpecial",
        "params": [],
        "path": "go/bytes/index#ToTitleSpecial",
        "syntax": "func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte",
        "type": "bytes"
    },
    "bytes.ToUpper": {
        "descr": "ToUpper treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters within it mapped to their upper case.",
        "name": "bytes.ToUpper",
        "params": [],
        "path": "go/bytes/index#ToUpper",
        "syntax": "func ToUpper(s []byte) []byte",
        "type": "bytes"
    },
    "bytes.ToUpperSpecial": {
        "descr": "ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their upper case, giving priority to the special casing rules.",
        "name": "bytes.ToUpperSpecial",
        "params": [],
        "path": "go/bytes/index#ToUpperSpecial",
        "syntax": "func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte",
        "type": "bytes"
    },
    "bytes.Trim": {
        "descr": "Trim returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points contained in cutset.",
        "name": "bytes.Trim",
        "params": [],
        "path": "go/bytes/index#Trim",
        "syntax": "func Trim(s []byte, cutset string) []byte",
        "type": "bytes"
    },
    "bytes.TrimFunc": {
        "descr": "TrimFunc returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points c that satisfy f(c).",
        "name": "bytes.TrimFunc",
        "params": [],
        "path": "go/bytes/index#TrimFunc",
        "syntax": "func TrimFunc(s []byte, f func(r rune) bool) []byte",
        "type": "bytes"
    },
    "bytes.TrimLeft": {
        "descr": "TrimLeft returns a subslice of s by slicing off all leading UTF-8-encoded code points contained in cutset.",
        "name": "bytes.TrimLeft",
        "params": [],
        "path": "go/bytes/index#TrimLeft",
        "syntax": "func TrimLeft(s []byte, cutset string) []byte",
        "type": "bytes"
    },
    "bytes.TrimLeftFunc": {
        "descr": "TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off all leading UTF-8-encoded code points c that satisfy f(c).",
        "name": "bytes.TrimLeftFunc",
        "params": [],
        "path": "go/bytes/index#TrimLeftFunc",
        "syntax": "func TrimLeftFunc(s []byte, f func(r rune) bool) []byte",
        "type": "bytes"
    },
    "bytes.TrimPrefix": {
        "descr": "TrimPrefix returns s without the provided leading prefix string. If s doesn't start with prefix, s is returned unchanged.",
        "name": "bytes.TrimPrefix",
        "params": [],
        "path": "go/bytes/index#TrimPrefix",
        "syntax": "func TrimPrefix(s, prefix []byte) []byte",
        "type": "bytes"
    },
    "bytes.TrimRight": {
        "descr": "TrimRight returns a subslice of s by slicing off all trailing UTF-8-encoded code points that are contained in cutset.",
        "name": "bytes.TrimRight",
        "params": [],
        "path": "go/bytes/index#TrimRight",
        "syntax": "func TrimRight(s []byte, cutset string) []byte",
        "type": "bytes"
    },
    "bytes.TrimRightFunc": {
        "descr": "TrimRightFunc returns a subslice of s by slicing off all trailing UTF-8-encoded code points c that satisfy f(c).",
        "name": "bytes.TrimRightFunc",
        "params": [],
        "path": "go/bytes/index#TrimRightFunc",
        "syntax": "func TrimRightFunc(s []byte, f func(r rune) bool) []byte",
        "type": "bytes"
    },
    "bytes.TrimSpace": {
        "descr": "TrimSpace returns a subslice of s by slicing off all leading and trailing white space, as defined by Unicode.",
        "name": "bytes.TrimSpace",
        "params": [],
        "path": "go/bytes/index#TrimSpace",
        "syntax": "func TrimSpace(s []byte) []byte",
        "type": "bytes"
    },
    "bytes.TrimSuffix": {
        "descr": "TrimSuffix returns s without the provided trailing suffix string. If s doesn't end with suffix, s is returned unchanged.",
        "name": "bytes.TrimSuffix",
        "params": [],
        "path": "go/bytes/index#TrimSuffix",
        "syntax": "func TrimSuffix(s, suffix []byte) []byte",
        "type": "bytes"
    },
    "bzip2.NewReader": {
        "descr": "NewReader returns an io.Reader which decompresses bzip2 data from r. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r.",
        "name": "bzip2.NewReader",
        "params": [],
        "path": "go/compress/bzip2/index#NewReader",
        "syntax": "func NewReader(r io.Reader) io.Reader",
        "type": "compress"
    },
    "bzip2.StructuralError": {
        "descr": "A StructuralError is returned when the bzip2 data is found to be syntactically invalid.",
        "name": "bzip2.StructuralError",
        "params": [],
        "path": "go/compress/bzip2/index#StructuralError",
        "syntax": "type StructuralError string",
        "type": "compress"
    },
    "bzip2.StructuralError.Error": {
        "descr": "",
        "name": "bzip2.StructuralError.Error",
        "params": [],
        "path": "go/compress/bzip2/index#StructuralError.Error",
        "syntax": "func (s StructuralError) Error() string",
        "type": "compress"
    },
    "cap": {
        "descr": "The cap built-in function returns the capacity of v, according to its type:",
        "name": "builtin.cap",
        "params": [],
        "path": "go/builtin/index#cap",
        "syntax": "func cap(v Type) int",
        "type": "builtin"
    },
    "cgi.Handler": {
        "descr": "Handler runs an executable in a subprocess with a CGI environment.",
        "name": "cgi.Handler",
        "params": [],
        "path": "go/net/http/cgi/index#Handler",
        "syntax": "type Handler struct { Path string // path to the CGI executable Root string // root URI prefix of handler or empty for \"/\" // Dir specifies the CGI executable's working directory. // If Dir is empty, the base directory of Path is used. // If Path has no base directory, the current working // directory is used. Dir string Env []string // extra environment variables to set, if any, as \"key=value\" InheritEnv []string // environment variables to inherit from host, as \"key\" Logger *log.Logger // optional log for errors or nil to use log.Print Args []string // optional arguments to pass to child process Stderr io.Writer // optional stderr for the child process; nil means os.Stderr; added in Go 1.7 // PathLocationHandler specifies the root http Handler that // should handle internal redirects when the CGI process // returns a Location header value starting with a \"/\", as // specified in RFC 3875  6.3.2. This will likely be // http.DefaultServeMux. // // If nil, a CGI response with a local URI path is instead sent // back to the client and not redirected internally. PathLocationHandler http.Handler }",
        "type": "net/http"
    },
    "cgi.Handler.ServeHTTP": {
        "descr": "",
        "name": "cgi.Handler.ServeHTTP",
        "params": [],
        "path": "go/net/http/cgi/index#Handler.ServeHTTP",
        "syntax": "func (h *Handler) ServeHTTP(rw http.ResponseWriter, req *http.Request)",
        "type": "net/http"
    },
    "cgi.Request": {
        "descr": "Request returns the HTTP request as represented in the current environment. This assumes the current program is being run by a web server in a CGI environment. The returned Request's Body is populated, if applicable.",
        "name": "cgi.Request",
        "params": [],
        "path": "go/net/http/cgi/index#Request",
        "syntax": "func Request() (*http.Request, error)",
        "type": "net/http"
    },
    "cgi.RequestFromMap": {
        "descr": "RequestFromMap creates an http.Request from CGI variables. The returned Request's Body field is not populated.",
        "name": "cgi.RequestFromMap",
        "params": [],
        "path": "go/net/http/cgi/index#RequestFromMap",
        "syntax": "func RequestFromMap(params map[string]string) (*http.Request, error)",
        "type": "net/http"
    },
    "cgi.Serve": {
        "descr": "Serve executes the provided Handler on the currently active CGI request, if any. If there's no current CGI environment an error is returned. The provided handler may be nil to use http.DefaultServeMux.",
        "name": "cgi.Serve",
        "params": [],
        "path": "go/net/http/cgi/index#Serve",
        "syntax": "func Serve(handler http.Handler) error",
        "type": "net/http"
    },
    "cipher.AEAD": {
        "descr": "AEAD is a cipher mode providing authenticated encryption with associated data. For a description of the methodology, see",
        "name": "cipher.AEAD",
        "params": [],
        "path": "go/crypto/cipher/index#AEAD",
        "syntax": "https://en.wikipedia.org/wiki/Authenticated_encryption",
        "type": "crypto"
    },
    "cipher.Block": {
        "descr": "A Block represents an implementation of block cipher using a given key. It provides the capability to encrypt or decrypt individual blocks. The mode implementations extend that capability to streams of blocks.",
        "name": "cipher.Block",
        "params": [],
        "path": "go/crypto/cipher/index#Block",
        "syntax": "type Block interface { // BlockSize returns the cipher's block size. BlockSize() int // Encrypt encrypts the first block in src into dst. // Dst and src must overlap entirely or not at all. Encrypt(dst, src []byte) // Decrypt decrypts the first block in src into dst. // Dst and src must overlap entirely or not at all. Decrypt(dst, src []byte) }",
        "type": "crypto"
    },
    "cipher.BlockMode": {
        "descr": "A BlockMode represents a block cipher running in a block-based mode (CBC, ECB etc).",
        "name": "cipher.BlockMode",
        "params": [],
        "path": "go/crypto/cipher/index#BlockMode",
        "syntax": "type BlockMode interface { // BlockSize returns the mode's block size. BlockSize() int // CryptBlocks encrypts or decrypts a number of blocks. The length of // src must be a multiple of the block size. Dst and src must overlap // entirely or not at all. // // If len(dst) < len(src), CryptBlocks should panic. It is acceptable // to pass a dst bigger than src, and in that case, CryptBlocks will // only update dst[:len(src)] and will not touch the rest of dst. // // Multiple calls to CryptBlocks behave as if the concatenation of // the src buffers was passed in a single run. That is, BlockMode // maintains state and does not reset at each CryptBlocks call. CryptBlocks(dst, src []byte) }",
        "type": "crypto"
    },
    "cipher.NewCBCDecrypter": {
        "descr": "NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining mode, using the given Block. The length of iv must be the same as the Block's block size and must match the iv used to encrypt the data.",
        "name": "cipher.NewCBCDecrypter",
        "params": [],
        "path": "go/crypto/cipher/index#NewCBCDecrypter",
        "syntax": "func NewCBCDecrypter(b Block, iv []byte) BlockMode",
        "type": "crypto"
    },
    "cipher.NewCBCEncrypter": {
        "descr": "NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining mode, using the given Block. The length of iv must be the same as the Block's block size.",
        "name": "cipher.NewCBCEncrypter",
        "params": [],
        "path": "go/crypto/cipher/index#NewCBCEncrypter",
        "syntax": "func NewCBCEncrypter(b Block, iv []byte) BlockMode",
        "type": "crypto"
    },
    "cipher.NewCFBDecrypter": {
        "descr": "NewCFBDecrypter returns a Stream which decrypts with cipher feedback mode, using the given Block. The iv must be the same length as the Block's block size.",
        "name": "cipher.NewCFBDecrypter",
        "params": [],
        "path": "go/crypto/cipher/index#NewCFBDecrypter",
        "syntax": "func NewCFBDecrypter(block Block, iv []byte) Stream",
        "type": "crypto"
    },
    "cipher.NewCFBEncrypter": {
        "descr": "NewCFBEncrypter returns a Stream which encrypts with cipher feedback mode, using the given Block. The iv must be the same length as the Block's block size.",
        "name": "cipher.NewCFBEncrypter",
        "params": [],
        "path": "go/crypto/cipher/index#NewCFBEncrypter",
        "syntax": "func NewCFBEncrypter(block Block, iv []byte) Stream",
        "type": "crypto"
    },
    "cipher.NewCTR": {
        "descr": "NewCTR returns a Stream which encrypts/decrypts using the given Block in counter mode. The length of iv must be the same as the Block's block size.",
        "name": "cipher.NewCTR",
        "params": [],
        "path": "go/crypto/cipher/index#NewCTR",
        "syntax": "func NewCTR(block Block, iv []byte) Stream",
        "type": "crypto"
    },
    "cipher.NewGCM": {
        "descr": "NewGCM returns the given 128-bit, block cipher wrapped in Galois Counter Mode with the standard nonce length.",
        "name": "cipher.NewGCM",
        "params": [],
        "path": "go/crypto/cipher/index#NewGCM",
        "syntax": "func NewGCM(cipher Block) (AEAD, error)",
        "type": "crypto"
    },
    "cipher.NewGCMWithNonceSize": {
        "descr": "NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in Galois Counter Mode, which accepts nonces of the given length.",
        "name": "cipher.NewGCMWithNonceSize",
        "params": [],
        "path": "go/crypto/cipher/index#NewGCMWithNonceSize",
        "syntax": "func NewGCMWithNonceSize(cipher Block, size int) (AEAD, error)",
        "type": "crypto"
    },
    "cipher.NewGCMWithTagSize": {
        "descr": "NewGCMWithTagSize returns the given 128-bit, block cipher wrapped in Galois Counter Mode, which generates tags with the given length.",
        "name": "cipher.NewGCMWithTagSize",
        "params": [],
        "path": "go/crypto/cipher/index#NewGCMWithTagSize",
        "syntax": "func NewGCMWithTagSize(cipher Block, tagSize int) (AEAD, error)",
        "type": "crypto"
    },
    "cipher.NewOFB": {
        "descr": "NewOFB returns a Stream that encrypts or decrypts using the block cipher b in output feedback mode. The initialization vector iv's length must be equal to b's block size.",
        "name": "cipher.NewOFB",
        "params": [],
        "path": "go/crypto/cipher/index#NewOFB",
        "syntax": "func NewOFB(b Block, iv []byte) Stream",
        "type": "crypto"
    },
    "cipher.Stream": {
        "descr": "A Stream represents a stream cipher.",
        "name": "cipher.Stream",
        "params": [],
        "path": "go/crypto/cipher/index#Stream",
        "syntax": "type Stream interface { // XORKeyStream XORs each byte in the given slice with a byte from the // cipher's key stream. Dst and src must overlap entirely or not at all. // // If len(dst) < len(src), XORKeyStream should panic. It is acceptable // to pass a dst bigger than src, and in that case, XORKeyStream will // only update dst[:len(src)] and will not touch the rest of dst. // // Multiple calls to XORKeyStream behave as if the concatenation of // the src buffers was passed in a single run. That is, Stream // maintains state and does not reset at each XORKeyStream call. XORKeyStream(dst, src []byte) }",
        "type": "crypto"
    },
    "cipher.StreamReader": {
        "descr": "StreamReader wraps a Stream into an io.Reader. It calls XORKeyStream to process each slice of data which passes through.",
        "name": "cipher.StreamReader",
        "params": [],
        "path": "go/crypto/cipher/index#StreamReader",
        "syntax": "type StreamReader struct { S Stream R io.Reader }",
        "type": "crypto"
    },
    "cipher.StreamReader.Read": {
        "descr": "",
        "name": "cipher.StreamReader.Read",
        "params": [],
        "path": "go/crypto/cipher/index#StreamReader.Read",
        "syntax": "func (r StreamReader) Read(dst []byte) (n int, err error)",
        "type": "crypto"
    },
    "cipher.StreamWriter": {
        "descr": "StreamWriter wraps a Stream into an io.Writer. It calls XORKeyStream to process each slice of data which passes through. If any Write call returns short then the StreamWriter is out of sync and must be discarded. A StreamWriter has no internal buffering; Close does not need to be called to flush write data.",
        "name": "cipher.StreamWriter",
        "params": [],
        "path": "go/crypto/cipher/index#StreamWriter",
        "syntax": "type StreamWriter struct { S Stream W io.Writer Err error // unused }",
        "type": "crypto"
    },
    "cipher.StreamWriter.Close": {
        "descr": "Close closes the underlying Writer and returns its Close return value, if the Writer is also an io.Closer. Otherwise it returns nil.",
        "name": "cipher.StreamWriter.Close",
        "params": [],
        "path": "go/crypto/cipher/index#StreamWriter.Close",
        "syntax": "func (w StreamWriter) Close() error",
        "type": "crypto"
    },
    "cipher.StreamWriter.Write": {
        "descr": "",
        "name": "cipher.StreamWriter.Write",
        "params": [],
        "path": "go/crypto/cipher/index#StreamWriter.Write",
        "syntax": "func (w StreamWriter) Write(src []byte) (n int, err error)",
        "type": "crypto"
    },
    "close": {
        "descr": "The close built-in function closes a channel, which must be either bidirectional or send-only. It should be executed only by the sender, never the receiver, and has the effect of shutting down the channel after the last sent value is received. After the last value has been received from a closed channel c, any receive from c will succeed without blocking, returning the zero value for the channel element. The form",
        "name": "builtin.close",
        "params": [],
        "path": "go/builtin/index#close",
        "syntax": "func close(c chan<- Type)",
        "type": "builtin"
    },
    "cmplx.Abs": {
        "descr": "Abs returns the absolute value (also called the modulus) of x.",
        "name": "cmplx.Abs",
        "params": [],
        "path": "go/math/cmplx/index#Abs",
        "syntax": "func Abs(x complex128) float64",
        "type": "math/cmplx"
    },
    "cmplx.Acos": {
        "descr": "Acos returns the inverse cosine of x.",
        "name": "cmplx.Acos",
        "params": [],
        "path": "go/math/cmplx/index#Acos",
        "syntax": "func Acos(x complex128) complex128",
        "type": "math/cmplx"
    },
    "cmplx.Acosh": {
        "descr": "Acosh returns the inverse hyperbolic cosine of x.",
        "name": "cmplx.Acosh",
        "params": [],
        "path": "go/math/cmplx/index#Acosh",
        "syntax": "func Acosh(x complex128) complex128",
        "type": "math/cmplx"
    },
    "cmplx.Asin": {
        "descr": "Asin returns the inverse sine of x.",
        "name": "cmplx.Asin",
        "params": [],
        "path": "go/math/cmplx/index#Asin",
        "syntax": "func Asin(x complex128) complex128",
        "type": "math/cmplx"
    },
    "cmplx.Asinh": {
        "descr": "Asinh returns the inverse hyperbolic sine of x.",
        "name": "cmplx.Asinh",
        "params": [],
        "path": "go/math/cmplx/index#Asinh",
        "syntax": "func Asinh(x complex128) complex128",
        "type": "math/cmplx"
    },
    "cmplx.Atan": {
        "descr": "Atan returns the inverse tangent of x.",
        "name": "cmplx.Atan",
        "params": [],
        "path": "go/math/cmplx/index#Atan",
        "syntax": "func Atan(x complex128) complex128",
        "type": "math/cmplx"
    },
    "cmplx.Atanh": {
        "descr": "Atanh returns the inverse hyperbolic tangent of x.",
        "name": "cmplx.Atanh",
        "params": [],
        "path": "go/math/cmplx/index#Atanh",
        "syntax": "func Atanh(x complex128) complex128",
        "type": "math/cmplx"
    },
    "cmplx.Conj": {
        "descr": "Conj returns the complex conjugate of x.",
        "name": "cmplx.Conj",
        "params": [],
        "path": "go/math/cmplx/index#Conj",
        "syntax": "func Conj(x complex128) complex128",
        "type": "math/cmplx"
    },
    "cmplx.Cos": {
        "descr": "Cos returns the cosine of x.",
        "name": "cmplx.Cos",
        "params": [],
        "path": "go/math/cmplx/index#Cos",
        "syntax": "func Cos(x complex128) complex128",
        "type": "math/cmplx"
    },
    "cmplx.Cosh": {
        "descr": "Cosh returns the hyperbolic cosine of x.",
        "name": "cmplx.Cosh",
        "params": [],
        "path": "go/math/cmplx/index#Cosh",
        "syntax": "func Cosh(x complex128) complex128",
        "type": "math/cmplx"
    },
    "cmplx.Cot": {
        "descr": "Cot returns the cotangent of x.",
        "name": "cmplx.Cot",
        "params": [],
        "path": "go/math/cmplx/index#Cot",
        "syntax": "func Cot(x complex128) complex128",
        "type": "math/cmplx"
    },
    "cmplx.Exp": {
        "descr": "Exp returns e**x, the base-e exponential of x.",
        "name": "cmplx.Exp",
        "params": [],
        "path": "go/math/cmplx/index#Exp",
        "syntax": "func Exp(x complex128) complex128",
        "type": "math/cmplx"
    },
    "cmplx.Inf": {
        "descr": "Inf returns a complex infinity, complex(+Inf, +Inf).",
        "name": "cmplx.Inf",
        "params": [],
        "path": "go/math/cmplx/index#Inf",
        "syntax": "func Inf() complex128",
        "type": "math/cmplx"
    },
    "cmplx.IsInf": {
        "descr": "IsInf returns true if either real(x) or imag(x) is an infinity.",
        "name": "cmplx.IsInf",
        "params": [],
        "path": "go/math/cmplx/index#IsInf",
        "syntax": "func IsInf(x complex128) bool",
        "type": "math/cmplx"
    },
    "cmplx.IsNaN": {
        "descr": "IsNaN returns true if either real(x) or imag(x) is NaN and neither is an infinity.",
        "name": "cmplx.IsNaN",
        "params": [],
        "path": "go/math/cmplx/index#IsNaN",
        "syntax": "func IsNaN(x complex128) bool",
        "type": "math/cmplx"
    },
    "cmplx.Log": {
        "descr": "Log returns the natural logarithm of x.",
        "name": "cmplx.Log",
        "params": [],
        "path": "go/math/cmplx/index#Log",
        "syntax": "func Log(x complex128) complex128",
        "type": "math/cmplx"
    },
    "cmplx.Log10": {
        "descr": "Log10 returns the decimal logarithm of x.",
        "name": "cmplx.Log10",
        "params": [],
        "path": "go/math/cmplx/index#Log10",
        "syntax": "func Log10(x complex128) complex128",
        "type": "math/cmplx"
    },
    "cmplx.NaN": {
        "descr": "NaN returns a complex not-a-number value.",
        "name": "cmplx.NaN",
        "params": [],
        "path": "go/math/cmplx/index#NaN",
        "syntax": "func NaN() complex128",
        "type": "math/cmplx"
    },
    "cmplx.Phase": {
        "descr": "Phase returns the phase (also called the argument) of x. The returned value is in the range [-Pi, Pi].",
        "name": "cmplx.Phase",
        "params": [],
        "path": "go/math/cmplx/index#Phase",
        "syntax": "func Phase(x complex128) float64",
        "type": "math/cmplx"
    },
    "cmplx.Polar": {
        "descr": "Polar returns the absolute value r and phase  of x, such that x = r * e**i. The phase is in the range [-Pi, Pi].",
        "name": "cmplx.Polar",
        "params": [],
        "path": "go/math/cmplx/index#Polar",
        "syntax": "func Polar(x complex128) (r,  float64)",
        "type": "math/cmplx"
    },
    "cmplx.Pow": {
        "descr": "Pow returns x**y, the base-x exponential of y. For generalized compatibility with math.Pow:",
        "name": "cmplx.Pow",
        "params": [],
        "path": "go/math/cmplx/index#Pow",
        "syntax": "func Pow(x, y complex128) complex128",
        "type": "math/cmplx"
    },
    "cmplx.Rect": {
        "descr": "Rect returns the complex number x with polar coordinates r, .",
        "name": "cmplx.Rect",
        "params": [],
        "path": "go/math/cmplx/index#Rect",
        "syntax": "func Rect(r,  float64) complex128",
        "type": "math/cmplx"
    },
    "cmplx.Sin": {
        "descr": "Sin returns the sine of x.",
        "name": "cmplx.Sin",
        "params": [],
        "path": "go/math/cmplx/index#Sin",
        "syntax": "func Sin(x complex128) complex128",
        "type": "math/cmplx"
    },
    "cmplx.Sinh": {
        "descr": "Sinh returns the hyperbolic sine of x.",
        "name": "cmplx.Sinh",
        "params": [],
        "path": "go/math/cmplx/index#Sinh",
        "syntax": "func Sinh(x complex128) complex128",
        "type": "math/cmplx"
    },
    "cmplx.Sqrt": {
        "descr": "Sqrt returns the square root of x. The result r is chosen so that real(r)  0 and imag(r) has the same sign as imag(x).",
        "name": "cmplx.Sqrt",
        "params": [],
        "path": "go/math/cmplx/index#Sqrt",
        "syntax": "func Sqrt(x complex128) complex128",
        "type": "math/cmplx"
    },
    "cmplx.Tan": {
        "descr": "Tan returns the tangent of x.",
        "name": "cmplx.Tan",
        "params": [],
        "path": "go/math/cmplx/index#Tan",
        "syntax": "func Tan(x complex128) complex128",
        "type": "math/cmplx"
    },
    "cmplx.Tanh": {
        "descr": "Tanh returns the hyperbolic tangent of x.",
        "name": "cmplx.Tanh",
        "params": [],
        "path": "go/math/cmplx/index#Tanh",
        "syntax": "func Tanh(x complex128) complex128",
        "type": "math/cmplx"
    },
    "color.Alpha": {
        "descr": "Alpha represents an 8-bit alpha color.",
        "name": "color.Alpha",
        "params": [],
        "path": "go/image/color/index#Alpha",
        "syntax": "type Alpha struct { A uint8 }",
        "type": "image"
    },
    "color.Alpha.RGBA": {
        "descr": "",
        "name": "color.Alpha.RGBA",
        "params": [],
        "path": "go/image/color/index#Alpha.RGBA",
        "syntax": "func (c Alpha) RGBA() (r, g, b, a uint32)",
        "type": "image"
    },
    "color.Alpha16": {
        "descr": "Alpha16 represents a 16-bit alpha color.",
        "name": "color.Alpha16",
        "params": [],
        "path": "go/image/color/index#Alpha16",
        "syntax": "type Alpha16 struct { A uint16 }",
        "type": "image"
    },
    "color.Alpha16.RGBA": {
        "descr": "",
        "name": "color.Alpha16.RGBA",
        "params": [],
        "path": "go/image/color/index#Alpha16.RGBA",
        "syntax": "func (c Alpha16) RGBA() (r, g, b, a uint32)",
        "type": "image"
    },
    "color.CMYK": {
        "descr": "CMYK represents a fully opaque CMYK color, having 8 bits for each of cyan, magenta, yellow and black.",
        "name": "color.CMYK",
        "params": [],
        "path": "go/image/color/index#CMYK",
        "syntax": "type CMYK struct { C, M, Y, K uint8 }",
        "type": "image"
    },
    "color.CMYK.RGBA": {
        "descr": "",
        "name": "color.CMYK.RGBA",
        "params": [],
        "path": "go/image/color/index#CMYK.RGBA",
        "syntax": "func (c CMYK) RGBA() (uint32, uint32, uint32, uint32)",
        "type": "image"
    },
    "color.CMYKToRGB": {
        "descr": "CMYKToRGB converts a CMYK quadruple to an RGB triple.",
        "name": "color.CMYKToRGB",
        "params": [],
        "path": "go/image/color/index#CMYKToRGB",
        "syntax": "func CMYKToRGB(c, m, y, k uint8) (uint8, uint8, uint8)",
        "type": "image"
    },
    "color.Color": {
        "descr": "Color can convert itself to alpha-premultiplied 16-bits per channel RGBA. The conversion may be lossy.",
        "name": "color.Color",
        "params": [],
        "path": "go/image/color/index#Color",
        "syntax": "type Color interface { // RGBA returns the alpha-premultiplied red, green, blue and alpha values // for the color. Each value ranges within [0, 0xffff], but is represented // by a uint32 so that multiplying by a blend factor up to 0xffff will not // overflow. // // An alpha-premultiplied color component c has been scaled by alpha (a), // so has valid values 0 <= c <= a. RGBA() (r, g, b, a uint32) }",
        "type": "image"
    },
    "color.Gray": {
        "descr": "Gray represents an 8-bit grayscale color.",
        "name": "color.Gray",
        "params": [],
        "path": "go/image/color/index#Gray",
        "syntax": "type Gray struct { Y uint8 }",
        "type": "image"
    },
    "color.Gray.RGBA": {
        "descr": "",
        "name": "color.Gray.RGBA",
        "params": [],
        "path": "go/image/color/index#Gray.RGBA",
        "syntax": "func (c Gray) RGBA() (r, g, b, a uint32)",
        "type": "image"
    },
    "color.Gray16": {
        "descr": "Gray16 represents a 16-bit grayscale color.",
        "name": "color.Gray16",
        "params": [],
        "path": "go/image/color/index#Gray16",
        "syntax": "type Gray16 struct { Y uint16 }",
        "type": "image"
    },
    "color.Gray16.RGBA": {
        "descr": "",
        "name": "color.Gray16.RGBA",
        "params": [],
        "path": "go/image/color/index#Gray16.RGBA",
        "syntax": "func (c Gray16) RGBA() (r, g, b, a uint32)",
        "type": "image"
    },
    "color.Model": {
        "descr": "Model can convert any Color to one from its own color model. The conversion may be lossy.",
        "name": "color.Model",
        "params": [],
        "path": "go/image/color/index#Model",
        "syntax": "type Model interface { Convert(c Color) Color }",
        "type": "image"
    },
    "color.ModelFunc": {
        "descr": "ModelFunc returns a Model that invokes f to implement the conversion.",
        "name": "color.ModelFunc",
        "params": [],
        "path": "go/image/color/index#ModelFunc",
        "syntax": "func ModelFunc(f func(Color) Color) Model",
        "type": "image"
    },
    "color.NRGBA": {
        "descr": "NRGBA represents a non-alpha-premultiplied 32-bit color.",
        "name": "color.NRGBA",
        "params": [],
        "path": "go/image/color/index#NRGBA",
        "syntax": "type NRGBA struct { R, G, B, A uint8 }",
        "type": "image"
    },
    "color.NRGBA.RGBA": {
        "descr": "",
        "name": "color.NRGBA.RGBA",
        "params": [],
        "path": "go/image/color/index#NRGBA.RGBA",
        "syntax": "func (c NRGBA) RGBA() (r, g, b, a uint32)",
        "type": "image"
    },
    "color.NRGBA64": {
        "descr": "NRGBA64 represents a non-alpha-premultiplied 64-bit color, having 16 bits for each of red, green, blue and alpha.",
        "name": "color.NRGBA64",
        "params": [],
        "path": "go/image/color/index#NRGBA64",
        "syntax": "type NRGBA64 struct { R, G, B, A uint16 }",
        "type": "image"
    },
    "color.NRGBA64.RGBA": {
        "descr": "",
        "name": "color.NRGBA64.RGBA",
        "params": [],
        "path": "go/image/color/index#NRGBA64.RGBA",
        "syntax": "func (c NRGBA64) RGBA() (r, g, b, a uint32)",
        "type": "image"
    },
    "color.NYCbCrA": {
        "descr": "NYCbCrA represents a non-alpha-premultiplied Y'CbCr-with-alpha color, having 8 bits each for one luma, two chroma and one alpha component.",
        "name": "color.NYCbCrA",
        "params": [],
        "path": "go/image/color/index#NYCbCrA",
        "syntax": "type NYCbCrA struct { YCbCr A uint8 }",
        "type": "image"
    },
    "color.NYCbCrA.RGBA": {
        "descr": "",
        "name": "color.NYCbCrA.RGBA",
        "params": [],
        "path": "go/image/color/index#NYCbCrA.RGBA",
        "syntax": "func (c NYCbCrA) RGBA() (uint32, uint32, uint32, uint32)",
        "type": "image"
    },
    "color.Palette": {
        "descr": "Palette is a palette of colors.",
        "name": "color.Palette",
        "params": [],
        "path": "go/image/color/index#Palette",
        "syntax": "type Palette []Color",
        "type": "image"
    },
    "color.Palette.Convert": {
        "descr": "Convert returns the palette color closest to c in Euclidean R,G,B space.",
        "name": "color.Palette.Convert",
        "params": [],
        "path": "go/image/color/index#Palette.Convert",
        "syntax": "func (p Palette) Convert(c Color) Color",
        "type": "image"
    },
    "color.Palette.Index": {
        "descr": "Index returns the index of the palette color closest to c in Euclidean R,G,B,A space.",
        "name": "color.Palette.Index",
        "params": [],
        "path": "go/image/color/index#Palette.Index",
        "syntax": "func (p Palette) Index(c Color) int",
        "type": "image"
    },
    "color.RGBA": {
        "descr": "RGBA represents a traditional 32-bit alpha-premultiplied color, having 8 bits for each of red, green, blue and alpha.",
        "name": "color.RGBA",
        "params": [],
        "path": "go/image/color/index#RGBA",
        "syntax": "type RGBA struct { R, G, B, A uint8 }",
        "type": "image"
    },
    "color.RGBA.RGBA": {
        "descr": "",
        "name": "color.RGBA.RGBA",
        "params": [],
        "path": "go/image/color/index#RGBA.RGBA",
        "syntax": "func (c RGBA) RGBA() (r, g, b, a uint32)",
        "type": "image"
    },
    "color.RGBA64": {
        "descr": "RGBA64 represents a 64-bit alpha-premultiplied color, having 16 bits for each of red, green, blue and alpha.",
        "name": "color.RGBA64",
        "params": [],
        "path": "go/image/color/index#RGBA64",
        "syntax": "type RGBA64 struct { R, G, B, A uint16 }",
        "type": "image"
    },
    "color.RGBA64.RGBA": {
        "descr": "",
        "name": "color.RGBA64.RGBA",
        "params": [],
        "path": "go/image/color/index#RGBA64.RGBA",
        "syntax": "func (c RGBA64) RGBA() (r, g, b, a uint32)",
        "type": "image"
    },
    "color.RGBToCMYK": {
        "descr": "RGBToCMYK converts an RGB triple to a CMYK quadruple.",
        "name": "color.RGBToCMYK",
        "params": [],
        "path": "go/image/color/index#RGBToCMYK",
        "syntax": "func RGBToCMYK(r, g, b uint8) (uint8, uint8, uint8, uint8)",
        "type": "image"
    },
    "color.RGBToYCbCr": {
        "descr": "RGBToYCbCr converts an RGB triple to a Y'CbCr triple.",
        "name": "color.RGBToYCbCr",
        "params": [],
        "path": "go/image/color/index#RGBToYCbCr",
        "syntax": "func RGBToYCbCr(r, g, b uint8) (uint8, uint8, uint8)",
        "type": "image"
    },
    "color.YCbCr": {
        "descr": "YCbCr represents a fully opaque 24-bit Y'CbCr color, having 8 bits each for one luma and two chroma components.",
        "name": "color.YCbCr",
        "params": [],
        "path": "go/image/color/index#YCbCr",
        "syntax": "type YCbCr struct { Y, Cb, Cr uint8 }",
        "type": "image"
    },
    "color.YCbCr.RGBA": {
        "descr": "",
        "name": "color.YCbCr.RGBA",
        "params": [],
        "path": "go/image/color/index#YCbCr.RGBA",
        "syntax": "func (c YCbCr) RGBA() (uint32, uint32, uint32, uint32)",
        "type": "image"
    },
    "color.YCbCrToRGB": {
        "descr": "YCbCrToRGB converts a Y'CbCr triple to an RGB triple.",
        "name": "color.YCbCrToRGB",
        "params": [],
        "path": "go/image/color/index#YCbCrToRGB",
        "syntax": "func YCbCrToRGB(y, cb, cr uint8) (uint8, uint8, uint8)",
        "type": "image"
    },
    "complex": {
        "descr": "The complex built-in function constructs a complex value from two floating-point values. The real and imaginary parts must be of the same size, either float32 or float64 (or assignable to them), and the return value will be the corresponding complex type (complex64 for float32, complex128 for float64).",
        "name": "builtin.complex",
        "params": [],
        "path": "go/builtin/index#complex",
        "syntax": "func complex(r, i FloatType) ComplexType",
        "type": "builtin"
    },
    "complex128": {
        "descr": "complex128 is the set of all complex numbers with float64 real and imaginary parts.",
        "name": "builtin.complex128",
        "params": [],
        "path": "go/builtin/index#complex128",
        "syntax": "type complex128 complex128",
        "type": "builtin"
    },
    "complex64": {
        "descr": "complex64 is the set of all complex numbers with float32 real and imaginary parts.",
        "name": "builtin.complex64",
        "params": [],
        "path": "go/builtin/index#complex64",
        "syntax": "type complex64 complex64",
        "type": "builtin"
    },
    "constant.BinaryOp": {
        "descr": "BinaryOp returns the result of the binary expression x op y. The operation must be defined for the operands. If one of the operands is Unknown, the result is Unknown. BinaryOp doesn't handle comparisons or shifts; use Compare or Shift instead.",
        "name": "constant.BinaryOp",
        "params": [],
        "path": "go/go/constant/index#BinaryOp",
        "syntax": "func BinaryOp(x_ Value, op token.Token, y_ Value) Value",
        "type": "go"
    },
    "constant.BitLen": {
        "descr": "BitLen returns the number of bits required to represent the absolute value x in binary representation; x must be an Int or an Unknown. If x is Unknown, the result is 0.",
        "name": "constant.BitLen",
        "params": [],
        "path": "go/go/constant/index#BitLen",
        "syntax": "func BitLen(x Value) int",
        "type": "go"
    },
    "constant.BoolVal": {
        "descr": "BoolVal returns the Go boolean value of x, which must be a Bool or an Unknown. If x is Unknown, the result is false.",
        "name": "constant.BoolVal",
        "params": [],
        "path": "go/go/constant/index#BoolVal",
        "syntax": "func BoolVal(x Value) bool",
        "type": "go"
    },
    "constant.Bytes": {
        "descr": "Bytes returns the bytes for the absolute value of x in little- endian binary representation; x must be an Int.",
        "name": "constant.Bytes",
        "params": [],
        "path": "go/go/constant/index#Bytes",
        "syntax": "func Bytes(x Value) []byte",
        "type": "go"
    },
    "constant.Compare": {
        "descr": "Compare returns the result of the comparison x op y. The comparison must be defined for the operands. If one of the operands is Unknown, the result is false.",
        "name": "constant.Compare",
        "params": [],
        "path": "go/go/constant/index#Compare",
        "syntax": "func Compare(x_ Value, op token.Token, y_ Value) bool",
        "type": "go"
    },
    "constant.Denom": {
        "descr": "Denom returns the denominator of x; x must be Int, Float, or Unknown. If x is Unknown, or if it is too large or small to represent as a fraction, the result is Unknown. Otherwise the result is an Int >= 1.",
        "name": "constant.Denom",
        "params": [],
        "path": "go/go/constant/index#Denom",
        "syntax": "func Denom(x Value) Value",
        "type": "go"
    },
    "constant.Float32Val": {
        "descr": "Float32Val is like Float64Val but for float32 instead of float64.",
        "name": "constant.Float32Val",
        "params": [],
        "path": "go/go/constant/index#Float32Val",
        "syntax": "func Float32Val(x Value) (float32, bool)",
        "type": "go"
    },
    "constant.Float64Val": {
        "descr": "Float64Val returns the nearest Go float64 value of x and whether the result is exact; x must be numeric or an Unknown, but not Complex. For values too small (too close to 0) to represent as float64, Float64Val silently underflows to 0. The result sign always matches the sign of x, even for 0. If x is Unknown, the result is (0, false).",
        "name": "constant.Float64Val",
        "params": [],
        "path": "go/go/constant/index#Float64Val",
        "syntax": "func Float64Val(x Value) (float64, bool)",
        "type": "go"
    },
    "constant.Imag": {
        "descr": "Imag returns the imaginary part of x, which must be a numeric or unknown value. If x is Unknown, the result is Unknown.",
        "name": "constant.Imag",
        "params": [],
        "path": "go/go/constant/index#Imag",
        "syntax": "func Imag(x Value) Value",
        "type": "go"
    },
    "constant.Int64Val": {
        "descr": "Int64Val returns the Go int64 value of x and whether the result is exact; x must be an Int or an Unknown. If the result is not exact, its value is undefined. If x is Unknown, the result is (0, false).",
        "name": "constant.Int64Val",
        "params": [],
        "path": "go/go/constant/index#Int64Val",
        "syntax": "func Int64Val(x Value) (int64, bool)",
        "type": "go"
    },
    "constant.Kind": {
        "descr": "Kind specifies the kind of value represented by a Value.",
        "name": "constant.Kind",
        "params": [],
        "path": "go/go/constant/index#Kind",
        "syntax": "type Kind int",
        "type": "go"
    },
    "constant.MakeBool": {
        "descr": "MakeBool returns the Bool value for b.",
        "name": "constant.MakeBool",
        "params": [],
        "path": "go/go/constant/index#MakeBool",
        "syntax": "func MakeBool(b bool) Value",
        "type": "go"
    },
    "constant.MakeFloat64": {
        "descr": "MakeFloat64 returns the Float value for x. If x is not finite, the result is an Unknown.",
        "name": "constant.MakeFloat64",
        "params": [],
        "path": "go/go/constant/index#MakeFloat64",
        "syntax": "func MakeFloat64(x float64) Value",
        "type": "go"
    },
    "constant.MakeFromBytes": {
        "descr": "MakeFromBytes returns the Int value given the bytes of its little-endian binary representation. An empty byte slice argument represents 0.",
        "name": "constant.MakeFromBytes",
        "params": [],
        "path": "go/go/constant/index#MakeFromBytes",
        "syntax": "func MakeFromBytes(bytes []byte) Value",
        "type": "go"
    },
    "constant.MakeFromLiteral": {
        "descr": "MakeFromLiteral returns the corresponding integer, floating-point, imaginary, character, or string value for a Go literal string. The tok value must be one of token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING. The final argument must be zero. If the literal string syntax is invalid, the result is an Unknown.",
        "name": "constant.MakeFromLiteral",
        "params": [],
        "path": "go/go/constant/index#MakeFromLiteral",
        "syntax": "func MakeFromLiteral(lit string, tok token.Token, zero uint) Value",
        "type": "go"
    },
    "constant.MakeImag": {
        "descr": "MakeImag returns the Complex value x*i; x must be Int, Float, or Unknown. If x is Unknown, the result is Unknown.",
        "name": "constant.MakeImag",
        "params": [],
        "path": "go/go/constant/index#MakeImag",
        "syntax": "func MakeImag(x Value) Value",
        "type": "go"
    },
    "constant.MakeInt64": {
        "descr": "MakeInt64 returns the Int value for x.",
        "name": "constant.MakeInt64",
        "params": [],
        "path": "go/go/constant/index#MakeInt64",
        "syntax": "func MakeInt64(x int64) Value",
        "type": "go"
    },
    "constant.MakeString": {
        "descr": "MakeString returns the String value for s.",
        "name": "constant.MakeString",
        "params": [],
        "path": "go/go/constant/index#MakeString",
        "syntax": "func MakeString(s string) Value",
        "type": "go"
    },
    "constant.MakeUint64": {
        "descr": "MakeUint64 returns the Int value for x.",
        "name": "constant.MakeUint64",
        "params": [],
        "path": "go/go/constant/index#MakeUint64",
        "syntax": "func MakeUint64(x uint64) Value",
        "type": "go"
    },
    "constant.MakeUnknown": {
        "descr": "MakeUnknown returns the Unknown value.",
        "name": "constant.MakeUnknown",
        "params": [],
        "path": "go/go/constant/index#MakeUnknown",
        "syntax": "func MakeUnknown() Value",
        "type": "go"
    },
    "constant.Num": {
        "descr": "Num returns the numerator of x; x must be Int, Float, or Unknown. If x is Unknown, or if it is too large or small to represent as a fraction, the result is Unknown. Otherwise the result is an Int with the same sign as x.",
        "name": "constant.Num",
        "params": [],
        "path": "go/go/constant/index#Num",
        "syntax": "func Num(x Value) Value",
        "type": "go"
    },
    "constant.Real": {
        "descr": "Real returns the real part of x, which must be a numeric or unknown value. If x is Unknown, the result is Unknown.",
        "name": "constant.Real",
        "params": [],
        "path": "go/go/constant/index#Real",
        "syntax": "func Real(x Value) Value",
        "type": "go"
    },
    "constant.Shift": {
        "descr": "Shift returns the result of the shift expression x op s with op == token.SHL or token.SHR (<< or >>). x must be an Int or an Unknown. If x is Unknown, the result is x.",
        "name": "constant.Shift",
        "params": [],
        "path": "go/go/constant/index#Shift",
        "syntax": "func Shift(x Value, op token.Token, s uint) Value",
        "type": "go"
    },
    "constant.Sign": {
        "descr": "Sign returns -1, 0, or 1 depending on whether x < 0, x == 0, or x > 0; x must be numeric or Unknown. For complex values x, the sign is 0 if x == 0, otherwise it is != 0. If x is Unknown, the result is 1.",
        "name": "constant.Sign",
        "params": [],
        "path": "go/go/constant/index#Sign",
        "syntax": "func Sign(x Value) int",
        "type": "go"
    },
    "constant.StringVal": {
        "descr": "StringVal returns the Go string value of x, which must be a String or an Unknown. If x is Unknown, the result is \"\".",
        "name": "constant.StringVal",
        "params": [],
        "path": "go/go/constant/index#StringVal",
        "syntax": "func StringVal(x Value) string",
        "type": "go"
    },
    "constant.ToComplex": {
        "descr": "ToComplex converts x to a Complex value if x is representable as a Complex. Otherwise it returns an Unknown.",
        "name": "constant.ToComplex",
        "params": [],
        "path": "go/go/constant/index#ToComplex",
        "syntax": "func ToComplex(x Value) Value",
        "type": "go"
    },
    "constant.ToFloat": {
        "descr": "ToFloat converts x to a Float value if x is representable as a Float. Otherwise it returns an Unknown.",
        "name": "constant.ToFloat",
        "params": [],
        "path": "go/go/constant/index#ToFloat",
        "syntax": "func ToFloat(x Value) Value",
        "type": "go"
    },
    "constant.ToInt": {
        "descr": "ToInt converts x to an Int value if x is representable as an Int. Otherwise it returns an Unknown.",
        "name": "constant.ToInt",
        "params": [],
        "path": "go/go/constant/index#ToInt",
        "syntax": "func ToInt(x Value) Value",
        "type": "go"
    },
    "constant.Uint64Val": {
        "descr": "Uint64Val returns the Go uint64 value of x and whether the result is exact; x must be an Int or an Unknown. If the result is not exact, its value is undefined. If x is Unknown, the result is (0, false).",
        "name": "constant.Uint64Val",
        "params": [],
        "path": "go/go/constant/index#Uint64Val",
        "syntax": "func Uint64Val(x Value) (uint64, bool)",
        "type": "go"
    },
    "constant.UnaryOp": {
        "descr": "UnaryOp returns the result of the unary expression op y. The operation must be defined for the operand. If prec > 0 it specifies the ^ (xor) result size in bits. If y is Unknown, the result is Unknown.",
        "name": "constant.UnaryOp",
        "params": [],
        "path": "go/go/constant/index#UnaryOp",
        "syntax": "func UnaryOp(op token.Token, y Value, prec uint) Value",
        "type": "go"
    },
    "constant.Value": {
        "descr": "A Value represents the value of a Go constant.",
        "name": "constant.Value",
        "params": [],
        "path": "go/go/constant/index#Value",
        "syntax": "type Value interface { // Kind returns the value kind. Kind() Kind // String returns a short, quoted (human-readable) form of the value. // For numeric values, the result may be an approximation; // for String values the result may be a shortened string. // Use ExactString for a string representing a value exactly. String() string // ExactString returns an exact, quoted (human-readable) form of the value. // If the Value is of Kind String, use StringVal to obtain the unquoted string. ExactString() string // contains filtered or unexported methods }",
        "type": "go"
    },
    "context": {
        "descr": "Canceled is the error returned by Context.Err when the context is canceled.",
        "name": "context",
        "params": [],
        "path": "go/context/index#pkg-variables",
        "syntax": "var Canceled = errors.New(\"context canceled\")",
        "type": "context"
    },
    "context.Background": {
        "descr": "Background returns a non-nil, empty Context. It is never canceled, has no values, and has no deadline. It is typically used by the main function, initialization, and tests, and as the top-level Context for incoming requests.",
        "name": "context.Background",
        "params": [],
        "path": "go/context/index#Background",
        "syntax": "func Background() Context",
        "type": "context"
    },
    "context.CancelFunc": {
        "descr": "A CancelFunc tells an operation to abandon its work. A CancelFunc does not wait for the work to stop. After the first call, subsequent calls to a CancelFunc do nothing.",
        "name": "context.CancelFunc",
        "params": [],
        "path": "go/context/index#CancelFunc",
        "syntax": "type CancelFunc func()",
        "type": "context"
    },
    "context.Context": {
        "descr": "A Context carries a deadline, a cancelation signal, and other values across API boundaries.",
        "name": "context.Context",
        "params": [],
        "path": "go/context/index#Context",
        "syntax": "type Context interface { // Deadline returns the time when work done on behalf of this context // should be canceled. Deadline returns ok==false when no deadline is // set. Successive calls to Deadline return the same results. Deadline() (deadline time.Time, ok bool) // Done returns a channel that's closed when work done on behalf of this // context should be canceled. Done may return nil if this context can // never be canceled. Successive calls to Done return the same value. // // WithCancel arranges for Done to be closed when cancel is called; // WithDeadline arranges for Done to be closed when the deadline // expires; WithTimeout arranges for Done to be closed when the timeout // elapses. // // Done is provided for use in select statements: // // // Stream generates values with DoSomething and sends them to out // // until DoSomething returns an error or ctx.Done is closed. // func Stream(ctx context.Context, out chan<- Value) error { // for { // v, err := DoSomething(ctx) // if err != nil { // return err // } // select { // case <-ctx.Done(): // return ctx.Err() // case out <- v: // } // } // } // // See https://blog.golang.org/pipelines for more examples of how to use // a Done channel for cancelation. Done() <-chan struct{} // If Done is not yet closed, Err returns nil. // If Done is closed, Err returns a non-nil error explaining why: // Canceled if the context was canceled // or DeadlineExceeded if the context's deadline passed. // After Err returns a non-nil error, successive calls to Err return the same error. Err() error // Value returns the value associated with this context for key, or nil // if no value is associated with key. Successive calls to Value with // the same key returns the same result. // // Use context values only for request-scoped data that transits // processes and API boundaries, not for passing optional parameters to // functions. // // A key identifies a specific value in a Context. Functions that wish // to store values in Context typically allocate a key in a global // variable then use that key as the argument to context.WithValue and // Context.Value. A key can be any type that supports equality; // packages should define keys as an unexported type to avoid // collisions. // // Packages that define a Context key should provide type-safe accessors // for the values stored using that key: // // // Package user defines a User type that's stored in Contexts. // package user // // import \"context\" // // // User is the type of value stored in the Contexts. // type User struct {...} // // // key is an unexported type for keys defined in this package. // // This prevents collisions with keys defined in other packages. // type key int // // // userKey is the key for user.User values in Contexts. It is // // unexported; clients use user.NewContext and user.FromContext // // instead of using this key directly. // var userKey key // // // NewContext returns a new Context that carries value u. // func NewContext(ctx context.Context, u *User) context.Context { // return context.WithValue(ctx, userKey, u) // } // // // FromContext returns the User value stored in ctx, if any. // func FromContext(ctx context.Context) (*User, bool) { // u, ok := ctx.Value(userKey).(*User) // return u, ok // } Value(key interface{}) interface{} }",
        "type": "context"
    },
    "context.TODO": {
        "descr": "TODO returns a non-nil, empty Context. Code should use context.TODO when it's unclear which Context to use or it is not yet available (because the surrounding function has not yet been extended to accept a Context parameter). TODO is recognized by static analysis tools that determine whether Contexts are propagated correctly in a program.",
        "name": "context.TODO",
        "params": [],
        "path": "go/context/index#TODO",
        "syntax": "func TODO() Context",
        "type": "context"
    },
    "context.WithCancel": {
        "descr": "WithCancel returns a copy of parent with a new Done channel. The returned context's Done channel is closed when the returned cancel function is called or when the parent context's Done channel is closed, whichever happens first.",
        "name": "context.WithCancel",
        "params": [],
        "path": "go/context/index#WithCancel",
        "syntax": "func WithCancel(parent Context) (ctx Context, cancel CancelFunc)",
        "type": "context"
    },
    "context.WithDeadline": {
        "descr": "WithDeadline returns a copy of the parent context with the deadline adjusted to be no later than d. If the parent's deadline is already earlier than d, WithDeadline(parent, d) is semantically equivalent to parent. The returned context's Done channel is closed when the deadline expires, when the returned cancel function is called, or when the parent context's Done channel is closed, whichever happens first.",
        "name": "context.WithDeadline",
        "params": [],
        "path": "go/context/index#WithDeadline",
        "syntax": "func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)",
        "type": "context"
    },
    "context.WithTimeout": {
        "descr": "WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).",
        "name": "context.WithTimeout",
        "params": [],
        "path": "go/context/index#WithTimeout",
        "syntax": "func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)",
        "type": "context"
    },
    "context.WithValue": {
        "descr": "WithValue returns a copy of parent in which the value associated with key is val.",
        "name": "context.WithValue",
        "params": [],
        "path": "go/context/index#WithValue",
        "syntax": "func WithValue(parent Context, key, val interface{}) Context",
        "type": "context"
    },
    "cookiejar.Jar": {
        "descr": "Jar implements the http.CookieJar interface from the net/http package.",
        "name": "cookiejar.Jar",
        "params": [],
        "path": "go/net/http/cookiejar/index#Jar",
        "syntax": "type Jar struct { // contains filtered or unexported fields }",
        "type": "net/http"
    },
    "cookiejar.Jar.Cookies": {
        "descr": "Cookies implements the Cookies method of the http.CookieJar interface.",
        "name": "cookiejar.Jar.Cookies",
        "params": [],
        "path": "go/net/http/cookiejar/index#Jar.Cookies",
        "syntax": "func (j *Jar) Cookies(u *url.URL) (cookies []*http.Cookie)",
        "type": "net/http"
    },
    "cookiejar.Jar.SetCookies": {
        "descr": "SetCookies implements the SetCookies method of the http.CookieJar interface.",
        "name": "cookiejar.Jar.SetCookies",
        "params": [],
        "path": "go/net/http/cookiejar/index#Jar.SetCookies",
        "syntax": "func (j *Jar) SetCookies(u *url.URL, cookies []*http.Cookie)",
        "type": "net/http"
    },
    "cookiejar.New": {
        "descr": "New returns a new cookie jar. A nil *Options is equivalent to a zero Options.",
        "name": "cookiejar.New",
        "params": [],
        "path": "go/net/http/cookiejar/index#New",
        "syntax": "func New(o *Options) (*Jar, error)",
        "type": "net/http"
    },
    "cookiejar.Options": {
        "descr": "Options are the options for creating a new Jar.",
        "name": "cookiejar.Options",
        "params": [],
        "path": "go/net/http/cookiejar/index#Options",
        "syntax": "type Options struct { // PublicSuffixList is the public suffix list that determines whether // an HTTP server can set a cookie for a domain. // // A nil value is valid and may be useful for testing but it is not // secure: it means that the HTTP server for foo.co.uk can set a cookie // for bar.co.uk. PublicSuffixList PublicSuffixList }",
        "type": "net/http"
    },
    "cookiejar.PublicSuffixList": {
        "descr": "PublicSuffixList provides the public suffix of a domain. For example:",
        "name": "cookiejar.PublicSuffixList",
        "params": [],
        "path": "go/net/http/cookiejar/index#PublicSuffixList",
        "syntax": "- the public suffix of \"example.com\" is \"com\", - the public suffix of \"foo1.foo2.foo3.co.uk\" is \"co.uk\", and - the public suffix of \"bar.pvt.k12.ma.us\" is \"pvt.k12.ma.us\".",
        "type": "net/http"
    },
    "copy": {
        "descr": "The copy built-in function copies elements from a source slice into a destination slice. (As a special case, it also will copy bytes from a string to a slice of bytes.) The source and destination may overlap. Copy returns the number of elements copied, which will be the minimum of len(src) and len(dst).",
        "name": "builtin.copy",
        "params": [],
        "path": "go/builtin/index#copy",
        "syntax": "func copy(dst, src []Type) int",
        "type": "builtin"
    },
    "crc32.Checksum": {
        "descr": "Checksum returns the CRC-32 checksum of data using the polynomial represented by the Table.",
        "name": "crc32.Checksum",
        "params": [],
        "path": "go/hash/crc32/index#Checksum",
        "syntax": "func Checksum(data []byte, tab *Table) uint32",
        "type": "hash"
    },
    "crc32.ChecksumIEEE": {
        "descr": "ChecksumIEEE returns the CRC-32 checksum of data using the IEEE polynomial.",
        "name": "crc32.ChecksumIEEE",
        "params": [],
        "path": "go/hash/crc32/index#ChecksumIEEE",
        "syntax": "func ChecksumIEEE(data []byte) uint32",
        "type": "hash"
    },
    "crc32.MakeTable": {
        "descr": "MakeTable returns a Table constructed from the specified polynomial. The contents of this Table must not be modified.",
        "name": "crc32.MakeTable",
        "params": [],
        "path": "go/hash/crc32/index#MakeTable",
        "syntax": "func MakeTable(poly uint32) *Table",
        "type": "hash"
    },
    "crc32.New": {
        "descr": "New creates a new hash.Hash32 computing the CRC-32 checksum using the polynomial represented by the Table. Its Sum method will lay the value out in big-endian byte order. The returned Hash32 also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.",
        "name": "crc32.New",
        "params": [],
        "path": "go/hash/crc32/index#New",
        "syntax": "func New(tab *Table) hash.Hash32",
        "type": "hash"
    },
    "crc32.NewIEEE": {
        "descr": "NewIEEE creates a new hash.Hash32 computing the CRC-32 checksum using the IEEE polynomial. Its Sum method will lay the value out in big-endian byte order. The returned Hash32 also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.",
        "name": "crc32.NewIEEE",
        "params": [],
        "path": "go/hash/crc32/index#NewIEEE",
        "syntax": "func NewIEEE() hash.Hash32",
        "type": "hash"
    },
    "crc32.Table": {
        "descr": "Table is a 256-word table representing the polynomial for efficient processing.",
        "name": "crc32.Table",
        "params": [],
        "path": "go/hash/crc32/index#Table",
        "syntax": "type Table [256]uint32",
        "type": "hash"
    },
    "crc32.Update": {
        "descr": "Update returns the result of adding the bytes in p to the crc.",
        "name": "crc32.Update",
        "params": [],
        "path": "go/hash/crc32/index#Update",
        "syntax": "func Update(crc uint32, tab *Table, p []byte) uint32",
        "type": "hash"
    },
    "crc64.Checksum": {
        "descr": "Checksum returns the CRC-64 checksum of data using the polynomial represented by the Table.",
        "name": "crc64.Checksum",
        "params": [],
        "path": "go/hash/crc64/index#Checksum",
        "syntax": "func Checksum(data []byte, tab *Table) uint64",
        "type": "hash"
    },
    "crc64.MakeTable": {
        "descr": "MakeTable returns a Table constructed from the specified polynomial. The contents of this Table must not be modified.",
        "name": "crc64.MakeTable",
        "params": [],
        "path": "go/hash/crc64/index#MakeTable",
        "syntax": "func MakeTable(poly uint64) *Table",
        "type": "hash"
    },
    "crc64.New": {
        "descr": "New creates a new hash.Hash64 computing the CRC-64 checksum using the polynomial represented by the Table. Its Sum method will lay the value out in big-endian byte order. The returned Hash64 also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.",
        "name": "crc64.New",
        "params": [],
        "path": "go/hash/crc64/index#New",
        "syntax": "func New(tab *Table) hash.Hash64",
        "type": "hash"
    },
    "crc64.Table": {
        "descr": "Table is a 256-word table representing the polynomial for efficient processing.",
        "name": "crc64.Table",
        "params": [],
        "path": "go/hash/crc64/index#Table",
        "syntax": "type Table [256]uint64",
        "type": "hash"
    },
    "crc64.Update": {
        "descr": "Update returns the result of adding the bytes in p to the crc.",
        "name": "crc64.Update",
        "params": [],
        "path": "go/hash/crc64/index#Update",
        "syntax": "func Update(crc uint64, tab *Table, p []byte) uint64",
        "type": "hash"
    },
    "crypto.Decrypter": {
        "descr": "Decrypter is an interface for an opaque private key that can be used for asymmetric decryption operations. An example would be an RSA key kept in a hardware module.",
        "name": "crypto.Decrypter",
        "params": [],
        "path": "go/crypto/index#Decrypter",
        "syntax": "type Decrypter interface { // Public returns the public key corresponding to the opaque, // private key. Public() PublicKey // Decrypt decrypts msg. The opts argument should be appropriate for // the primitive used. See the documentation in each implementation for // details. Decrypt(rand io.Reader, msg []byte, opts DecrypterOpts) (plaintext []byte, err error) }",
        "type": "crypto"
    },
    "crypto.DecrypterOpts": {
        "descr": "",
        "name": "crypto.DecrypterOpts",
        "params": [],
        "path": "go/crypto/index#DecrypterOpts",
        "syntax": "type DecrypterOpts interface{}",
        "type": "crypto"
    },
    "crypto.Hash": {
        "descr": "Hash identifies a cryptographic hash function that is implemented in another package.",
        "name": "crypto.Hash",
        "params": [],
        "path": "go/crypto/index#Hash",
        "syntax": "type Hash uint",
        "type": "crypto"
    },
    "crypto.Hash.Available": {
        "descr": "Available reports whether the given hash function is linked into the binary.",
        "name": "crypto.Hash.Available",
        "params": [],
        "path": "go/crypto/index#Hash.Available",
        "syntax": "func (h Hash) Available() bool",
        "type": "crypto"
    },
    "crypto.Hash.HashFunc": {
        "descr": "HashFunc simply returns the value of h so that Hash implements SignerOpts.",
        "name": "crypto.Hash.HashFunc",
        "params": [],
        "path": "go/crypto/index#Hash.HashFunc",
        "syntax": "func (h Hash) HashFunc() Hash",
        "type": "crypto"
    },
    "crypto.Hash.New": {
        "descr": "New returns a new hash.Hash calculating the given hash function. New panics if the hash function is not linked into the binary.",
        "name": "crypto.Hash.New",
        "params": [],
        "path": "go/crypto/index#Hash.New",
        "syntax": "func (h Hash) New() hash.Hash",
        "type": "crypto"
    },
    "crypto.Hash.Size": {
        "descr": "Size returns the length, in bytes, of a digest resulting from the given hash function. It doesn't require that the hash function in question be linked into the program.",
        "name": "crypto.Hash.Size",
        "params": [],
        "path": "go/crypto/index#Hash.Size",
        "syntax": "func (h Hash) Size() int",
        "type": "crypto"
    },
    "crypto.PrivateKey": {
        "descr": "PrivateKey represents a private key using an unspecified algorithm.",
        "name": "crypto.PrivateKey",
        "params": [],
        "path": "go/crypto/index#PrivateKey",
        "syntax": "type PrivateKey interface{}",
        "type": "crypto"
    },
    "crypto.PublicKey": {
        "descr": "PublicKey represents a public key using an unspecified algorithm.",
        "name": "crypto.PublicKey",
        "params": [],
        "path": "go/crypto/index#PublicKey",
        "syntax": "type PublicKey interface{}",
        "type": "crypto"
    },
    "crypto.RegisterHash": {
        "descr": "RegisterHash registers a function that returns a new instance of the given hash function. This is intended to be called from the init function in packages that implement hash functions.",
        "name": "crypto.RegisterHash",
        "params": [],
        "path": "go/crypto/index#RegisterHash",
        "syntax": "func RegisterHash(h Hash, f func() hash.Hash)",
        "type": "crypto"
    },
    "crypto.Signer": {
        "descr": "Signer is an interface for an opaque private key that can be used for signing operations. For example, an RSA key kept in a hardware module.",
        "name": "crypto.Signer",
        "params": [],
        "path": "go/crypto/index#Signer",
        "syntax": "type Signer interface { // Public returns the public key corresponding to the opaque, // private key. Public() PublicKey // Sign signs digest with the private key, possibly using entropy from // rand. For an RSA key, the resulting signature should be either a // PKCS#1 v1.5 or PSS signature (as indicated by opts). For an (EC)DSA // key, it should be a DER-serialised, ASN.1 signature structure. // // Hash implements the SignerOpts interface and, in most cases, one can // simply pass in the hash function used as opts. Sign may also attempt // to type assert opts to other types in order to obtain algorithm // specific values. See the documentation in each package for details. // // Note that when a signature of a hash of a larger message is needed, // the caller is responsible for hashing the larger message and passing // the hash (as digest) and the hash function (as opts) to Sign. Sign(rand io.Reader, digest []byte, opts SignerOpts) (signature []byte, err error) }",
        "type": "crypto"
    },
    "crypto.SignerOpts": {
        "descr": "SignerOpts contains options for signing with a Signer.",
        "name": "crypto.SignerOpts",
        "params": [],
        "path": "go/crypto/index#SignerOpts",
        "syntax": "type SignerOpts interface { // HashFunc returns an identifier for the hash function used to produce // the message passed to Signer.Sign, or else zero to indicate that no // hashing was done. HashFunc() Hash }",
        "type": "crypto"
    },
    "csv.NewReader": {
        "descr": "NewReader returns a new Reader that reads from r.",
        "name": "csv.NewReader",
        "params": [],
        "path": "go/encoding/csv/index#NewReader",
        "syntax": "func NewReader(r io.Reader) *Reader",
        "type": "encoding"
    },
    "csv.NewWriter": {
        "descr": "NewWriter returns a new Writer that writes to w.",
        "name": "csv.NewWriter",
        "params": [],
        "path": "go/encoding/csv/index#NewWriter",
        "syntax": "func NewWriter(w io.Writer) *Writer",
        "type": "encoding"
    },
    "csv.ParseError": {
        "descr": "A ParseError is returned for parsing errors. Line numbers are 1-indexed and columns are 0-indexed.",
        "name": "csv.ParseError",
        "params": [],
        "path": "go/encoding/csv/index#ParseError",
        "syntax": "type ParseError struct { StartLine int // Line where the record starts; added in Go 1.10 Line int // Line where the error occurred Column int // Column (rune index) where the error occurred Err error // The actual error }",
        "type": "encoding"
    },
    "csv.ParseError.Error": {
        "descr": "",
        "name": "csv.ParseError.Error",
        "params": [],
        "path": "go/encoding/csv/index#ParseError.Error",
        "syntax": "func (e *ParseError) Error() string",
        "type": "encoding"
    },
    "csv.Reader": {
        "descr": "A Reader reads records from a CSV-encoded file.",
        "name": "csv.Reader",
        "params": [],
        "path": "go/encoding/csv/index#Reader",
        "syntax": "type Reader struct { // Comma is the field delimiter. // It is set to comma (',') by NewReader. // Comma must be a valid rune and must not be \\r, \\n, // or the Unicode replacement character (0xFFFD). Comma rune // Comment, if not 0, is the comment character. Lines beginning with the // Comment character without preceding whitespace are ignored. // With leading whitespace the Comment character becomes part of the // field, even if TrimLeadingSpace is true. // Comment must be a valid rune and must not be \\r, \\n, // or the Unicode replacement character (0xFFFD). // It must also not be equal to Comma. Comment rune // FieldsPerRecord is the number of expected fields per record. // If FieldsPerRecord is positive, Read requires each record to // have the given number of fields. If FieldsPerRecord is 0, Read sets it to // the number of fields in the first record, so that future records must // have the same field count. If FieldsPerRecord is negative, no check is // made and records may have a variable number of fields. FieldsPerRecord int // If LazyQuotes is true, a quote may appear in an unquoted field and a // non-doubled quote may appear in a quoted field. LazyQuotes bool // If TrimLeadingSpace is true, leading white space in a field is ignored. // This is done even if the field delimiter, Comma, is white space. TrimLeadingSpace bool // ReuseRecord controls whether calls to Read may return a slice sharing // the backing array of the previous call's returned slice for performance. // By default, each call to Read returns newly allocated memory owned by the caller. ReuseRecord bool // Go 1.9 TrailingComma bool // Deprecated: No longer used. // contains filtered or unexported fields }",
        "type": "encoding"
    },
    "csv.Reader.Read": {
        "descr": "Read reads one record (a slice of fields) from r. If the record has an unexpected number of fields, Read returns the record along with the error ErrFieldCount. Except for that case, Read always returns either a non-nil record or a non-nil error, but not both. If there is no data left to be read, Read returns nil, io.EOF. If ReuseRecord is true, the returned slice may be shared between multiple calls to Read.",
        "name": "csv.Reader.Read",
        "params": [],
        "path": "go/encoding/csv/index#Reader.Read",
        "syntax": "func (r *Reader) Read() (record []string, err error)",
        "type": "encoding"
    },
    "csv.Reader.ReadAll": {
        "descr": "ReadAll reads all the remaining records from r. Each record is a slice of fields. A successful call returns err == nil, not err == io.EOF. Because ReadAll is defined to read until EOF, it does not treat end of file as an error to be reported.",
        "name": "csv.Reader.ReadAll",
        "params": [],
        "path": "go/encoding/csv/index#Reader.ReadAll",
        "syntax": "func (r *Reader) ReadAll() (records [][]string, err error)",
        "type": "encoding"
    },
    "csv.Writer": {
        "descr": "A Writer writes records to a CSV encoded file.",
        "name": "csv.Writer",
        "params": [],
        "path": "go/encoding/csv/index#Writer",
        "syntax": "type Writer struct { Comma rune // Field delimiter (set to ',' by NewWriter) UseCRLF bool // True to use \\r\\n as the line terminator // contains filtered or unexported fields }",
        "type": "encoding"
    },
    "csv.Writer.Error": {
        "descr": "Error reports any error that has occurred during a previous Write or Flush.",
        "name": "csv.Writer.Error",
        "params": [],
        "path": "go/encoding/csv/index#Writer.Error",
        "syntax": "func (w *Writer) Error() error",
        "type": "encoding"
    },
    "csv.Writer.Flush": {
        "descr": "Flush writes any buffered data to the underlying io.Writer. To check if an error occurred during the Flush, call Error.",
        "name": "csv.Writer.Flush",
        "params": [],
        "path": "go/encoding/csv/index#Writer.Flush",
        "syntax": "func (w *Writer) Flush()",
        "type": "encoding"
    },
    "csv.Writer.Write": {
        "descr": "Writer writes a single CSV record to w along with any necessary quoting. A record is a slice of strings with each string being one field.",
        "name": "csv.Writer.Write",
        "params": [],
        "path": "go/encoding/csv/index#Writer.Write",
        "syntax": "func (w *Writer) Write(record []string) error",
        "type": "encoding"
    },
    "csv.Writer.WriteAll": {
        "descr": "WriteAll writes multiple CSV records to w using Write and then calls Flush.",
        "name": "csv.Writer.WriteAll",
        "params": [],
        "path": "go/encoding/csv/index#Writer.WriteAll",
        "syntax": "func (w *Writer) WriteAll(records [][]string) error",
        "type": "encoding"
    },
    "debug.FreeOSMemory": {
        "descr": "FreeOSMemory forces a garbage collection followed by an attempt to return as much memory to the operating system as possible. (Even if this is not called, the runtime gradually returns memory to the operating system in a background task.)",
        "name": "debug.FreeOSMemory",
        "params": [],
        "path": "go/runtime/debug/index#FreeOSMemory",
        "syntax": "func FreeOSMemory()",
        "type": "runtime"
    },
    "debug.GCStats": {
        "descr": "GCStats collect information about recent garbage collections.",
        "name": "debug.GCStats",
        "params": [],
        "path": "go/runtime/debug/index#GCStats",
        "syntax": "type GCStats struct { LastGC time.Time // time of last collection NumGC int64 // number of garbage collections PauseTotal time.Duration // total pause for all collections Pause []time.Duration // pause history, most recent first PauseEnd []time.Time // pause end times history, most recent first; added in Go 1.4 PauseQuantiles []time.Duration }",
        "type": "runtime"
    },
    "debug.PrintStack": {
        "descr": "PrintStack prints to standard error the stack trace returned by runtime.Stack.",
        "name": "debug.PrintStack",
        "params": [],
        "path": "go/runtime/debug/index#PrintStack",
        "syntax": "func PrintStack()",
        "type": "runtime"
    },
    "debug.ReadGCStats": {
        "descr": "ReadGCStats reads statistics about garbage collection into stats. The number of entries in the pause history is system-dependent; stats.Pause slice will be reused if large enough, reallocated otherwise. ReadGCStats may use the full capacity of the stats.Pause slice. If stats.PauseQuantiles is non-empty, ReadGCStats fills it with quantiles summarizing the distribution of pause time. For example, if len(stats.PauseQuantiles) is 5, it will be filled with the minimum, 25%, 50%, 75%, and maximum pause times.",
        "name": "debug.ReadGCStats",
        "params": [],
        "path": "go/runtime/debug/index#ReadGCStats",
        "syntax": "func ReadGCStats(stats *GCStats)",
        "type": "runtime"
    },
    "debug.SetGCPercent": {
        "descr": "SetGCPercent sets the garbage collection target percentage: a collection is triggered when the ratio of freshly allocated data to live data remaining after the previous collection reaches this percentage. SetGCPercent returns the previous setting. The initial setting is the value of the GOGC environment variable at startup, or 100 if the variable is not set. A negative percentage disables garbage collection.",
        "name": "debug.SetGCPercent",
        "params": [],
        "path": "go/runtime/debug/index#SetGCPercent",
        "syntax": "func SetGCPercent(percent int) int",
        "type": "runtime"
    },
    "debug.SetMaxStack": {
        "descr": "SetMaxStack sets the maximum amount of memory that can be used by a single goroutine stack. If any goroutine exceeds this limit while growing its stack, the program crashes. SetMaxStack returns the previous setting. The initial setting is 1 GB on 64-bit systems, 250 MB on 32-bit systems.",
        "name": "debug.SetMaxStack",
        "params": [],
        "path": "go/runtime/debug/index#SetMaxStack",
        "syntax": "func SetMaxStack(bytes int) int",
        "type": "runtime"
    },
    "debug.SetMaxThreads": {
        "descr": "SetMaxThreads sets the maximum number of operating system threads that the Go program can use. If it attempts to use more than this many, the program crashes. SetMaxThreads returns the previous setting. The initial setting is 10,000 threads.",
        "name": "debug.SetMaxThreads",
        "params": [],
        "path": "go/runtime/debug/index#SetMaxThreads",
        "syntax": "func SetMaxThreads(threads int) int",
        "type": "runtime"
    },
    "debug.SetPanicOnFault": {
        "descr": "SetPanicOnFault controls the runtime's behavior when a program faults at an unexpected (non-nil) address. Such faults are typically caused by bugs such as runtime memory corruption, so the default response is to crash the program. Programs working with memory-mapped files or unsafe manipulation of memory may cause faults at non-nil addresses in less dramatic situations; SetPanicOnFault allows such programs to request that the runtime trigger only a panic, not a crash. SetPanicOnFault applies only to the current goroutine. It returns the previous setting.",
        "name": "debug.SetPanicOnFault",
        "params": [],
        "path": "go/runtime/debug/index#SetPanicOnFault",
        "syntax": "func SetPanicOnFault(enabled bool) bool",
        "type": "runtime"
    },
    "debug.SetTraceback": {
        "descr": "SetTraceback sets the amount of detail printed by the runtime in the traceback it prints before exiting due to an unrecovered panic or an internal runtime error. The level argument takes the same values as the GOTRACEBACK environment variable. For example, SetTraceback(\"all\") ensure that the program prints all goroutines when it crashes. See the package runtime documentation for details. If SetTraceback is called with a level lower than that of the environment variable, the call is ignored.",
        "name": "debug.SetTraceback",
        "params": [],
        "path": "go/runtime/debug/index#SetTraceback",
        "syntax": "func SetTraceback(level string)",
        "type": "runtime"
    },
    "debug.Stack": {
        "descr": "Stack returns a formatted stack trace of the goroutine that calls it. It calls runtime.Stack with a large enough buffer to capture the entire trace.",
        "name": "debug.Stack",
        "params": [],
        "path": "go/runtime/debug/index#Stack",
        "syntax": "func Stack() []byte",
        "type": "runtime"
    },
    "debug.WriteHeapDump": {
        "descr": "WriteHeapDump writes a description of the heap and the objects in it to the given file descriptor.",
        "name": "debug.WriteHeapDump",
        "params": [],
        "path": "go/runtime/debug/index#WriteHeapDump",
        "syntax": "func WriteHeapDump(fd uintptr)",
        "type": "runtime"
    },
    "delete": {
        "descr": "The delete built-in function deletes the element with the specified key (m[key]) from the map. If m is nil or there is no such element, delete is a no-op.",
        "name": "builtin.delete",
        "params": [],
        "path": "go/builtin/index#delete",
        "syntax": "func delete(m map[Type]Type1, key Type)",
        "type": "builtin"
    },
    "des.KeySizeError": {
        "descr": "",
        "name": "des.KeySizeError",
        "params": [],
        "path": "go/crypto/des/index#KeySizeError",
        "syntax": "type KeySizeError int",
        "type": "crypto"
    },
    "des.KeySizeError.Error": {
        "descr": "",
        "name": "des.KeySizeError.Error",
        "params": [],
        "path": "go/crypto/des/index#KeySizeError.Error",
        "syntax": "func (k KeySizeError) Error() string",
        "type": "crypto"
    },
    "des.NewCipher": {
        "descr": "NewCipher creates and returns a new cipher.Block.",
        "name": "des.NewCipher",
        "params": [],
        "path": "go/crypto/des/index#NewCipher",
        "syntax": "func NewCipher(key []byte) (cipher.Block, error)",
        "type": "crypto"
    },
    "des.NewTripleDESCipher": {
        "descr": "NewTripleDESCipher creates and returns a new cipher.Block.",
        "name": "des.NewTripleDESCipher",
        "params": [],
        "path": "go/crypto/des/index#NewTripleDESCipher",
        "syntax": "func NewTripleDESCipher(key []byte) (cipher.Block, error)",
        "type": "crypto"
    },
    "doc.Example": {
        "descr": "An Example represents an example function found in a source files.",
        "name": "doc.Example",
        "params": [],
        "path": "go/go/doc/index#Example",
        "syntax": "type Example struct { Name string // name of the item being exemplified Doc string // example function doc string Code ast.Node Play *ast.File // a whole program version of the example; added in Go 1.1 Comments []*ast.CommentGroup Output string // expected output Unordered bool // Go 1.7 EmptyOutput bool // expect empty output; added in Go 1.1 Order int // original source code order; added in Go 1.1 }",
        "type": "go"
    },
    "doc.Examples": {
        "descr": "Examples returns the examples found in the files, sorted by Name field. The Order fields record the order in which the examples were encountered.",
        "name": "doc.Examples",
        "params": [],
        "path": "go/go/doc/index#Examples",
        "syntax": "func Examples(files ...*ast.File) []*Example",
        "type": "go"
    },
    "doc.Filter": {
        "descr": "",
        "name": "doc.Filter",
        "params": [],
        "path": "go/go/doc/index#Filter",
        "syntax": "type Filter func(string) bool",
        "type": "go"
    },
    "doc.Func": {
        "descr": "Func is the documentation for a func declaration.",
        "name": "doc.Func",
        "params": [],
        "path": "go/go/doc/index#Func",
        "syntax": "type Func struct { Doc string Name string Decl *ast.FuncDecl // methods // (for functions, these fields have the respective zero value) Recv string // actual receiver \"T\" or \"*T\" Orig string // original receiver \"T\" or \"*T\" Level int // embedding level; 0 means not embedded }",
        "type": "go"
    },
    "doc.IsPredeclared": {
        "descr": "IsPredeclared reports whether s is a predeclared identifier.",
        "name": "doc.IsPredeclared",
        "params": [],
        "path": "go/go/doc/index#IsPredeclared",
        "syntax": "func IsPredeclared(s string) bool",
        "type": "go"
    },
    "doc.Mode": {
        "descr": "Mode values control the operation of New.",
        "name": "doc.Mode",
        "params": [],
        "path": "go/go/doc/index#Mode",
        "syntax": "type Mode int",
        "type": "go"
    },
    "doc.New": {
        "descr": "New computes the package documentation for the given package AST. New takes ownership of the AST pkg and may edit or overwrite it.",
        "name": "doc.New",
        "params": [],
        "path": "go/go/doc/index#New",
        "syntax": "func New(pkg *ast.Package, importPath string, mode Mode) *Package",
        "type": "go"
    },
    "doc.Note": {
        "descr": "A Note represents a marked comment starting with \"MARKER(uid): note body\". Any note with a marker of 2 or more upper case [A-Z] letters and a uid of at least one character is recognized. The \":\" following the uid is optional. Notes are collected in the Package.Notes map indexed by the notes marker.",
        "name": "doc.Note",
        "params": [],
        "path": "go/go/doc/index#Note",
        "syntax": "type Note struct { Pos, End token.Pos // position range of the comment containing the marker UID string // uid found with the marker Body string // note body text }",
        "type": "go"
    },
    "doc.Package": {
        "descr": "Package is the documentation for an entire package.",
        "name": "doc.Package",
        "params": [],
        "path": "go/go/doc/index#Package",
        "syntax": "type Package struct { Doc string Name string ImportPath string Imports []string Filenames []string Notes map[string][]*Note // Go 1.1 // Deprecated: For backward compatibility Bugs is still populated, // but all new code should use Notes instead. Bugs []string // declarations Consts []*Value Types []*Type Vars []*Value Funcs []*Func }",
        "type": "go"
    },
    "doc.Package.Filter": {
        "descr": "Filter eliminates documentation for names that don't pass through the filter f. TODO(gri): Recognize \"Type.Method\" as a name.",
        "name": "doc.Package.Filter",
        "params": [],
        "path": "go/go/doc/index#Package.Filter",
        "syntax": "func (p *Package) Filter(f Filter)",
        "type": "go"
    },
    "doc.Synopsis": {
        "descr": "Synopsis returns a cleaned version of the first sentence in s. That sentence ends after the first period followed by space and not preceded by exactly one uppercase letter. The result string has no \\n, \\r, or \\t characters and uses only single spaces between words. If s starts with any of the IllegalPrefixes, the result is the empty string.",
        "name": "doc.Synopsis",
        "params": [],
        "path": "go/go/doc/index#Synopsis",
        "syntax": "func Synopsis(s string) string",
        "type": "go"
    },
    "doc.ToHTML": {
        "descr": "ToHTML converts comment text to formatted HTML. The comment was prepared by DocReader, so it is known not to have leading, trailing blank lines nor to have trailing spaces at the end of lines. The comment markers have already been removed.",
        "name": "doc.ToHTML",
        "params": [],
        "path": "go/go/doc/index#ToHTML",
        "syntax": "func ToHTML(w io.Writer, text string, words map[string]string)",
        "type": "go"
    },
    "doc.ToText": {
        "descr": "ToText prepares comment text for presentation in textual output. It wraps paragraphs of text to width or fewer Unicode code points and then prefixes each line with the indent. In preformatted sections (such as program text), it prefixes each non-blank line with preIndent.",
        "name": "doc.ToText",
        "params": [],
        "path": "go/go/doc/index#ToText",
        "syntax": "func ToText(w io.Writer, text string, indent, preIndent string, width int)",
        "type": "go"
    },
    "doc.Type": {
        "descr": "Type is the documentation for a type declaration.",
        "name": "doc.Type",
        "params": [],
        "path": "go/go/doc/index#Type",
        "syntax": "type Type struct { Doc string Name string Decl *ast.GenDecl // associated declarations Consts []*Value // sorted list of constants of (mostly) this type Vars []*Value // sorted list of variables of (mostly) this type Funcs []*Func // sorted list of functions returning this type Methods []*Func // sorted list of methods (including embedded ones) of this type }",
        "type": "go"
    },
    "doc.Value": {
        "descr": "Value is the documentation for a (possibly grouped) var or const declaration.",
        "name": "doc.Value",
        "params": [],
        "path": "go/go/doc/index#Value",
        "syntax": "type Value struct { Doc string Names []string // var or const names in declaration order Decl *ast.GenDecl // contains filtered or unexported fields }",
        "type": "go"
    },
    "draw.Draw": {
        "descr": "Draw calls DrawMask with a nil mask.",
        "name": "draw.Draw",
        "params": [],
        "path": "go/image/draw/index#Draw",
        "syntax": "func Draw(dst Image, r image.Rectangle, src image.Image, sp image.Point, op Op)",
        "type": "image"
    },
    "draw.DrawMask": {
        "descr": "DrawMask aligns r.Min in dst with sp in src and mp in mask and then replaces the rectangle r in dst with the result of a Porter-Duff composition. A nil mask is treated as opaque.",
        "name": "draw.DrawMask",
        "params": [],
        "path": "go/image/draw/index#DrawMask",
        "syntax": "func DrawMask(dst Image, r image.Rectangle, src image.Image, sp image.Point, mask image.Image, mp image.Point, op Op)",
        "type": "image"
    },
    "draw.Drawer": {
        "descr": "Drawer contains the Draw method.",
        "name": "draw.Drawer",
        "params": [],
        "path": "go/image/draw/index#Drawer",
        "syntax": "type Drawer interface { // Draw aligns r.Min in dst with sp in src and then replaces the // rectangle r in dst with the result of drawing src on dst. Draw(dst Image, r image.Rectangle, src image.Image, sp image.Point) }",
        "type": "image"
    },
    "draw.Image": {
        "descr": "Image is an image.Image with a Set method to change a single pixel.",
        "name": "draw.Image",
        "params": [],
        "path": "go/image/draw/index#Image",
        "syntax": "type Image interface { image.Image Set(x, y int, c color.Color) }",
        "type": "image"
    },
    "draw.Op": {
        "descr": "Op is a Porter-Duff compositing operator.",
        "name": "draw.Op",
        "params": [],
        "path": "go/image/draw/index#Op",
        "syntax": "type Op int",
        "type": "image"
    },
    "draw.Op.Draw": {
        "descr": "Draw implements the Drawer interface by calling the Draw function with this Op.",
        "name": "draw.Op.Draw",
        "params": [],
        "path": "go/image/draw/index#Op.Draw",
        "syntax": "func (op Op) Draw(dst Image, r image.Rectangle, src image.Image, sp image.Point)",
        "type": "image"
    },
    "draw.Quantizer": {
        "descr": "Quantizer produces a palette for an image.",
        "name": "draw.Quantizer",
        "params": [],
        "path": "go/image/draw/index#Quantizer",
        "syntax": "type Quantizer interface { // Quantize appends up to cap(p) - len(p) colors to p and returns the // updated palette suitable for converting m to a paletted image. Quantize(p color.Palette, m image.Image) color.Palette }",
        "type": "image"
    },
    "driver.ColumnConverter": {
        "descr": "ColumnConverter may be optionally implemented by Stmt if the statement is aware of its own columns' types and can convert from any type to a driver Value.",
        "name": "driver.ColumnConverter",
        "params": [],
        "path": "go/database/sql/driver/index#ColumnConverter",
        "syntax": "type ColumnConverter interface { // ColumnConverter returns a ValueConverter for the provided // column index. If the type of a specific column isn't known // or shouldn't be handled specially, DefaultValueConverter // can be returned. ColumnConverter(idx int) ValueConverter }",
        "type": "database"
    },
    "driver.Conn": {
        "descr": "Conn is a connection to a database. It is not used concurrently by multiple goroutines.",
        "name": "driver.Conn",
        "params": [],
        "path": "go/database/sql/driver/index#Conn",
        "syntax": "type Conn interface { // Prepare returns a prepared statement, bound to this connection. Prepare(query string) (Stmt, error) // Close invalidates and potentially stops any current // prepared statements and transactions, marking this // connection as no longer in use. // // Because the sql package maintains a free pool of // connections and only calls Close when there's a surplus of // idle connections, it shouldn't be necessary for drivers to // do their own connection caching. Close() error // Begin starts and returns a new transaction. // // Deprecated: Drivers should implement ConnBeginTx instead (or additionally). Begin() (Tx, error) }",
        "type": "database"
    },
    "driver.ConnBeginTx": {
        "descr": "ConnBeginTx enhances the Conn interface with context and TxOptions.",
        "name": "driver.ConnBeginTx",
        "params": [],
        "path": "go/database/sql/driver/index#ConnBeginTx",
        "syntax": "type ConnBeginTx interface { // BeginTx starts and returns a new transaction. // If the context is canceled by the user the sql package will // call Tx.Rollback before discarding and closing the connection. // // This must check opts.Isolation to determine if there is a set // isolation level. If the driver does not support a non-default // level and one is set or if there is a non-default isolation level // that is not supported, an error must be returned. // // This must also check opts.ReadOnly to determine if the read-only // value is true to either set the read-only transaction property if supported // or return an error if it is not supported. BeginTx(ctx context.Context, opts TxOptions) (Tx, error) }",
        "type": "database"
    },
    "driver.ConnPrepareContext": {
        "descr": "ConnPrepareContext enhances the Conn interface with context.",
        "name": "driver.ConnPrepareContext",
        "params": [],
        "path": "go/database/sql/driver/index#ConnPrepareContext",
        "syntax": "type ConnPrepareContext interface { // PrepareContext returns a prepared statement, bound to this connection. // context is for the preparation of the statement, // it must not store the context within the statement itself. PrepareContext(ctx context.Context, query string) (Stmt, error) }",
        "type": "database"
    },
    "driver.Connector": {
        "descr": "A Connector represents a driver in a fixed configuration and can create any number of equivalent Conns for use by multiple goroutines.",
        "name": "driver.Connector",
        "params": [],
        "path": "go/database/sql/driver/index#Connector",
        "syntax": "type Connector interface { // Connect returns a connection to the database. // Connect may return a cached connection (one previously // closed), but doing so is unnecessary; the sql package // maintains a pool of idle connections for efficient re-use. // // The provided context.Context is for dialing purposes only // (see net.DialContext) and should not be stored or used for // other purposes. // // The returned connection is only used by one goroutine at a // time. Connect(context.Context) (Conn, error) // Driver returns the underlying Driver of the Connector, // mainly to maintain compatibility with the Driver method // on sql.DB. Driver() Driver }",
        "type": "database"
    },
    "driver.Driver": {
        "descr": "Driver is the interface that must be implemented by a database driver.",
        "name": "driver.Driver",
        "params": [],
        "path": "go/database/sql/driver/index#Driver",
        "syntax": "type Driver interface { // Open returns a new connection to the database. // The name is a string in a driver-specific format. // // Open may return a cached connection (one previously // closed), but doing so is unnecessary; the sql package // maintains a pool of idle connections for efficient re-use. // // The returned connection is only used by one goroutine at a // time. Open(name string) (Conn, error) }",
        "type": "database"
    },
    "driver.DriverContext": {
        "descr": "If a Driver implements DriverContext, then sql.DB will call OpenConnector to obtain a Connector and then invoke that Connector's Conn method to obtain each needed connection, instead of invoking the Driver's Open method for each connection. The two-step sequence allows drivers to parse the name just once and also provides access to per-Conn contexts.",
        "name": "driver.DriverContext",
        "params": [],
        "path": "go/database/sql/driver/index#DriverContext",
        "syntax": "type DriverContext interface { // OpenConnector must parse the name in the same format that Driver.Open // parses the name parameter. OpenConnector(name string) (Connector, error) }",
        "type": "database"
    },
    "driver.Execer": {
        "descr": "Execer is an optional interface that may be implemented by a Conn.",
        "name": "driver.Execer",
        "params": [],
        "path": "go/database/sql/driver/index#Execer",
        "syntax": "type Execer interface { Exec(query string, args []Value) (Result, error) }",
        "type": "database"
    },
    "driver.ExecerContext": {
        "descr": "ExecerContext is an optional interface that may be implemented by a Conn.",
        "name": "driver.ExecerContext",
        "params": [],
        "path": "go/database/sql/driver/index#ExecerContext",
        "syntax": "type ExecerContext interface { ExecContext(ctx context.Context, query string, args []NamedValue) (Result, error) }",
        "type": "database"
    },
    "driver.IsScanValue": {
        "descr": "IsScanValue is equivalent to IsValue. It exists for compatibility.",
        "name": "driver.IsScanValue",
        "params": [],
        "path": "go/database/sql/driver/index#IsScanValue",
        "syntax": "func IsScanValue(v interface{}) bool",
        "type": "database"
    },
    "driver.IsValue": {
        "descr": "IsValue reports whether v is a valid Value parameter type.",
        "name": "driver.IsValue",
        "params": [],
        "path": "go/database/sql/driver/index#IsValue",
        "syntax": "func IsValue(v interface{}) bool",
        "type": "database"
    },
    "driver.IsolationLevel": {
        "descr": "IsolationLevel is the transaction isolation level stored in TxOptions.",
        "name": "driver.IsolationLevel",
        "params": [],
        "path": "go/database/sql/driver/index#IsolationLevel",
        "syntax": "type IsolationLevel int",
        "type": "database"
    },
    "driver.NamedValue": {
        "descr": "NamedValue holds both the value name and value.",
        "name": "driver.NamedValue",
        "params": [],
        "path": "go/database/sql/driver/index#NamedValue",
        "syntax": "type NamedValue struct { // If the Name is not empty it should be used for the parameter identifier and // not the ordinal position. // // Name will not have a symbol prefix. Name string // Ordinal position of the parameter starting from one and is always set. Ordinal int // Value is the parameter value. Value Value }",
        "type": "database"
    },
    "driver.NamedValueChecker": {
        "descr": "NamedValueChecker may be optionally implemented by Conn or Stmt. It provides the driver more control to handle Go and database types beyond the default Values types allowed.",
        "name": "driver.NamedValueChecker",
        "params": [],
        "path": "go/database/sql/driver/index#NamedValueChecker",
        "syntax": "type NamedValueChecker interface { // CheckNamedValue is called before passing arguments to the driver // and is called in place of any ColumnConverter. CheckNamedValue must do type // validation and conversion as appropriate for the driver. CheckNamedValue(*NamedValue) error }",
        "type": "database"
    },
    "driver.NotNull": {
        "descr": "NotNull is a type that implements ValueConverter by disallowing nil values but otherwise delegating to another ValueConverter.",
        "name": "driver.NotNull",
        "params": [],
        "path": "go/database/sql/driver/index#NotNull",
        "syntax": "type NotNull struct { Converter ValueConverter }",
        "type": "database"
    },
    "driver.NotNull.ConvertValue": {
        "descr": "",
        "name": "driver.NotNull.ConvertValue",
        "params": [],
        "path": "go/database/sql/driver/index#NotNull.ConvertValue",
        "syntax": "func (n NotNull) ConvertValue(v interface{}) (Value, error)",
        "type": "database"
    },
    "driver.Null": {
        "descr": "Null is a type that implements ValueConverter by allowing nil values but otherwise delegating to another ValueConverter.",
        "name": "driver.Null",
        "params": [],
        "path": "go/database/sql/driver/index#Null",
        "syntax": "type Null struct { Converter ValueConverter }",
        "type": "database"
    },
    "driver.Null.ConvertValue": {
        "descr": "",
        "name": "driver.Null.ConvertValue",
        "params": [],
        "path": "go/database/sql/driver/index#Null.ConvertValue",
        "syntax": "func (n Null) ConvertValue(v interface{}) (Value, error)",
        "type": "database"
    },
    "driver.Pinger": {
        "descr": "Pinger is an optional interface that may be implemented by a Conn.",
        "name": "driver.Pinger",
        "params": [],
        "path": "go/database/sql/driver/index#Pinger",
        "syntax": "type Pinger interface { Ping(ctx context.Context) error }",
        "type": "database"
    },
    "driver.Queryer": {
        "descr": "Queryer is an optional interface that may be implemented by a Conn.",
        "name": "driver.Queryer",
        "params": [],
        "path": "go/database/sql/driver/index#Queryer",
        "syntax": "type Queryer interface { Query(query string, args []Value) (Rows, error) }",
        "type": "database"
    },
    "driver.QueryerContext": {
        "descr": "QueryerContext is an optional interface that may be implemented by a Conn.",
        "name": "driver.QueryerContext",
        "params": [],
        "path": "go/database/sql/driver/index#QueryerContext",
        "syntax": "type QueryerContext interface { QueryContext(ctx context.Context, query string, args []NamedValue) (Rows, error) }",
        "type": "database"
    },
    "driver.Result": {
        "descr": "Result is the result of a query execution.",
        "name": "driver.Result",
        "params": [],
        "path": "go/database/sql/driver/index#Result",
        "syntax": "type Result interface { // LastInsertId returns the database's auto-generated ID // after, for example, an INSERT into a table with primary // key. LastInsertId() (int64, error) // RowsAffected returns the number of rows affected by the // query. RowsAffected() (int64, error) }",
        "type": "database"
    },
    "driver.Rows": {
        "descr": "Rows is an iterator over an executed query's results.",
        "name": "driver.Rows",
        "params": [],
        "path": "go/database/sql/driver/index#Rows",
        "syntax": "type Rows interface { // Columns returns the names of the columns. The number of // columns of the result is inferred from the length of the // slice. If a particular column name isn't known, an empty // string should be returned for that entry. Columns() []string // Close closes the rows iterator. Close() error // Next is called to populate the next row of data into // the provided slice. The provided slice will be the same // size as the Columns() are wide. // // Next should return io.EOF when there are no more rows. // // The dest should not be written to outside of Next. Care // should be taken when closing Rows not to modify // a buffer held in dest. Next(dest []Value) error }",
        "type": "database"
    },
    "driver.RowsAffected": {
        "descr": "RowsAffected implements Result for an INSERT or UPDATE operation which mutates a number of rows.",
        "name": "driver.RowsAffected",
        "params": [],
        "path": "go/database/sql/driver/index#RowsAffected",
        "syntax": "type RowsAffected int64",
        "type": "database"
    },
    "driver.RowsAffected.LastInsertId": {
        "descr": "",
        "name": "driver.RowsAffected.LastInsertId",
        "params": [],
        "path": "go/database/sql/driver/index#RowsAffected.LastInsertId",
        "syntax": "func (RowsAffected) LastInsertId() (int64, error)",
        "type": "database"
    },
    "driver.RowsAffected.RowsAffected": {
        "descr": "",
        "name": "driver.RowsAffected.RowsAffected",
        "params": [],
        "path": "go/database/sql/driver/index#RowsAffected.RowsAffected",
        "syntax": "func (v RowsAffected) RowsAffected() (int64, error)",
        "type": "database"
    },
    "driver.RowsColumnTypeDatabaseTypeName": {
        "descr": "RowsColumnTypeDatabaseTypeName may be implemented by Rows. It should return the database system type name without the length. Type names should be uppercase. Examples of returned types: \"VARCHAR\", \"NVARCHAR\", \"VARCHAR2\", \"CHAR\", \"TEXT\", \"DECIMAL\", \"SMALLINT\", \"INT\", \"BIGINT\", \"BOOL\", \"[]BIGINT\", \"JSONB\", \"XML\", \"TIMESTAMP\".",
        "name": "driver.RowsColumnTypeDatabaseTypeName",
        "params": [],
        "path": "go/database/sql/driver/index#RowsColumnTypeDatabaseTypeName",
        "syntax": "type RowsColumnTypeDatabaseTypeName interface { Rows ColumnTypeDatabaseTypeName(index int) string }",
        "type": "database"
    },
    "driver.RowsColumnTypeLength": {
        "descr": "RowsColumnTypeLength may be implemented by Rows. It should return the length of the column type if the column is a variable length type. If the column is not a variable length type ok should return false. If length is not limited other than system limits, it should return math.MaxInt64. The following are examples of returned values for various types:",
        "name": "driver.RowsColumnTypeLength",
        "params": [],
        "path": "go/database/sql/driver/index#RowsColumnTypeLength",
        "syntax": "TEXT (math.MaxInt64, true) varchar(10) (10, true) nvarchar(10) (10, true) decimal (0, false) int (0, false) bytea(30) (30, true)",
        "type": "database"
    },
    "driver.RowsColumnTypeNullable": {
        "descr": "RowsColumnTypeNullable may be implemented by Rows. The nullable value should be true if it is known the column may be null, or false if the column is known to be not nullable. If the column nullability is unknown, ok should be false.",
        "name": "driver.RowsColumnTypeNullable",
        "params": [],
        "path": "go/database/sql/driver/index#RowsColumnTypeNullable",
        "syntax": "type RowsColumnTypeNullable interface { Rows ColumnTypeNullable(index int) (nullable, ok bool) }",
        "type": "database"
    },
    "driver.RowsColumnTypePrecisionScale": {
        "descr": "RowsColumnTypePrecisionScale may be implemented by Rows. It should return the precision and scale for decimal types. If not applicable, ok should be false. The following are examples of returned values for various types:",
        "name": "driver.RowsColumnTypePrecisionScale",
        "params": [],
        "path": "go/database/sql/driver/index#RowsColumnTypePrecisionScale",
        "syntax": "decimal(38, 4) (38, 4, true) int (0, 0, false) decimal (math.MaxInt64, math.MaxInt64, true)",
        "type": "database"
    },
    "driver.RowsColumnTypeScanType": {
        "descr": "RowsColumnTypeScanType may be implemented by Rows. It should return the value type that can be used to scan types into. For example, the database column type \"bigint\" this should return \"reflect.TypeOf(int64(0))\".",
        "name": "driver.RowsColumnTypeScanType",
        "params": [],
        "path": "go/database/sql/driver/index#RowsColumnTypeScanType",
        "syntax": "type RowsColumnTypeScanType interface { Rows ColumnTypeScanType(index int) reflect.Type }",
        "type": "database"
    },
    "driver.RowsNextResultSet": {
        "descr": "RowsNextResultSet extends the Rows interface by providing a way to signal the driver to advance to the next result set.",
        "name": "driver.RowsNextResultSet",
        "params": [],
        "path": "go/database/sql/driver/index#RowsNextResultSet",
        "syntax": "type RowsNextResultSet interface { Rows // HasNextResultSet is called at the end of the current result set and // reports whether there is another result set after the current one. HasNextResultSet() bool // NextResultSet advances the driver to the next result set even // if there are remaining rows in the current result set. // // NextResultSet should return io.EOF when there are no more result sets. NextResultSet() error }",
        "type": "database"
    },
    "driver.SessionResetter": {
        "descr": "SessionResetter may be implemented by Conn to allow drivers to reset the session state associated with the connection and to signal a bad connection.",
        "name": "driver.SessionResetter",
        "params": [],
        "path": "go/database/sql/driver/index#SessionResetter",
        "syntax": "type SessionResetter interface { // ResetSession is called while a connection is in the connection // pool. No queries will run on this connection until this method returns. // // If the connection is bad this should return driver.ErrBadConn to prevent // the connection from being returned to the connection pool. Any other // error will be discarded. ResetSession(ctx context.Context) error }",
        "type": "database"
    },
    "driver.Stmt": {
        "descr": "Stmt is a prepared statement. It is bound to a Conn and not used by multiple goroutines concurrently.",
        "name": "driver.Stmt",
        "params": [],
        "path": "go/database/sql/driver/index#Stmt",
        "syntax": "type Stmt interface { // Close closes the statement. // // As of Go 1.1, a Stmt will not be closed if it's in use // by any queries. Close() error // NumInput returns the number of placeholder parameters. // // If NumInput returns >= 0, the sql package will sanity check // argument counts from callers and return errors to the caller // before the statement's Exec or Query methods are called. // // NumInput may also return -1, if the driver doesn't know // its number of placeholders. In that case, the sql package // will not sanity check Exec or Query argument counts. NumInput() int // Exec executes a query that doesn't return rows, such // as an INSERT or UPDATE. // // Deprecated: Drivers should implement StmtExecContext instead (or additionally). Exec(args []Value) (Result, error) // Query executes a query that may return rows, such as a // SELECT. // // Deprecated: Drivers should implement StmtQueryContext instead (or additionally). Query(args []Value) (Rows, error) }",
        "type": "database"
    },
    "driver.StmtExecContext": {
        "descr": "StmtExecContext enhances the Stmt interface by providing Exec with context.",
        "name": "driver.StmtExecContext",
        "params": [],
        "path": "go/database/sql/driver/index#StmtExecContext",
        "syntax": "type StmtExecContext interface { // ExecContext executes a query that doesn't return rows, such // as an INSERT or UPDATE. // // ExecContext must honor the context timeout and return when it is canceled. ExecContext(ctx context.Context, args []NamedValue) (Result, error) }",
        "type": "database"
    },
    "driver.StmtQueryContext": {
        "descr": "StmtQueryContext enhances the Stmt interface by providing Query with context.",
        "name": "driver.StmtQueryContext",
        "params": [],
        "path": "go/database/sql/driver/index#StmtQueryContext",
        "syntax": "type StmtQueryContext interface { // QueryContext executes a query that may return rows, such as a // SELECT. // // QueryContext must honor the context timeout and return when it is canceled. QueryContext(ctx context.Context, args []NamedValue) (Rows, error) }",
        "type": "database"
    },
    "driver.Tx": {
        "descr": "Tx is a transaction.",
        "name": "driver.Tx",
        "params": [],
        "path": "go/database/sql/driver/index#Tx",
        "syntax": "type Tx interface { Commit() error Rollback() error }",
        "type": "database"
    },
    "driver.TxOptions": {
        "descr": "TxOptions holds the transaction options.",
        "name": "driver.TxOptions",
        "params": [],
        "path": "go/database/sql/driver/index#TxOptions",
        "syntax": "type TxOptions struct { Isolation IsolationLevel ReadOnly bool }",
        "type": "database"
    },
    "driver.Value": {
        "descr": "Value is a value that drivers must be able to handle. It is either nil, a type handled by a database driver's NamedValueChecker interface, or an instance of one of these types:",
        "name": "driver.Value",
        "params": [],
        "path": "go/database/sql/driver/index#Value",
        "syntax": "int64 float64 bool []byte string time.Time",
        "type": "database"
    },
    "driver.ValueConverter": {
        "descr": "ValueConverter is the interface providing the ConvertValue method.",
        "name": "driver.ValueConverter",
        "params": [],
        "path": "go/database/sql/driver/index#ValueConverter",
        "syntax": "* converting from the Value types as provided by the sql package into a database table's specific column type and making sure it fits, such as making sure a particular int64 fits in a table's uint16 column. * converting a value as given from the database into one of the driver Value types. * by the sql package, for converting from a driver's Value type to a user's type in a scan.",
        "type": "database"
    },
    "driver.Valuer": {
        "descr": "Valuer is the interface providing the Value method.",
        "name": "driver.Valuer",
        "params": [],
        "path": "go/database/sql/driver/index#Valuer",
        "syntax": "type Valuer interface { // Value returns a driver Value. Value() (Value, error) }",
        "type": "database"
    },
    "dsa.GenerateKey": {
        "descr": "GenerateKey generates a public&private key pair. The Parameters of the PrivateKey must already be valid (see GenerateParameters).",
        "name": "dsa.GenerateKey",
        "params": [],
        "path": "go/crypto/dsa/index#GenerateKey",
        "syntax": "func GenerateKey(priv *PrivateKey, rand io.Reader) error",
        "type": "crypto"
    },
    "dsa.GenerateParameters": {
        "descr": "GenerateParameters puts a random, valid set of DSA parameters into params. This function can take many seconds, even on fast machines.",
        "name": "dsa.GenerateParameters",
        "params": [],
        "path": "go/crypto/dsa/index#GenerateParameters",
        "syntax": "func GenerateParameters(params *Parameters, rand io.Reader, sizes ParameterSizes) error",
        "type": "crypto"
    },
    "dsa.ParameterSizes": {
        "descr": "ParameterSizes is an enumeration of the acceptable bit lengths of the primes in a set of DSA parameters. See FIPS 186-3, section 4.2.",
        "name": "dsa.ParameterSizes",
        "params": [],
        "path": "go/crypto/dsa/index#ParameterSizes",
        "syntax": "type ParameterSizes int",
        "type": "crypto"
    },
    "dsa.Parameters": {
        "descr": "Parameters represents the domain parameters for a key. These parameters can be shared across many keys. The bit length of Q must be a multiple of 8.",
        "name": "dsa.Parameters",
        "params": [],
        "path": "go/crypto/dsa/index#Parameters",
        "syntax": "type Parameters struct { P, Q, G *big.Int }",
        "type": "crypto"
    },
    "dsa.PrivateKey": {
        "descr": "PrivateKey represents a DSA private key.",
        "name": "dsa.PrivateKey",
        "params": [],
        "path": "go/crypto/dsa/index#PrivateKey",
        "syntax": "type PrivateKey struct { PublicKey X *big.Int }",
        "type": "crypto"
    },
    "dsa.PublicKey": {
        "descr": "PublicKey represents a DSA public key.",
        "name": "dsa.PublicKey",
        "params": [],
        "path": "go/crypto/dsa/index#PublicKey",
        "syntax": "type PublicKey struct { Parameters Y *big.Int }",
        "type": "crypto"
    },
    "dsa.Sign": {
        "descr": "Sign signs an arbitrary length hash (which should be the result of hashing a larger message) using the private key, priv. It returns the signature as a pair of integers. The security of the private key depends on the entropy of rand.",
        "name": "dsa.Sign",
        "params": [],
        "path": "go/crypto/dsa/index#Sign",
        "syntax": "func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error)",
        "type": "crypto"
    },
    "dsa.Verify": {
        "descr": "Verify verifies the signature in r, s of hash using the public key, pub. It reports whether the signature is valid.",
        "name": "dsa.Verify",
        "params": [],
        "path": "go/crypto/dsa/index#Verify",
        "syntax": "func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool",
        "type": "crypto"
    },
    "dwarf.AddrType": {
        "descr": "An AddrType represents a machine address type.",
        "name": "dwarf.AddrType",
        "params": [],
        "path": "go/debug/dwarf/index#AddrType",
        "syntax": "type AddrType struct { BasicType }",
        "type": "debug"
    },
    "dwarf.ArrayType": {
        "descr": "An ArrayType represents a fixed size array type.",
        "name": "dwarf.ArrayType",
        "params": [],
        "path": "go/debug/dwarf/index#ArrayType",
        "syntax": "type ArrayType struct { CommonType Type Type StrideBitSize int64 // if > 0, number of bits to hold each element Count int64 // if == -1, an incomplete array, like char x[]. }",
        "type": "debug"
    },
    "dwarf.ArrayType.Size": {
        "descr": "",
        "name": "dwarf.ArrayType.Size",
        "params": [],
        "path": "go/debug/dwarf/index#ArrayType.Size",
        "syntax": "func (t *ArrayType) Size() int64",
        "type": "debug"
    },
    "dwarf.ArrayType.String": {
        "descr": "",
        "name": "dwarf.ArrayType.String",
        "params": [],
        "path": "go/debug/dwarf/index#ArrayType.String",
        "syntax": "func (t *ArrayType) String() string",
        "type": "debug"
    },
    "dwarf.Attr": {
        "descr": "An Attr identifies the attribute type in a DWARF Entry's Field.",
        "name": "dwarf.Attr",
        "params": [],
        "path": "go/debug/dwarf/index#Attr",
        "syntax": "type Attr uint32",
        "type": "debug"
    },
    "dwarf.Attr.GoString": {
        "descr": "",
        "name": "dwarf.Attr.GoString",
        "params": [],
        "path": "go/debug/dwarf/index#Attr.GoString",
        "syntax": "func (a Attr) GoString() string",
        "type": "debug"
    },
    "dwarf.Attr.String": {
        "descr": "",
        "name": "dwarf.Attr.String",
        "params": [],
        "path": "go/debug/dwarf/index#Attr.String",
        "syntax": "func (i Attr) String() string",
        "type": "debug"
    },
    "dwarf.BasicType": {
        "descr": "A BasicType holds fields common to all basic types.",
        "name": "dwarf.BasicType",
        "params": [],
        "path": "go/debug/dwarf/index#BasicType",
        "syntax": "type BasicType struct { CommonType BitSize int64 BitOffset int64 }",
        "type": "debug"
    },
    "dwarf.BasicType.Basic": {
        "descr": "",
        "name": "dwarf.BasicType.Basic",
        "params": [],
        "path": "go/debug/dwarf/index#BasicType.Basic",
        "syntax": "func (b *BasicType) Basic() *BasicType",
        "type": "debug"
    },
    "dwarf.BasicType.String": {
        "descr": "",
        "name": "dwarf.BasicType.String",
        "params": [],
        "path": "go/debug/dwarf/index#BasicType.String",
        "syntax": "func (t *BasicType) String() string",
        "type": "debug"
    },
    "dwarf.BoolType": {
        "descr": "A BoolType represents a boolean type.",
        "name": "dwarf.BoolType",
        "params": [],
        "path": "go/debug/dwarf/index#BoolType",
        "syntax": "type BoolType struct { BasicType }",
        "type": "debug"
    },
    "dwarf.CharType": {
        "descr": "A CharType represents a signed character type.",
        "name": "dwarf.CharType",
        "params": [],
        "path": "go/debug/dwarf/index#CharType",
        "syntax": "type CharType struct { BasicType }",
        "type": "debug"
    },
    "dwarf.Class": {
        "descr": "A Class is the DWARF 4 class of an attribute value.",
        "name": "dwarf.Class",
        "params": [],
        "path": "go/debug/dwarf/index#Class",
        "syntax": "type Class int",
        "type": "debug"
    },
    "dwarf.Class.GoString": {
        "descr": "",
        "name": "dwarf.Class.GoString",
        "params": [],
        "path": "go/debug/dwarf/index#Class.GoString",
        "syntax": "func (i Class) GoString() string",
        "type": "debug"
    },
    "dwarf.Class.String": {
        "descr": "",
        "name": "dwarf.Class.String",
        "params": [],
        "path": "go/debug/dwarf/index#Class.String",
        "syntax": "func (i Class) String() string",
        "type": "debug"
    },
    "dwarf.CommonType": {
        "descr": "A CommonType holds fields common to multiple types. If a field is not known or not applicable for a given type, the zero value is used.",
        "name": "dwarf.CommonType",
        "params": [],
        "path": "go/debug/dwarf/index#CommonType",
        "syntax": "type CommonType struct { ByteSize int64 // size of value of this type, in bytes Name string // name that can be used to refer to type }",
        "type": "debug"
    },
    "dwarf.CommonType.Common": {
        "descr": "",
        "name": "dwarf.CommonType.Common",
        "params": [],
        "path": "go/debug/dwarf/index#CommonType.Common",
        "syntax": "func (c *CommonType) Common() *CommonType",
        "type": "debug"
    },
    "dwarf.CommonType.Size": {
        "descr": "",
        "name": "dwarf.CommonType.Size",
        "params": [],
        "path": "go/debug/dwarf/index#CommonType.Size",
        "syntax": "func (c *CommonType) Size() int64",
        "type": "debug"
    },
    "dwarf.ComplexType": {
        "descr": "A ComplexType represents a complex floating point type.",
        "name": "dwarf.ComplexType",
        "params": [],
        "path": "go/debug/dwarf/index#ComplexType",
        "syntax": "type ComplexType struct { BasicType }",
        "type": "debug"
    },
    "dwarf.Data": {
        "descr": "Data represents the DWARF debugging information loaded from an executable file (for example, an ELF or Mach-O executable).",
        "name": "dwarf.Data",
        "params": [],
        "path": "go/debug/dwarf/index#Data",
        "syntax": "type Data struct { // contains filtered or unexported fields }",
        "type": "debug"
    },
    "dwarf.Data.AddTypes": {
        "descr": "AddTypes will add one .debug_types section to the DWARF data. A typical object with DWARF version 4 debug info will have multiple .debug_types sections. The name is used for error reporting only, and serves to distinguish one .debug_types section from another.",
        "name": "dwarf.Data.AddTypes",
        "params": [],
        "path": "go/debug/dwarf/index#Data.AddTypes",
        "syntax": "func (d *Data) AddTypes(name string, types []byte) error",
        "type": "debug"
    },
    "dwarf.Data.LineReader": {
        "descr": "LineReader returns a new reader for the line table of compilation unit cu, which must be an Entry with tag TagCompileUnit.",
        "name": "dwarf.Data.LineReader",
        "params": [],
        "path": "go/debug/dwarf/index#Data.LineReader",
        "syntax": "func (d *Data) LineReader(cu *Entry) (*LineReader, error)",
        "type": "debug"
    },
    "dwarf.Data.Ranges": {
        "descr": "Ranges returns the PC ranges covered by e, a slice of [low,high) pairs. Only some entry types, such as TagCompileUnit or TagSubprogram, have PC ranges; for others, this will return nil with no error.",
        "name": "dwarf.Data.Ranges",
        "params": [],
        "path": "go/debug/dwarf/index#Data.Ranges",
        "syntax": "func (d *Data) Ranges(e *Entry) ([][2]uint64, error)",
        "type": "debug"
    },
    "dwarf.Data.Reader": {
        "descr": "Reader returns a new Reader for Data. The reader is positioned at byte offset 0 in the DWARF info section.",
        "name": "dwarf.Data.Reader",
        "params": [],
        "path": "go/debug/dwarf/index#Data.Reader",
        "syntax": "func (d *Data) Reader() *Reader",
        "type": "debug"
    },
    "dwarf.Data.Type": {
        "descr": "Type reads the type at off in the DWARF info section.",
        "name": "dwarf.Data.Type",
        "params": [],
        "path": "go/debug/dwarf/index#Data.Type",
        "syntax": "func (d *Data) Type(off Offset) (Type, error)",
        "type": "debug"
    },
    "dwarf.DecodeError": {
        "descr": "",
        "name": "dwarf.DecodeError",
        "params": [],
        "path": "go/debug/dwarf/index#DecodeError",
        "syntax": "type DecodeError struct { Name string Offset Offset Err string }",
        "type": "debug"
    },
    "dwarf.DecodeError.Error": {
        "descr": "",
        "name": "dwarf.DecodeError.Error",
        "params": [],
        "path": "go/debug/dwarf/index#DecodeError.Error",
        "syntax": "func (e DecodeError) Error() string",
        "type": "debug"
    },
    "dwarf.DotDotDotType": {
        "descr": "A DotDotDotType represents the variadic ... function parameter.",
        "name": "dwarf.DotDotDotType",
        "params": [],
        "path": "go/debug/dwarf/index#DotDotDotType",
        "syntax": "type DotDotDotType struct { CommonType }",
        "type": "debug"
    },
    "dwarf.DotDotDotType.String": {
        "descr": "",
        "name": "dwarf.DotDotDotType.String",
        "params": [],
        "path": "go/debug/dwarf/index#DotDotDotType.String",
        "syntax": "func (t *DotDotDotType) String() string",
        "type": "debug"
    },
    "dwarf.Entry": {
        "descr": "An entry is a sequence of attribute/value pairs.",
        "name": "dwarf.Entry",
        "params": [],
        "path": "go/debug/dwarf/index#Entry",
        "syntax": "type Entry struct { Offset Offset // offset of Entry in DWARF info Tag Tag // tag (kind of Entry) Children bool // whether Entry is followed by children Field []Field }",
        "type": "debug"
    },
    "dwarf.Entry.AttrField": {
        "descr": "AttrField returns the Field associated with attribute Attr in Entry, or nil if there is no such attribute.",
        "name": "dwarf.Entry.AttrField",
        "params": [],
        "path": "go/debug/dwarf/index#Entry.AttrField",
        "syntax": "func (e *Entry) AttrField(a Attr) *Field",
        "type": "debug"
    },
    "dwarf.Entry.Val": {
        "descr": "Val returns the value associated with attribute Attr in Entry, or nil if there is no such attribute.",
        "name": "dwarf.Entry.Val",
        "params": [],
        "path": "go/debug/dwarf/index#Entry.Val",
        "syntax": "func (e *Entry) Val(a Attr) interface{}",
        "type": "debug"
    },
    "dwarf.EnumType": {
        "descr": "An EnumType represents an enumerated type. The only indication of its native integer type is its ByteSize (inside CommonType).",
        "name": "dwarf.EnumType",
        "params": [],
        "path": "go/debug/dwarf/index#EnumType",
        "syntax": "type EnumType struct { CommonType EnumName string Val []*EnumValue }",
        "type": "debug"
    },
    "dwarf.EnumType.String": {
        "descr": "",
        "name": "dwarf.EnumType.String",
        "params": [],
        "path": "go/debug/dwarf/index#EnumType.String",
        "syntax": "func (t *EnumType) String() string",
        "type": "debug"
    },
    "dwarf.EnumValue": {
        "descr": "An EnumValue represents a single enumeration value.",
        "name": "dwarf.EnumValue",
        "params": [],
        "path": "go/debug/dwarf/index#EnumValue",
        "syntax": "type EnumValue struct { Name string Val int64 }",
        "type": "debug"
    },
    "dwarf.Field": {
        "descr": "A Field is a single attribute/value pair in an Entry.",
        "name": "dwarf.Field",
        "params": [],
        "path": "go/debug/dwarf/index#Field",
        "syntax": "DWARF class Go type Class ----------- ------- ----- address uint64 ClassAddress block []byte ClassBlock constant int64 ClassConstant flag bool ClassFlag reference to info dwarf.Offset ClassReference to type unit uint64 ClassReferenceSig string string ClassString exprloc []byte ClassExprLoc lineptr int64 ClassLinePtr loclistptr int64 ClassLocListPtr macptr int64 ClassMacPtr rangelistptr int64 ClassRangeListPtr",
        "type": "debug"
    },
    "dwarf.FloatType": {
        "descr": "A FloatType represents a floating point type.",
        "name": "dwarf.FloatType",
        "params": [],
        "path": "go/debug/dwarf/index#FloatType",
        "syntax": "type FloatType struct { BasicType }",
        "type": "debug"
    },
    "dwarf.FuncType": {
        "descr": "A FuncType represents a function type.",
        "name": "dwarf.FuncType",
        "params": [],
        "path": "go/debug/dwarf/index#FuncType",
        "syntax": "type FuncType struct { CommonType ReturnType Type ParamType []Type }",
        "type": "debug"
    },
    "dwarf.FuncType.String": {
        "descr": "",
        "name": "dwarf.FuncType.String",
        "params": [],
        "path": "go/debug/dwarf/index#FuncType.String",
        "syntax": "func (t *FuncType) String() string",
        "type": "debug"
    },
    "dwarf.IntType": {
        "descr": "An IntType represents a signed integer type.",
        "name": "dwarf.IntType",
        "params": [],
        "path": "go/debug/dwarf/index#IntType",
        "syntax": "type IntType struct { BasicType }",
        "type": "debug"
    },
    "dwarf.LineEntry": {
        "descr": "A LineEntry is a row in a DWARF line table.",
        "name": "dwarf.LineEntry",
        "params": [],
        "path": "go/debug/dwarf/index#LineEntry",
        "syntax": "type LineEntry struct { // Address is the program-counter value of a machine // instruction generated by the compiler. This LineEntry // applies to each instruction from Address to just before the // Address of the next LineEntry. Address uint64 // OpIndex is the index of an operation within a VLIW // instruction. The index of the first operation is 0. For // non-VLIW architectures, it will always be 0. Address and // OpIndex together form an operation pointer that can // reference any individual operation within the instruction // stream. OpIndex int // File is the source file corresponding to these // instructions. File *LineFile // Line is the source code line number corresponding to these // instructions. Lines are numbered beginning at 1. It may be // 0 if these instructions cannot be attributed to any source // line. Line int // Column is the column number within the source line of these // instructions. Columns are numbered beginning at 1. It may // be 0 to indicate the \"left edge\" of the line. Column int // IsStmt indicates that Address is a recommended breakpoint // location, such as the beginning of a line, statement, or a // distinct subpart of a statement. IsStmt bool // BasicBlock indicates that Address is the beginning of a // basic block. BasicBlock bool // PrologueEnd indicates that Address is one (of possibly // many) PCs where execution should be suspended for a // breakpoint on entry to the containing function. // // Added in DWARF 3. PrologueEnd bool // EpilogueBegin indicates that Address is one (of possibly // many) PCs where execution should be suspended for a // breakpoint on exit from this function. // // Added in DWARF 3. EpilogueBegin bool // ISA is the instruction set architecture for these // instructions. Possible ISA values should be defined by the // applicable ABI specification. // // Added in DWARF 3. ISA int // Discriminator is an arbitrary integer indicating the block // to which these instructions belong. It serves to // distinguish among multiple blocks that may all have with // the same source file, line, and column. Where only one // block exists for a given source position, it should be 0. // // Added in DWARF 3. Discriminator int // EndSequence indicates that Address is the first byte after // the end of a sequence of target machine instructions. If it // is set, only this and the Address field are meaningful. A // line number table may contain information for multiple // potentially disjoint instruction sequences. The last entry // in a line table should always have EndSequence set. EndSequence bool }",
        "type": "debug"
    },
    "dwarf.LineFile": {
        "descr": "A LineFile is a source file referenced by a DWARF line table entry.",
        "name": "dwarf.LineFile",
        "params": [],
        "path": "go/debug/dwarf/index#LineFile",
        "syntax": "type LineFile struct { Name string Mtime uint64 // Implementation defined modification time, or 0 if unknown Length int // File length, or 0 if unknown }",
        "type": "debug"
    },
    "dwarf.LineReader": {
        "descr": "A LineReader reads a sequence of LineEntry structures from a DWARF \"line\" section for a single compilation unit. LineEntries occur in order of increasing PC and each LineEntry gives metadata for the instructions from that LineEntry's PC to just before the next LineEntry's PC. The last entry will have its EndSequence field set.",
        "name": "dwarf.LineReader",
        "params": [],
        "path": "go/debug/dwarf/index#LineReader",
        "syntax": "type LineReader struct { // contains filtered or unexported fields }",
        "type": "debug"
    },
    "dwarf.LineReader.Next": {
        "descr": "Next sets *entry to the next row in this line table and moves to the next row. If there are no more entries and the line table is properly terminated, it returns io.EOF.",
        "name": "dwarf.LineReader.Next",
        "params": [],
        "path": "go/debug/dwarf/index#LineReader.Next",
        "syntax": "func (r *LineReader) Next(entry *LineEntry) error",
        "type": "debug"
    },
    "dwarf.LineReader.Reset": {
        "descr": "Reset repositions the line table reader at the beginning of the line table.",
        "name": "dwarf.LineReader.Reset",
        "params": [],
        "path": "go/debug/dwarf/index#LineReader.Reset",
        "syntax": "func (r *LineReader) Reset()",
        "type": "debug"
    },
    "dwarf.LineReader.Seek": {
        "descr": "Seek restores the line table reader to a position returned by Tell.",
        "name": "dwarf.LineReader.Seek",
        "params": [],
        "path": "go/debug/dwarf/index#LineReader.Seek",
        "syntax": "func (r *LineReader) Seek(pos LineReaderPos)",
        "type": "debug"
    },
    "dwarf.LineReader.SeekPC": {
        "descr": "SeekPC sets *entry to the LineEntry that includes pc and positions the reader on the next entry in the line table. If necessary, this will seek backwards to find pc.",
        "name": "dwarf.LineReader.SeekPC",
        "params": [],
        "path": "go/debug/dwarf/index#LineReader.SeekPC",
        "syntax": "func (r *LineReader) SeekPC(pc uint64, entry *LineEntry) error",
        "type": "debug"
    },
    "dwarf.LineReader.Tell": {
        "descr": "Tell returns the current position in the line table.",
        "name": "dwarf.LineReader.Tell",
        "params": [],
        "path": "go/debug/dwarf/index#LineReader.Tell",
        "syntax": "func (r *LineReader) Tell() LineReaderPos",
        "type": "debug"
    },
    "dwarf.LineReaderPos": {
        "descr": "A LineReaderPos represents a position in a line table.",
        "name": "dwarf.LineReaderPos",
        "params": [],
        "path": "go/debug/dwarf/index#LineReaderPos",
        "syntax": "type LineReaderPos struct { // contains filtered or unexported fields }",
        "type": "debug"
    },
    "dwarf.New": {
        "descr": "New returns a new Data object initialized from the given parameters. Rather than calling this function directly, clients should typically use the DWARF method of the File type of the appropriate package debug/elf, debug/macho, or debug/pe.",
        "name": "dwarf.New",
        "params": [],
        "path": "go/debug/dwarf/index#New",
        "syntax": "func New(abbrev, aranges, frame, info, line, pubnames, ranges, str []byte) (*Data, error)",
        "type": "debug"
    },
    "dwarf.Offset": {
        "descr": "An Offset represents the location of an Entry within the DWARF info. (See Reader.Seek.)",
        "name": "dwarf.Offset",
        "params": [],
        "path": "go/debug/dwarf/index#Offset",
        "syntax": "type Offset uint32",
        "type": "debug"
    },
    "dwarf.PtrType": {
        "descr": "A PtrType represents a pointer type.",
        "name": "dwarf.PtrType",
        "params": [],
        "path": "go/debug/dwarf/index#PtrType",
        "syntax": "type PtrType struct { CommonType Type Type }",
        "type": "debug"
    },
    "dwarf.PtrType.String": {
        "descr": "",
        "name": "dwarf.PtrType.String",
        "params": [],
        "path": "go/debug/dwarf/index#PtrType.String",
        "syntax": "func (t *PtrType) String() string",
        "type": "debug"
    },
    "dwarf.QualType": {
        "descr": "A QualType represents a type that has the C/C++ \"const\", \"restrict\", or \"volatile\" qualifier.",
        "name": "dwarf.QualType",
        "params": [],
        "path": "go/debug/dwarf/index#QualType",
        "syntax": "type QualType struct { CommonType Qual string Type Type }",
        "type": "debug"
    },
    "dwarf.QualType.Size": {
        "descr": "",
        "name": "dwarf.QualType.Size",
        "params": [],
        "path": "go/debug/dwarf/index#QualType.Size",
        "syntax": "func (t *QualType) Size() int64",
        "type": "debug"
    },
    "dwarf.QualType.String": {
        "descr": "",
        "name": "dwarf.QualType.String",
        "params": [],
        "path": "go/debug/dwarf/index#QualType.String",
        "syntax": "func (t *QualType) String() string",
        "type": "debug"
    },
    "dwarf.Reader": {
        "descr": "A Reader allows reading Entry structures from a DWARF info section. The Entry structures are arranged in a tree. The Reader's Next function return successive entries from a pre-order traversal of the tree. If an entry has children, its Children field will be true, and the children follow, terminated by an Entry with Tag 0.",
        "name": "dwarf.Reader",
        "params": [],
        "path": "go/debug/dwarf/index#Reader",
        "syntax": "type Reader struct { // contains filtered or unexported fields }",
        "type": "debug"
    },
    "dwarf.Reader.AddressSize": {
        "descr": "AddressSize returns the size in bytes of addresses in the current compilation unit.",
        "name": "dwarf.Reader.AddressSize",
        "params": [],
        "path": "go/debug/dwarf/index#Reader.AddressSize",
        "syntax": "func (r *Reader) AddressSize() int",
        "type": "debug"
    },
    "dwarf.Reader.Next": {
        "descr": "Next reads the next entry from the encoded entry stream. It returns nil, nil when it reaches the end of the section. It returns an error if the current offset is invalid or the data at the offset cannot be decoded as a valid Entry.",
        "name": "dwarf.Reader.Next",
        "params": [],
        "path": "go/debug/dwarf/index#Reader.Next",
        "syntax": "func (r *Reader) Next() (*Entry, error)",
        "type": "debug"
    },
    "dwarf.Reader.Seek": {
        "descr": "Seek positions the Reader at offset off in the encoded entry stream. Offset 0 can be used to denote the first entry.",
        "name": "dwarf.Reader.Seek",
        "params": [],
        "path": "go/debug/dwarf/index#Reader.Seek",
        "syntax": "func (r *Reader) Seek(off Offset)",
        "type": "debug"
    },
    "dwarf.Reader.SeekPC": {
        "descr": "SeekPC returns the Entry for the compilation unit that includes pc, and positions the reader to read the children of that unit. If pc is not covered by any unit, SeekPC returns ErrUnknownPC and the position of the reader is undefined.",
        "name": "dwarf.Reader.SeekPC",
        "params": [],
        "path": "go/debug/dwarf/index#Reader.SeekPC",
        "syntax": "func (r *Reader) SeekPC(pc uint64) (*Entry, error)",
        "type": "debug"
    },
    "dwarf.Reader.SkipChildren": {
        "descr": "SkipChildren skips over the child entries associated with the last Entry returned by Next. If that Entry did not have children or Next has not been called, SkipChildren is a no-op.",
        "name": "dwarf.Reader.SkipChildren",
        "params": [],
        "path": "go/debug/dwarf/index#Reader.SkipChildren",
        "syntax": "func (r *Reader) SkipChildren()",
        "type": "debug"
    },
    "dwarf.StructField": {
        "descr": "A StructField represents a field in a struct, union, or C++ class type.",
        "name": "dwarf.StructField",
        "params": [],
        "path": "go/debug/dwarf/index#StructField",
        "syntax": "type StructField struct { Name string Type Type ByteOffset int64 ByteSize int64 // usually zero; use Type.Size() for normal fields BitOffset int64 // within the ByteSize bytes at ByteOffset BitSize int64 // zero if not a bit field }",
        "type": "debug"
    },
    "dwarf.StructType": {
        "descr": "A StructType represents a struct, union, or C++ class type.",
        "name": "dwarf.StructType",
        "params": [],
        "path": "go/debug/dwarf/index#StructType",
        "syntax": "type StructType struct { CommonType StructName string Kind string // \"struct\", \"union\", or \"class\". Field []*StructField Incomplete bool // if true, struct, union, class is declared but not defined }",
        "type": "debug"
    },
    "dwarf.StructType.Defn": {
        "descr": "",
        "name": "dwarf.StructType.Defn",
        "params": [],
        "path": "go/debug/dwarf/index#StructType.Defn",
        "syntax": "func (t *StructType) Defn() string",
        "type": "debug"
    },
    "dwarf.StructType.String": {
        "descr": "",
        "name": "dwarf.StructType.String",
        "params": [],
        "path": "go/debug/dwarf/index#StructType.String",
        "syntax": "func (t *StructType) String() string",
        "type": "debug"
    },
    "dwarf.Tag": {
        "descr": "A Tag is the classification (the type) of an Entry.",
        "name": "dwarf.Tag",
        "params": [],
        "path": "go/debug/dwarf/index#Tag",
        "syntax": "type Tag uint32",
        "type": "debug"
    },
    "dwarf.Tag.GoString": {
        "descr": "",
        "name": "dwarf.Tag.GoString",
        "params": [],
        "path": "go/debug/dwarf/index#Tag.GoString",
        "syntax": "func (t Tag) GoString() string",
        "type": "debug"
    },
    "dwarf.Tag.String": {
        "descr": "",
        "name": "dwarf.Tag.String",
        "params": [],
        "path": "go/debug/dwarf/index#Tag.String",
        "syntax": "func (i Tag) String() string",
        "type": "debug"
    },
    "dwarf.Type": {
        "descr": "A Type conventionally represents a pointer to any of the specific Type structures (CharType, StructType, etc.).",
        "name": "dwarf.Type",
        "params": [],
        "path": "go/debug/dwarf/index#Type",
        "syntax": "type Type interface { Common() *CommonType String() string Size() int64 }",
        "type": "debug"
    },
    "dwarf.TypedefType": {
        "descr": "A TypedefType represents a named type.",
        "name": "dwarf.TypedefType",
        "params": [],
        "path": "go/debug/dwarf/index#TypedefType",
        "syntax": "type TypedefType struct { CommonType Type Type }",
        "type": "debug"
    },
    "dwarf.TypedefType.Size": {
        "descr": "",
        "name": "dwarf.TypedefType.Size",
        "params": [],
        "path": "go/debug/dwarf/index#TypedefType.Size",
        "syntax": "func (t *TypedefType) Size() int64",
        "type": "debug"
    },
    "dwarf.TypedefType.String": {
        "descr": "",
        "name": "dwarf.TypedefType.String",
        "params": [],
        "path": "go/debug/dwarf/index#TypedefType.String",
        "syntax": "func (t *TypedefType) String() string",
        "type": "debug"
    },
    "dwarf.UcharType": {
        "descr": "A UcharType represents an unsigned character type.",
        "name": "dwarf.UcharType",
        "params": [],
        "path": "go/debug/dwarf/index#UcharType",
        "syntax": "type UcharType struct { BasicType }",
        "type": "debug"
    },
    "dwarf.UintType": {
        "descr": "A UintType represents an unsigned integer type.",
        "name": "dwarf.UintType",
        "params": [],
        "path": "go/debug/dwarf/index#UintType",
        "syntax": "type UintType struct { BasicType }",
        "type": "debug"
    },
    "dwarf.UnspecifiedType": {
        "descr": "An UnspecifiedType represents an implicit, unknown, ambiguous or nonexistent type.",
        "name": "dwarf.UnspecifiedType",
        "params": [],
        "path": "go/debug/dwarf/index#UnspecifiedType",
        "syntax": "type UnspecifiedType struct { BasicType }",
        "type": "debug"
    },
    "dwarf.VoidType": {
        "descr": "A VoidType represents the C void type.",
        "name": "dwarf.VoidType",
        "params": [],
        "path": "go/debug/dwarf/index#VoidType",
        "syntax": "type VoidType struct { CommonType }",
        "type": "debug"
    },
    "dwarf.VoidType.String": {
        "descr": "",
        "name": "dwarf.VoidType.String",
        "params": [],
        "path": "go/debug/dwarf/index#VoidType.String",
        "syntax": "func (t *VoidType) String() string",
        "type": "debug"
    },
    "ecdsa.GenerateKey": {
        "descr": "GenerateKey generates a public and private key pair.",
        "name": "ecdsa.GenerateKey",
        "params": [],
        "path": "go/crypto/ecdsa/index#GenerateKey",
        "syntax": "func GenerateKey(c elliptic.Curve, rand io.Reader) (*PrivateKey, error)",
        "type": "crypto"
    },
    "ecdsa.PrivateKey": {
        "descr": "PrivateKey represents an ECDSA private key.",
        "name": "ecdsa.PrivateKey",
        "params": [],
        "path": "go/crypto/ecdsa/index#PrivateKey",
        "syntax": "type PrivateKey struct { PublicKey D *big.Int }",
        "type": "crypto"
    },
    "ecdsa.PrivateKey.Public": {
        "descr": "Public returns the public key corresponding to priv.",
        "name": "ecdsa.PrivateKey.Public",
        "params": [],
        "path": "go/crypto/ecdsa/index#PrivateKey.Public",
        "syntax": "func (priv *PrivateKey) Public() crypto.PublicKey",
        "type": "crypto"
    },
    "ecdsa.PrivateKey.Sign": {
        "descr": "Sign signs digest with priv, reading randomness from rand. The opts argument is not currently used but, in keeping with the crypto.Signer interface, should be the hash function used to digest the message.",
        "name": "ecdsa.PrivateKey.Sign",
        "params": [],
        "path": "go/crypto/ecdsa/index#PrivateKey.Sign",
        "syntax": "func (priv *PrivateKey) Sign(rand io.Reader, digest []byte, opts crypto.SignerOpts) ([]byte, error)",
        "type": "crypto"
    },
    "ecdsa.PublicKey": {
        "descr": "PublicKey represents an ECDSA public key.",
        "name": "ecdsa.PublicKey",
        "params": [],
        "path": "go/crypto/ecdsa/index#PublicKey",
        "syntax": "type PublicKey struct { elliptic.Curve X, Y *big.Int }",
        "type": "crypto"
    },
    "ecdsa.Sign": {
        "descr": "Sign signs a hash (which should be the result of hashing a larger message) using the private key, priv. If the hash is longer than the bit-length of the private key's curve order, the hash will be truncated to that length. It returns the signature as a pair of integers. The security of the private key depends on the entropy of rand.",
        "name": "ecdsa.Sign",
        "params": [],
        "path": "go/crypto/ecdsa/index#Sign",
        "syntax": "func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error)",
        "type": "crypto"
    },
    "ecdsa.Verify": {
        "descr": "Verify verifies the signature in r, s of hash using the public key, pub. Its return value records whether the signature is valid.",
        "name": "ecdsa.Verify",
        "params": [],
        "path": "go/crypto/ecdsa/index#Verify",
        "syntax": "func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool",
        "type": "crypto"
    },
    "elf.Chdr32": {
        "descr": "ELF32 Compression header.",
        "name": "elf.Chdr32",
        "params": [],
        "path": "go/debug/elf/index#Chdr32",
        "syntax": "type Chdr32 struct { Type uint32 Size uint32 Addralign uint32 }",
        "type": "debug"
    },
    "elf.Chdr64": {
        "descr": "ELF64 Compression header.",
        "name": "elf.Chdr64",
        "params": [],
        "path": "go/debug/elf/index#Chdr64",
        "syntax": "type Chdr64 struct { Type uint32 Size uint64 Addralign uint64 // contains filtered or unexported fields }",
        "type": "debug"
    },
    "elf.Class": {
        "descr": "Class is found in Header.Ident[EI_CLASS] and Header.Class.",
        "name": "elf.Class",
        "params": [],
        "path": "go/debug/elf/index#Class",
        "syntax": "type Class byte",
        "type": "debug"
    },
    "elf.Class.GoString": {
        "descr": "",
        "name": "elf.Class.GoString",
        "params": [],
        "path": "go/debug/elf/index#Class.GoString",
        "syntax": "func (i Class) GoString() string",
        "type": "debug"
    },
    "elf.Class.String": {
        "descr": "",
        "name": "elf.Class.String",
        "params": [],
        "path": "go/debug/elf/index#Class.String",
        "syntax": "func (i Class) String() string",
        "type": "debug"
    },
    "elf.CompressionType": {
        "descr": "Section compression type.",
        "name": "elf.CompressionType",
        "params": [],
        "path": "go/debug/elf/index#CompressionType",
        "syntax": "type CompressionType int",
        "type": "debug"
    },
    "elf.CompressionType.GoString": {
        "descr": "",
        "name": "elf.CompressionType.GoString",
        "params": [],
        "path": "go/debug/elf/index#CompressionType.GoString",
        "syntax": "func (i CompressionType) GoString() string",
        "type": "debug"
    },
    "elf.CompressionType.String": {
        "descr": "",
        "name": "elf.CompressionType.String",
        "params": [],
        "path": "go/debug/elf/index#CompressionType.String",
        "syntax": "func (i CompressionType) String() string",
        "type": "debug"
    },
    "elf.Data": {
        "descr": "Data is found in Header.Ident[EI_DATA] and Header.Data.",
        "name": "elf.Data",
        "params": [],
        "path": "go/debug/elf/index#Data",
        "syntax": "type Data byte",
        "type": "debug"
    },
    "elf.Data.GoString": {
        "descr": "",
        "name": "elf.Data.GoString",
        "params": [],
        "path": "go/debug/elf/index#Data.GoString",
        "syntax": "func (i Data) GoString() string",
        "type": "debug"
    },
    "elf.Data.String": {
        "descr": "",
        "name": "elf.Data.String",
        "params": [],
        "path": "go/debug/elf/index#Data.String",
        "syntax": "func (i Data) String() string",
        "type": "debug"
    },
    "elf.Dyn32": {
        "descr": "ELF32 Dynamic structure. The \".dynamic\" section contains an array of them.",
        "name": "elf.Dyn32",
        "params": [],
        "path": "go/debug/elf/index#Dyn32",
        "syntax": "type Dyn32 struct { Tag int32 /* Entry type. */ Val uint32 /* Integer/Address value. */ }",
        "type": "debug"
    },
    "elf.Dyn64": {
        "descr": "ELF64 Dynamic structure. The \".dynamic\" section contains an array of them.",
        "name": "elf.Dyn64",
        "params": [],
        "path": "go/debug/elf/index#Dyn64",
        "syntax": "type Dyn64 struct { Tag int64 /* Entry type. */ Val uint64 /* Integer/address value */ }",
        "type": "debug"
    },
    "elf.DynFlag": {
        "descr": "DT_FLAGS values.",
        "name": "elf.DynFlag",
        "params": [],
        "path": "go/debug/elf/index#DynFlag",
        "syntax": "type DynFlag int",
        "type": "debug"
    },
    "elf.DynFlag.GoString": {
        "descr": "",
        "name": "elf.DynFlag.GoString",
        "params": [],
        "path": "go/debug/elf/index#DynFlag.GoString",
        "syntax": "func (i DynFlag) GoString() string",
        "type": "debug"
    },
    "elf.DynFlag.String": {
        "descr": "",
        "name": "elf.DynFlag.String",
        "params": [],
        "path": "go/debug/elf/index#DynFlag.String",
        "syntax": "func (i DynFlag) String() string",
        "type": "debug"
    },
    "elf.DynTag": {
        "descr": "Dyn.Tag",
        "name": "elf.DynTag",
        "params": [],
        "path": "go/debug/elf/index#DynTag",
        "syntax": "type DynTag int",
        "type": "debug"
    },
    "elf.DynTag.GoString": {
        "descr": "",
        "name": "elf.DynTag.GoString",
        "params": [],
        "path": "go/debug/elf/index#DynTag.GoString",
        "syntax": "func (i DynTag) GoString() string",
        "type": "debug"
    },
    "elf.DynTag.String": {
        "descr": "",
        "name": "elf.DynTag.String",
        "params": [],
        "path": "go/debug/elf/index#DynTag.String",
        "syntax": "func (i DynTag) String() string",
        "type": "debug"
    },
    "elf.File": {
        "descr": "A File represents an open ELF file.",
        "name": "elf.File",
        "params": [],
        "path": "go/debug/elf/index#File",
        "syntax": "type File struct { FileHeader Sections []*Section Progs []*Prog // contains filtered or unexported fields }",
        "type": "debug"
    },
    "elf.File.Close": {
        "descr": "Close closes the File. If the File was created using NewFile directly instead of Open, Close has no effect.",
        "name": "elf.File.Close",
        "params": [],
        "path": "go/debug/elf/index#File.Close",
        "syntax": "func (f *File) Close() error",
        "type": "debug"
    },
    "elf.File.DWARF": {
        "descr": "",
        "name": "elf.File.DWARF",
        "params": [],
        "path": "go/debug/elf/index#File.DWARF",
        "syntax": "func (f *File) DWARF() (*dwarf.Data, error)",
        "type": "debug"
    },
    "elf.File.DynString": {
        "descr": "DynString returns the strings listed for the given tag in the file's dynamic section.",
        "name": "elf.File.DynString",
        "params": [],
        "path": "go/debug/elf/index#File.DynString",
        "syntax": "func (f *File) DynString(tag DynTag) ([]string, error)",
        "type": "debug"
    },
    "elf.File.DynamicSymbols": {
        "descr": "DynamicSymbols returns the dynamic symbol table for f. The symbols will be listed in the order they appear in f.",
        "name": "elf.File.DynamicSymbols",
        "params": [],
        "path": "go/debug/elf/index#File.DynamicSymbols",
        "syntax": "func (f *File) DynamicSymbols() ([]Symbol, error)",
        "type": "debug"
    },
    "elf.File.ImportedLibraries": {
        "descr": "ImportedLibraries returns the names of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time.",
        "name": "elf.File.ImportedLibraries",
        "params": [],
        "path": "go/debug/elf/index#File.ImportedLibraries",
        "syntax": "func (f *File) ImportedLibraries() ([]string, error)",
        "type": "debug"
    },
    "elf.File.ImportedSymbols": {
        "descr": "ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time. It does not return weak symbols.",
        "name": "elf.File.ImportedSymbols",
        "params": [],
        "path": "go/debug/elf/index#File.ImportedSymbols",
        "syntax": "func (f *File) ImportedSymbols() ([]ImportedSymbol, error)",
        "type": "debug"
    },
    "elf.File.Section": {
        "descr": "Section returns a section with the given name, or nil if no such section exists.",
        "name": "elf.File.Section",
        "params": [],
        "path": "go/debug/elf/index#File.Section",
        "syntax": "func (f *File) Section(name string) *Section",
        "type": "debug"
    },
    "elf.File.SectionByType": {
        "descr": "SectionByType returns the first section in f with the given type, or nil if there is no such section.",
        "name": "elf.File.SectionByType",
        "params": [],
        "path": "go/debug/elf/index#File.SectionByType",
        "syntax": "func (f *File) SectionByType(typ SectionType) *Section",
        "type": "debug"
    },
    "elf.File.Symbols": {
        "descr": "Symbols returns the symbol table for f. The symbols will be listed in the order they appear in f.",
        "name": "elf.File.Symbols",
        "params": [],
        "path": "go/debug/elf/index#File.Symbols",
        "syntax": "func (f *File) Symbols() ([]Symbol, error)",
        "type": "debug"
    },
    "elf.FileHeader": {
        "descr": "A FileHeader represents an ELF file header.",
        "name": "elf.FileHeader",
        "params": [],
        "path": "go/debug/elf/index#FileHeader",
        "syntax": "type FileHeader struct { Class Class Data Data Version Version OSABI OSABI ABIVersion uint8 ByteOrder binary.ByteOrder Type Type Machine Machine Entry uint64 // Go 1.1 }",
        "type": "debug"
    },
    "elf.FormatError": {
        "descr": "",
        "name": "elf.FormatError",
        "params": [],
        "path": "go/debug/elf/index#FormatError",
        "syntax": "type FormatError struct { // contains filtered or unexported fields }",
        "type": "debug"
    },
    "elf.FormatError.Error": {
        "descr": "",
        "name": "elf.FormatError.Error",
        "params": [],
        "path": "go/debug/elf/index#FormatError.Error",
        "syntax": "func (e *FormatError) Error() string",
        "type": "debug"
    },
    "elf.Header32": {
        "descr": "ELF32 File header.",
        "name": "elf.Header32",
        "params": [],
        "path": "go/debug/elf/index#Header32",
        "syntax": "type Header32 struct { Ident [EI_NIDENT]byte /* File identification. */ Type uint16 /* File type. */ Machine uint16 /* Machine architecture. */ Version uint32 /* ELF format version. */ Entry uint32 /* Entry point. */ Phoff uint32 /* Program header file offset. */ Shoff uint32 /* Section header file offset. */ Flags uint32 /* Architecture-specific flags. */ Ehsize uint16 /* Size of ELF header in bytes. */ Phentsize uint16 /* Size of program header entry. */ Phnum uint16 /* Number of program header entries. */ Shentsize uint16 /* Size of section header entry. */ Shnum uint16 /* Number of section header entries. */ Shstrndx uint16 /* Section name strings section. */ }",
        "type": "debug"
    },
    "elf.Header64": {
        "descr": "ELF64 file header.",
        "name": "elf.Header64",
        "params": [],
        "path": "go/debug/elf/index#Header64",
        "syntax": "type Header64 struct { Ident [EI_NIDENT]byte /* File identification. */ Type uint16 /* File type. */ Machine uint16 /* Machine architecture. */ Version uint32 /* ELF format version. */ Entry uint64 /* Entry point. */ Phoff uint64 /* Program header file offset. */ Shoff uint64 /* Section header file offset. */ Flags uint32 /* Architecture-specific flags. */ Ehsize uint16 /* Size of ELF header in bytes. */ Phentsize uint16 /* Size of program header entry. */ Phnum uint16 /* Number of program header entries. */ Shentsize uint16 /* Size of section header entry. */ Shnum uint16 /* Number of section header entries. */ Shstrndx uint16 /* Section name strings section. */ }",
        "type": "debug"
    },
    "elf.ImportedSymbol": {
        "descr": "",
        "name": "elf.ImportedSymbol",
        "params": [],
        "path": "go/debug/elf/index#ImportedSymbol",
        "syntax": "type ImportedSymbol struct { Name string Version string Library string }",
        "type": "debug"
    },
    "elf.Machine": {
        "descr": "Machine is found in Header.Machine.",
        "name": "elf.Machine",
        "params": [],
        "path": "go/debug/elf/index#Machine",
        "syntax": "type Machine uint16",
        "type": "debug"
    },
    "elf.Machine.GoString": {
        "descr": "",
        "name": "elf.Machine.GoString",
        "params": [],
        "path": "go/debug/elf/index#Machine.GoString",
        "syntax": "func (i Machine) GoString() string",
        "type": "debug"
    },
    "elf.Machine.String": {
        "descr": "",
        "name": "elf.Machine.String",
        "params": [],
        "path": "go/debug/elf/index#Machine.String",
        "syntax": "func (i Machine) String() string",
        "type": "debug"
    },
    "elf.NType": {
        "descr": "NType values; used in core files.",
        "name": "elf.NType",
        "params": [],
        "path": "go/debug/elf/index#NType",
        "syntax": "type NType int",
        "type": "debug"
    },
    "elf.NType.GoString": {
        "descr": "",
        "name": "elf.NType.GoString",
        "params": [],
        "path": "go/debug/elf/index#NType.GoString",
        "syntax": "func (i NType) GoString() string",
        "type": "debug"
    },
    "elf.NType.String": {
        "descr": "",
        "name": "elf.NType.String",
        "params": [],
        "path": "go/debug/elf/index#NType.String",
        "syntax": "func (i NType) String() string",
        "type": "debug"
    },
    "elf.NewFile": {
        "descr": "NewFile creates a new File for accessing an ELF binary in an underlying reader. The ELF binary is expected to start at position 0 in the ReaderAt.",
        "name": "elf.NewFile",
        "params": [],
        "path": "go/debug/elf/index#NewFile",
        "syntax": "func NewFile(r io.ReaderAt) (*File, error)",
        "type": "debug"
    },
    "elf.OSABI": {
        "descr": "OSABI is found in Header.Ident[EI_OSABI] and Header.OSABI.",
        "name": "elf.OSABI",
        "params": [],
        "path": "go/debug/elf/index#OSABI",
        "syntax": "type OSABI byte",
        "type": "debug"
    },
    "elf.OSABI.GoString": {
        "descr": "",
        "name": "elf.OSABI.GoString",
        "params": [],
        "path": "go/debug/elf/index#OSABI.GoString",
        "syntax": "func (i OSABI) GoString() string",
        "type": "debug"
    },
    "elf.OSABI.String": {
        "descr": "",
        "name": "elf.OSABI.String",
        "params": [],
        "path": "go/debug/elf/index#OSABI.String",
        "syntax": "func (i OSABI) String() string",
        "type": "debug"
    },
    "elf.Open": {
        "descr": "Open opens the named file using os.Open and prepares it for use as an ELF binary.",
        "name": "elf.Open",
        "params": [],
        "path": "go/debug/elf/index#Open",
        "syntax": "func Open(name string) (*File, error)",
        "type": "debug"
    },
    "elf.Prog": {
        "descr": "A Prog represents a single ELF program header in an ELF binary.",
        "name": "elf.Prog",
        "params": [],
        "path": "go/debug/elf/index#Prog",
        "syntax": "type Prog struct { ProgHeader // Embed ReaderAt for ReadAt method. // Do not embed SectionReader directly // to avoid having Read and Seek. // If a client wants Read and Seek it must use // Open() to avoid fighting over the seek offset // with other clients. io.ReaderAt // contains filtered or unexported fields }",
        "type": "debug"
    },
    "elf.Prog.Open": {
        "descr": "Open returns a new ReadSeeker reading the ELF program body.",
        "name": "elf.Prog.Open",
        "params": [],
        "path": "go/debug/elf/index#Prog.Open",
        "syntax": "func (p *Prog) Open() io.ReadSeeker",
        "type": "debug"
    },
    "elf.Prog32": {
        "descr": "ELF32 Program header.",
        "name": "elf.Prog32",
        "params": [],
        "path": "go/debug/elf/index#Prog32",
        "syntax": "type Prog32 struct { Type uint32 /* Entry type. */ Off uint32 /* File offset of contents. */ Vaddr uint32 /* Virtual address in memory image. */ Paddr uint32 /* Physical address (not used). */ Filesz uint32 /* Size of contents in file. */ Memsz uint32 /* Size of contents in memory. */ Flags uint32 /* Access permission flags. */ Align uint32 /* Alignment in memory and file. */ }",
        "type": "debug"
    },
    "elf.Prog64": {
        "descr": "ELF64 Program header.",
        "name": "elf.Prog64",
        "params": [],
        "path": "go/debug/elf/index#Prog64",
        "syntax": "type Prog64 struct { Type uint32 /* Entry type. */ Flags uint32 /* Access permission flags. */ Off uint64 /* File offset of contents. */ Vaddr uint64 /* Virtual address in memory image. */ Paddr uint64 /* Physical address (not used). */ Filesz uint64 /* Size of contents in file. */ Memsz uint64 /* Size of contents in memory. */ Align uint64 /* Alignment in memory and file. */ }",
        "type": "debug"
    },
    "elf.ProgFlag": {
        "descr": "Prog.Flag",
        "name": "elf.ProgFlag",
        "params": [],
        "path": "go/debug/elf/index#ProgFlag",
        "syntax": "type ProgFlag uint32",
        "type": "debug"
    },
    "elf.ProgFlag.GoString": {
        "descr": "",
        "name": "elf.ProgFlag.GoString",
        "params": [],
        "path": "go/debug/elf/index#ProgFlag.GoString",
        "syntax": "func (i ProgFlag) GoString() string",
        "type": "debug"
    },
    "elf.ProgFlag.String": {
        "descr": "",
        "name": "elf.ProgFlag.String",
        "params": [],
        "path": "go/debug/elf/index#ProgFlag.String",
        "syntax": "func (i ProgFlag) String() string",
        "type": "debug"
    },
    "elf.ProgHeader": {
        "descr": "A ProgHeader represents a single ELF program header.",
        "name": "elf.ProgHeader",
        "params": [],
        "path": "go/debug/elf/index#ProgHeader",
        "syntax": "type ProgHeader struct { Type ProgType Flags ProgFlag Off uint64 Vaddr uint64 Paddr uint64 Filesz uint64 Memsz uint64 Align uint64 }",
        "type": "debug"
    },
    "elf.ProgType": {
        "descr": "Prog.Type",
        "name": "elf.ProgType",
        "params": [],
        "path": "go/debug/elf/index#ProgType",
        "syntax": "type ProgType int",
        "type": "debug"
    },
    "elf.ProgType.GoString": {
        "descr": "",
        "name": "elf.ProgType.GoString",
        "params": [],
        "path": "go/debug/elf/index#ProgType.GoString",
        "syntax": "func (i ProgType) GoString() string",
        "type": "debug"
    },
    "elf.ProgType.String": {
        "descr": "",
        "name": "elf.ProgType.String",
        "params": [],
        "path": "go/debug/elf/index#ProgType.String",
        "syntax": "func (i ProgType) String() string",
        "type": "debug"
    },
    "elf.R_386": {
        "descr": "Relocation types for 386.",
        "name": "elf.R_386",
        "params": [],
        "path": "go/debug/elf/index#R_386",
        "syntax": "type R_386 int",
        "type": "debug"
    },
    "elf.R_386.GoString": {
        "descr": "",
        "name": "elf.R_386.GoString",
        "params": [],
        "path": "go/debug/elf/index#R_386.GoString",
        "syntax": "func (i R_386) GoString() string",
        "type": "debug"
    },
    "elf.R_386.String": {
        "descr": "",
        "name": "elf.R_386.String",
        "params": [],
        "path": "go/debug/elf/index#R_386.String",
        "syntax": "func (i R_386) String() string",
        "type": "debug"
    },
    "elf.R_390": {
        "descr": "Relocation types for s390x processors.",
        "name": "elf.R_390",
        "params": [],
        "path": "go/debug/elf/index#R_390",
        "syntax": "type R_390 int",
        "type": "debug"
    },
    "elf.R_390.GoString": {
        "descr": "",
        "name": "elf.R_390.GoString",
        "params": [],
        "path": "go/debug/elf/index#R_390.GoString",
        "syntax": "func (i R_390) GoString() string",
        "type": "debug"
    },
    "elf.R_390.String": {
        "descr": "",
        "name": "elf.R_390.String",
        "params": [],
        "path": "go/debug/elf/index#R_390.String",
        "syntax": "func (i R_390) String() string",
        "type": "debug"
    },
    "elf.R_AARCH64": {
        "descr": "Relocation types for AArch64 (aka arm64)",
        "name": "elf.R_AARCH64",
        "params": [],
        "path": "go/debug/elf/index#R_AARCH64",
        "syntax": "type R_AARCH64 int",
        "type": "debug"
    },
    "elf.R_AARCH64.GoString": {
        "descr": "",
        "name": "elf.R_AARCH64.GoString",
        "params": [],
        "path": "go/debug/elf/index#R_AARCH64.GoString",
        "syntax": "func (i R_AARCH64) GoString() string",
        "type": "debug"
    },
    "elf.R_AARCH64.String": {
        "descr": "",
        "name": "elf.R_AARCH64.String",
        "params": [],
        "path": "go/debug/elf/index#R_AARCH64.String",
        "syntax": "func (i R_AARCH64) String() string",
        "type": "debug"
    },
    "elf.R_ALPHA": {
        "descr": "Relocation types for Alpha.",
        "name": "elf.R_ALPHA",
        "params": [],
        "path": "go/debug/elf/index#R_ALPHA",
        "syntax": "type R_ALPHA int",
        "type": "debug"
    },
    "elf.R_ALPHA.GoString": {
        "descr": "",
        "name": "elf.R_ALPHA.GoString",
        "params": [],
        "path": "go/debug/elf/index#R_ALPHA.GoString",
        "syntax": "func (i R_ALPHA) GoString() string",
        "type": "debug"
    },
    "elf.R_ALPHA.String": {
        "descr": "",
        "name": "elf.R_ALPHA.String",
        "params": [],
        "path": "go/debug/elf/index#R_ALPHA.String",
        "syntax": "func (i R_ALPHA) String() string",
        "type": "debug"
    },
    "elf.R_ARM": {
        "descr": "Relocation types for ARM.",
        "name": "elf.R_ARM",
        "params": [],
        "path": "go/debug/elf/index#R_ARM",
        "syntax": "type R_ARM int",
        "type": "debug"
    },
    "elf.R_ARM.GoString": {
        "descr": "",
        "name": "elf.R_ARM.GoString",
        "params": [],
        "path": "go/debug/elf/index#R_ARM.GoString",
        "syntax": "func (i R_ARM) GoString() string",
        "type": "debug"
    },
    "elf.R_ARM.String": {
        "descr": "",
        "name": "elf.R_ARM.String",
        "params": [],
        "path": "go/debug/elf/index#R_ARM.String",
        "syntax": "func (i R_ARM) String() string",
        "type": "debug"
    },
    "elf.R_INFO": {
        "descr": "",
        "name": "elf.R_INFO",
        "params": [],
        "path": "go/debug/elf/index#R_INFO",
        "syntax": "func R_INFO(sym, typ uint32) uint64",
        "type": "debug"
    },
    "elf.R_INFO32": {
        "descr": "",
        "name": "elf.R_INFO32",
        "params": [],
        "path": "go/debug/elf/index#R_INFO32",
        "syntax": "func R_INFO32(sym, typ uint32) uint32",
        "type": "debug"
    },
    "elf.R_MIPS": {
        "descr": "Relocation types for MIPS.",
        "name": "elf.R_MIPS",
        "params": [],
        "path": "go/debug/elf/index#R_MIPS",
        "syntax": "type R_MIPS int",
        "type": "debug"
    },
    "elf.R_MIPS.GoString": {
        "descr": "",
        "name": "elf.R_MIPS.GoString",
        "params": [],
        "path": "go/debug/elf/index#R_MIPS.GoString",
        "syntax": "func (i R_MIPS) GoString() string",
        "type": "debug"
    },
    "elf.R_MIPS.String": {
        "descr": "",
        "name": "elf.R_MIPS.String",
        "params": [],
        "path": "go/debug/elf/index#R_MIPS.String",
        "syntax": "func (i R_MIPS) String() string",
        "type": "debug"
    },
    "elf.R_PPC": {
        "descr": "Relocation types for PowerPC.",
        "name": "elf.R_PPC",
        "params": [],
        "path": "go/debug/elf/index#R_PPC",
        "syntax": "type R_PPC int",
        "type": "debug"
    },
    "elf.R_PPC.GoString": {
        "descr": "",
        "name": "elf.R_PPC.GoString",
        "params": [],
        "path": "go/debug/elf/index#R_PPC.GoString",
        "syntax": "func (i R_PPC) GoString() string",
        "type": "debug"
    },
    "elf.R_PPC.String": {
        "descr": "",
        "name": "elf.R_PPC.String",
        "params": [],
        "path": "go/debug/elf/index#R_PPC.String",
        "syntax": "func (i R_PPC) String() string",
        "type": "debug"
    },
    "elf.R_PPC64": {
        "descr": "Relocation types for 64-bit PowerPC or Power Architecture processors.",
        "name": "elf.R_PPC64",
        "params": [],
        "path": "go/debug/elf/index#R_PPC64",
        "syntax": "type R_PPC64 int",
        "type": "debug"
    },
    "elf.R_PPC64.GoString": {
        "descr": "",
        "name": "elf.R_PPC64.GoString",
        "params": [],
        "path": "go/debug/elf/index#R_PPC64.GoString",
        "syntax": "func (i R_PPC64) GoString() string",
        "type": "debug"
    },
    "elf.R_PPC64.String": {
        "descr": "",
        "name": "elf.R_PPC64.String",
        "params": [],
        "path": "go/debug/elf/index#R_PPC64.String",
        "syntax": "func (i R_PPC64) String() string",
        "type": "debug"
    },
    "elf.R_RISCV": {
        "descr": "Relocation types for RISC-V processors.",
        "name": "elf.R_RISCV",
        "params": [],
        "path": "go/debug/elf/index#R_RISCV",
        "syntax": "type R_RISCV int",
        "type": "debug"
    },
    "elf.R_RISCV.GoString": {
        "descr": "",
        "name": "elf.R_RISCV.GoString",
        "params": [],
        "path": "go/debug/elf/index#R_RISCV.GoString",
        "syntax": "func (i R_RISCV) GoString() string",
        "type": "debug"
    },
    "elf.R_RISCV.String": {
        "descr": "",
        "name": "elf.R_RISCV.String",
        "params": [],
        "path": "go/debug/elf/index#R_RISCV.String",
        "syntax": "func (i R_RISCV) String() string",
        "type": "debug"
    },
    "elf.R_SPARC": {
        "descr": "Relocation types for SPARC.",
        "name": "elf.R_SPARC",
        "params": [],
        "path": "go/debug/elf/index#R_SPARC",
        "syntax": "type R_SPARC int",
        "type": "debug"
    },
    "elf.R_SPARC.GoString": {
        "descr": "",
        "name": "elf.R_SPARC.GoString",
        "params": [],
        "path": "go/debug/elf/index#R_SPARC.GoString",
        "syntax": "func (i R_SPARC) GoString() string",
        "type": "debug"
    },
    "elf.R_SPARC.String": {
        "descr": "",
        "name": "elf.R_SPARC.String",
        "params": [],
        "path": "go/debug/elf/index#R_SPARC.String",
        "syntax": "func (i R_SPARC) String() string",
        "type": "debug"
    },
    "elf.R_SYM32": {
        "descr": "",
        "name": "elf.R_SYM32",
        "params": [],
        "path": "go/debug/elf/index#R_SYM32",
        "syntax": "func R_SYM32(info uint32) uint32",
        "type": "debug"
    },
    "elf.R_SYM64": {
        "descr": "",
        "name": "elf.R_SYM64",
        "params": [],
        "path": "go/debug/elf/index#R_SYM64",
        "syntax": "func R_SYM64(info uint64) uint32",
        "type": "debug"
    },
    "elf.R_TYPE32": {
        "descr": "",
        "name": "elf.R_TYPE32",
        "params": [],
        "path": "go/debug/elf/index#R_TYPE32",
        "syntax": "func R_TYPE32(info uint32) uint32",
        "type": "debug"
    },
    "elf.R_TYPE64": {
        "descr": "",
        "name": "elf.R_TYPE64",
        "params": [],
        "path": "go/debug/elf/index#R_TYPE64",
        "syntax": "func R_TYPE64(info uint64) uint32",
        "type": "debug"
    },
    "elf.R_X86_64": {
        "descr": "Relocation types for x86-64.",
        "name": "elf.R_X86_64",
        "params": [],
        "path": "go/debug/elf/index#R_X86_64",
        "syntax": "type R_X86_64 int",
        "type": "debug"
    },
    "elf.R_X86_64.GoString": {
        "descr": "",
        "name": "elf.R_X86_64.GoString",
        "params": [],
        "path": "go/debug/elf/index#R_X86_64.GoString",
        "syntax": "func (i R_X86_64) GoString() string",
        "type": "debug"
    },
    "elf.R_X86_64.String": {
        "descr": "",
        "name": "elf.R_X86_64.String",
        "params": [],
        "path": "go/debug/elf/index#R_X86_64.String",
        "syntax": "func (i R_X86_64) String() string",
        "type": "debug"
    },
    "elf.Rel32": {
        "descr": "ELF32 Relocations that don't need an addend field.",
        "name": "elf.Rel32",
        "params": [],
        "path": "go/debug/elf/index#Rel32",
        "syntax": "type Rel32 struct { Off uint32 /* Location to be relocated. */ Info uint32 /* Relocation type and symbol index. */ }",
        "type": "debug"
    },
    "elf.Rel64": {
        "descr": "ELF64 relocations that don't need an addend field.",
        "name": "elf.Rel64",
        "params": [],
        "path": "go/debug/elf/index#Rel64",
        "syntax": "type Rel64 struct { Off uint64 /* Location to be relocated. */ Info uint64 /* Relocation type and symbol index. */ }",
        "type": "debug"
    },
    "elf.Rela32": {
        "descr": "ELF32 Relocations that need an addend field.",
        "name": "elf.Rela32",
        "params": [],
        "path": "go/debug/elf/index#Rela32",
        "syntax": "type Rela32 struct { Off uint32 /* Location to be relocated. */ Info uint32 /* Relocation type and symbol index. */ Addend int32 /* Addend. */ }",
        "type": "debug"
    },
    "elf.Rela64": {
        "descr": "ELF64 relocations that need an addend field.",
        "name": "elf.Rela64",
        "params": [],
        "path": "go/debug/elf/index#Rela64",
        "syntax": "type Rela64 struct { Off uint64 /* Location to be relocated. */ Info uint64 /* Relocation type and symbol index. */ Addend int64 /* Addend. */ }",
        "type": "debug"
    },
    "elf.ST_BIND": {
        "descr": "",
        "name": "elf.ST_BIND",
        "params": [],
        "path": "go/debug/elf/index#ST_BIND",
        "syntax": "func ST_BIND(info uint8) SymBind",
        "type": "debug"
    },
    "elf.ST_INFO": {
        "descr": "",
        "name": "elf.ST_INFO",
        "params": [],
        "path": "go/debug/elf/index#ST_INFO",
        "syntax": "func ST_INFO(bind SymBind, typ SymType) uint8",
        "type": "debug"
    },
    "elf.ST_TYPE": {
        "descr": "",
        "name": "elf.ST_TYPE",
        "params": [],
        "path": "go/debug/elf/index#ST_TYPE",
        "syntax": "func ST_TYPE(info uint8) SymType",
        "type": "debug"
    },
    "elf.ST_VISIBILITY": {
        "descr": "",
        "name": "elf.ST_VISIBILITY",
        "params": [],
        "path": "go/debug/elf/index#ST_VISIBILITY",
        "syntax": "func ST_VISIBILITY(other uint8) SymVis",
        "type": "debug"
    },
    "elf.Section": {
        "descr": "A Section represents a single section in an ELF file.",
        "name": "elf.Section",
        "params": [],
        "path": "go/debug/elf/index#Section",
        "syntax": "type Section struct { SectionHeader // Embed ReaderAt for ReadAt method. // Do not embed SectionReader directly // to avoid having Read and Seek. // If a client wants Read and Seek it must use // Open() to avoid fighting over the seek offset // with other clients. // // ReaderAt may be nil if the section is not easily available // in a random-access form. For example, a compressed section // may have a nil ReaderAt. io.ReaderAt // contains filtered or unexported fields }",
        "type": "debug"
    },
    "elf.Section.Data": {
        "descr": "Data reads and returns the contents of the ELF section. Even if the section is stored compressed in the ELF file, Data returns uncompressed data.",
        "name": "elf.Section.Data",
        "params": [],
        "path": "go/debug/elf/index#Section.Data",
        "syntax": "func (s *Section) Data() ([]byte, error)",
        "type": "debug"
    },
    "elf.Section.Open": {
        "descr": "Open returns a new ReadSeeker reading the ELF section. Even if the section is stored compressed in the ELF file, the ReadSeeker reads uncompressed data.",
        "name": "elf.Section.Open",
        "params": [],
        "path": "go/debug/elf/index#Section.Open",
        "syntax": "func (s *Section) Open() io.ReadSeeker",
        "type": "debug"
    },
    "elf.Section32": {
        "descr": "ELF32 Section header.",
        "name": "elf.Section32",
        "params": [],
        "path": "go/debug/elf/index#Section32",
        "syntax": "type Section32 struct { Name uint32 /* Section name (index into the section header string table). */ Type uint32 /* Section type. */ Flags uint32 /* Section flags. */ Addr uint32 /* Address in memory image. */ Off uint32 /* Offset in file. */ Size uint32 /* Size in bytes. */ Link uint32 /* Index of a related section. */ Info uint32 /* Depends on section type. */ Addralign uint32 /* Alignment in bytes. */ Entsize uint32 /* Size of each entry in section. */ }",
        "type": "debug"
    },
    "elf.Section64": {
        "descr": "ELF64 Section header.",
        "name": "elf.Section64",
        "params": [],
        "path": "go/debug/elf/index#Section64",
        "syntax": "type Section64 struct { Name uint32 /* Section name (index into the section header string table). */ Type uint32 /* Section type. */ Flags uint64 /* Section flags. */ Addr uint64 /* Address in memory image. */ Off uint64 /* Offset in file. */ Size uint64 /* Size in bytes. */ Link uint32 /* Index of a related section. */ Info uint32 /* Depends on section type. */ Addralign uint64 /* Alignment in bytes. */ Entsize uint64 /* Size of each entry in section. */ }",
        "type": "debug"
    },
    "elf.SectionFlag": {
        "descr": "Section flags.",
        "name": "elf.SectionFlag",
        "params": [],
        "path": "go/debug/elf/index#SectionFlag",
        "syntax": "type SectionFlag uint32",
        "type": "debug"
    },
    "elf.SectionFlag.GoString": {
        "descr": "",
        "name": "elf.SectionFlag.GoString",
        "params": [],
        "path": "go/debug/elf/index#SectionFlag.GoString",
        "syntax": "func (i SectionFlag) GoString() string",
        "type": "debug"
    },
    "elf.SectionFlag.String": {
        "descr": "",
        "name": "elf.SectionFlag.String",
        "params": [],
        "path": "go/debug/elf/index#SectionFlag.String",
        "syntax": "func (i SectionFlag) String() string",
        "type": "debug"
    },
    "elf.SectionHeader": {
        "descr": "A SectionHeader represents a single ELF section header.",
        "name": "elf.SectionHeader",
        "params": [],
        "path": "go/debug/elf/index#SectionHeader",
        "syntax": "type SectionHeader struct { Name string Type SectionType Flags SectionFlag Addr uint64 Offset uint64 Size uint64 Link uint32 Info uint32 Addralign uint64 Entsize uint64 // FileSize is the size of this section in the file in bytes. // If a section is compressed, FileSize is the size of the // compressed data, while Size (above) is the size of the // uncompressed data. FileSize uint64 // Go 1.6 }",
        "type": "debug"
    },
    "elf.SectionIndex": {
        "descr": "Special section indices.",
        "name": "elf.SectionIndex",
        "params": [],
        "path": "go/debug/elf/index#SectionIndex",
        "syntax": "type SectionIndex int",
        "type": "debug"
    },
    "elf.SectionIndex.GoString": {
        "descr": "",
        "name": "elf.SectionIndex.GoString",
        "params": [],
        "path": "go/debug/elf/index#SectionIndex.GoString",
        "syntax": "func (i SectionIndex) GoString() string",
        "type": "debug"
    },
    "elf.SectionIndex.String": {
        "descr": "",
        "name": "elf.SectionIndex.String",
        "params": [],
        "path": "go/debug/elf/index#SectionIndex.String",
        "syntax": "func (i SectionIndex) String() string",
        "type": "debug"
    },
    "elf.SectionType": {
        "descr": "Section type.",
        "name": "elf.SectionType",
        "params": [],
        "path": "go/debug/elf/index#SectionType",
        "syntax": "type SectionType uint32",
        "type": "debug"
    },
    "elf.SectionType.GoString": {
        "descr": "",
        "name": "elf.SectionType.GoString",
        "params": [],
        "path": "go/debug/elf/index#SectionType.GoString",
        "syntax": "func (i SectionType) GoString() string",
        "type": "debug"
    },
    "elf.SectionType.String": {
        "descr": "",
        "name": "elf.SectionType.String",
        "params": [],
        "path": "go/debug/elf/index#SectionType.String",
        "syntax": "func (i SectionType) String() string",
        "type": "debug"
    },
    "elf.Sym32": {
        "descr": "ELF32 Symbol.",
        "name": "elf.Sym32",
        "params": [],
        "path": "go/debug/elf/index#Sym32",
        "syntax": "type Sym32 struct { Name uint32 Value uint32 Size uint32 Info uint8 Other uint8 Shndx uint16 }",
        "type": "debug"
    },
    "elf.Sym64": {
        "descr": "ELF64 symbol table entries.",
        "name": "elf.Sym64",
        "params": [],
        "path": "go/debug/elf/index#Sym64",
        "syntax": "type Sym64 struct { Name uint32 /* String table index of name. */ Info uint8 /* Type and binding information. */ Other uint8 /* Reserved (not used). */ Shndx uint16 /* Section index of symbol. */ Value uint64 /* Symbol value. */ Size uint64 /* Size of associated object. */ }",
        "type": "debug"
    },
    "elf.SymBind": {
        "descr": "Symbol Binding - ELFNN_ST_BIND - st_info",
        "name": "elf.SymBind",
        "params": [],
        "path": "go/debug/elf/index#SymBind",
        "syntax": "type SymBind int",
        "type": "debug"
    },
    "elf.SymBind.GoString": {
        "descr": "",
        "name": "elf.SymBind.GoString",
        "params": [],
        "path": "go/debug/elf/index#SymBind.GoString",
        "syntax": "func (i SymBind) GoString() string",
        "type": "debug"
    },
    "elf.SymBind.String": {
        "descr": "",
        "name": "elf.SymBind.String",
        "params": [],
        "path": "go/debug/elf/index#SymBind.String",
        "syntax": "func (i SymBind) String() string",
        "type": "debug"
    },
    "elf.SymType": {
        "descr": "Symbol type - ELFNN_ST_TYPE - st_info",
        "name": "elf.SymType",
        "params": [],
        "path": "go/debug/elf/index#SymType",
        "syntax": "type SymType int",
        "type": "debug"
    },
    "elf.SymType.GoString": {
        "descr": "",
        "name": "elf.SymType.GoString",
        "params": [],
        "path": "go/debug/elf/index#SymType.GoString",
        "syntax": "func (i SymType) GoString() string",
        "type": "debug"
    },
    "elf.SymType.String": {
        "descr": "",
        "name": "elf.SymType.String",
        "params": [],
        "path": "go/debug/elf/index#SymType.String",
        "syntax": "func (i SymType) String() string",
        "type": "debug"
    },
    "elf.SymVis": {
        "descr": "Symbol visibility - ELFNN_ST_VISIBILITY - st_other",
        "name": "elf.SymVis",
        "params": [],
        "path": "go/debug/elf/index#SymVis",
        "syntax": "type SymVis int",
        "type": "debug"
    },
    "elf.SymVis.GoString": {
        "descr": "",
        "name": "elf.SymVis.GoString",
        "params": [],
        "path": "go/debug/elf/index#SymVis.GoString",
        "syntax": "func (i SymVis) GoString() string",
        "type": "debug"
    },
    "elf.SymVis.String": {
        "descr": "",
        "name": "elf.SymVis.String",
        "params": [],
        "path": "go/debug/elf/index#SymVis.String",
        "syntax": "func (i SymVis) String() string",
        "type": "debug"
    },
    "elf.Symbol": {
        "descr": "A Symbol represents an entry in an ELF symbol table section.",
        "name": "elf.Symbol",
        "params": [],
        "path": "go/debug/elf/index#Symbol",
        "syntax": "type Symbol struct { Name string Info, Other byte Section SectionIndex Value, Size uint64 }",
        "type": "debug"
    },
    "elf.Type": {
        "descr": "Type is found in Header.Type.",
        "name": "elf.Type",
        "params": [],
        "path": "go/debug/elf/index#Type",
        "syntax": "type Type uint16",
        "type": "debug"
    },
    "elf.Type.GoString": {
        "descr": "",
        "name": "elf.Type.GoString",
        "params": [],
        "path": "go/debug/elf/index#Type.GoString",
        "syntax": "func (i Type) GoString() string",
        "type": "debug"
    },
    "elf.Type.String": {
        "descr": "",
        "name": "elf.Type.String",
        "params": [],
        "path": "go/debug/elf/index#Type.String",
        "syntax": "func (i Type) String() string",
        "type": "debug"
    },
    "elf.Version": {
        "descr": "Version is found in Header.Ident[EI_VERSION] and Header.Version.",
        "name": "elf.Version",
        "params": [],
        "path": "go/debug/elf/index#Version",
        "syntax": "type Version byte",
        "type": "debug"
    },
    "elf.Version.GoString": {
        "descr": "",
        "name": "elf.Version.GoString",
        "params": [],
        "path": "go/debug/elf/index#Version.GoString",
        "syntax": "func (i Version) GoString() string",
        "type": "debug"
    },
    "elf.Version.String": {
        "descr": "",
        "name": "elf.Version.String",
        "params": [],
        "path": "go/debug/elf/index#Version.String",
        "syntax": "func (i Version) String() string",
        "type": "debug"
    },
    "elliptic.Curve": {
        "descr": "A Curve represents a short-form Weierstrass curve with a=-3. See https://www.hyperelliptic.org/EFD/g1p/auto-shortw.html",
        "name": "elliptic.Curve",
        "params": [],
        "path": "go/crypto/elliptic/index#Curve",
        "syntax": "type Curve interface { // Params returns the parameters for the curve. Params() *CurveParams // IsOnCurve reports whether the given (x,y) lies on the curve. IsOnCurve(x, y *big.Int) bool // Add returns the sum of (x1,y1) and (x2,y2) Add(x1, y1, x2, y2 *big.Int) (x, y *big.Int) // Double returns 2*(x,y) Double(x1, y1 *big.Int) (x, y *big.Int) // ScalarMult returns k*(Bx,By) where k is a number in big-endian form. ScalarMult(x1, y1 *big.Int, k []byte) (x, y *big.Int) // ScalarBaseMult returns k*G, where G is the base point of the group // and k is an integer in big-endian form. ScalarBaseMult(k []byte) (x, y *big.Int) }",
        "type": "crypto"
    },
    "elliptic.CurveParams": {
        "descr": "CurveParams contains the parameters of an elliptic curve and also provides a generic, non-constant time implementation of Curve.",
        "name": "elliptic.CurveParams",
        "params": [],
        "path": "go/crypto/elliptic/index#CurveParams",
        "syntax": "type CurveParams struct { P *big.Int // the order of the underlying field N *big.Int // the order of the base point B *big.Int // the constant of the curve equation Gx, Gy *big.Int // (x,y) of the base point BitSize int // the size of the underlying field Name string // the canonical name of the curve; added in Go 1.5 }",
        "type": "crypto"
    },
    "elliptic.CurveParams.Add": {
        "descr": "",
        "name": "elliptic.CurveParams.Add",
        "params": [],
        "path": "go/crypto/elliptic/index#CurveParams.Add",
        "syntax": "func (curve *CurveParams) Add(x1, y1, x2, y2 *big.Int) (*big.Int, *big.Int)",
        "type": "crypto"
    },
    "elliptic.CurveParams.Double": {
        "descr": "",
        "name": "elliptic.CurveParams.Double",
        "params": [],
        "path": "go/crypto/elliptic/index#CurveParams.Double",
        "syntax": "func (curve *CurveParams) Double(x1, y1 *big.Int) (*big.Int, *big.Int)",
        "type": "crypto"
    },
    "elliptic.CurveParams.IsOnCurve": {
        "descr": "",
        "name": "elliptic.CurveParams.IsOnCurve",
        "params": [],
        "path": "go/crypto/elliptic/index#CurveParams.IsOnCurve",
        "syntax": "func (curve *CurveParams) IsOnCurve(x, y *big.Int) bool",
        "type": "crypto"
    },
    "elliptic.CurveParams.Params": {
        "descr": "",
        "name": "elliptic.CurveParams.Params",
        "params": [],
        "path": "go/crypto/elliptic/index#CurveParams.Params",
        "syntax": "func (curve *CurveParams) Params() *CurveParams",
        "type": "crypto"
    },
    "elliptic.CurveParams.ScalarBaseMult": {
        "descr": "",
        "name": "elliptic.CurveParams.ScalarBaseMult",
        "params": [],
        "path": "go/crypto/elliptic/index#CurveParams.ScalarBaseMult",
        "syntax": "func (curve *CurveParams) ScalarBaseMult(k []byte) (*big.Int, *big.Int)",
        "type": "crypto"
    },
    "elliptic.CurveParams.ScalarMult": {
        "descr": "",
        "name": "elliptic.CurveParams.ScalarMult",
        "params": [],
        "path": "go/crypto/elliptic/index#CurveParams.ScalarMult",
        "syntax": "func (curve *CurveParams) ScalarMult(Bx, By *big.Int, k []byte) (*big.Int, *big.Int)",
        "type": "crypto"
    },
    "elliptic.GenerateKey": {
        "descr": "GenerateKey returns a public/private key pair. The private key is generated using the given reader, which must return random data.",
        "name": "elliptic.GenerateKey",
        "params": [],
        "path": "go/crypto/elliptic/index#GenerateKey",
        "syntax": "func GenerateKey(curve Curve, rand io.Reader) (priv []byte, x, y *big.Int, err error)",
        "type": "crypto"
    },
    "elliptic.Marshal": {
        "descr": "Marshal converts a point into the uncompressed form specified in section 4.3.6 of ANSI X9.62.",
        "name": "elliptic.Marshal",
        "params": [],
        "path": "go/crypto/elliptic/index#Marshal",
        "syntax": "func Marshal(curve Curve, x, y *big.Int) []byte",
        "type": "crypto"
    },
    "elliptic.P224": {
        "descr": "P224 returns a Curve which implements P-224 (see FIPS 186-3, section D.2.2).",
        "name": "elliptic.P224",
        "params": [],
        "path": "go/crypto/elliptic/index#P224",
        "syntax": "func P224() Curve",
        "type": "crypto"
    },
    "elliptic.P256": {
        "descr": "P256 returns a Curve which implements P-256 (see FIPS 186-3, section D.2.3)",
        "name": "elliptic.P256",
        "params": [],
        "path": "go/crypto/elliptic/index#P256",
        "syntax": "func P256() Curve",
        "type": "crypto"
    },
    "elliptic.P384": {
        "descr": "P384 returns a Curve which implements P-384 (see FIPS 186-3, section D.2.4)",
        "name": "elliptic.P384",
        "params": [],
        "path": "go/crypto/elliptic/index#P384",
        "syntax": "func P384() Curve",
        "type": "crypto"
    },
    "elliptic.P521": {
        "descr": "P521 returns a Curve which implements P-521 (see FIPS 186-3, section D.2.5)",
        "name": "elliptic.P521",
        "params": [],
        "path": "go/crypto/elliptic/index#P521",
        "syntax": "func P521() Curve",
        "type": "crypto"
    },
    "elliptic.Unmarshal": {
        "descr": "Unmarshal converts a point, serialized by Marshal, into an x, y pair. It is an error if the point is not in uncompressed form or is not on the curve. On error, x = nil.",
        "name": "elliptic.Unmarshal",
        "params": [],
        "path": "go/crypto/elliptic/index#Unmarshal",
        "syntax": "func Unmarshal(curve Curve, data []byte) (x, y *big.Int)",
        "type": "crypto"
    },
    "encoding.BinaryMarshaler": {
        "descr": "BinaryMarshaler is the interface implemented by an object that can marshal itself into a binary form.",
        "name": "encoding.BinaryMarshaler",
        "params": [],
        "path": "go/encoding/index#BinaryMarshaler",
        "syntax": "type BinaryMarshaler interface { MarshalBinary() (data []byte, err error) }",
        "type": "encoding"
    },
    "encoding.BinaryUnmarshaler": {
        "descr": "BinaryUnmarshaler is the interface implemented by an object that can unmarshal a binary representation of itself.",
        "name": "encoding.BinaryUnmarshaler",
        "params": [],
        "path": "go/encoding/index#BinaryUnmarshaler",
        "syntax": "type BinaryUnmarshaler interface { UnmarshalBinary(data []byte) error }",
        "type": "encoding"
    },
    "encoding.TextMarshaler": {
        "descr": "TextMarshaler is the interface implemented by an object that can marshal itself into a textual form.",
        "name": "encoding.TextMarshaler",
        "params": [],
        "path": "go/encoding/index#TextMarshaler",
        "syntax": "type TextMarshaler interface { MarshalText() (text []byte, err error) }",
        "type": "encoding"
    },
    "encoding.TextUnmarshaler": {
        "descr": "TextUnmarshaler is the interface implemented by an object that can unmarshal a textual representation of itself.",
        "name": "encoding.TextUnmarshaler",
        "params": [],
        "path": "go/encoding/index#TextUnmarshaler",
        "syntax": "type TextUnmarshaler interface { UnmarshalText(text []byte) error }",
        "type": "encoding"
    },
    "error": {
        "descr": "The error built-in interface type is the conventional interface for representing an error condition, with the nil value representing no error.",
        "name": "builtin.error",
        "params": [],
        "path": "go/builtin/index#error",
        "syntax": "type error interface { Error() string }",
        "type": "builtin"
    },
    "errors.New": {
        "descr": "New returns an error that formats as the given text.",
        "name": "errors.New",
        "params": [],
        "path": "go/errors/index#New",
        "syntax": "func New(text string) error",
        "type": "errors"
    },
    "exec.Cmd": {
        "descr": "Cmd represents an external command being prepared or run.",
        "name": "exec.Cmd",
        "params": [],
        "path": "go/os/exec/index#Cmd",
        "syntax": "type Cmd struct { // Path is the path of the command to run. // // This is the only field that must be set to a non-zero // value. If Path is relative, it is evaluated relative // to Dir. Path string // Args holds command line arguments, including the command as Args[0]. // If the Args field is empty or nil, Run uses {Path}. // // In typical use, both Path and Args are set by calling Command. Args []string // Env specifies the environment of the process. // Each entry is of the form \"key=value\". // If Env is nil, the new process uses the current process's // environment. // If Env contains duplicate environment keys, only the last // value in the slice for each duplicate key is used. Env []string // Dir specifies the working directory of the command. // If Dir is the empty string, Run runs the command in the // calling process's current directory. Dir string // Stdin specifies the process's standard input. // // If Stdin is nil, the process reads from the null device (os.DevNull). // // If Stdin is an *os.File, the process's standard input is connected // directly to that file. // // Otherwise, during the execution of the command a separate // goroutine reads from Stdin and delivers that data to the command // over a pipe. In this case, Wait does not complete until the goroutine // stops copying, either because it has reached the end of Stdin // (EOF or a read error) or because writing to the pipe returned an error. Stdin io.Reader // Stdout and Stderr specify the process's standard output and error. // // If either is nil, Run connects the corresponding file descriptor // to the null device (os.DevNull). // // If either is an *os.File, the corresponding output from the process // is connected directly to that file. // // Otherwise, during the execution of the command a separate goroutine // reads from the process over a pipe and delivers that data to the // corresponding Writer. In this case, Wait does not complete until the // goroutine reaches EOF or encounters an error. // // If Stdout and Stderr are the same writer, and have a type that can // be compared with ==, at most one goroutine at a time will call Write. Stdout io.Writer Stderr io.Writer // ExtraFiles specifies additional open files to be inherited by the // new process. It does not include standard input, standard output, or // standard error. If non-nil, entry i becomes file descriptor 3+i. // // ExtraFiles is not supported on Windows. ExtraFiles []*os.File // SysProcAttr holds optional, operating system-specific attributes. // Run passes it to os.StartProcess as the os.ProcAttr's Sys field. SysProcAttr *syscall.SysProcAttr // Process is the underlying process, once started. Process *os.Process // ProcessState contains information about an exited process, // available after a call to Wait or Run. ProcessState *os.ProcessState // contains filtered or unexported fields }",
        "type": "os"
    },
    "exec.Cmd.CombinedOutput": {
        "descr": "CombinedOutput runs the command and returns its combined standard output and standard error.",
        "name": "exec.Cmd.CombinedOutput",
        "params": [],
        "path": "go/os/exec/index#Cmd.CombinedOutput",
        "syntax": "func (c *Cmd) CombinedOutput() ([]byte, error)",
        "type": "os"
    },
    "exec.Cmd.Output": {
        "descr": "Output runs the command and returns its standard output. Any returned error will usually be of type *ExitError. If c.Stderr was nil, Output populates ExitError.Stderr.",
        "name": "exec.Cmd.Output",
        "params": [],
        "path": "go/os/exec/index#Cmd.Output",
        "syntax": "func (c *Cmd) Output() ([]byte, error)",
        "type": "os"
    },
    "exec.Cmd.Run": {
        "descr": "Run starts the specified command and waits for it to complete.",
        "name": "exec.Cmd.Run",
        "params": [],
        "path": "go/os/exec/index#Cmd.Run",
        "syntax": "func (c *Cmd) Run() error",
        "type": "os"
    },
    "exec.Cmd.Start": {
        "descr": "Start starts the specified command but does not wait for it to complete.",
        "name": "exec.Cmd.Start",
        "params": [],
        "path": "go/os/exec/index#Cmd.Start",
        "syntax": "func (c *Cmd) Start() error",
        "type": "os"
    },
    "exec.Cmd.StderrPipe": {
        "descr": "StderrPipe returns a pipe that will be connected to the command's standard error when the command starts.",
        "name": "exec.Cmd.StderrPipe",
        "params": [],
        "path": "go/os/exec/index#Cmd.StderrPipe",
        "syntax": "func (c *Cmd) StderrPipe() (io.ReadCloser, error)",
        "type": "os"
    },
    "exec.Cmd.StdinPipe": {
        "descr": "StdinPipe returns a pipe that will be connected to the command's standard input when the command starts. The pipe will be closed automatically after Wait sees the command exit. A caller need only call Close to force the pipe to close sooner. For example, if the command being run will not exit until standard input is closed, the caller must close the pipe.",
        "name": "exec.Cmd.StdinPipe",
        "params": [],
        "path": "go/os/exec/index#Cmd.StdinPipe",
        "syntax": "func (c *Cmd) StdinPipe() (io.WriteCloser, error)",
        "type": "os"
    },
    "exec.Cmd.StdoutPipe": {
        "descr": "StdoutPipe returns a pipe that will be connected to the command's standard output when the command starts.",
        "name": "exec.Cmd.StdoutPipe",
        "params": [],
        "path": "go/os/exec/index#Cmd.StdoutPipe",
        "syntax": "func (c *Cmd) StdoutPipe() (io.ReadCloser, error)",
        "type": "os"
    },
    "exec.Cmd.Wait": {
        "descr": "Wait waits for the command to exit and waits for any copying to stdin or copying from stdout or stderr to complete.",
        "name": "exec.Cmd.Wait",
        "params": [],
        "path": "go/os/exec/index#Cmd.Wait",
        "syntax": "func (c *Cmd) Wait() error",
        "type": "os"
    },
    "exec.Command": {
        "descr": "Command returns the Cmd struct to execute the named program with the given arguments.",
        "name": "exec.Command",
        "params": [],
        "path": "go/os/exec/index#Command",
        "syntax": "func Command(name string, arg ...string) *Cmd",
        "type": "os"
    },
    "exec.CommandContext": {
        "descr": "CommandContext is like Command but includes a context.",
        "name": "exec.CommandContext",
        "params": [],
        "path": "go/os/exec/index#CommandContext",
        "syntax": "func CommandContext(ctx context.Context, name string, arg ...string) *Cmd",
        "type": "os"
    },
    "exec.Error": {
        "descr": "Error is returned by LookPath when it fails to classify a file as an executable.",
        "name": "exec.Error",
        "params": [],
        "path": "go/os/exec/index#Error",
        "syntax": "type Error struct { // Name is the file name for which the error occurred. Name string // Err is the underlying error. Err error }",
        "type": "os"
    },
    "exec.Error.Error": {
        "descr": "",
        "name": "exec.Error.Error",
        "params": [],
        "path": "go/os/exec/index#Error.Error",
        "syntax": "func (e *Error) Error() string",
        "type": "os"
    },
    "exec.ExitError": {
        "descr": "An ExitError reports an unsuccessful exit by a command.",
        "name": "exec.ExitError",
        "params": [],
        "path": "go/os/exec/index#ExitError",
        "syntax": "type ExitError struct { *os.ProcessState // Stderr holds a subset of the standard error output from the // Cmd.Output method if standard error was not otherwise being // collected. // // If the error output is long, Stderr may contain only a prefix // and suffix of the output, with the middle replaced with // text about the number of omitted bytes. // // Stderr is provided for debugging, for inclusion in error messages. // Users with other needs should redirect Cmd.Stderr as needed. Stderr []byte // Go 1.6 }",
        "type": "os"
    },
    "exec.ExitError.Error": {
        "descr": "",
        "name": "exec.ExitError.Error",
        "params": [],
        "path": "go/os/exec/index#ExitError.Error",
        "syntax": "func (e *ExitError) Error() string",
        "type": "os"
    },
    "exec.LookPath": {
        "descr": "LookPath searches for an executable named file in the directories named by the PATH environment variable. If file contains a slash, it is tried directly and the PATH is not consulted. The result may be an absolute path or a path relative to the current directory.",
        "name": "exec.LookPath",
        "params": [],
        "path": "go/os/exec/index#LookPath",
        "syntax": "func LookPath(file string) (string, error)",
        "type": "os"
    },
    "expvar.Do": {
        "descr": "Do calls f for each exported variable. The global variable map is locked during the iteration, but existing entries may be concurrently updated.",
        "name": "expvar.Do",
        "params": [],
        "path": "go/expvar/index#Do",
        "syntax": "func Do(f func(KeyValue))",
        "type": "expvar"
    },
    "expvar.Float": {
        "descr": "Float is a 64-bit float variable that satisfies the Var interface.",
        "name": "expvar.Float",
        "params": [],
        "path": "go/expvar/index#Float",
        "syntax": "type Float struct { // contains filtered or unexported fields }",
        "type": "expvar"
    },
    "expvar.Float.Add": {
        "descr": "Add adds delta to v.",
        "name": "expvar.Float.Add",
        "params": [],
        "path": "go/expvar/index#Float.Add",
        "syntax": "func (v *Float) Add(delta float64)",
        "type": "expvar"
    },
    "expvar.Float.Set": {
        "descr": "Set sets v to value.",
        "name": "expvar.Float.Set",
        "params": [],
        "path": "go/expvar/index#Float.Set",
        "syntax": "func (v *Float) Set(value float64)",
        "type": "expvar"
    },
    "expvar.Float.String": {
        "descr": "",
        "name": "expvar.Float.String",
        "params": [],
        "path": "go/expvar/index#Float.String",
        "syntax": "func (v *Float) String() string",
        "type": "expvar"
    },
    "expvar.Float.Value": {
        "descr": "",
        "name": "expvar.Float.Value",
        "params": [],
        "path": "go/expvar/index#Float.Value",
        "syntax": "func (v *Float) Value() float64",
        "type": "expvar"
    },
    "expvar.Func": {
        "descr": "Func implements Var by calling the function and formatting the returned value using JSON.",
        "name": "expvar.Func",
        "params": [],
        "path": "go/expvar/index#Func",
        "syntax": "type Func func() interface{}",
        "type": "expvar"
    },
    "expvar.Func.String": {
        "descr": "",
        "name": "expvar.Func.String",
        "params": [],
        "path": "go/expvar/index#Func.String",
        "syntax": "func (f Func) String() string",
        "type": "expvar"
    },
    "expvar.Func.Value": {
        "descr": "",
        "name": "expvar.Func.Value",
        "params": [],
        "path": "go/expvar/index#Func.Value",
        "syntax": "func (f Func) Value() interface{}",
        "type": "expvar"
    },
    "expvar.Get": {
        "descr": "Get retrieves a named exported variable. It returns nil if the name has not been registered.",
        "name": "expvar.Get",
        "params": [],
        "path": "go/expvar/index#Get",
        "syntax": "func Get(name string) Var",
        "type": "expvar"
    },
    "expvar.Handler": {
        "descr": "Handler returns the expvar HTTP Handler.",
        "name": "expvar.Handler",
        "params": [],
        "path": "go/expvar/index#Handler",
        "syntax": "func Handler() http.Handler",
        "type": "expvar"
    },
    "expvar.Int": {
        "descr": "Int is a 64-bit integer variable that satisfies the Var interface.",
        "name": "expvar.Int",
        "params": [],
        "path": "go/expvar/index#Int",
        "syntax": "type Int struct { // contains filtered or unexported fields }",
        "type": "expvar"
    },
    "expvar.Int.Add": {
        "descr": "",
        "name": "expvar.Int.Add",
        "params": [],
        "path": "go/expvar/index#Int.Add",
        "syntax": "func (v *Int) Add(delta int64)",
        "type": "expvar"
    },
    "expvar.Int.Set": {
        "descr": "",
        "name": "expvar.Int.Set",
        "params": [],
        "path": "go/expvar/index#Int.Set",
        "syntax": "func (v *Int) Set(value int64)",
        "type": "expvar"
    },
    "expvar.Int.String": {
        "descr": "",
        "name": "expvar.Int.String",
        "params": [],
        "path": "go/expvar/index#Int.String",
        "syntax": "func (v *Int) String() string",
        "type": "expvar"
    },
    "expvar.Int.Value": {
        "descr": "",
        "name": "expvar.Int.Value",
        "params": [],
        "path": "go/expvar/index#Int.Value",
        "syntax": "func (v *Int) Value() int64",
        "type": "expvar"
    },
    "expvar.KeyValue": {
        "descr": "KeyValue represents a single entry in a Map.",
        "name": "expvar.KeyValue",
        "params": [],
        "path": "go/expvar/index#KeyValue",
        "syntax": "type KeyValue struct { Key string Value Var }",
        "type": "expvar"
    },
    "expvar.Map": {
        "descr": "Map is a string-to-Var map variable that satisfies the Var interface.",
        "name": "expvar.Map",
        "params": [],
        "path": "go/expvar/index#Map",
        "syntax": "type Map struct { // contains filtered or unexported fields }",
        "type": "expvar"
    },
    "expvar.Map.Add": {
        "descr": "Add adds delta to the *Int value stored under the given map key.",
        "name": "expvar.Map.Add",
        "params": [],
        "path": "go/expvar/index#Map.Add",
        "syntax": "func (v *Map) Add(key string, delta int64)",
        "type": "expvar"
    },
    "expvar.Map.AddFloat": {
        "descr": "AddFloat adds delta to the *Float value stored under the given map key.",
        "name": "expvar.Map.AddFloat",
        "params": [],
        "path": "go/expvar/index#Map.AddFloat",
        "syntax": "func (v *Map) AddFloat(key string, delta float64)",
        "type": "expvar"
    },
    "expvar.Map.Do": {
        "descr": "Do calls f for each entry in the map. The map is locked during the iteration, but existing entries may be concurrently updated.",
        "name": "expvar.Map.Do",
        "params": [],
        "path": "go/expvar/index#Map.Do",
        "syntax": "func (v *Map) Do(f func(KeyValue))",
        "type": "expvar"
    },
    "expvar.Map.Get": {
        "descr": "",
        "name": "expvar.Map.Get",
        "params": [],
        "path": "go/expvar/index#Map.Get",
        "syntax": "func (v *Map) Get(key string) Var",
        "type": "expvar"
    },
    "expvar.Map.Init": {
        "descr": "Init removes all keys from the map.",
        "name": "expvar.Map.Init",
        "params": [],
        "path": "go/expvar/index#Map.Init",
        "syntax": "func (v *Map) Init() *Map",
        "type": "expvar"
    },
    "expvar.Map.Set": {
        "descr": "",
        "name": "expvar.Map.Set",
        "params": [],
        "path": "go/expvar/index#Map.Set",
        "syntax": "func (v *Map) Set(key string, av Var)",
        "type": "expvar"
    },
    "expvar.Map.String": {
        "descr": "",
        "name": "expvar.Map.String",
        "params": [],
        "path": "go/expvar/index#Map.String",
        "syntax": "func (v *Map) String() string",
        "type": "expvar"
    },
    "expvar.NewFloat": {
        "descr": "",
        "name": "expvar.NewFloat",
        "params": [],
        "path": "go/expvar/index#NewFloat",
        "syntax": "func NewFloat(name string) *Float",
        "type": "expvar"
    },
    "expvar.NewInt": {
        "descr": "",
        "name": "expvar.NewInt",
        "params": [],
        "path": "go/expvar/index#NewInt",
        "syntax": "func NewInt(name string) *Int",
        "type": "expvar"
    },
    "expvar.NewMap": {
        "descr": "",
        "name": "expvar.NewMap",
        "params": [],
        "path": "go/expvar/index#NewMap",
        "syntax": "func NewMap(name string) *Map",
        "type": "expvar"
    },
    "expvar.NewString": {
        "descr": "",
        "name": "expvar.NewString",
        "params": [],
        "path": "go/expvar/index#NewString",
        "syntax": "func NewString(name string) *String",
        "type": "expvar"
    },
    "expvar.Publish": {
        "descr": "Publish declares a named exported variable. This should be called from a package's init function when it creates its Vars. If the name is already registered then this will log.Panic.",
        "name": "expvar.Publish",
        "params": [],
        "path": "go/expvar/index#Publish",
        "syntax": "func Publish(name string, v Var)",
        "type": "expvar"
    },
    "expvar.String": {
        "descr": "String is a string variable, and satisfies the Var interface.",
        "name": "expvar.String",
        "params": [],
        "path": "go/expvar/index#String",
        "syntax": "type String struct { // contains filtered or unexported fields }",
        "type": "expvar"
    },
    "expvar.String.Set": {
        "descr": "",
        "name": "expvar.String.Set",
        "params": [],
        "path": "go/expvar/index#String.Set",
        "syntax": "func (v *String) Set(value string)",
        "type": "expvar"
    },
    "expvar.String.String": {
        "descr": "String implements the Val interface. To get the unquoted string use Value.",
        "name": "expvar.String.String",
        "params": [],
        "path": "go/expvar/index#String.String",
        "syntax": "func (v *String) String() string",
        "type": "expvar"
    },
    "expvar.String.Value": {
        "descr": "",
        "name": "expvar.String.Value",
        "params": [],
        "path": "go/expvar/index#String.Value",
        "syntax": "func (v *String) Value() string",
        "type": "expvar"
    },
    "expvar.Var": {
        "descr": "Var is an abstract type for all exported variables.",
        "name": "expvar.Var",
        "params": [],
        "path": "go/expvar/index#Var",
        "syntax": "type Var interface { // String returns a valid JSON value for the variable. // Types with String methods that do not return valid JSON // (such as time.Time) must not be used as a Var. String() string }",
        "type": "expvar"
    },
    "fcgi.ProcessEnv": {
        "descr": "ProcessEnv returns FastCGI environment variables associated with the request r for which no effort was made to be included in the request itself - the data is hidden in the request's context. As an example, if REMOTE_USER is set for a request, it will not be found anywhere in r, but it will be included in ProcessEnv's response (via r's context).",
        "name": "fcgi.ProcessEnv",
        "params": [],
        "path": "go/net/http/fcgi/index#ProcessEnv",
        "syntax": "func ProcessEnv(r *http.Request) map[string]string",
        "type": "net/http"
    },
    "fcgi.Serve": {
        "descr": "Serve accepts incoming FastCGI connections on the listener l, creating a new goroutine for each. The goroutine reads requests and then calls handler to reply to them. If l is nil, Serve accepts connections from os.Stdin. If handler is nil, http.DefaultServeMux is used.",
        "name": "fcgi.Serve",
        "params": [],
        "path": "go/net/http/fcgi/index#Serve",
        "syntax": "func Serve(l net.Listener, handler http.Handler) error",
        "type": "net/http"
    },
    "filepath.Abs": {
        "descr": "Abs returns an absolute representation of path. If the path is not absolute it will be joined with the current working directory to turn it into an absolute path. The absolute path name for a given file is not guaranteed to be unique. Abs calls Clean on the result.",
        "name": "filepath.Abs",
        "params": [],
        "path": "go/path/filepath/index#Abs",
        "syntax": "func Abs(path string) (string, error)",
        "type": "path"
    },
    "filepath.Base": {
        "descr": "Base returns the last element of path. Trailing path separators are removed before extracting the last element. If the path is empty, Base returns \".\". If the path consists entirely of separators, Base returns a single separator.",
        "name": "filepath.Base",
        "params": [],
        "path": "go/path/filepath/index#Base",
        "syntax": "func Base(path string) string",
        "type": "path"
    },
    "filepath.Clean": {
        "descr": "Clean returns the shortest path name equivalent to path by purely lexical processing. It applies the following rules iteratively until no further processing can be done:",
        "name": "filepath.Clean",
        "params": [],
        "path": "go/path/filepath/index#Clean",
        "syntax": "func Clean(path string) string",
        "type": "path"
    },
    "filepath.Dir": {
        "descr": "Dir returns all but the last element of path, typically the path's directory. After dropping the final element, Dir calls Clean on the path and trailing slashes are removed. If the path is empty, Dir returns \".\". If the path consists entirely of separators, Dir returns a single separator. The returned path does not end in a separator unless it is the root directory.",
        "name": "filepath.Dir",
        "params": [],
        "path": "go/path/filepath/index#Dir",
        "syntax": "func Dir(path string) string",
        "type": "path"
    },
    "filepath.EvalSymlinks": {
        "descr": "EvalSymlinks returns the path name after the evaluation of any symbolic links. If path is relative the result will be relative to the current directory, unless one of the components is an absolute symbolic link. EvalSymlinks calls Clean on the result.",
        "name": "filepath.EvalSymlinks",
        "params": [],
        "path": "go/path/filepath/index#EvalSymlinks",
        "syntax": "func EvalSymlinks(path string) (string, error)",
        "type": "path"
    },
    "filepath.Ext": {
        "descr": "Ext returns the file name extension used by path. The extension is the suffix beginning at the final dot in the final element of path; it is empty if there is no dot.",
        "name": "filepath.Ext",
        "params": [],
        "path": "go/path/filepath/index#Ext",
        "syntax": "func Ext(path string) string",
        "type": "path"
    },
    "filepath.FromSlash": {
        "descr": "FromSlash returns the result of replacing each slash ('/') character in path with a separator character. Multiple slashes are replaced by multiple separators.",
        "name": "filepath.FromSlash",
        "params": [],
        "path": "go/path/filepath/index#FromSlash",
        "syntax": "func FromSlash(path string) string",
        "type": "path"
    },
    "filepath.Glob": {
        "descr": "Glob returns the names of all files matching pattern or nil if there is no matching file. The syntax of patterns is the same as in Match. The pattern may describe hierarchical names such as /usr/*/bin/ed (assuming the Separator is '/').",
        "name": "filepath.Glob",
        "params": [],
        "path": "go/path/filepath/index#Glob",
        "syntax": "func Glob(pattern string) (matches []string, err error)",
        "type": "path"
    },
    "filepath.HasPrefix": {
        "descr": "HasPrefix exists for historical compatibility and should not be used.",
        "name": "filepath.HasPrefix",
        "params": [],
        "path": "go/path/filepath/index#HasPrefix",
        "syntax": "func HasPrefix(p, prefix string) bool",
        "type": "path"
    },
    "filepath.IsAbs": {
        "descr": "IsAbs reports whether the path is absolute.",
        "name": "filepath.IsAbs",
        "params": [],
        "path": "go/path/filepath/index#IsAbs",
        "syntax": "func IsAbs(path string) bool",
        "type": "path"
    },
    "filepath.Join": {
        "descr": "Join joins any number of path elements into a single path, adding a Separator if necessary. Join calls Clean on the result; in particular, all empty strings are ignored. On Windows, the result is a UNC path if and only if the first path element is a UNC path.",
        "name": "filepath.Join",
        "params": [],
        "path": "go/path/filepath/index#Join",
        "syntax": "func Join(elem ...string) string",
        "type": "path"
    },
    "filepath.Match": {
        "descr": "Match reports whether name matches the shell file name pattern. The pattern syntax is:",
        "name": "filepath.Match",
        "params": [],
        "path": "go/path/filepath/index#Match",
        "syntax": "func Match(pattern, name string) (matched bool, err error)",
        "type": "path"
    },
    "filepath.Rel": {
        "descr": "Rel returns a relative path that is lexically equivalent to targpath when joined to basepath with an intervening separator. That is, Join(basepath, Rel(basepath, targpath)) is equivalent to targpath itself. On success, the returned path will always be relative to basepath, even if basepath and targpath share no elements. An error is returned if targpath can't be made relative to basepath or if knowing the current working directory would be necessary to compute it. Rel calls Clean on the result.",
        "name": "filepath.Rel",
        "params": [],
        "path": "go/path/filepath/index#Rel",
        "syntax": "func Rel(basepath, targpath string) (string, error)",
        "type": "path"
    },
    "filepath.Split": {
        "descr": "Split splits path immediately following the final Separator, separating it into a directory and file name component. If there is no Separator in path, Split returns an empty dir and file set to path. The returned values have the property that path = dir+file.",
        "name": "filepath.Split",
        "params": [],
        "path": "go/path/filepath/index#Split",
        "syntax": "func Split(path string) (dir, file string)",
        "type": "path"
    },
    "filepath.SplitList": {
        "descr": "SplitList splits a list of paths joined by the OS-specific ListSeparator, usually found in PATH or GOPATH environment variables. Unlike strings.Split, SplitList returns an empty slice when passed an empty string.",
        "name": "filepath.SplitList",
        "params": [],
        "path": "go/path/filepath/index#SplitList",
        "syntax": "func SplitList(path string) []string",
        "type": "path"
    },
    "filepath.ToSlash": {
        "descr": "ToSlash returns the result of replacing each separator character in path with a slash ('/') character. Multiple separators are replaced by multiple slashes.",
        "name": "filepath.ToSlash",
        "params": [],
        "path": "go/path/filepath/index#ToSlash",
        "syntax": "func ToSlash(path string) string",
        "type": "path"
    },
    "filepath.VolumeName": {
        "descr": "VolumeName returns leading volume name. Given \"C:\\foo\\bar\" it returns \"C:\" on Windows. Given \"\\\\host\\share\\foo\" it returns \"\\\\host\\share\". On other platforms it returns \"\".",
        "name": "filepath.VolumeName",
        "params": [],
        "path": "go/path/filepath/index#VolumeName",
        "syntax": "func VolumeName(path string) string",
        "type": "path"
    },
    "filepath.Walk": {
        "descr": "Walk walks the file tree rooted at root, calling walkFn for each file or directory in the tree, including root. All errors that arise visiting files and directories are filtered by walkFn. The files are walked in lexical order, which makes the output deterministic but means that for very large directories Walk can be inefficient. Walk does not follow symbolic links.",
        "name": "filepath.Walk",
        "params": [],
        "path": "go/path/filepath/index#Walk",
        "syntax": "func Walk(root string, walkFn WalkFunc) error",
        "type": "path"
    },
    "filepath.WalkFunc": {
        "descr": "WalkFunc is the type of the function called for each file or directory visited by Walk. The path argument contains the argument to Walk as a prefix; that is, if Walk is called with \"dir\", which is a directory containing the file \"a\", the walk function will be called with argument \"dir/a\". The info argument is the os.FileInfo for the named path.",
        "name": "filepath.WalkFunc",
        "params": [],
        "path": "go/path/filepath/index#WalkFunc",
        "syntax": "type WalkFunc func(path string, info os.FileInfo, err error) error",
        "type": "path"
    },
    "flag": {
        "descr": "CommandLine is the default set of command-line flags, parsed from os.Args. The top-level functions such as BoolVar, Arg, and so on are wrappers for the methods of CommandLine.",
        "name": "flag",
        "params": [],
        "path": "go/flag/index#pkg-variables",
        "syntax": "var CommandLine = NewFlagSet(os.Args[0], ExitOnError)",
        "type": "flag"
    },
    "flag.Arg": {
        "descr": "Arg returns the i'th command-line argument. Arg(0) is the first remaining argument after flags have been processed. Arg returns an empty string if the requested element does not exist.",
        "name": "flag.Arg",
        "params": [],
        "path": "go/flag/index#Arg",
        "syntax": "func Arg(i int) string",
        "type": "flag"
    },
    "flag.Args": {
        "descr": "Args returns the non-flag command-line arguments.",
        "name": "flag.Args",
        "params": [],
        "path": "go/flag/index#Args",
        "syntax": "func Args() []string",
        "type": "flag"
    },
    "flag.Bool": {
        "descr": "Bool defines a bool flag with specified name, default value, and usage string. The return value is the address of a bool variable that stores the value of the flag.",
        "name": "flag.Bool",
        "params": [],
        "path": "go/flag/index#Bool",
        "syntax": "func Bool(name string, value bool, usage string) *bool",
        "type": "flag"
    },
    "flag.BoolVar": {
        "descr": "BoolVar defines a bool flag with specified name, default value, and usage string. The argument p points to a bool variable in which to store the value of the flag.",
        "name": "flag.BoolVar",
        "params": [],
        "path": "go/flag/index#BoolVar",
        "syntax": "func BoolVar(p *bool, name string, value bool, usage string)",
        "type": "flag"
    },
    "flag.Duration": {
        "descr": "Duration defines a time.Duration flag with specified name, default value, and usage string. The return value is the address of a time.Duration variable that stores the value of the flag. The flag accepts a value acceptable to time.ParseDuration.",
        "name": "flag.Duration",
        "params": [],
        "path": "go/flag/index#Duration",
        "syntax": "func Duration(name string, value time.Duration, usage string) *time.Duration",
        "type": "flag"
    },
    "flag.DurationVar": {
        "descr": "DurationVar defines a time.Duration flag with specified name, default value, and usage string. The argument p points to a time.Duration variable in which to store the value of the flag. The flag accepts a value acceptable to time.ParseDuration.",
        "name": "flag.DurationVar",
        "params": [],
        "path": "go/flag/index#DurationVar",
        "syntax": "func DurationVar(p *time.Duration, name string, value time.Duration, usage string)",
        "type": "flag"
    },
    "flag.ErrorHandling": {
        "descr": "ErrorHandling defines how FlagSet.Parse behaves if the parse fails.",
        "name": "flag.ErrorHandling",
        "params": [],
        "path": "go/flag/index#ErrorHandling",
        "syntax": "type ErrorHandling int",
        "type": "flag"
    },
    "flag.Flag": {
        "descr": "A Flag represents the state of a flag.",
        "name": "flag.Flag",
        "params": [],
        "path": "go/flag/index#Flag",
        "syntax": "type Flag struct { Name string // name as it appears on command line Usage string // help message Value Value // value as set DefValue string // default value (as text);\n or  for usage message });",
        "type": "flag"
    },
    "flag.FlagSet": {
        "descr": "A FlagSet represents a set of defined flags. The zero value of a FlagSet has no name and has ContinueOnError error handling.",
        "name": "flag.FlagSet",
        "params": [],
        "path": "go/flag/index#FlagSet",
        "syntax": "type FlagSet struct { // Usage is the function called when an error occurs while parsing flags. // The field is a function (not a method) that may be changed to point to // a custom error handler. What happens after Usage is called depends // on the ErrorHandling setting; for the command line, this defaults // to ExitOnError, which exits the program after calling Usage. Usage func() // contains filtered or unexported fields }",
        "type": "flag"
    },
    "flag.FlagSet.Arg": {
        "descr": "Arg returns the i'th argument. Arg(0) is the first remaining argument after flags have been processed. Arg returns an empty string if the requested element does not exist.",
        "name": "flag.FlagSet.Arg",
        "params": [],
        "path": "go/flag/index#FlagSet.Arg",
        "syntax": "func (f *FlagSet) Arg(i int) string",
        "type": "flag"
    },
    "flag.FlagSet.Args": {
        "descr": "Args returns the non-flag arguments.",
        "name": "flag.FlagSet.Args",
        "params": [],
        "path": "go/flag/index#FlagSet.Args",
        "syntax": "func (f *FlagSet) Args() []string",
        "type": "flag"
    },
    "flag.FlagSet.Bool": {
        "descr": "Bool defines a bool flag with specified name, default value, and usage string. The return value is the address of a bool variable that stores the value of the flag.",
        "name": "flag.FlagSet.Bool",
        "params": [],
        "path": "go/flag/index#FlagSet.Bool",
        "syntax": "func (f *FlagSet) Bool(name string, value bool, usage string) *bool",
        "type": "flag"
    },
    "flag.FlagSet.BoolVar": {
        "descr": "BoolVar defines a bool flag with specified name, default value, and usage string. The argument p points to a bool variable in which to store the value of the flag.",
        "name": "flag.FlagSet.BoolVar",
        "params": [],
        "path": "go/flag/index#FlagSet.BoolVar",
        "syntax": "func (f *FlagSet) BoolVar(p *bool, name string, value bool, usage string)",
        "type": "flag"
    },
    "flag.FlagSet.Duration": {
        "descr": "Duration defines a time.Duration flag with specified name, default value, and usage string. The return value is the address of a time.Duration variable that stores the value of the flag. The flag accepts a value acceptable to time.ParseDuration.",
        "name": "flag.FlagSet.Duration",
        "params": [],
        "path": "go/flag/index#FlagSet.Duration",
        "syntax": "func (f *FlagSet) Duration(name string, value time.Duration, usage string) *time.Duration",
        "type": "flag"
    },
    "flag.FlagSet.DurationVar": {
        "descr": "DurationVar defines a time.Duration flag with specified name, default value, and usage string. The argument p points to a time.Duration variable in which to store the value of the flag. The flag accepts a value acceptable to time.ParseDuration.",
        "name": "flag.FlagSet.DurationVar",
        "params": [],
        "path": "go/flag/index#FlagSet.DurationVar",
        "syntax": "func (f *FlagSet) DurationVar(p *time.Duration, name string, value time.Duration, usage string)",
        "type": "flag"
    },
    "flag.FlagSet.ErrorHandling": {
        "descr": "ErrorHandling returns the error handling behavior of the flag set.",
        "name": "flag.FlagSet.ErrorHandling",
        "params": [],
        "path": "go/flag/index#FlagSet.ErrorHandling",
        "syntax": "func (f *FlagSet) ErrorHandling() ErrorHandling",
        "type": "flag"
    },
    "flag.FlagSet.Float64": {
        "descr": "Float64 defines a float64 flag with specified name, default value, and usage string. The return value is the address of a float64 variable that stores the value of the flag.",
        "name": "flag.FlagSet.Float64",
        "params": [],
        "path": "go/flag/index#FlagSet.Float64",
        "syntax": "func (f *FlagSet) Float64(name string, value float64, usage string) *float64",
        "type": "flag"
    },
    "flag.FlagSet.Float64Var": {
        "descr": "Float64Var defines a float64 flag with specified name, default value, and usage string. The argument p points to a float64 variable in which to store the value of the flag.",
        "name": "flag.FlagSet.Float64Var",
        "params": [],
        "path": "go/flag/index#FlagSet.Float64Var",
        "syntax": "func (f *FlagSet) Float64Var(p *float64, name string, value float64, usage string)",
        "type": "flag"
    },
    "flag.FlagSet.Init": {
        "descr": "Init sets the name and error handling property for a flag set. By default, the zero FlagSet uses an empty name and the ContinueOnError error handling policy.",
        "name": "flag.FlagSet.Init",
        "params": [],
        "path": "go/flag/index#FlagSet.Init",
        "syntax": "func (f *FlagSet) Init(name string, errorHandling ErrorHandling)",
        "type": "flag"
    },
    "flag.FlagSet.Int": {
        "descr": "Int defines an int flag with specified name, default value, and usage string. The return value is the address of an int variable that stores the value of the flag.",
        "name": "flag.FlagSet.Int",
        "params": [],
        "path": "go/flag/index#FlagSet.Int",
        "syntax": "func (f *FlagSet) Int(name string, value int, usage string) *int",
        "type": "flag"
    },
    "flag.FlagSet.Int64": {
        "descr": "Int64 defines an int64 flag with specified name, default value, and usage string. The return value is the address of an int64 variable that stores the value of the flag.",
        "name": "flag.FlagSet.Int64",
        "params": [],
        "path": "go/flag/index#FlagSet.Int64",
        "syntax": "func (f *FlagSet) Int64(name string, value int64, usage string) *int64",
        "type": "flag"
    },
    "flag.FlagSet.Int64Var": {
        "descr": "Int64Var defines an int64 flag with specified name, default value, and usage string. The argument p points to an int64 variable in which to store the value of the flag.",
        "name": "flag.FlagSet.Int64Var",
        "params": [],
        "path": "go/flag/index#FlagSet.Int64Var",
        "syntax": "func (f *FlagSet) Int64Var(p *int64, name string, value int64, usage string)",
        "type": "flag"
    },
    "flag.FlagSet.IntVar": {
        "descr": "IntVar defines an int flag with specified name, default value, and usage string. The argument p points to an int variable in which to store the value of the flag.",
        "name": "flag.FlagSet.IntVar",
        "params": [],
        "path": "go/flag/index#FlagSet.IntVar",
        "syntax": "func (f *FlagSet) IntVar(p *int, name string, value int, usage string)",
        "type": "flag"
    },
    "flag.FlagSet.Lookup": {
        "descr": "Lookup returns the Flag structure of the named flag, returning nil if none exists.",
        "name": "flag.FlagSet.Lookup",
        "params": [],
        "path": "go/flag/index#FlagSet.Lookup",
        "syntax": "func (f *FlagSet) Lookup(name string) *Flag",
        "type": "flag"
    },
    "flag.FlagSet.NArg": {
        "descr": "NArg is the number of arguments remaining after flags have been processed.",
        "name": "flag.FlagSet.NArg",
        "params": [],
        "path": "go/flag/index#FlagSet.NArg",
        "syntax": "func (f *FlagSet) NArg() int",
        "type": "flag"
    },
    "flag.FlagSet.NFlag": {
        "descr": "NFlag returns the number of flags that have been set.",
        "name": "flag.FlagSet.NFlag",
        "params": [],
        "path": "go/flag/index#FlagSet.NFlag",
        "syntax": "func (f *FlagSet) NFlag() int",
        "type": "flag"
    },
    "flag.FlagSet.Name": {
        "descr": "Name returns the name of the flag set.",
        "name": "flag.FlagSet.Name",
        "params": [],
        "path": "go/flag/index#FlagSet.Name",
        "syntax": "func (f *FlagSet) Name() string",
        "type": "flag"
    },
    "flag.FlagSet.Output": {
        "descr": "Output returns the destination for usage and error messages. os.Stderr is returned if output was not set or was set to nil.",
        "name": "flag.FlagSet.Output",
        "params": [],
        "path": "go/flag/index#FlagSet.Output",
        "syntax": "func (f *FlagSet) Output() io.Writer",
        "type": "flag"
    },
    "flag.FlagSet.Parse": {
        "descr": "Parse parses flag definitions from the argument list, which should not include the command name. Must be called after all flags in the FlagSet are defined and before flags are accessed by the program. The return value will be ErrHelp if -help or -h were set but not defined.",
        "name": "flag.FlagSet.Parse",
        "params": [],
        "path": "go/flag/index#FlagSet.Parse",
        "syntax": "func (f *FlagSet) Parse(arguments []string) error",
        "type": "flag"
    },
    "flag.FlagSet.Parsed": {
        "descr": "Parsed reports whether f.Parse has been called.",
        "name": "flag.FlagSet.Parsed",
        "params": [],
        "path": "go/flag/index#FlagSet.Parsed",
        "syntax": "func (f *FlagSet) Parsed() bool",
        "type": "flag"
    },
    "flag.FlagSet.PrintDefaults": {
        "descr": "PrintDefaults prints, to standard error unless configured otherwise, the default values of all defined command-line flags in the set. See the documentation for the global function PrintDefaults for more information.",
        "name": "flag.FlagSet.PrintDefaults",
        "params": [],
        "path": "go/flag/index#FlagSet.PrintDefaults",
        "syntax": "func (f *FlagSet) PrintDefaults()",
        "type": "flag"
    },
    "flag.FlagSet.Set": {
        "descr": "Set sets the value of the named flag.",
        "name": "flag.FlagSet.Set",
        "params": [],
        "path": "go/flag/index#FlagSet.Set",
        "syntax": "func (f *FlagSet) Set(name, value string) error",
        "type": "flag"
    },
    "flag.FlagSet.SetOutput": {
        "descr": "SetOutput sets the destination for usage and error messages. If output is nil, os.Stderr is used.",
        "name": "flag.FlagSet.SetOutput",
        "params": [],
        "path": "go/flag/index#FlagSet.SetOutput",
        "syntax": "func (f *FlagSet) SetOutput(output io.Writer)",
        "type": "flag"
    },
    "flag.FlagSet.String": {
        "descr": "String defines a string flag with specified name, default value, and usage string. The return value is the address of a string variable that stores the value of the flag.",
        "name": "flag.FlagSet.String",
        "params": [],
        "path": "go/flag/index#FlagSet.String",
        "syntax": "func (f *FlagSet) String(name string, value string, usage string) *string",
        "type": "flag"
    },
    "flag.FlagSet.StringVar": {
        "descr": "StringVar defines a string flag with specified name, default value, and usage string. The argument p points to a string variable in which to store the value of the flag.",
        "name": "flag.FlagSet.StringVar",
        "params": [],
        "path": "go/flag/index#FlagSet.StringVar",
        "syntax": "func (f *FlagSet) StringVar(p *string, name string, value string, usage string)",
        "type": "flag"
    },
    "flag.FlagSet.Uint": {
        "descr": "Uint defines a uint flag with specified name, default value, and usage string. The return value is the address of a uint variable that stores the value of the flag.",
        "name": "flag.FlagSet.Uint",
        "params": [],
        "path": "go/flag/index#FlagSet.Uint",
        "syntax": "func (f *FlagSet) Uint(name string, value uint, usage string) *uint",
        "type": "flag"
    },
    "flag.FlagSet.Uint64": {
        "descr": "Uint64 defines a uint64 flag with specified name, default value, and usage string. The return value is the address of a uint64 variable that stores the value of the flag.",
        "name": "flag.FlagSet.Uint64",
        "params": [],
        "path": "go/flag/index#FlagSet.Uint64",
        "syntax": "func (f *FlagSet) Uint64(name string, value uint64, usage string) *uint64",
        "type": "flag"
    },
    "flag.FlagSet.Uint64Var": {
        "descr": "Uint64Var defines a uint64 flag with specified name, default value, and usage string. The argument p points to a uint64 variable in which to store the value of the flag.",
        "name": "flag.FlagSet.Uint64Var",
        "params": [],
        "path": "go/flag/index#FlagSet.Uint64Var",
        "syntax": "func (f *FlagSet) Uint64Var(p *uint64, name string, value uint64, usage string)",
        "type": "flag"
    },
    "flag.FlagSet.UintVar": {
        "descr": "UintVar defines a uint flag with specified name, default value, and usage string. The argument p points to a uint variable in which to store the value of the flag.",
        "name": "flag.FlagSet.UintVar",
        "params": [],
        "path": "go/flag/index#FlagSet.UintVar",
        "syntax": "func (f *FlagSet) UintVar(p *uint, name string, value uint, usage string)",
        "type": "flag"
    },
    "flag.FlagSet.Var": {
        "descr": "Var defines a flag with the specified name and usage string. The type and value of the flag are represented by the first argument, of type Value, which typically holds a user-defined implementation of Value. For instance, the caller could create a flag that turns a comma-separated string into a slice of strings by giving the slice the methods of Value; in particular, Set would decompose the comma-separated string into the slice.",
        "name": "flag.FlagSet.Var",
        "params": [],
        "path": "go/flag/index#FlagSet.Var",
        "syntax": "func (f *FlagSet) Var(value Value, name string, usage string)",
        "type": "flag"
    },
    "flag.FlagSet.Visit": {
        "descr": "Visit visits the flags in lexicographical order, calling fn for each. It visits only those flags that have been set.",
        "name": "flag.FlagSet.Visit",
        "params": [],
        "path": "go/flag/index#FlagSet.Visit",
        "syntax": "func (f *FlagSet) Visit(fn func(*Flag))",
        "type": "flag"
    },
    "flag.FlagSet.VisitAll": {
        "descr": "VisitAll visits the flags in lexicographical order, calling fn for each. It visits all flags, even those not set.",
        "name": "flag.FlagSet.VisitAll",
        "params": [],
        "path": "go/flag/index#FlagSet.VisitAll",
        "syntax": "func (f *FlagSet) VisitAll(fn func(*Flag))",
        "type": "flag"
    },
    "flag.Float64": {
        "descr": "Float64 defines a float64 flag with specified name, default value, and usage string. The return value is the address of a float64 variable that stores the value of the flag.",
        "name": "flag.Float64",
        "params": [],
        "path": "go/flag/index#Float64",
        "syntax": "func Float64(name string, value float64, usage string) *float64",
        "type": "flag"
    },
    "flag.Float64Var": {
        "descr": "Float64Var defines a float64 flag with specified name, default value, and usage string. The argument p points to a float64 variable in which to store the value of the flag.",
        "name": "flag.Float64Var",
        "params": [],
        "path": "go/flag/index#Float64Var",
        "syntax": "func Float64Var(p *float64, name string, value float64, usage string)",
        "type": "flag"
    },
    "flag.Getter": {
        "descr": "Getter is an interface that allows the contents of a Value to be retrieved. It wraps the Value interface, rather than being part of it, because it appeared after Go 1 and its compatibility rules. All Value types provided by this package satisfy the Getter interface.",
        "name": "flag.Getter",
        "params": [],
        "path": "go/flag/index#Getter",
        "syntax": "type Getter interface { Value Get() interface{} }",
        "type": "flag"
    },
    "flag.Int": {
        "descr": "Int defines an int flag with specified name, default value, and usage string. The return value is the address of an int variable that stores the value of the flag.",
        "name": "flag.Int",
        "params": [],
        "path": "go/flag/index#Int",
        "syntax": "func Int(name string, value int, usage string) *int",
        "type": "flag"
    },
    "flag.Int64": {
        "descr": "Int64 defines an int64 flag with specified name, default value, and usage string. The return value is the address of an int64 variable that stores the value of the flag.",
        "name": "flag.Int64",
        "params": [],
        "path": "go/flag/index#Int64",
        "syntax": "func Int64(name string, value int64, usage string) *int64",
        "type": "flag"
    },
    "flag.Int64Var": {
        "descr": "Int64Var defines an int64 flag with specified name, default value, and usage string. The argument p points to an int64 variable in which to store the value of the flag.",
        "name": "flag.Int64Var",
        "params": [],
        "path": "go/flag/index#Int64Var",
        "syntax": "func Int64Var(p *int64, name string, value int64, usage string)",
        "type": "flag"
    },
    "flag.IntVar": {
        "descr": "IntVar defines an int flag with specified name, default value, and usage string. The argument p points to an int variable in which to store the value of the flag.",
        "name": "flag.IntVar",
        "params": [],
        "path": "go/flag/index#IntVar",
        "syntax": "func IntVar(p *int, name string, value int, usage string)",
        "type": "flag"
    },
    "flag.Lookup": {
        "descr": "Lookup returns the Flag structure of the named command-line flag, returning nil if none exists.",
        "name": "flag.Lookup",
        "params": [],
        "path": "go/flag/index#Lookup",
        "syntax": "func Lookup(name string) *Flag",
        "type": "flag"
    },
    "flag.NArg": {
        "descr": "NArg is the number of arguments remaining after flags have been processed.",
        "name": "flag.NArg",
        "params": [],
        "path": "go/flag/index#NArg",
        "syntax": "func NArg() int",
        "type": "flag"
    },
    "flag.NFlag": {
        "descr": "NFlag returns the number of command-line flags that have been set.",
        "name": "flag.NFlag",
        "params": [],
        "path": "go/flag/index#NFlag",
        "syntax": "func NFlag() int",
        "type": "flag"
    },
    "flag.NewFlagSet": {
        "descr": "NewFlagSet returns a new, empty flag set with the specified name and error handling property. If the name is not empty, it will be printed in the default usage message and in error messages.",
        "name": "flag.NewFlagSet",
        "params": [],
        "path": "go/flag/index#NewFlagSet",
        "syntax": "func NewFlagSet(name string, errorHandling ErrorHandling) *FlagSet",
        "type": "flag"
    },
    "flag.Parse": {
        "descr": "Parse parses the command-line flags from os.Args[1:]. Must be called after all flags are defined and before flags are accessed by the program.",
        "name": "flag.Parse",
        "params": [],
        "path": "go/flag/index#Parse",
        "syntax": "func Parse()",
        "type": "flag"
    },
    "flag.Parsed": {
        "descr": "Parsed reports whether the command-line flags have been parsed.",
        "name": "flag.Parsed",
        "params": [],
        "path": "go/flag/index#Parsed",
        "syntax": "func Parsed() bool",
        "type": "flag"
    },
    "flag.PrintDefaults": {
        "descr": "PrintDefaults prints, to standard error unless configured otherwise, a usage message showing the default settings of all defined command-line flags. For an integer valued flag x, the default output has the form",
        "name": "flag.PrintDefaults",
        "params": [],
        "path": "go/flag/index#PrintDefaults",
        "syntax": "func PrintDefaults()",
        "type": "flag"
    },
    "flag.Set": {
        "descr": "Set sets the value of the named command-line flag.",
        "name": "flag.Set",
        "params": [],
        "path": "go/flag/index#Set",
        "syntax": "func Set(name, value string) error",
        "type": "flag"
    },
    "flag.String": {
        "descr": "String defines a string flag with specified name, default value, and usage string. The return value is the address of a string variable that stores the value of the flag.",
        "name": "flag.String",
        "params": [],
        "path": "go/flag/index#String",
        "syntax": "func String(name string, value string, usage string) *string",
        "type": "flag"
    },
    "flag.StringVar": {
        "descr": "StringVar defines a string flag with specified name, default value, and usage string. The argument p points to a string variable in which to store the value of the flag.",
        "name": "flag.StringVar",
        "params": [],
        "path": "go/flag/index#StringVar",
        "syntax": "func StringVar(p *string, name string, value string, usage string)",
        "type": "flag"
    },
    "flag.Uint": {
        "descr": "Uint defines a uint flag with specified name, default value, and usage string. The return value is the address of a uint variable that stores the value of the flag.",
        "name": "flag.Uint",
        "params": [],
        "path": "go/flag/index#Uint",
        "syntax": "func Uint(name string, value uint, usage string) *uint",
        "type": "flag"
    },
    "flag.Uint64": {
        "descr": "Uint64 defines a uint64 flag with specified name, default value, and usage string. The return value is the address of a uint64 variable that stores the value of the flag.",
        "name": "flag.Uint64",
        "params": [],
        "path": "go/flag/index#Uint64",
        "syntax": "func Uint64(name string, value uint64, usage string) *uint64",
        "type": "flag"
    },
    "flag.Uint64Var": {
        "descr": "Uint64Var defines a uint64 flag with specified name, default value, and usage string. The argument p points to a uint64 variable in which to store the value of the flag.",
        "name": "flag.Uint64Var",
        "params": [],
        "path": "go/flag/index#Uint64Var",
        "syntax": "func Uint64Var(p *uint64, name string, value uint64, usage string)",
        "type": "flag"
    },
    "flag.UintVar": {
        "descr": "UintVar defines a uint flag with specified name, default value, and usage string. The argument p points to a uint variable in which to store the value of the flag.",
        "name": "flag.UintVar",
        "params": [],
        "path": "go/flag/index#UintVar",
        "syntax": "func UintVar(p *uint, name string, value uint, usage string)",
        "type": "flag"
    },
    "flag.UnquoteUsage": {
        "descr": "UnquoteUsage extracts a back-quoted name from the usage string for a flag and returns it and the un-quoted usage. Given \"a `name` to show\" it returns (\"name\", \"a name to show\"). If there are no back quotes, the name is an educated guess of the type of the flag's value, or the empty string if the flag is boolean.",
        "name": "flag.UnquoteUsage",
        "params": [],
        "path": "go/flag/index#UnquoteUsage",
        "syntax": "func UnquoteUsage(flag *Flag) (name string, usage string)",
        "type": "flag"
    },
    "flag.Value": {
        "descr": "Value is the interface to the dynamic value stored in a flag. (The default value is represented as a string.)",
        "name": "flag.Value",
        "params": [],
        "path": "go/flag/index#Value",
        "syntax": "type Value interface { String() string Set(string) error }",
        "type": "flag"
    },
    "flag.Var": {
        "descr": "Var defines a flag with the specified name and usage string. The type and value of the flag are represented by the first argument, of type Value, which typically holds a user-defined implementation of Value. For instance, the caller could create a flag that turns a comma-separated string into a slice of strings by giving the slice the methods of Value; in particular, Set would decompose the comma-separated string into the slice.",
        "name": "flag.Var",
        "params": [],
        "path": "go/flag/index#Var",
        "syntax": "func Var(value Value, name string, usage string)",
        "type": "flag"
    },
    "flag.Visit": {
        "descr": "Visit visits the command-line flags in lexicographical order, calling fn for each. It visits only those flags that have been set.",
        "name": "flag.Visit",
        "params": [],
        "path": "go/flag/index#Visit",
        "syntax": "func Visit(fn func(*Flag))",
        "type": "flag"
    },
    "flag.VisitAll": {
        "descr": "VisitAll visits the command-line flags in lexicographical order, calling fn for each. It visits all flags, even those not set.",
        "name": "flag.VisitAll",
        "params": [],
        "path": "go/flag/index#VisitAll",
        "syntax": "func VisitAll(fn func(*Flag))",
        "type": "flag"
    },
    "flate.CorruptInputError": {
        "descr": "A CorruptInputError reports the presence of corrupt input at a given offset.",
        "name": "flate.CorruptInputError",
        "params": [],
        "path": "go/compress/flate/index#CorruptInputError",
        "syntax": "type CorruptInputError int64",
        "type": "compress"
    },
    "flate.CorruptInputError.Error": {
        "descr": "",
        "name": "flate.CorruptInputError.Error",
        "params": [],
        "path": "go/compress/flate/index#CorruptInputError.Error",
        "syntax": "func (e CorruptInputError) Error() string",
        "type": "compress"
    },
    "flate.InternalError": {
        "descr": "An InternalError reports an error in the flate code itself.",
        "name": "flate.InternalError",
        "params": [],
        "path": "go/compress/flate/index#InternalError",
        "syntax": "type InternalError string",
        "type": "compress"
    },
    "flate.InternalError.Error": {
        "descr": "",
        "name": "flate.InternalError.Error",
        "params": [],
        "path": "go/compress/flate/index#InternalError.Error",
        "syntax": "func (e InternalError) Error() string",
        "type": "compress"
    },
    "flate.NewReader": {
        "descr": "NewReader returns a new ReadCloser that can be used to read the uncompressed version of r. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r. It is the caller's responsibility to call Close on the ReadCloser when finished reading.",
        "name": "flate.NewReader",
        "params": [],
        "path": "go/compress/flate/index#NewReader",
        "syntax": "func NewReader(r io.Reader) io.ReadCloser",
        "type": "compress"
    },
    "flate.NewReaderDict": {
        "descr": "NewReaderDict is like NewReader but initializes the reader with a preset dictionary. The returned Reader behaves as if the uncompressed data stream started with the given dictionary, which has already been read. NewReaderDict is typically used to read data compressed by NewWriterDict.",
        "name": "flate.NewReaderDict",
        "params": [],
        "path": "go/compress/flate/index#NewReaderDict",
        "syntax": "func NewReaderDict(r io.Reader, dict []byte) io.ReadCloser",
        "type": "compress"
    },
    "flate.NewWriter": {
        "descr": "NewWriter returns a new Writer compressing data at the given level. Following zlib, levels range from 1 (BestSpeed) to 9 (BestCompression); higher levels typically run slower but compress more. Level 0 (NoCompression) does not attempt any compression; it only adds the necessary DEFLATE framing. Level -1 (DefaultCompression) uses the default compression level. Level -2 (HuffmanOnly) will use Huffman compression only, giving a very fast compression for all types of input, but sacrificing considerable compression efficiency.",
        "name": "flate.NewWriter",
        "params": [],
        "path": "go/compress/flate/index#NewWriter",
        "syntax": "func NewWriter(w io.Writer, level int) (*Writer, error)",
        "type": "compress"
    },
    "flate.NewWriterDict": {
        "descr": "NewWriterDict is like NewWriter but initializes the new Writer with a preset dictionary. The returned Writer behaves as if the dictionary had been written to it without producing any compressed output. The compressed data written to w can only be decompressed by a Reader initialized with the same dictionary.",
        "name": "flate.NewWriterDict",
        "params": [],
        "path": "go/compress/flate/index#NewWriterDict",
        "syntax": "func NewWriterDict(w io.Writer, level int, dict []byte) (*Writer, error)",
        "type": "compress"
    },
    "flate.ReadError": {
        "descr": "A ReadError reports an error encountered while reading input.",
        "name": "flate.ReadError",
        "params": [],
        "path": "go/compress/flate/index#ReadError",
        "syntax": "type ReadError struct { Offset int64 // byte offset where error occurred Err error // error returned by underlying Read }",
        "type": "compress"
    },
    "flate.ReadError.Error": {
        "descr": "",
        "name": "flate.ReadError.Error",
        "params": [],
        "path": "go/compress/flate/index#ReadError.Error",
        "syntax": "func (e *ReadError) Error() string",
        "type": "compress"
    },
    "flate.Reader": {
        "descr": "The actual read interface needed by NewReader. If the passed in io.Reader does not also have ReadByte, the NewReader will introduce its own buffering.",
        "name": "flate.Reader",
        "params": [],
        "path": "go/compress/flate/index#Reader",
        "syntax": "type Reader interface { io.Reader io.ByteReader }",
        "type": "compress"
    },
    "flate.Resetter": {
        "descr": "Resetter resets a ReadCloser returned by NewReader or NewReaderDict to to switch to a new underlying Reader. This permits reusing a ReadCloser instead of allocating a new one.",
        "name": "flate.Resetter",
        "params": [],
        "path": "go/compress/flate/index#Resetter",
        "syntax": "type Resetter interface { // Reset discards any buffered data and resets the Resetter as if it was // newly initialized with the given reader. Reset(r io.Reader, dict []byte) error }",
        "type": "compress"
    },
    "flate.WriteError": {
        "descr": "A WriteError reports an error encountered while writing output.",
        "name": "flate.WriteError",
        "params": [],
        "path": "go/compress/flate/index#WriteError",
        "syntax": "type WriteError struct { Offset int64 // byte offset where error occurred Err error // error returned by underlying Write }",
        "type": "compress"
    },
    "flate.WriteError.Error": {
        "descr": "",
        "name": "flate.WriteError.Error",
        "params": [],
        "path": "go/compress/flate/index#WriteError.Error",
        "syntax": "func (e *WriteError) Error() string",
        "type": "compress"
    },
    "flate.Writer": {
        "descr": "A Writer takes data written to it and writes the compressed form of that data to an underlying writer (see NewWriter).",
        "name": "flate.Writer",
        "params": [],
        "path": "go/compress/flate/index#Writer",
        "syntax": "type Writer struct { // contains filtered or unexported fields }",
        "type": "compress"
    },
    "flate.Writer.Close": {
        "descr": "Close flushes and closes the writer.",
        "name": "flate.Writer.Close",
        "params": [],
        "path": "go/compress/flate/index#Writer.Close",
        "syntax": "func (w *Writer) Close() error",
        "type": "compress"
    },
    "flate.Writer.Flush": {
        "descr": "Flush flushes any pending data to the underlying writer. It is useful mainly in compressed network protocols, to ensure that a remote reader has enough data to reconstruct a packet. Flush does not return until the data has been written. Calling Flush when there is no pending data still causes the Writer to emit a sync marker of at least 4 bytes. If the underlying writer returns an error, Flush returns that error.",
        "name": "flate.Writer.Flush",
        "params": [],
        "path": "go/compress/flate/index#Writer.Flush",
        "syntax": "func (w *Writer) Flush() error",
        "type": "compress"
    },
    "flate.Writer.Reset": {
        "descr": "Reset discards the writer's state and makes it equivalent to the result of NewWriter or NewWriterDict called with dst and w's level and dictionary.",
        "name": "flate.Writer.Reset",
        "params": [],
        "path": "go/compress/flate/index#Writer.Reset",
        "syntax": "func (w *Writer) Reset(dst io.Writer)",
        "type": "compress"
    },
    "flate.Writer.Write": {
        "descr": "Write writes data to w, which will eventually write the compressed form of data to its underlying writer.",
        "name": "flate.Writer.Write",
        "params": [],
        "path": "go/compress/flate/index#Writer.Write",
        "syntax": "func (w *Writer) Write(data []byte) (n int, err error)",
        "type": "compress"
    },
    "float32": {
        "descr": "float32 is the set of all IEEE-754 32-bit floating-point numbers.",
        "name": "builtin.float32",
        "params": [],
        "path": "go/builtin/index#float32",
        "syntax": "type float32 float32",
        "type": "builtin"
    },
    "float64": {
        "descr": "float64 is the set of all IEEE-754 64-bit floating-point numbers.",
        "name": "builtin.float64",
        "params": [],
        "path": "go/builtin/index#float64",
        "syntax": "type float64 float64",
        "type": "builtin"
    },
    "fmt.Errorf": {
        "descr": "Errorf formats according to a format specifier and returns the string as a value that satisfies error.",
        "name": "fmt.Errorf",
        "params": [],
        "path": "go/fmt/index#Errorf",
        "syntax": "func Errorf(format string, a ...interface{}) error",
        "type": "fmt"
    },
    "fmt.Formatter": {
        "descr": "Formatter is the interface implemented by values with a custom formatter. The implementation of Format may call Sprint(f) or Fprint(f) etc. to generate its output.",
        "name": "fmt.Formatter",
        "params": [],
        "path": "go/fmt/index#Formatter",
        "syntax": "type Formatter interface { Format(f State, c rune) }",
        "type": "fmt"
    },
    "fmt.Fprint": {
        "descr": "Fprint formats using the default formats for its operands and writes to w. Spaces are added between operands when neither is a string. It returns the number of bytes written and any write error encountered.",
        "name": "fmt.Fprint",
        "params": [],
        "path": "go/fmt/index#Fprint",
        "syntax": "func Fprint(w io.Writer, a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "fmt.Fprintf": {
        "descr": "Fprintf formats according to a format specifier and writes to w. It returns the number of bytes written and any write error encountered.",
        "name": "fmt.Fprintf",
        "params": [],
        "path": "go/fmt/index#Fprintf",
        "syntax": "func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "fmt.Fprintln": {
        "descr": "Fprintln formats using the default formats for its operands and writes to w. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered.",
        "name": "fmt.Fprintln",
        "params": [],
        "path": "go/fmt/index#Fprintln",
        "syntax": "func Fprintln(w io.Writer, a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "fmt.Fscan": {
        "descr": "Fscan scans text read from r, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why.",
        "name": "fmt.Fscan",
        "params": [],
        "path": "go/fmt/index#Fscan",
        "syntax": "func Fscan(r io.Reader, a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "fmt.Fscanf": {
        "descr": "Fscanf scans text read from r, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully parsed. Newlines in the input must match newlines in the format.",
        "name": "fmt.Fscanf",
        "params": [],
        "path": "go/fmt/index#Fscanf",
        "syntax": "func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "fmt.Fscanln": {
        "descr": "Fscanln is similar to Fscan, but stops scanning at a newline and after the final item there must be a newline or EOF.",
        "name": "fmt.Fscanln",
        "params": [],
        "path": "go/fmt/index#Fscanln",
        "syntax": "func Fscanln(r io.Reader, a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "fmt.GoStringer": {
        "descr": "GoStringer is implemented by any value that has a GoString method, which defines the Go syntax for that value. The GoString method is used to print values passed as an operand to a %#v format.",
        "name": "fmt.GoStringer",
        "params": [],
        "path": "go/fmt/index#GoStringer",
        "syntax": "type GoStringer interface { GoString() string }",
        "type": "fmt"
    },
    "fmt.Print": {
        "descr": "Print formats using the default formats for its operands and writes to standard output. Spaces are added between operands when neither is a string. It returns the number of bytes written and any write error encountered.",
        "name": "fmt.Print",
        "params": [],
        "path": "go/fmt/index#Print",
        "syntax": "func Print(a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "fmt.Printf": {
        "descr": "Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered.",
        "name": "fmt.Printf",
        "params": [],
        "path": "go/fmt/index#Printf",
        "syntax": "func Printf(format string, a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "fmt.Println": {
        "descr": "Println formats using the default formats for its operands and writes to standard output. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered.",
        "name": "fmt.Println",
        "params": [],
        "path": "go/fmt/index#Println",
        "syntax": "func Println(a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "fmt.Scan": {
        "descr": "Scan scans text read from standard input, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why.",
        "name": "fmt.Scan",
        "params": [],
        "path": "go/fmt/index#Scan",
        "syntax": "func Scan(a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "fmt.ScanState": {
        "descr": "ScanState represents the scanner state passed to custom scanners. Scanners may do rune-at-a-time scanning or ask the ScanState to discover the next space-delimited token.",
        "name": "fmt.ScanState",
        "params": [],
        "path": "go/fmt/index#ScanState",
        "syntax": "type ScanState interface { // ReadRune reads the next rune (Unicode code point) from the input. // If invoked during Scanln, Fscanln, or Sscanln, ReadRune() will // return EOF after returning the first '\\n' or when reading beyond // the specified width. ReadRune() (r rune, size int, err error) // UnreadRune causes the next call to ReadRune to return the same rune. UnreadRune() error // SkipSpace skips space in the input. Newlines are treated appropriately // for the operation being performed; see the package documentation // for more information. SkipSpace() // Token skips space in the input if skipSpace is true, then returns the // run of Unicode code points c satisfying f(c). If f is nil, // !unicode.IsSpace(c) is used; that is, the token will hold non-space // characters. Newlines are treated appropriately for the operation being // performed; see the package documentation for more information. // The returned slice points to shared data that may be overwritten // by the next call to Token, a call to a Scan function using the ScanState // as input, or when the calling Scan method returns. Token(skipSpace bool, f func(rune) bool) (token []byte, err error) // Width returns the value of the width option and whether it has been set. // The unit is Unicode code points. Width() (wid int, ok bool) // Because ReadRune is implemented by the interface, Read should never be // called by the scanning routines and a valid implementation of // ScanState may choose always to return an error from Read. Read(buf []byte) (n int, err error) }",
        "type": "fmt"
    },
    "fmt.Scanf": {
        "descr": "Scanf scans text read from standard input, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why. Newlines in the input must match newlines in the format. The one exception: the verb %c always scans the next rune in the input, even if it is a space (or tab etc.) or newline.",
        "name": "fmt.Scanf",
        "params": [],
        "path": "go/fmt/index#Scanf",
        "syntax": "func Scanf(format string, a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "fmt.Scanln": {
        "descr": "Scanln is similar to Scan, but stops scanning at a newline and after the final item there must be a newline or EOF.",
        "name": "fmt.Scanln",
        "params": [],
        "path": "go/fmt/index#Scanln",
        "syntax": "func Scanln(a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "fmt.Scanner": {
        "descr": "Scanner is implemented by any value that has a Scan method, which scans the input for the representation of a value and stores the result in the receiver, which must be a pointer to be useful. The Scan method is called for any argument to Scan, Scanf, or Scanln that implements it.",
        "name": "fmt.Scanner",
        "params": [],
        "path": "go/fmt/index#Scanner",
        "syntax": "type Scanner interface { Scan(state ScanState, verb rune) error }",
        "type": "fmt"
    },
    "fmt.Sprint": {
        "descr": "Sprint formats using the default formats for its operands and returns the resulting string. Spaces are added between operands when neither is a string.",
        "name": "fmt.Sprint",
        "params": [],
        "path": "go/fmt/index#Sprint",
        "syntax": "func Sprint(a ...interface{}) string",
        "type": "fmt"
    },
    "fmt.Sprintf": {
        "descr": "Sprintf formats according to a format specifier and returns the resulting string.",
        "name": "fmt.Sprintf",
        "params": [],
        "path": "go/fmt/index#Sprintf",
        "syntax": "func Sprintf(format string, a ...interface{}) string",
        "type": "fmt"
    },
    "fmt.Sprintln": {
        "descr": "Sprintln formats using the default formats for its operands and returns the resulting string. Spaces are always added between operands and a newline is appended.",
        "name": "fmt.Sprintln",
        "params": [],
        "path": "go/fmt/index#Sprintln",
        "syntax": "func Sprintln(a ...interface{}) string",
        "type": "fmt"
    },
    "fmt.Sscan": {
        "descr": "Sscan scans the argument string, storing successive space-separated values into successive arguments. Newlines count as space. It returns the number of items successfully scanned. If that is less than the number of arguments, err will report why.",
        "name": "fmt.Sscan",
        "params": [],
        "path": "go/fmt/index#Sscan",
        "syntax": "func Sscan(str string, a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "fmt.Sscanf": {
        "descr": "Sscanf scans the argument string, storing successive space-separated values into successive arguments as determined by the format. It returns the number of items successfully parsed. Newlines in the input must match newlines in the format.",
        "name": "fmt.Sscanf",
        "params": [],
        "path": "go/fmt/index#Sscanf",
        "syntax": "func Sscanf(str string, format string, a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "fmt.Sscanln": {
        "descr": "Sscanln is similar to Sscan, but stops scanning at a newline and after the final item there must be a newline or EOF.",
        "name": "fmt.Sscanln",
        "params": [],
        "path": "go/fmt/index#Sscanln",
        "syntax": "func Sscanln(str string, a ...interface{}) (n int, err error)",
        "type": "fmt"
    },
    "fmt.State": {
        "descr": "State represents the printer state passed to custom formatters. It provides access to the io.Writer interface plus information about the flags and options for the operand's format specifier.",
        "name": "fmt.State",
        "params": [],
        "path": "go/fmt/index#State",
        "syntax": "type State interface { // Write is the function to call to emit formatted output to be printed. Write(b []byte) (n int, err error) // Width returns the value of the width option and whether it has been set. Width() (wid int, ok bool) // Precision returns the value of the precision option and whether it has been set. Precision() (prec int, ok bool) // Flag reports whether the flag c, a character, has been set. Flag(c int) bool }",
        "type": "fmt"
    },
    "fmt.Stringer": {
        "descr": "Stringer is implemented by any value that has a String method, which defines the native format for that value. The String method is used to print values passed as an operand to any format that accepts a string or to an unformatted printer such as Print.",
        "name": "fmt.Stringer",
        "params": [],
        "path": "go/fmt/index#Stringer",
        "syntax": "type Stringer interface { String() string }",
        "type": "fmt"
    },
    "fnv.New128": {
        "descr": "New128 returns a new 128-bit FNV-1 hash.Hash. Its Sum method will lay the value out in big-endian byte order.",
        "name": "fnv.New128",
        "params": [],
        "path": "go/hash/fnv/index#New128",
        "syntax": "func New128() hash.Hash",
        "type": "hash"
    },
    "fnv.New128a": {
        "descr": "New128a returns a new 128-bit FNV-1a hash.Hash. Its Sum method will lay the value out in big-endian byte order.",
        "name": "fnv.New128a",
        "params": [],
        "path": "go/hash/fnv/index#New128a",
        "syntax": "func New128a() hash.Hash",
        "type": "hash"
    },
    "fnv.New32": {
        "descr": "New32 returns a new 32-bit FNV-1 hash.Hash. Its Sum method will lay the value out in big-endian byte order.",
        "name": "fnv.New32",
        "params": [],
        "path": "go/hash/fnv/index#New32",
        "syntax": "func New32() hash.Hash32",
        "type": "hash"
    },
    "fnv.New32a": {
        "descr": "New32a returns a new 32-bit FNV-1a hash.Hash. Its Sum method will lay the value out in big-endian byte order.",
        "name": "fnv.New32a",
        "params": [],
        "path": "go/hash/fnv/index#New32a",
        "syntax": "func New32a() hash.Hash32",
        "type": "hash"
    },
    "fnv.New64": {
        "descr": "New64 returns a new 64-bit FNV-1 hash.Hash. Its Sum method will lay the value out in big-endian byte order.",
        "name": "fnv.New64",
        "params": [],
        "path": "go/hash/fnv/index#New64",
        "syntax": "func New64() hash.Hash64",
        "type": "hash"
    },
    "fnv.New64a": {
        "descr": "New64a returns a new 64-bit FNV-1a hash.Hash. Its Sum method will lay the value out in big-endian byte order.",
        "name": "fnv.New64a",
        "params": [],
        "path": "go/hash/fnv/index#New64a",
        "syntax": "func New64a() hash.Hash64",
        "type": "hash"
    },
    "format.Node": {
        "descr": "Node formats node in canonical gofmt style and writes the result to dst.",
        "name": "format.Node",
        "params": [],
        "path": "go/go/format/index#Node",
        "syntax": "func Node(dst io.Writer, fset *token.FileSet, node interface{}) error",
        "type": "go"
    },
    "format.Source": {
        "descr": "Source formats src in canonical gofmt style and returns the result or an (I/O or syntax) error. src is expected to be a syntactically correct Go source file, or a list of Go declarations or statements.",
        "name": "format.Source",
        "params": [],
        "path": "go/go/format/index#Source",
        "syntax": "func Source(src []byte) ([]byte, error)",
        "type": "go"
    },
    "gif.Decode": {
        "descr": "Decode reads a GIF image from r and returns the first embedded image as an image.Image.",
        "name": "gif.Decode",
        "params": [],
        "path": "go/image/gif/index#Decode",
        "syntax": "func Decode(r io.Reader) (image.Image, error)",
        "type": "image"
    },
    "gif.DecodeAll": {
        "descr": "DecodeAll reads a GIF image from r and returns the sequential frames and timing information.",
        "name": "gif.DecodeAll",
        "params": [],
        "path": "go/image/gif/index#DecodeAll",
        "syntax": "func DecodeAll(r io.Reader) (*GIF, error)",
        "type": "image"
    },
    "gif.DecodeConfig": {
        "descr": "DecodeConfig returns the global color model and dimensions of a GIF image without decoding the entire image.",
        "name": "gif.DecodeConfig",
        "params": [],
        "path": "go/image/gif/index#DecodeConfig",
        "syntax": "func DecodeConfig(r io.Reader) (image.Config, error)",
        "type": "image"
    },
    "gif.Encode": {
        "descr": "Encode writes the Image m to w in GIF format.",
        "name": "gif.Encode",
        "params": [],
        "path": "go/image/gif/index#Encode",
        "syntax": "func Encode(w io.Writer, m image.Image, o *Options) error",
        "type": "image"
    },
    "gif.EncodeAll": {
        "descr": "EncodeAll writes the images in g to w in GIF format with the given loop count and delay between frames.",
        "name": "gif.EncodeAll",
        "params": [],
        "path": "go/image/gif/index#EncodeAll",
        "syntax": "func EncodeAll(w io.Writer, g *GIF) error",
        "type": "image"
    },
    "gif.GIF": {
        "descr": "GIF represents the possibly multiple images stored in a GIF file.",
        "name": "gif.GIF",
        "params": [],
        "path": "go/image/gif/index#GIF",
        "syntax": "type GIF struct { Image []*image.Paletted // The successive images. Delay []int // The successive delay times, one per frame, in 100ths of a second. // LoopCount controls the number of times an animation will be // restarted during display. // A LoopCount of 0 means to loop forever. // A LoopCount of -1 means to show each frame only once. // Otherwise, the animation is looped LoopCount+1 times. LoopCount int // Disposal is the successive disposal methods, one per frame. For // backwards compatibility, a nil Disposal is valid to pass to EncodeAll, // and implies that each frame's disposal method is 0 (no disposal // specified). Disposal []byte // Go 1.5 // Config is the global color table (palette), width and height. A nil or // empty-color.Palette Config.ColorModel means that each frame has its own // color table and there is no global color table. Each frame's bounds must // be within the rectangle defined by the two points (0, 0) and // (Config.Width, Config.Height). // // For backwards compatibility, a zero-valued Config is valid to pass to // EncodeAll, and implies that the overall GIF's width and height equals // the first frame's bounds' Rectangle.Max point. Config image.Config // Go 1.5 // BackgroundIndex is the background index in the global color table, for // use with the DisposalBackground disposal method. BackgroundIndex byte // Go 1.5 }",
        "type": "image"
    },
    "gif.Options": {
        "descr": "Options are the encoding parameters.",
        "name": "gif.Options",
        "params": [],
        "path": "go/image/gif/index#Options",
        "syntax": "type Options struct { // NumColors is the maximum number of colors used in the image. // It ranges from 1 to 256. NumColors int // Quantizer is used to produce a palette with size NumColors. // palette.Plan9 is used in place of a nil Quantizer. Quantizer draw.Quantizer // Drawer is used to convert the source image to the desired palette. // draw.FloydSteinberg is used in place of a nil Drawer. Drawer draw.Drawer }",
        "type": "image"
    },
    "gob.CommonType": {
        "descr": "CommonType holds elements of all types. It is a historical artifact, kept for binary compatibility and exported only for the benefit of the package's encoding of type descriptors. It is not intended for direct use by clients.",
        "name": "gob.CommonType",
        "params": [],
        "path": "go/encoding/gob/index#CommonType",
        "syntax": "type CommonType struct { Name string Id typeId }",
        "type": "encoding"
    },
    "gob.Decoder": {
        "descr": "A Decoder manages the receipt of type and data information read from the remote side of a connection.",
        "name": "gob.Decoder",
        "params": [],
        "path": "go/encoding/gob/index#Decoder",
        "syntax": "type Decoder struct { // contains filtered or unexported fields }",
        "type": "encoding"
    },
    "gob.Decoder.Decode": {
        "descr": "Decode reads the next value from the input stream and stores it in the data represented by the empty interface value. If e is nil, the value will be discarded. Otherwise, the value underlying e must be a pointer to the correct type for the next data item received. If the input is at EOF, Decode returns io.EOF and does not modify e.",
        "name": "gob.Decoder.Decode",
        "params": [],
        "path": "go/encoding/gob/index#Decoder.Decode",
        "syntax": "func (dec *Decoder) Decode(e interface{}) error",
        "type": "encoding"
    },
    "gob.Decoder.DecodeValue": {
        "descr": "DecodeValue reads the next value from the input stream. If v is the zero reflect.Value (v.Kind() == Invalid), DecodeValue discards the value. Otherwise, it stores the value into v. In that case, v must represent a non-nil pointer to data or be an assignable reflect.Value (v.CanSet()) If the input is at EOF, DecodeValue returns io.EOF and does not modify v.",
        "name": "gob.Decoder.DecodeValue",
        "params": [],
        "path": "go/encoding/gob/index#Decoder.DecodeValue",
        "syntax": "func (dec *Decoder) DecodeValue(v reflect.Value) error",
        "type": "encoding"
    },
    "gob.Encoder": {
        "descr": "An Encoder manages the transmission of type and data information to the other side of a connection.",
        "name": "gob.Encoder",
        "params": [],
        "path": "go/encoding/gob/index#Encoder",
        "syntax": "type Encoder struct { // contains filtered or unexported fields }",
        "type": "encoding"
    },
    "gob.Encoder.Encode": {
        "descr": "Encode transmits the data item represented by the empty interface value, guaranteeing that all necessary type information has been transmitted first. Passing a nil pointer to Encoder will panic, as they cannot be transmitted by gob.",
        "name": "gob.Encoder.Encode",
        "params": [],
        "path": "go/encoding/gob/index#Encoder.Encode",
        "syntax": "func (enc *Encoder) Encode(e interface{}) error",
        "type": "encoding"
    },
    "gob.Encoder.EncodeValue": {
        "descr": "EncodeValue transmits the data item represented by the reflection value, guaranteeing that all necessary type information has been transmitted first. Passing a nil pointer to EncodeValue will panic, as they cannot be transmitted by gob.",
        "name": "gob.Encoder.EncodeValue",
        "params": [],
        "path": "go/encoding/gob/index#Encoder.EncodeValue",
        "syntax": "func (enc *Encoder) EncodeValue(value reflect.Value) error",
        "type": "encoding"
    },
    "gob.GobDecoder": {
        "descr": "GobDecoder is the interface describing data that provides its own routine for decoding transmitted values sent by a GobEncoder.",
        "name": "gob.GobDecoder",
        "params": [],
        "path": "go/encoding/gob/index#GobDecoder",
        "syntax": "type GobDecoder interface { // GobDecode overwrites the receiver, which must be a pointer, // with the value represented by the byte slice, which was written // by GobEncode, usually for the same concrete type. GobDecode([]byte) error }",
        "type": "encoding"
    },
    "gob.GobEncoder": {
        "descr": "GobEncoder is the interface describing data that provides its own representation for encoding values for transmission to a GobDecoder. A type that implements GobEncoder and GobDecoder has complete control over the representation of its data and may therefore contain things such as private fields, channels, and functions, which are not usually transmissible in gob streams.",
        "name": "gob.GobEncoder",
        "params": [],
        "path": "go/encoding/gob/index#GobEncoder",
        "syntax": "type GobEncoder interface { // GobEncode returns a byte slice representing the encoding of the // receiver for transmission to a GobDecoder, usually of the same // concrete type. GobEncode() ([]byte, error) }",
        "type": "encoding"
    },
    "gob.NewDecoder": {
        "descr": "NewDecoder returns a new decoder that reads from the io.Reader. If r does not also implement io.ByteReader, it will be wrapped in a bufio.Reader.",
        "name": "gob.NewDecoder",
        "params": [],
        "path": "go/encoding/gob/index#NewDecoder",
        "syntax": "func NewDecoder(r io.Reader) *Decoder",
        "type": "encoding"
    },
    "gob.NewEncoder": {
        "descr": "NewEncoder returns a new encoder that will transmit on the io.Writer.",
        "name": "gob.NewEncoder",
        "params": [],
        "path": "go/encoding/gob/index#NewEncoder",
        "syntax": "func NewEncoder(w io.Writer) *Encoder",
        "type": "encoding"
    },
    "gob.Register": {
        "descr": "Register records a type, identified by a value for that type, under its internal type name. That name will identify the concrete type of a value sent or received as an interface variable. Only types that will be transferred as implementations of interface values need to be registered. Expecting to be used only during initialization, it panics if the mapping between types and names is not a bijection.",
        "name": "gob.Register",
        "params": [],
        "path": "go/encoding/gob/index#Register",
        "syntax": "func Register(value interface{})",
        "type": "encoding"
    },
    "gob.RegisterName": {
        "descr": "RegisterName is like Register but uses the provided name rather than the type's default.",
        "name": "gob.RegisterName",
        "params": [],
        "path": "go/encoding/gob/index#RegisterName",
        "syntax": "func RegisterName(name string, value interface{})",
        "type": "encoding"
    },
    "gosym.DecodingError": {
        "descr": "DecodingError represents an error during the decoding of the symbol table.",
        "name": "gosym.DecodingError",
        "params": [],
        "path": "go/debug/gosym/index#DecodingError",
        "syntax": "type DecodingError struct { // contains filtered or unexported fields }",
        "type": "debug"
    },
    "gosym.DecodingError.Error": {
        "descr": "",
        "name": "gosym.DecodingError.Error",
        "params": [],
        "path": "go/debug/gosym/index#DecodingError.Error",
        "syntax": "func (e *DecodingError) Error() string",
        "type": "debug"
    },
    "gosym.Func": {
        "descr": "A Func collects information about a single function.",
        "name": "gosym.Func",
        "params": [],
        "path": "go/debug/gosym/index#Func",
        "syntax": "type Func struct { Entry uint64 *Sym End uint64 Params []*Sym // nil for Go 1.3 and later binaries Locals []*Sym // nil for Go 1.3 and later binaries FrameSize int LineTable *LineTable Obj *Obj }",
        "type": "debug"
    },
    "gosym.LineTable": {
        "descr": "A LineTable is a data structure mapping program counters to line numbers.",
        "name": "gosym.LineTable",
        "params": [],
        "path": "go/debug/gosym/index#LineTable",
        "syntax": "type LineTable struct { Data []byte PC uint64 Line int // contains filtered or unexported fields }",
        "type": "debug"
    },
    "gosym.LineTable.LineToPC": {
        "descr": "LineToPC returns the program counter for the given line number, considering only program counters before maxpc. Callers should use Table's LineToPC method instead.",
        "name": "gosym.LineTable.LineToPC",
        "params": [],
        "path": "go/debug/gosym/index#LineTable.LineToPC",
        "syntax": "func (t *LineTable) LineToPC(line int, maxpc uint64) uint64",
        "type": "debug"
    },
    "gosym.LineTable.PCToLine": {
        "descr": "PCToLine returns the line number for the given program counter. Callers should use Table's PCToLine method instead.",
        "name": "gosym.LineTable.PCToLine",
        "params": [],
        "path": "go/debug/gosym/index#LineTable.PCToLine",
        "syntax": "func (t *LineTable) PCToLine(pc uint64) int",
        "type": "debug"
    },
    "gosym.NewLineTable": {
        "descr": "NewLineTable returns a new PC/line table corresponding to the encoded data. Text must be the start address of the corresponding text segment.",
        "name": "gosym.NewLineTable",
        "params": [],
        "path": "go/debug/gosym/index#NewLineTable",
        "syntax": "func NewLineTable(data []byte, text uint64) *LineTable",
        "type": "debug"
    },
    "gosym.NewTable": {
        "descr": "NewTable decodes the Go symbol table (the \".gosymtab\" section in ELF), returning an in-memory representation. Starting with Go 1.3, the Go symbol table no longer includes symbol data.",
        "name": "gosym.NewTable",
        "params": [],
        "path": "go/debug/gosym/index#NewTable",
        "syntax": "func NewTable(symtab []byte, pcln *LineTable) (*Table, error)",
        "type": "debug"
    },
    "gosym.Obj": {
        "descr": "An Obj represents a collection of functions in a symbol table.",
        "name": "gosym.Obj",
        "params": [],
        "path": "go/debug/gosym/index#Obj",
        "syntax": "type Obj struct { // Funcs is a list of functions in the Obj. Funcs []Func // In Go 1.1 and earlier, Paths is a list of symbols corresponding // to the source file names that produced the Obj. // In Go 1.2, Paths is nil. // Use the keys of Table.Files to obtain a list of source files. Paths []Sym // meta }",
        "type": "debug"
    },
    "gosym.Sym": {
        "descr": "A Sym represents a single symbol table entry.",
        "name": "gosym.Sym",
        "params": [],
        "path": "go/debug/gosym/index#Sym",
        "syntax": "type Sym struct { Value uint64 Type byte Name string GoType uint64 // If this symbol is a function symbol, the corresponding Func Func *Func }",
        "type": "debug"
    },
    "gosym.Sym.BaseName": {
        "descr": "BaseName returns the symbol name without the package or receiver name.",
        "name": "gosym.Sym.BaseName",
        "params": [],
        "path": "go/debug/gosym/index#Sym.BaseName",
        "syntax": "func (s *Sym) BaseName() string",
        "type": "debug"
    },
    "gosym.Sym.PackageName": {
        "descr": "PackageName returns the package part of the symbol name, or the empty string if there is none.",
        "name": "gosym.Sym.PackageName",
        "params": [],
        "path": "go/debug/gosym/index#Sym.PackageName",
        "syntax": "func (s *Sym) PackageName() string",
        "type": "debug"
    },
    "gosym.Sym.ReceiverName": {
        "descr": "ReceiverName returns the receiver type name of this symbol, or the empty string if there is none.",
        "name": "gosym.Sym.ReceiverName",
        "params": [],
        "path": "go/debug/gosym/index#Sym.ReceiverName",
        "syntax": "func (s *Sym) ReceiverName() string",
        "type": "debug"
    },
    "gosym.Sym.Static": {
        "descr": "Static reports whether this symbol is static (not visible outside its file).",
        "name": "gosym.Sym.Static",
        "params": [],
        "path": "go/debug/gosym/index#Sym.Static",
        "syntax": "func (s *Sym) Static() bool",
        "type": "debug"
    },
    "gosym.Table": {
        "descr": "Table represents a Go symbol table. It stores all of the symbols decoded from the program and provides methods to translate between symbols, names, and addresses.",
        "name": "gosym.Table",
        "params": [],
        "path": "go/debug/gosym/index#Table",
        "syntax": "type Table struct { Syms []Sym // nil for Go 1.3 and later binaries Funcs []Func Files map[string]*Obj // nil for Go 1.2 and later binaries Objs []Obj // nil for Go 1.2 and later binaries // contains filtered or unexported fields }",
        "type": "debug"
    },
    "gosym.Table.LineToPC": {
        "descr": "LineToPC looks up the first program counter on the given line in the named file. It returns UnknownPathError or UnknownLineError if there is an error looking up this line.",
        "name": "gosym.Table.LineToPC",
        "params": [],
        "path": "go/debug/gosym/index#Table.LineToPC",
        "syntax": "func (t *Table) LineToPC(file string, line int) (pc uint64, fn *Func, err error)",
        "type": "debug"
    },
    "gosym.Table.LookupFunc": {
        "descr": "LookupFunc returns the text, data, or bss symbol with the given name, or nil if no such symbol is found.",
        "name": "gosym.Table.LookupFunc",
        "params": [],
        "path": "go/debug/gosym/index#Table.LookupFunc",
        "syntax": "func (t *Table) LookupFunc(name string) *Func",
        "type": "debug"
    },
    "gosym.Table.LookupSym": {
        "descr": "LookupSym returns the text, data, or bss symbol with the given name, or nil if no such symbol is found.",
        "name": "gosym.Table.LookupSym",
        "params": [],
        "path": "go/debug/gosym/index#Table.LookupSym",
        "syntax": "func (t *Table) LookupSym(name string) *Sym",
        "type": "debug"
    },
    "gosym.Table.PCToFunc": {
        "descr": "PCToFunc returns the function containing the program counter pc, or nil if there is no such function.",
        "name": "gosym.Table.PCToFunc",
        "params": [],
        "path": "go/debug/gosym/index#Table.PCToFunc",
        "syntax": "func (t *Table) PCToFunc(pc uint64) *Func",
        "type": "debug"
    },
    "gosym.Table.PCToLine": {
        "descr": "PCToLine looks up line number information for a program counter. If there is no information, it returns fn == nil.",
        "name": "gosym.Table.PCToLine",
        "params": [],
        "path": "go/debug/gosym/index#Table.PCToLine",
        "syntax": "func (t *Table) PCToLine(pc uint64) (file string, line int, fn *Func)",
        "type": "debug"
    },
    "gosym.Table.SymByAddr": {
        "descr": "SymByAddr returns the text, data, or bss symbol starting at the given address.",
        "name": "gosym.Table.SymByAddr",
        "params": [],
        "path": "go/debug/gosym/index#Table.SymByAddr",
        "syntax": "func (t *Table) SymByAddr(addr uint64) *Sym",
        "type": "debug"
    },
    "gosym.UnknownFileError": {
        "descr": "UnknownFileError represents a failure to find the specific file in the symbol table.",
        "name": "gosym.UnknownFileError",
        "params": [],
        "path": "go/debug/gosym/index#UnknownFileError",
        "syntax": "type UnknownFileError string",
        "type": "debug"
    },
    "gosym.UnknownFileError.Error": {
        "descr": "",
        "name": "gosym.UnknownFileError.Error",
        "params": [],
        "path": "go/debug/gosym/index#UnknownFileError.Error",
        "syntax": "func (e UnknownFileError) Error() string",
        "type": "debug"
    },
    "gosym.UnknownLineError": {
        "descr": "UnknownLineError represents a failure to map a line to a program counter, either because the line is beyond the bounds of the file or because there is no code on the given line.",
        "name": "gosym.UnknownLineError",
        "params": [],
        "path": "go/debug/gosym/index#UnknownLineError",
        "syntax": "type UnknownLineError struct { File string Line int }",
        "type": "debug"
    },
    "gosym.UnknownLineError.Error": {
        "descr": "",
        "name": "gosym.UnknownLineError.Error",
        "params": [],
        "path": "go/debug/gosym/index#UnknownLineError.Error",
        "syntax": "func (e *UnknownLineError) Error() string",
        "type": "debug"
    },
    "gzip.Header": {
        "descr": "The gzip file stores a header giving metadata about the compressed file. That header is exposed as the fields of the Writer and Reader structs.",
        "name": "gzip.Header",
        "params": [],
        "path": "go/compress/gzip/index#Header",
        "syntax": "type Header struct { Comment string // comment Extra []byte // \"extra data\" ModTime time.Time // modification time Name string // file name OS byte // operating system type }",
        "type": "compress"
    },
    "gzip.NewReader": {
        "descr": "NewReader creates a new Reader reading the given reader. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r.",
        "name": "gzip.NewReader",
        "params": [],
        "path": "go/compress/gzip/index#NewReader",
        "syntax": "func NewReader(r io.Reader) (*Reader, error)",
        "type": "compress"
    },
    "gzip.NewWriter": {
        "descr": "NewWriter returns a new Writer. Writes to the returned writer are compressed and written to w.",
        "name": "gzip.NewWriter",
        "params": [],
        "path": "go/compress/gzip/index#NewWriter",
        "syntax": "func NewWriter(w io.Writer) *Writer",
        "type": "compress"
    },
    "gzip.NewWriterLevel": {
        "descr": "NewWriterLevel is like NewWriter but specifies the compression level instead of assuming DefaultCompression.",
        "name": "gzip.NewWriterLevel",
        "params": [],
        "path": "go/compress/gzip/index#NewWriterLevel",
        "syntax": "func NewWriterLevel(w io.Writer, level int) (*Writer, error)",
        "type": "compress"
    },
    "gzip.Reader": {
        "descr": "A Reader is an io.Reader that can be read to retrieve uncompressed data from a gzip-format compressed file.",
        "name": "gzip.Reader",
        "params": [],
        "path": "go/compress/gzip/index#Reader",
        "syntax": "type Reader struct { Header // valid after NewReader or Reader.Reset // contains filtered or unexported fields }",
        "type": "compress"
    },
    "gzip.Reader.Close": {
        "descr": "Close closes the Reader. It does not close the underlying io.Reader. In order for the GZIP checksum to be verified, the reader must be fully consumed until the io.EOF.",
        "name": "gzip.Reader.Close",
        "params": [],
        "path": "go/compress/gzip/index#Reader.Close",
        "syntax": "func (z *Reader) Close() error",
        "type": "compress"
    },
    "gzip.Reader.Multistream": {
        "descr": "Multistream controls whether the reader supports multistream files.",
        "name": "gzip.Reader.Multistream",
        "params": [],
        "path": "go/compress/gzip/index#Reader.Multistream",
        "syntax": "func (z *Reader) Multistream(ok bool)",
        "type": "compress"
    },
    "gzip.Reader.Read": {
        "descr": "Read implements io.Reader, reading uncompressed bytes from its underlying Reader.",
        "name": "gzip.Reader.Read",
        "params": [],
        "path": "go/compress/gzip/index#Reader.Read",
        "syntax": "func (z *Reader) Read(p []byte) (n int, err error)",
        "type": "compress"
    },
    "gzip.Reader.Reset": {
        "descr": "Reset discards the Reader z's state and makes it equivalent to the result of its original state from NewReader, but reading from r instead. This permits reusing a Reader rather than allocating a new one.",
        "name": "gzip.Reader.Reset",
        "params": [],
        "path": "go/compress/gzip/index#Reader.Reset",
        "syntax": "func (z *Reader) Reset(r io.Reader) error",
        "type": "compress"
    },
    "gzip.Writer": {
        "descr": "A Writer is an io.WriteCloser. Writes to a Writer are compressed and written to w.",
        "name": "gzip.Writer",
        "params": [],
        "path": "go/compress/gzip/index#Writer",
        "syntax": "type Writer struct { Header // written at first call to Write, Flush, or Close // contains filtered or unexported fields }",
        "type": "compress"
    },
    "gzip.Writer.Close": {
        "descr": "Close closes the Writer by flushing any unwritten data to the underlying io.Writer and writing the GZIP footer. It does not close the underlying io.Writer.",
        "name": "gzip.Writer.Close",
        "params": [],
        "path": "go/compress/gzip/index#Writer.Close",
        "syntax": "func (z *Writer) Close() error",
        "type": "compress"
    },
    "gzip.Writer.Flush": {
        "descr": "Flush flushes any pending compressed data to the underlying writer.",
        "name": "gzip.Writer.Flush",
        "params": [],
        "path": "go/compress/gzip/index#Writer.Flush",
        "syntax": "func (z *Writer) Flush() error",
        "type": "compress"
    },
    "gzip.Writer.Reset": {
        "descr": "Reset discards the Writer z's state and makes it equivalent to the result of its original state from NewWriter or NewWriterLevel, but writing to w instead. This permits reusing a Writer rather than allocating a new one.",
        "name": "gzip.Writer.Reset",
        "params": [],
        "path": "go/compress/gzip/index#Writer.Reset",
        "syntax": "func (z *Writer) Reset(w io.Writer)",
        "type": "compress"
    },
    "gzip.Writer.Write": {
        "descr": "Write writes a compressed form of p to the underlying io.Writer. The compressed bytes are not necessarily flushed until the Writer is closed.",
        "name": "gzip.Writer.Write",
        "params": [],
        "path": "go/compress/gzip/index#Writer.Write",
        "syntax": "func (z *Writer) Write(p []byte) (int, error)",
        "type": "compress"
    },
    "hash.Hash": {
        "descr": "Hash is the common interface implemented by all hash functions.",
        "name": "hash.Hash",
        "params": [],
        "path": "go/hash/index#Hash",
        "syntax": "type Hash interface { // Write (via the embedded io.Writer interface) adds more data to the running hash. // It never returns an error. io.Writer // Sum appends the current hash to b and returns the resulting slice. // It does not change the underlying hash state. Sum(b []byte) []byte // Reset resets the Hash to its initial state. Reset() // Size returns the number of bytes Sum will return. Size() int // BlockSize returns the hash's underlying block size. // The Write method must be able to accept any amount // of data, but it may operate more efficiently if all writes // are a multiple of the block size. BlockSize() int }",
        "type": "hash"
    },
    "hash.Hash32": {
        "descr": "Hash32 is the common interface implemented by all 32-bit hash functions.",
        "name": "hash.Hash32",
        "params": [],
        "path": "go/hash/index#Hash32",
        "syntax": "type Hash32 interface { Hash Sum32() uint32 }",
        "type": "hash"
    },
    "hash.Hash64": {
        "descr": "Hash64 is the common interface implemented by all 64-bit hash functions.",
        "name": "hash.Hash64",
        "params": [],
        "path": "go/hash/index#Hash64",
        "syntax": "type Hash64 interface { Hash Sum64() uint64 }",
        "type": "hash"
    },
    "heap.Fix": {
        "descr": "Fix re-establishes the heap ordering after the element at index i has changed its value. Changing the value of the element at index i and then calling Fix is equivalent to, but less expensive than, calling Remove(h, i) followed by a Push of the new value. The complexity is O(log(n)) where n = h.Len().",
        "name": "heap.Fix",
        "params": [],
        "path": "go/container/heap/index#Fix",
        "syntax": "func Fix(h Interface, i int)",
        "type": "container"
    },
    "heap.Init": {
        "descr": "Init establishes the heap invariants required by the other routines in this package. Init is idempotent with respect to the heap invariants and may be called whenever the heap invariants may have been invalidated. Its complexity is O(n) where n = h.Len().",
        "name": "heap.Init",
        "params": [],
        "path": "go/container/heap/index#Init",
        "syntax": "func Init(h Interface)",
        "type": "container"
    },
    "heap.Interface": {
        "descr": "The Interface type describes the requirements for a type using the routines in this package. Any type that implements it may be used as a min-heap with the following invariants (established after Init has been called or if the data is empty or sorted):",
        "name": "heap.Interface",
        "params": [],
        "path": "go/container/heap/index#Interface",
        "syntax": "!h.Less(j, i) for 0 <= i < h.Len() and 2*i+1 <= j <= 2*i+2 and j < h.Len()",
        "type": "container"
    },
    "heap.Pop": {
        "descr": "Pop removes the minimum element (according to Less) from the heap and returns it. The complexity is O(log(n)) where n = h.Len(). It is equivalent to Remove(h, 0).",
        "name": "heap.Pop",
        "params": [],
        "path": "go/container/heap/index#Pop",
        "syntax": "func Pop(h Interface) interface{}",
        "type": "container"
    },
    "heap.Push": {
        "descr": "Push pushes the element x onto the heap. The complexity is O(log(n)) where n = h.Len().",
        "name": "heap.Push",
        "params": [],
        "path": "go/container/heap/index#Push",
        "syntax": "func Push(h Interface, x interface{})",
        "type": "container"
    },
    "heap.Remove": {
        "descr": "Remove removes the element at index i from the heap. The complexity is O(log(n)) where n = h.Len().",
        "name": "heap.Remove",
        "params": [],
        "path": "go/container/heap/index#Remove",
        "syntax": "func Remove(h Interface, i int) interface{}",
        "type": "container"
    },
    "hex.Decode": {
        "descr": "Decode decodes src into DecodedLen(len(src)) bytes, returning the actual number of bytes written to dst.",
        "name": "hex.Decode",
        "params": [],
        "path": "go/encoding/hex/index#Decode",
        "syntax": "func Decode(dst, src []byte) (int, error)",
        "type": "encoding"
    },
    "hex.DecodeString": {
        "descr": "DecodeString returns the bytes represented by the hexadecimal string s.",
        "name": "hex.DecodeString",
        "params": [],
        "path": "go/encoding/hex/index#DecodeString",
        "syntax": "func DecodeString(s string) ([]byte, error)",
        "type": "encoding"
    },
    "hex.DecodedLen": {
        "descr": "DecodedLen returns the length of a decoding of x source bytes. Specifically, it returns x / 2.",
        "name": "hex.DecodedLen",
        "params": [],
        "path": "go/encoding/hex/index#DecodedLen",
        "syntax": "func DecodedLen(x int) int",
        "type": "encoding"
    },
    "hex.Dump": {
        "descr": "Dump returns a string that contains a hex dump of the given data. The format of the hex dump matches the output of `hexdump -C` on the command line.",
        "name": "hex.Dump",
        "params": [],
        "path": "go/encoding/hex/index#Dump",
        "syntax": "func Dump(data []byte) string",
        "type": "encoding"
    },
    "hex.Dumper": {
        "descr": "Dumper returns a WriteCloser that writes a hex dump of all written data to w. The format of the dump matches the output of `hexdump -C` on the command line.",
        "name": "hex.Dumper",
        "params": [],
        "path": "go/encoding/hex/index#Dumper",
        "syntax": "func Dumper(w io.Writer) io.WriteCloser",
        "type": "encoding"
    },
    "hex.Encode": {
        "descr": "Encode encodes src into EncodedLen(len(src)) bytes of dst. As a convenience, it returns the number of bytes written to dst, but this value is always EncodedLen(len(src)). Encode implements hexadecimal encoding.",
        "name": "hex.Encode",
        "params": [],
        "path": "go/encoding/hex/index#Encode",
        "syntax": "func Encode(dst, src []byte) int",
        "type": "encoding"
    },
    "hex.EncodeToString": {
        "descr": "EncodeToString returns the hexadecimal encoding of src.",
        "name": "hex.EncodeToString",
        "params": [],
        "path": "go/encoding/hex/index#EncodeToString",
        "syntax": "func EncodeToString(src []byte) string",
        "type": "encoding"
    },
    "hex.EncodedLen": {
        "descr": "EncodedLen returns the length of an encoding of n source bytes. Specifically, it returns n * 2.",
        "name": "hex.EncodedLen",
        "params": [],
        "path": "go/encoding/hex/index#EncodedLen",
        "syntax": "func EncodedLen(n int) int",
        "type": "encoding"
    },
    "hex.InvalidByteError": {
        "descr": "InvalidByteError values describe errors resulting from an invalid byte in a hex string.",
        "name": "hex.InvalidByteError",
        "params": [],
        "path": "go/encoding/hex/index#InvalidByteError",
        "syntax": "type InvalidByteError byte",
        "type": "encoding"
    },
    "hex.InvalidByteError.Error": {
        "descr": "",
        "name": "hex.InvalidByteError.Error",
        "params": [],
        "path": "go/encoding/hex/index#InvalidByteError.Error",
        "syntax": "func (e InvalidByteError) Error() string",
        "type": "encoding"
    },
    "hex.NewDecoder": {
        "descr": "NewDecoder returns an io.Reader that decodes hexadecimal characters from r. NewDecoder expects that r contain only an even number of hexadecimal characters.",
        "name": "hex.NewDecoder",
        "params": [],
        "path": "go/encoding/hex/index#NewDecoder",
        "syntax": "func NewDecoder(r io.Reader) io.Reader",
        "type": "encoding"
    },
    "hex.NewEncoder": {
        "descr": "NewEncoder returns an io.Writer that writes lowercase hexadecimal characters to w.",
        "name": "hex.NewEncoder",
        "params": [],
        "path": "go/encoding/hex/index#NewEncoder",
        "syntax": "func NewEncoder(w io.Writer) io.Writer",
        "type": "encoding"
    },
    "hmac.Equal": {
        "descr": "Equal compares two MACs for equality without leaking timing information.",
        "name": "hmac.Equal",
        "params": [],
        "path": "go/crypto/hmac/index#Equal",
        "syntax": "func Equal(mac1, mac2 []byte) bool",
        "type": "crypto"
    },
    "hmac.New": {
        "descr": "New returns a new HMAC hash using the given hash.Hash type and key. Note that unlike other hash implementations in the standard library, the returned Hash does not implement encoding.BinaryMarshaler or encoding.BinaryUnmarshaler.",
        "name": "hmac.New",
        "params": [],
        "path": "go/crypto/hmac/index#New",
        "syntax": "func New(h func() hash.Hash, key []byte) hash.Hash",
        "type": "crypto"
    },
    "html.EscapeString": {
        "descr": "EscapeString escapes special characters like \"<\" to become \"&lt;\". It escapes only five such characters: <, >, &, ' and \". UnescapeString(EscapeString(s)) == s always holds, but the converse isn't always true.",
        "name": "html.EscapeString",
        "params": [],
        "path": "go/html/index#EscapeString",
        "syntax": "func EscapeString(s string) string",
        "type": "html"
    },
    "html.UnescapeString": {
        "descr": "UnescapeString unescapes entities like \"&lt;\" to become \"<\". It unescapes a larger range of entities than EscapeString escapes. For example, \"&aacute;\" unescapes to \"\", as does \"&#225;\" and \"&#xE1;\". UnescapeString(EscapeString(s)) == s always holds, but the converse isn't always true.",
        "name": "html.UnescapeString",
        "params": [],
        "path": "go/html/index#UnescapeString",
        "syntax": "func UnescapeString(s string) string",
        "type": "html"
    },
    "http.CanonicalHeaderKey": {
        "descr": "CanonicalHeaderKey returns the canonical format of the header key s. The canonicalization converts the first letter and any letter following a hyphen to upper case; the rest are converted to lowercase. For example, the canonical key for \"accept-encoding\" is \"Accept-Encoding\". If s contains a space or invalid header field bytes, it is returned without modifications.",
        "name": "http.CanonicalHeaderKey",
        "params": [],
        "path": "go/net/http/index#CanonicalHeaderKey",
        "syntax": "func CanonicalHeaderKey(s string) string",
        "type": "net/http"
    },
    "http.Client": {
        "descr": "A Client is an HTTP client. Its zero value (DefaultClient) is a usable client that uses DefaultTransport.",
        "name": "http.Client",
        "params": [],
        "path": "go/net/http/index#Client",
        "syntax": "type Client struct { // Transport specifies the mechanism by which individual // HTTP requests are made. // If nil, DefaultTransport is used. Transport RoundTripper // CheckRedirect specifies the policy for handling redirects. // If CheckRedirect is not nil, the client calls it before // following an HTTP redirect. The arguments req and via are // the upcoming request and the requests made already, oldest // first. If CheckRedirect returns an error, the Client's Get // method returns both the previous Response (with its Body // closed) and CheckRedirect's error (wrapped in a url.Error) // instead of issuing the Request req. // As a special case, if CheckRedirect returns ErrUseLastResponse, // then the most recent response is returned with its body // unclosed, along with a nil error. // // If CheckRedirect is nil, the Client uses its default policy, // which is to stop after 10 consecutive requests. CheckRedirect func(req *Request, via []*Request) error // Jar specifies the cookie jar. // // The Jar is used to insert relevant cookies into every // outbound Request and is updated with the cookie values // of every inbound Response. The Jar is consulted for every // redirect that the Client follows. // // If Jar is nil, cookies are only sent if they are explicitly // set on the Request. Jar CookieJar // Timeout specifies a time limit for requests made by this // Client. The timeout includes connection time, any // redirects, and reading the response body. The timer remains // running after Get, Head, Post, or Do return and will // interrupt reading of the Response.Body. // // A Timeout of zero means no timeout. // // The Client cancels requests to the underlying Transport // as if the Request's Context ended. // // For compatibility, the Client will also use the deprecated // CancelRequest method on Transport if found. New // RoundTripper implementations should use the Request's Context // for cancelation instead of implementing CancelRequest. Timeout time.Duration // Go 1.3 }",
        "type": "net/http"
    },
    "http.Client.Do": {
        "descr": "Do sends an HTTP request and returns an HTTP response, following policy (such as redirects, cookies, auth) as configured on the client.",
        "name": "http.Client.Do",
        "params": [],
        "path": "go/net/http/index#Client.Do",
        "syntax": "func (c *Client) Do(req *Request) (*Response, error)",
        "type": "net/http"
    },
    "http.Client.Get": {
        "descr": "Get issues a GET to the specified URL. If the response is one of the following redirect codes, Get follows the redirect after calling the Client's CheckRedirect function:",
        "name": "http.Client.Get",
        "params": [],
        "path": "go/net/http/index#Client.Get",
        "syntax": "func (c *Client) Get(url string) (resp *Response, err error)",
        "type": "net/http"
    },
    "http.Client.Head": {
        "descr": "Head issues a HEAD to the specified URL. If the response is one of the following redirect codes, Head follows the redirect after calling the Client's CheckRedirect function:",
        "name": "http.Client.Head",
        "params": [],
        "path": "go/net/http/index#Client.Head",
        "syntax": "func (c *Client) Head(url string) (resp *Response, err error)",
        "type": "net/http"
    },
    "http.Client.Post": {
        "descr": "Post issues a POST to the specified URL.",
        "name": "http.Client.Post",
        "params": [],
        "path": "go/net/http/index#Client.Post",
        "syntax": "func (c *Client) Post(url, contentType string, body io.Reader) (resp *Response, err error)",
        "type": "net/http"
    },
    "http.Client.PostForm": {
        "descr": "PostForm issues a POST to the specified URL, with data's keys and values URL-encoded as the request body.",
        "name": "http.Client.PostForm",
        "params": [],
        "path": "go/net/http/index#Client.PostForm",
        "syntax": "func (c *Client) PostForm(url string, data url.Values) (resp *Response, err error)",
        "type": "net/http"
    },
    "http.CloseNotifier": {
        "descr": "The CloseNotifier interface is implemented by ResponseWriters which allow detecting when the underlying connection has gone away.",
        "name": "http.CloseNotifier",
        "params": [],
        "path": "go/net/http/index#CloseNotifier",
        "syntax": "type CloseNotifier interface { // CloseNotify returns a channel that receives at most a // single value (true) when the client connection has gone // away. // // CloseNotify may wait to notify until Request.Body has been // fully read. // // After the Handler has returned, there is no guarantee // that the channel receives a value. // // If the protocol is HTTP/1.1 and CloseNotify is called while // processing an idempotent request (such a GET) while // HTTP/1.1 pipelining is in use, the arrival of a subsequent // pipelined request may cause a value to be sent on the // returned channel. In practice HTTP/1.1 pipelining is not // enabled in browsers and not seen often in the wild. If this // is a problem, use HTTP/2 or only use CloseNotify on methods // such as POST. CloseNotify() <-chan bool }",
        "type": "net/http"
    },
    "http.ConnState": {
        "descr": "A ConnState represents the state of a client connection to a server. It's used by the optional Server.ConnState hook.",
        "name": "http.ConnState",
        "params": [],
        "path": "go/net/http/index#ConnState",
        "syntax": "type ConnState int",
        "type": "net/http"
    },
    "http.ConnState.String": {
        "descr": "",
        "name": "http.ConnState.String",
        "params": [],
        "path": "go/net/http/index#ConnState.String",
        "syntax": "func (c ConnState) String() string",
        "type": "net/http"
    },
    "http.Cookie": {
        "descr": "A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an HTTP response or the Cookie header of an HTTP request.",
        "name": "http.Cookie",
        "params": [],
        "path": "go/net/http/index#Cookie",
        "syntax": "type Cookie struct { Name string Value string Path string // optional Domain string // optional Expires time.Time // optional RawExpires string // for reading cookies only // MaxAge=0 means no 'Max-Age' attribute specified. // MaxAge<0 means delete cookie now, equivalently 'Max-Age: 0' // MaxAge>0 means Max-Age attribute present and given in seconds MaxAge int Secure bool HttpOnly bool SameSite SameSite // Go 1.11 Raw string Unparsed []string // Raw text of unparsed attribute-value pairs }",
        "type": "net/http"
    },
    "http.Cookie.String": {
        "descr": "String returns the serialization of the cookie for use in a Cookie header (if only Name and Value are set) or a Set-Cookie response header (if other fields are set). If c is nil or c.Name is invalid, the empty string is returned.",
        "name": "http.Cookie.String",
        "params": [],
        "path": "go/net/http/index#Cookie.String",
        "syntax": "func (c *Cookie) String() string",
        "type": "net/http"
    },
    "http.CookieJar": {
        "descr": "A CookieJar manages storage and use of cookies in HTTP requests.",
        "name": "http.CookieJar",
        "params": [],
        "path": "go/net/http/index#CookieJar",
        "syntax": "type CookieJar interface { // SetCookies handles the receipt of the cookies in a reply for the // given URL. It may or may not choose to save the cookies, depending // on the jar's policy and implementation. SetCookies(u *url.URL, cookies []*Cookie) // Cookies returns the cookies to send in a request for the given URL. // It is up to the implementation to honor the standard cookie use // restrictions such as in RFC 6265. Cookies(u *url.URL) []*Cookie }",
        "type": "net/http"
    },
    "http.DetectContentType": {
        "descr": "DetectContentType implements the algorithm described at https://mimesniff.spec.whatwg.org/ to determine the Content-Type of the given data. It considers at most the first 512 bytes of data. DetectContentType always returns a valid MIME type: if it cannot determine a more specific one, it returns \"application/octet-stream\".",
        "name": "http.DetectContentType",
        "params": [],
        "path": "go/net/http/index#DetectContentType",
        "syntax": "func DetectContentType(data []byte) string",
        "type": "net/http"
    },
    "http.Dir": {
        "descr": "A Dir implements FileSystem using the native file system restricted to a specific directory tree.",
        "name": "http.Dir",
        "params": [],
        "path": "go/net/http/index#Dir",
        "syntax": "type Dir string",
        "type": "net/http"
    },
    "http.Dir.Open": {
        "descr": "",
        "name": "http.Dir.Open",
        "params": [],
        "path": "go/net/http/index#Dir.Open",
        "syntax": "func (d Dir) Open(name string) (File, error)",
        "type": "net/http"
    },
    "http.Error": {
        "descr": "Error replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text.",
        "name": "http.Error",
        "params": [],
        "path": "go/net/http/index#Error",
        "syntax": "func Error(w ResponseWriter, error string, code int)",
        "type": "net/http"
    },
    "http.File": {
        "descr": "A File is returned by a FileSystem's Open method and can be served by the FileServer implementation.",
        "name": "http.File",
        "params": [],
        "path": "go/net/http/index#File",
        "syntax": "type File interface { io.Closer io.Reader io.Seeker Readdir(count int) ([]os.FileInfo, error) Stat() (os.FileInfo, error) }",
        "type": "net/http"
    },
    "http.FileServer": {
        "descr": "FileServer returns a handler that serves HTTP requests with the contents of the file system rooted at root.",
        "name": "http.FileServer",
        "params": [],
        "path": "go/net/http/index#FileServer",
        "syntax": "func FileServer(root FileSystem) Handler",
        "type": "net/http"
    },
    "http.FileSystem": {
        "descr": "A FileSystem implements access to a collection of named files. The elements in a file path are separated by slash ('/', U+002F) characters, regardless of host operating system convention.",
        "name": "http.FileSystem",
        "params": [],
        "path": "go/net/http/index#FileSystem",
        "syntax": "type FileSystem interface { Open(name string) (File, error) }",
        "type": "net/http"
    },
    "http.Flusher": {
        "descr": "The Flusher interface is implemented by ResponseWriters that allow an HTTP handler to flush buffered data to the client.",
        "name": "http.Flusher",
        "params": [],
        "path": "go/net/http/index#Flusher",
        "syntax": "type Flusher interface { // Flush sends any buffered data to the client. Flush() }",
        "type": "net/http"
    },
    "http.Get": {
        "descr": "Get issues a GET to the specified URL. If the response is one of the following redirect codes, Get follows the redirect, up to a maximum of 10 redirects:",
        "name": "http.Get",
        "params": [],
        "path": "go/net/http/index#Get",
        "syntax": "func Get(url string) (resp *Response, err error)",
        "type": "net/http"
    },
    "http.Handle": {
        "descr": "Handle registers the handler for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched.",
        "name": "http.Handle",
        "params": [],
        "path": "go/net/http/index#Handle",
        "syntax": "func Handle(pattern string, handler Handler)",
        "type": "net/http"
    },
    "http.HandleFunc": {
        "descr": "HandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched.",
        "name": "http.HandleFunc",
        "params": [],
        "path": "go/net/http/index#HandleFunc",
        "syntax": "func HandleFunc(pattern string, handler func(ResponseWriter, *Request))",
        "type": "net/http"
    },
    "http.Handler": {
        "descr": "A Handler responds to an HTTP request.",
        "name": "http.Handler",
        "params": [],
        "path": "go/net/http/index#Handler",
        "syntax": "type Handler interface { ServeHTTP(ResponseWriter, *Request) }",
        "type": "net/http"
    },
    "http.HandlerFunc": {
        "descr": "The HandlerFunc type is an adapter to allow the use of ordinary functions as HTTP handlers. If f is a function with the appropriate signature, HandlerFunc(f) is a Handler that calls f.",
        "name": "http.HandlerFunc",
        "params": [],
        "path": "go/net/http/index#HandlerFunc",
        "syntax": "type HandlerFunc func(ResponseWriter, *Request)",
        "type": "net/http"
    },
    "http.HandlerFunc.ServeHTTP": {
        "descr": "ServeHTTP calls f(w, r).",
        "name": "http.HandlerFunc.ServeHTTP",
        "params": [],
        "path": "go/net/http/index#HandlerFunc.ServeHTTP",
        "syntax": "func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request)",
        "type": "net/http"
    },
    "http.Head": {
        "descr": "Head issues a HEAD to the specified URL. If the response is one of the following redirect codes, Head follows the redirect, up to a maximum of 10 redirects:",
        "name": "http.Head",
        "params": [],
        "path": "go/net/http/index#Head",
        "syntax": "func Head(url string) (resp *Response, err error)",
        "type": "net/http"
    },
    "http.Header": {
        "descr": "A Header represents the key-value pairs in an HTTP header.",
        "name": "http.Header",
        "params": [],
        "path": "go/net/http/index#Header",
        "syntax": "type Header map[string][]string",
        "type": "net/http"
    },
    "http.Header.Add": {
        "descr": "Add adds the key, value pair to the header. It appends to any existing values associated with key.",
        "name": "http.Header.Add",
        "params": [],
        "path": "go/net/http/index#Header.Add",
        "syntax": "func (h Header) Add(key, value string)",
        "type": "net/http"
    },
    "http.Header.Del": {
        "descr": "Del deletes the values associated with key.",
        "name": "http.Header.Del",
        "params": [],
        "path": "go/net/http/index#Header.Del",
        "syntax": "func (h Header) Del(key string)",
        "type": "net/http"
    },
    "http.Header.Get": {
        "descr": "Get gets the first value associated with the given key. It is case insensitive; textproto.CanonicalMIMEHeaderKey is used to canonicalize the provided key. If there are no values associated with the key, Get returns \"\". To access multiple values of a key, or to use non-canonical keys, access the map directly.",
        "name": "http.Header.Get",
        "params": [],
        "path": "go/net/http/index#Header.Get",
        "syntax": "func (h Header) Get(key string) string",
        "type": "net/http"
    },
    "http.Header.Set": {
        "descr": "Set sets the header entries associated with key to the single element value. It replaces any existing values associated with key.",
        "name": "http.Header.Set",
        "params": [],
        "path": "go/net/http/index#Header.Set",
        "syntax": "func (h Header) Set(key, value string)",
        "type": "net/http"
    },
    "http.Header.Write": {
        "descr": "Write writes a header in wire format.",
        "name": "http.Header.Write",
        "params": [],
        "path": "go/net/http/index#Header.Write",
        "syntax": "func (h Header) Write(w io.Writer) error",
        "type": "net/http"
    },
    "http.Header.WriteSubset": {
        "descr": "WriteSubset writes a header in wire format. If exclude is not nil, keys where exclude[key] == true are not written.",
        "name": "http.Header.WriteSubset",
        "params": [],
        "path": "go/net/http/index#Header.WriteSubset",
        "syntax": "func (h Header) WriteSubset(w io.Writer, exclude map[string]bool) error",
        "type": "net/http"
    },
    "http.Hijacker": {
        "descr": "The Hijacker interface is implemented by ResponseWriters that allow an HTTP handler to take over the connection.",
        "name": "http.Hijacker",
        "params": [],
        "path": "go/net/http/index#Hijacker",
        "syntax": "type Hijacker interface { // Hijack lets the caller take over the connection. // After a call to Hijack the HTTP server library // will not do anything else with the connection. // // It becomes the caller's responsibility to manage // and close the connection. // // The returned net.Conn may have read or write deadlines // already set, depending on the configuration of the // Server. It is the caller's responsibility to set // or clear those deadlines as needed. // // The returned bufio.Reader may contain unprocessed buffered // data from the client. // // After a call to Hijack, the original Request.Body must not // be used. The original Request's Context remains valid and // is not canceled until the Request's ServeHTTP method // returns. Hijack() (net.Conn, *bufio.ReadWriter, error) }",
        "type": "net/http"
    },
    "http.ListenAndServe": {
        "descr": "ListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.",
        "name": "http.ListenAndServe",
        "params": [],
        "path": "go/net/http/index#ListenAndServe",
        "syntax": "func ListenAndServe(addr string, handler Handler) error",
        "type": "net/http"
    },
    "http.ListenAndServeTLS": {
        "descr": "ListenAndServeTLS acts identically to ListenAndServe, except that it expects HTTPS connections. Additionally, files containing a certificate and matching private key for the server must be provided. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate.",
        "name": "http.ListenAndServeTLS",
        "params": [],
        "path": "go/net/http/index#ListenAndServeTLS",
        "syntax": "func ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error",
        "type": "net/http"
    },
    "http.MaxBytesReader": {
        "descr": "MaxBytesReader is similar to io.LimitReader but is intended for limiting the size of incoming request bodies. In contrast to io.LimitReader, MaxBytesReader's result is a ReadCloser, returns a non-EOF error for a Read beyond the limit, and closes the underlying reader when its Close method is called.",
        "name": "http.MaxBytesReader",
        "params": [],
        "path": "go/net/http/index#MaxBytesReader",
        "syntax": "func MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser",
        "type": "net/http"
    },
    "http.NewFileTransport": {
        "descr": "NewFileTransport returns a new RoundTripper, serving the provided FileSystem. The returned RoundTripper ignores the URL host in its incoming requests, as well as most other properties of the request.",
        "name": "http.NewFileTransport",
        "params": [],
        "path": "go/net/http/index#NewFileTransport",
        "syntax": "func NewFileTransport(fs FileSystem) RoundTripper",
        "type": "net/http"
    },
    "http.NewRequest": {
        "descr": "NewRequest returns a new Request given a method, URL, and optional body.",
        "name": "http.NewRequest",
        "params": [],
        "path": "go/net/http/index#NewRequest",
        "syntax": "func NewRequest(method, url string, body io.Reader) (*Request, error)",
        "type": "net/http"
    },
    "http.NewServeMux": {
        "descr": "NewServeMux allocates and returns a new ServeMux.",
        "name": "http.NewServeMux",
        "params": [],
        "path": "go/net/http/index#NewServeMux",
        "syntax": "func NewServeMux() *ServeMux",
        "type": "net/http"
    },
    "http.NotFound": {
        "descr": "NotFound replies to the request with an HTTP 404 not found error.",
        "name": "http.NotFound",
        "params": [],
        "path": "go/net/http/index#NotFound",
        "syntax": "func NotFound(w ResponseWriter, r *Request)",
        "type": "net/http"
    },
    "http.NotFoundHandler": {
        "descr": "NotFoundHandler returns a simple request handler that replies to each request with a 404 page not found reply.",
        "name": "http.NotFoundHandler",
        "params": [],
        "path": "go/net/http/index#NotFoundHandler",
        "syntax": "func NotFoundHandler() Handler",
        "type": "net/http"
    },
    "http.ParseHTTPVersion": {
        "descr": "ParseHTTPVersion parses a HTTP version string. \"HTTP/1.0\" returns (1, 0, true).",
        "name": "http.ParseHTTPVersion",
        "params": [],
        "path": "go/net/http/index#ParseHTTPVersion",
        "syntax": "func ParseHTTPVersion(vers string) (major, minor int, ok bool)",
        "type": "net/http"
    },
    "http.ParseTime": {
        "descr": "ParseTime parses a time header (such as the Date: header), trying each of the three formats allowed by HTTP/1.1: TimeFormat, time.RFC850, and time.ANSIC.",
        "name": "http.ParseTime",
        "params": [],
        "path": "go/net/http/index#ParseTime",
        "syntax": "func ParseTime(text string) (t time.Time, err error)",
        "type": "net/http"
    },
    "http.Post": {
        "descr": "Post issues a POST to the specified URL.",
        "name": "http.Post",
        "params": [],
        "path": "go/net/http/index#Post",
        "syntax": "func Post(url, contentType string, body io.Reader) (resp *Response, err error)",
        "type": "net/http"
    },
    "http.PostForm": {
        "descr": "PostForm issues a POST to the specified URL, with data's keys and values URL-encoded as the request body.",
        "name": "http.PostForm",
        "params": [],
        "path": "go/net/http/index#PostForm",
        "syntax": "func PostForm(url string, data url.Values) (resp *Response, err error)",
        "type": "net/http"
    },
    "http.ProtocolError": {
        "descr": "ProtocolError represents an HTTP protocol error.",
        "name": "http.ProtocolError",
        "params": [],
        "path": "go/net/http/index#ProtocolError",
        "syntax": "type ProtocolError struct { ErrorString string }",
        "type": "net/http"
    },
    "http.ProtocolError.Error": {
        "descr": "",
        "name": "http.ProtocolError.Error",
        "params": [],
        "path": "go/net/http/index#ProtocolError.Error",
        "syntax": "func (pe *ProtocolError) Error() string",
        "type": "net/http"
    },
    "http.ProxyFromEnvironment": {
        "descr": "ProxyFromEnvironment returns the URL of the proxy to use for a given request, as indicated by the environment variables HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions thereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https requests.",
        "name": "http.ProxyFromEnvironment",
        "params": [],
        "path": "go/net/http/index#ProxyFromEnvironment",
        "syntax": "func ProxyFromEnvironment(req *Request) (*url.URL, error)",
        "type": "net/http"
    },
    "http.ProxyURL": {
        "descr": "ProxyURL returns a proxy function (for use in a Transport) that always returns the same URL.",
        "name": "http.ProxyURL",
        "params": [],
        "path": "go/net/http/index#ProxyURL",
        "syntax": "func ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error)",
        "type": "net/http"
    },
    "http.PushOptions": {
        "descr": "PushOptions describes options for Pusher.Push.",
        "name": "http.PushOptions",
        "params": [],
        "path": "go/net/http/index#PushOptions",
        "syntax": "type PushOptions struct { // Method specifies the HTTP method for the promised request. // If set, it must be \"GET\" or \"HEAD\". Empty means \"GET\". Method string // Header specifies additional promised request headers. This cannot // include HTTP/2 pseudo header fields like \":path\" and \":scheme\", // which will be added automatically. Header Header }",
        "type": "net/http"
    },
    "http.Pusher": {
        "descr": "Pusher is the interface implemented by ResponseWriters that support HTTP/2 server push. For more background, see https://tools.ietf.org/html/rfc7540#section-8.2.",
        "name": "http.Pusher",
        "params": [],
        "path": "go/net/http/index#Pusher",
        "syntax": "type Pusher interface { // Push initiates an HTTP/2 server push. This constructs a synthetic // request using the given target and options, serializes that request // into a PUSH_PROMISE frame, then dispatches that request using the // server's request handler. If opts is nil, default options are used. // // The target must either be an absolute path (like \"/path\") or an absolute // URL that contains a valid host and the same scheme as the parent request. // If the target is a path, it will inherit the scheme and host of the // parent request. // // The HTTP/2 spec disallows recursive pushes and cross-authority pushes. // Push may or may not detect these invalid pushes; however, invalid // pushes will be detected and canceled by conforming clients. // // Handlers that wish to push URL X should call Push before sending any // data that may trigger a request for URL X. This avoids a race where the // client issues requests for X before receiving the PUSH_PROMISE for X. // // Push returns ErrNotSupported if the client has disabled push or if push // is not supported on the underlying connection. Push(target string, opts *PushOptions) error }",
        "type": "net/http"
    },
    "http.ReadRequest": {
        "descr": "ReadRequest reads and parses an incoming request from b.",
        "name": "http.ReadRequest",
        "params": [],
        "path": "go/net/http/index#ReadRequest",
        "syntax": "func ReadRequest(b *bufio.Reader) (*Request, error)",
        "type": "net/http"
    },
    "http.ReadResponse": {
        "descr": "ReadResponse reads and returns an HTTP response from r. The req parameter optionally specifies the Request that corresponds to this Response. If nil, a GET request is assumed. Clients must call resp.Body.Close when finished reading resp.Body. After that call, clients can inspect resp.Trailer to find key/value pairs included in the response trailer.",
        "name": "http.ReadResponse",
        "params": [],
        "path": "go/net/http/index#ReadResponse",
        "syntax": "func ReadResponse(r *bufio.Reader, req *Request) (*Response, error)",
        "type": "net/http"
    },
    "http.Redirect": {
        "descr": "Redirect replies to the request with a redirect to url, which may be a path relative to the request path.",
        "name": "http.Redirect",
        "params": [],
        "path": "go/net/http/index#Redirect",
        "syntax": "func Redirect(w ResponseWriter, r *Request, url string, code int)",
        "type": "net/http"
    },
    "http.RedirectHandler": {
        "descr": "RedirectHandler returns a request handler that redirects each request it receives to the given url using the given status code.",
        "name": "http.RedirectHandler",
        "params": [],
        "path": "go/net/http/index#RedirectHandler",
        "syntax": "func RedirectHandler(url string, code int) Handler",
        "type": "net/http"
    },
    "http.Request": {
        "descr": "A Request represents an HTTP request received by a server or to be sent by a client.",
        "name": "http.Request",
        "params": [],
        "path": "go/net/http/index#Request",
        "syntax": "type Request struct { // Method specifies the HTTP method (GET, POST, PUT, etc.). // For client requests an empty string means GET. // // Go's HTTP client does not support sending a request with // the CONNECT method. See the documentation on Transport for // details. Method string // URL specifies either the URI being requested (for server // requests) or the URL to access (for client requests). // // For server requests the URL is parsed from the URI // supplied on the Request-Line as stored in RequestURI. For // most requests, fields other than Path and RawQuery will be // empty. (See RFC 7230, Section 5.3) // // For client requests, the URL's Host specifies the server to // connect to, while the Request's Host field optionally // specifies the Host header value to send in the HTTP // request. URL *url.URL // The protocol version for incoming server requests. // // For client requests these fields are ignored. The HTTP // client code always uses either HTTP/1.1 or HTTP/2. // See the docs on Transport for details. Proto string // \"HTTP/1.0\" ProtoMajor int // 1 ProtoMinor int // 0 // Header contains the request header fields either received // by the server or to be sent by the client. // // If a server received a request with header lines, // // Host: example.com // accept-encoding: gzip, deflate // Accept-Language: en-us // fOO: Bar // foo: two // // then // // Header = map[string][]string{ // \"Accept-Encoding\": {\"gzip, deflate\"}, // \"Accept-Language\": {\"en-us\"}, // \"Foo\": {\"Bar\", \"two\"}, // } // // For incoming requests, the Host header is promoted to the // Request.Host field and removed from the Header map. // // HTTP defines that header names are case-insensitive. The // request parser implements this by using CanonicalHeaderKey, // making the first character and any characters following a // hyphen uppercase and the rest lowercase. // // For client requests, certain headers such as Content-Length // and Connection are automatically written when needed and // values in Header may be ignored. See the documentation // for the Request.Write method. Header Header // Body is the request's body. // // For client requests a nil body means the request has no // body, such as a GET request. The HTTP Client's Transport // is responsible for calling the Close method. // // For server requests the Request Body is always non-nil // but will return EOF immediately when no body is present. // The Server will close the request body. The ServeHTTP // Handler does not need to. Body io.ReadCloser // GetBody defines an optional func to return a new copy of // Body. It is used for client requests when a redirect requires // reading the body more than once. Use of GetBody still // requires setting Body. // // For server requests it is unused. GetBody func() (io.ReadCloser, error) // Go 1.8 // ContentLength records the length of the associated content. // The value -1 indicates that the length is unknown. // Values >= 0 indicate that the given number of bytes may // be read from Body. // For client requests, a value of 0 with a non-nil Body is // also treated as unknown. ContentLength int64 // TransferEncoding lists the transfer encodings from outermost to // innermost. An empty list denotes the \"identity\" encoding. // TransferEncoding can usually be ignored; chunked encoding is // automatically added and removed as necessary when sending and // receiving requests. TransferEncoding []string // Close indicates whether to close the connection after // replying to this request (for servers) or after sending this // request and reading its response (for clients). // // For server requests, the HTTP server handles this automatically // and this field is not needed by Handlers. // // For client requests, setting this field prevents re-use of // TCP connections between requests to the same hosts, as if // Transport.DisableKeepAlives were set. Close bool // For server requests Host specifies the host on which the URL // is sought. Per RFC 7230, section 5.4, this is either the value // of the \"Host\" header or the host name given in the URL itself. // It may be of the form \"host:port\". For international domain // names, Host may be in Punycode or Unicode form. Use // golang.org/x/net/idna to convert it to either format if // needed. // To prevent DNS rebinding attacks, server Handlers should // validate that the Host header has a value for which the // Handler considers itself authoritative. The included // ServeMux supports patterns registered to particular host // names and thus protects its registered Handlers. // // For client requests Host optionally overrides the Host // header to send. If empty, the Request.Write method uses // the value of URL.Host. Host may contain an international // domain name. Host string // Form contains the parsed form data, including both the URL // field's query parameters and the POST or PUT form data. // This field is only available after ParseForm is called. // The HTTP client ignores Form and uses Body instead. Form url.Values // PostForm contains the parsed form data from POST, PATCH, // or PUT body parameters. // // This field is only available after ParseForm is called. // The HTTP client ignores PostForm and uses Body instead. PostForm url.Values // Go 1.1 // MultipartForm is the parsed multipart form, including file uploads. // This field is only available after ParseMultipartForm is called. // The HTTP client ignores MultipartForm and uses Body instead. MultipartForm *multipart.Form // Trailer specifies additional headers that are sent after the request // body. // // For server requests the Trailer map initially contains only the // trailer keys, with nil values. (The client declares which trailers it // will later send.) While the handler is reading from Body, it must // not reference Trailer. After reading from Body returns EOF, Trailer // can be read again and will contain non-nil values, if they were sent // by the client. // // For client requests Trailer must be initialized to a map containing // the trailer keys to later send. The values may be nil or their final // values. The ContentLength must be 0 or -1, to send a chunked request. // After the HTTP request is sent the map values can be updated while // the request body is read. Once the body returns EOF, the caller must // not mutate Trailer. // // Few HTTP clients, servers, or proxies support HTTP trailers. Trailer Header // RemoteAddr allows HTTP servers and other software to record // the network address that sent the request, usually for // logging. This field is not filled in by ReadRequest and // has no defined format. The HTTP server in this package // sets RemoteAddr to an \"IP:port\" address before invoking a // handler. // This field is ignored by the HTTP client. RemoteAddr string // RequestURI is the unmodified request-target of the // Request-Line (RFC 7230, Section 3.1.1) as sent by the client // to a server. Usually the URL field should be used instead. // It is an error to set this field in an HTTP client request. RequestURI string // TLS allows HTTP servers and other software to record // information about the TLS connection on which the request // was received. This field is not filled in by ReadRequest. // The HTTP server in this package sets the field for // TLS-enabled connections before invoking a handler; // otherwise it leaves the field nil. // This field is ignored by the HTTP client. TLS *tls.ConnectionState // Cancel is an optional channel whose closure indicates that the client // request should be regarded as canceled. Not all implementations of // RoundTripper may support Cancel. // // For server requests, this field is not applicable. // // Deprecated: Use the Context and WithContext methods // instead. If a Request's Cancel field and context are both // set, it is undefined whether Cancel is respected. Cancel <-chan struct{} // Go 1.5 // Response is the redirect response which caused this request // to be created. This field is only populated during client // redirects. Response *Response // Go 1.7 // contains filtered or unexported fields }",
        "type": "net/http"
    },
    "http.Request.AddCookie": {
        "descr": "AddCookie adds a cookie to the request. Per RFC 6265 section 5.4, AddCookie does not attach more than one Cookie header field. That means all cookies, if any, are written into the same line, separated by semicolon.",
        "name": "http.Request.AddCookie",
        "params": [],
        "path": "go/net/http/index#Request.AddCookie",
        "syntax": "func (r *Request) AddCookie(c *Cookie)",
        "type": "net/http"
    },
    "http.Request.BasicAuth": {
        "descr": "BasicAuth returns the username and password provided in the request's Authorization header, if the request uses HTTP Basic Authentication. See RFC 2617, Section 2.",
        "name": "http.Request.BasicAuth",
        "params": [],
        "path": "go/net/http/index#Request.BasicAuth",
        "syntax": "func (r *Request) BasicAuth() (username, password string, ok bool)",
        "type": "net/http"
    },
    "http.Request.Context": {
        "descr": "Context returns the request's context. To change the context, use WithContext.",
        "name": "http.Request.Context",
        "params": [],
        "path": "go/net/http/index#Request.Context",
        "syntax": "func (r *Request) Context() context.Context",
        "type": "net/http"
    },
    "http.Request.Cookie": {
        "descr": "Cookie returns the named cookie provided in the request or ErrNoCookie if not found. If multiple cookies match the given name, only one cookie will be returned.",
        "name": "http.Request.Cookie",
        "params": [],
        "path": "go/net/http/index#Request.Cookie",
        "syntax": "func (r *Request) Cookie(name string) (*Cookie, error)",
        "type": "net/http"
    },
    "http.Request.Cookies": {
        "descr": "Cookies parses and returns the HTTP cookies sent with the request.",
        "name": "http.Request.Cookies",
        "params": [],
        "path": "go/net/http/index#Request.Cookies",
        "syntax": "func (r *Request) Cookies() []*Cookie",
        "type": "net/http"
    },
    "http.Request.FormFile": {
        "descr": "FormFile returns the first file for the provided form key. FormFile calls ParseMultipartForm and ParseForm if necessary.",
        "name": "http.Request.FormFile",
        "params": [],
        "path": "go/net/http/index#Request.FormFile",
        "syntax": "func (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, error)",
        "type": "net/http"
    },
    "http.Request.FormValue": {
        "descr": "FormValue returns the first value for the named component of the query. POST and PUT body parameters take precedence over URL query string values. FormValue calls ParseMultipartForm and ParseForm if necessary and ignores any errors returned by these functions. If key is not present, FormValue returns the empty string. To access multiple values of the same key, call ParseForm and then inspect Request.Form directly.",
        "name": "http.Request.FormValue",
        "params": [],
        "path": "go/net/http/index#Request.FormValue",
        "syntax": "func (r *Request) FormValue(key string) string",
        "type": "net/http"
    },
    "http.Request.MultipartReader": {
        "descr": "MultipartReader returns a MIME multipart reader if this is a multipart/form-data or a multipart/mixed POST request, else returns nil and an error. Use this function instead of ParseMultipartForm to process the request body as a stream.",
        "name": "http.Request.MultipartReader",
        "params": [],
        "path": "go/net/http/index#Request.MultipartReader",
        "syntax": "func (r *Request) MultipartReader() (*multipart.Reader, error)",
        "type": "net/http"
    },
    "http.Request.ParseForm": {
        "descr": "ParseForm populates r.Form and r.PostForm.",
        "name": "http.Request.ParseForm",
        "params": [],
        "path": "go/net/http/index#Request.ParseForm",
        "syntax": "func (r *Request) ParseForm() error",
        "type": "net/http"
    },
    "http.Request.ParseMultipartForm": {
        "descr": "ParseMultipartForm parses a request body as multipart/form-data. The whole request body is parsed and up to a total of maxMemory bytes of its file parts are stored in memory, with the remainder stored on disk in temporary files. ParseMultipartForm calls ParseForm if necessary. After one call to ParseMultipartForm, subsequent calls have no effect.",
        "name": "http.Request.ParseMultipartForm",
        "params": [],
        "path": "go/net/http/index#Request.ParseMultipartForm",
        "syntax": "func (r *Request) ParseMultipartForm(maxMemory int64) error",
        "type": "net/http"
    },
    "http.Request.PostFormValue": {
        "descr": "PostFormValue returns the first value for the named component of the POST, PATCH, or PUT request body. URL query parameters are ignored. PostFormValue calls ParseMultipartForm and ParseForm if necessary and ignores any errors returned by these functions. If key is not present, PostFormValue returns the empty string.",
        "name": "http.Request.PostFormValue",
        "params": [],
        "path": "go/net/http/index#Request.PostFormValue",
        "syntax": "func (r *Request) PostFormValue(key string) string",
        "type": "net/http"
    },
    "http.Request.ProtoAtLeast": {
        "descr": "ProtoAtLeast reports whether the HTTP protocol used in the request is at least major.minor.",
        "name": "http.Request.ProtoAtLeast",
        "params": [],
        "path": "go/net/http/index#Request.ProtoAtLeast",
        "syntax": "func (r *Request) ProtoAtLeast(major, minor int) bool",
        "type": "net/http"
    },
    "http.Request.Referer": {
        "descr": "Referer returns the referring URL, if sent in the request.",
        "name": "http.Request.Referer",
        "params": [],
        "path": "go/net/http/index#Request.Referer",
        "syntax": "func (r *Request) Referer() string",
        "type": "net/http"
    },
    "http.Request.SetBasicAuth": {
        "descr": "SetBasicAuth sets the request's Authorization header to use HTTP Basic Authentication with the provided username and password.",
        "name": "http.Request.SetBasicAuth",
        "params": [],
        "path": "go/net/http/index#Request.SetBasicAuth",
        "syntax": "func (r *Request) SetBasicAuth(username, password string)",
        "type": "net/http"
    },
    "http.Request.UserAgent": {
        "descr": "UserAgent returns the client's User-Agent, if sent in the request.",
        "name": "http.Request.UserAgent",
        "params": [],
        "path": "go/net/http/index#Request.UserAgent",
        "syntax": "func (r *Request) UserAgent() string",
        "type": "net/http"
    },
    "http.Request.WithContext": {
        "descr": "WithContext returns a shallow copy of r with its context changed to ctx. The provided ctx must be non-nil.",
        "name": "http.Request.WithContext",
        "params": [],
        "path": "go/net/http/index#Request.WithContext",
        "syntax": "func (r *Request) WithContext(ctx context.Context) *Request",
        "type": "net/http"
    },
    "http.Request.Write": {
        "descr": "Write writes an HTTP/1.1 request, which is the header and body, in wire format. This method consults the following fields of the request:",
        "name": "http.Request.Write",
        "params": [],
        "path": "go/net/http/index#Request.Write",
        "syntax": "func (r *Request) Write(w io.Writer) error",
        "type": "net/http"
    },
    "http.Request.WriteProxy": {
        "descr": "WriteProxy is like Write but writes the request in the form expected by an HTTP proxy. In particular, WriteProxy writes the initial Request-URI line of the request with an absolute URI, per section 5.3 of RFC 7230, including the scheme and host. In either case, WriteProxy also writes a Host header, using either r.Host or r.URL.Host.",
        "name": "http.Request.WriteProxy",
        "params": [],
        "path": "go/net/http/index#Request.WriteProxy",
        "syntax": "func (r *Request) WriteProxy(w io.Writer) error",
        "type": "net/http"
    },
    "http.Response": {
        "descr": "Response represents the response from an HTTP request.",
        "name": "http.Response",
        "params": [],
        "path": "go/net/http/index#Response",
        "syntax": "type Response struct { Status string // e.g. \"200 OK\" StatusCode int // e.g. 200 Proto string // e.g. \"HTTP/1.0\" ProtoMajor int // e.g. 1 ProtoMinor int // e.g. 0 // Header maps header keys to values. If the response had multiple // headers with the same key, they may be concatenated, with comma // delimiters. (RFC 7230, section 3.2.2 requires that multiple headers // be semantically equivalent to a comma-delimited sequence.) When // Header values are duplicated by other fields in this struct (e.g., // ContentLength, TransferEncoding, Trailer), the field values are // authoritative. // // Keys in the map are canonicalized (see CanonicalHeaderKey). Header Header // Body represents the response body. // // The response body is streamed on demand as the Body field // is read. If the network connection fails or the server // terminates the response, Body.Read calls return an error. // // The http Client and Transport guarantee that Body is always // non-nil, even on responses without a body or responses with // a zero-length body. It is the caller's responsibility to // close Body. The default HTTP client's Transport may not // reuse HTTP/1.x \"keep-alive\" TCP connections if the Body is // not read to completion and closed. // // The Body is automatically dechunked if the server replied // with a \"chunked\" Transfer-Encoding. Body io.ReadCloser // ContentLength records the length of the associated content. The // value -1 indicates that the length is unknown. Unless Request.Method // is \"HEAD\", values >= 0 indicate that the given number of bytes may // be read from Body. ContentLength int64 // Contains transfer encodings from outer-most to inner-most. Value is // nil, means that \"identity\" encoding is used. TransferEncoding []string // Close records whether the header directed that the connection be // closed after reading Body. The value is advice for clients: neither // ReadResponse nor Response.Write ever closes a connection. Close bool // Uncompressed reports whether the response was sent compressed but // was decompressed by the http package. When true, reading from // Body yields the uncompressed content instead of the compressed // content actually set from the server, ContentLength is set to -1, // and the \"Content-Length\" and \"Content-Encoding\" fields are deleted // from the responseHeader. To get the original response from // the server, set Transport.DisableCompression to true. Uncompressed bool // Go 1.7 // Trailer maps trailer keys to values in the same // format as Header. // // The Trailer initially contains only nil values, one for // each key specified in the server's \"Trailer\" header // value. Those values are not added to Header. // // Trailer must not be accessed concurrently with Read calls // on the Body. // // After Body.Read has returned io.EOF, Trailer will contain // any trailer values sent by the server. Trailer Header // Request is the request that was sent to obtain this Response. // Request's Body is nil (having already been consumed). // This is only populated for Client requests. Request *Request // TLS contains information about the TLS connection on which the // response was received. It is nil for unencrypted responses. // The pointer is shared between responses and should not be // modified. TLS *tls.ConnectionState // Go 1.3 }",
        "type": "net/http"
    },
    "http.Response.Cookies": {
        "descr": "Cookies parses and returns the cookies set in the Set-Cookie headers.",
        "name": "http.Response.Cookies",
        "params": [],
        "path": "go/net/http/index#Response.Cookies",
        "syntax": "func (r *Response) Cookies() []*Cookie",
        "type": "net/http"
    },
    "http.Response.Location": {
        "descr": "Location returns the URL of the response's \"Location\" header, if present. Relative redirects are resolved relative to the Response's Request. ErrNoLocation is returned if no Location header is present.",
        "name": "http.Response.Location",
        "params": [],
        "path": "go/net/http/index#Response.Location",
        "syntax": "func (r *Response) Location() (*url.URL, error)",
        "type": "net/http"
    },
    "http.Response.ProtoAtLeast": {
        "descr": "ProtoAtLeast reports whether the HTTP protocol used in the response is at least major.minor.",
        "name": "http.Response.ProtoAtLeast",
        "params": [],
        "path": "go/net/http/index#Response.ProtoAtLeast",
        "syntax": "func (r *Response) ProtoAtLeast(major, minor int) bool",
        "type": "net/http"
    },
    "http.Response.Write": {
        "descr": "Write writes r to w in the HTTP/1.x server response format, including the status line, headers, body, and optional trailer.",
        "name": "http.Response.Write",
        "params": [],
        "path": "go/net/http/index#Response.Write",
        "syntax": "func (r *Response) Write(w io.Writer) error",
        "type": "net/http"
    },
    "http.ResponseWriter": {
        "descr": "A ResponseWriter interface is used by an HTTP handler to construct an HTTP response.",
        "name": "http.ResponseWriter",
        "params": [],
        "path": "go/net/http/index#ResponseWriter",
        "syntax": "type ResponseWriter interface { // Header returns the header map that will be sent by // WriteHeader. The Header map also is the mechanism with which // Handlers can set HTTP trailers. // // Changing the header map after a call to WriteHeader (or // Write) has no effect unless the modified headers are // trailers. // // There are two ways to set Trailers. The preferred way is to // predeclare in the headers which trailers you will later // send by setting the \"Trailer\" header to the names of the // trailer keys which will come later. In this case, those // keys of the Header map are treated as if they were // trailers. See the example. The second way, for trailer // keys not known to the Handler until after the first Write, // is to prefix the Header map keys with the TrailerPrefix // constant value. See TrailerPrefix. // // To suppress automatic response headers (such as \"Date\"), set // their value to nil. Header() Header // Write writes the data to the connection as part of an HTTP reply. // // If WriteHeader has not yet been called, Write calls // WriteHeader(http.StatusOK) before writing the data. If the Header // does not contain a Content-Type line, Write adds a Content-Type set // to the result of passing the initial 512 bytes of written data to // DetectContentType. Additionally, if the total size of all written // data is under a few KB and there are no Flush calls, the // Content-Length header is added automatically. // // Depending on the HTTP protocol version and the client, calling // Write or WriteHeader may prevent future reads on the // Request.Body. For HTTP/1.x requests, handlers should read any // needed request body data before writing the response. Once the // headers have been flushed (due to either an explicit Flusher.Flush // call or writing enough data to trigger a flush), the request body // may be unavailable. For HTTP/2 requests, the Go HTTP server permits // handlers to continue to read the request body while concurrently // writing the response. However, such behavior may not be supported // by all HTTP/2 clients. Handlers should read before writing if // possible to maximize compatibility. Write([]byte) (int, error) // WriteHeader sends an HTTP response header with the provided // status code. // // If WriteHeader is not called explicitly, the first call to Write // will trigger an implicit WriteHeader(http.StatusOK). // Thus explicit calls to WriteHeader are mainly used to // send error codes. // // The provided code must be a valid HTTP 1xx-5xx status code. // Only one header may be written. Go does not currently // support sending user-defined 1xx informational headers, // with the exception of 100-continue response header that the // Server sends automatically when the Request.Body is read. WriteHeader(statusCode int) }",
        "type": "net/http"
    },
    "http.RoundTripper": {
        "descr": "RoundTripper is an interface representing the ability to execute a single HTTP transaction, obtaining the Response for a given Request.",
        "name": "http.RoundTripper",
        "params": [],
        "path": "go/net/http/index#RoundTripper",
        "syntax": "type RoundTripper interface { // RoundTrip executes a single HTTP transaction, returning // a Response for the provided Request. // // RoundTrip should not attempt to interpret the response. In // particular, RoundTrip must return err == nil if it obtained // a response, regardless of the response's HTTP status code. // A non-nil err should be reserved for failure to obtain a // response. Similarly, RoundTrip should not attempt to // handle higher-level protocol details such as redirects, // authentication, or cookies. // // RoundTrip should not modify the request, except for // consuming and closing the Request's Body. RoundTrip may // read fields of the request in a separate goroutine. Callers // should not mutate or reuse the request until the Response's // Body has been closed. // // RoundTrip must always close the body, including on errors, // but depending on the implementation may do so in a separate // goroutine even after RoundTrip returns. This means that // callers wanting to reuse the body for subsequent requests // must arrange to wait for the Close call before doing so. // // The Request's URL and Header fields must be initialized. RoundTrip(*Request) (*Response, error) }",
        "type": "net/http"
    },
    "http.SameSite": {
        "descr": "SameSite allows a server define a cookie attribute making it impossible to the browser send this cookie along with cross-site requests. The main goal is mitigate the risk of cross-origin information leakage, and provides some protection against cross-site request forgery attacks.",
        "name": "http.SameSite",
        "params": [],
        "path": "go/net/http/index#SameSite",
        "syntax": "type SameSite int",
        "type": "net/http"
    },
    "http.Serve": {
        "descr": "Serve accepts incoming HTTP connections on the listener l, creating a new service goroutine for each. The service goroutines read requests and then call handler to reply to them.",
        "name": "http.Serve",
        "params": [],
        "path": "go/net/http/index#Serve",
        "syntax": "func Serve(l net.Listener, handler Handler) error",
        "type": "net/http"
    },
    "http.ServeContent": {
        "descr": "ServeContent replies to the request using the content in the provided ReadSeeker. The main benefit of ServeContent over io.Copy is that it handles Range requests properly, sets the MIME type, and handles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since, and If-Range requests.",
        "name": "http.ServeContent",
        "params": [],
        "path": "go/net/http/index#ServeContent",
        "syntax": "func ServeContent(w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)",
        "type": "net/http"
    },
    "http.ServeFile": {
        "descr": "ServeFile replies to the request with the contents of the named file or directory.",
        "name": "http.ServeFile",
        "params": [],
        "path": "go/net/http/index#ServeFile",
        "syntax": "func ServeFile(w ResponseWriter, r *Request, name string)",
        "type": "net/http"
    },
    "http.ServeMux": {
        "descr": "ServeMux is an HTTP request multiplexer. It matches the URL of each incoming request against a list of registered patterns and calls the handler for the pattern that most closely matches the URL.",
        "name": "http.ServeMux",
        "params": [],
        "path": "go/net/http/index#ServeMux",
        "syntax": "type ServeMux struct { // contains filtered or unexported fields }",
        "type": "net/http"
    },
    "http.ServeMux.Handle": {
        "descr": "Handle registers the handler for the given pattern. If a handler already exists for pattern, Handle panics.",
        "name": "http.ServeMux.Handle",
        "params": [],
        "path": "go/net/http/index#ServeMux.Handle",
        "syntax": "func (mux *ServeMux) Handle(pattern string, handler Handler)",
        "type": "net/http"
    },
    "http.ServeMux.HandleFunc": {
        "descr": "HandleFunc registers the handler function for the given pattern.",
        "name": "http.ServeMux.HandleFunc",
        "params": [],
        "path": "go/net/http/index#ServeMux.HandleFunc",
        "syntax": "func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))",
        "type": "net/http"
    },
    "http.ServeMux.Handler": {
        "descr": "Handler returns the handler to use for the given request, consulting r.Method, r.Host, and r.URL.Path. It always returns a non-nil handler. If the path is not in its canonical form, the handler will be an internally-generated handler that redirects to the canonical path. If the host contains a port, it is ignored when matching handlers.",
        "name": "http.ServeMux.Handler",
        "params": [],
        "path": "go/net/http/index#ServeMux.Handler",
        "syntax": "func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string)",
        "type": "net/http"
    },
    "http.ServeMux.ServeHTTP": {
        "descr": "ServeHTTP dispatches the request to the handler whose pattern most closely matches the request URL.",
        "name": "http.ServeMux.ServeHTTP",
        "params": [],
        "path": "go/net/http/index#ServeMux.ServeHTTP",
        "syntax": "func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)",
        "type": "net/http"
    },
    "http.ServeTLS": {
        "descr": "ServeTLS accepts incoming HTTPS connections on the listener l, creating a new service goroutine for each. The service goroutines read requests and then call handler to reply to them.",
        "name": "http.ServeTLS",
        "params": [],
        "path": "go/net/http/index#ServeTLS",
        "syntax": "func ServeTLS(l net.Listener, handler Handler, certFile, keyFile string) error",
        "type": "net/http"
    },
    "http.Server": {
        "descr": "A Server defines parameters for running an HTTP server. The zero value for Server is a valid configuration.",
        "name": "http.Server",
        "params": [],
        "path": "go/net/http/index#Server",
        "syntax": "type Server struct { Addr string // TCP address to listen on, \":http\" if empty Handler Handler // handler to invoke, http.DefaultServeMux if nil // TLSConfig optionally provides a TLS configuration for use // by ServeTLS and ListenAndServeTLS. Note that this value is // cloned by ServeTLS and ListenAndServeTLS, so it's not // possible to modify the configuration with methods like // tls.Config.SetSessionTicketKeys. To use // SetSessionTicketKeys, use Server.Serve with a TLS Listener // instead. TLSConfig *tls.Config // ReadTimeout is the maximum duration for reading the entire // request, including the body. // // Because ReadTimeout does not let Handlers make per-request // decisions on each request body's acceptable deadline or // upload rate, most users will prefer to use // ReadHeaderTimeout. It is valid to use them both. ReadTimeout time.Duration // ReadHeaderTimeout is the amount of time allowed to read // request headers. The connection's read deadline is reset // after reading the headers and the Handler can decide what // is considered too slow for the body. ReadHeaderTimeout time.Duration // Go 1.8 // WriteTimeout is the maximum duration before timing out // writes of the response. It is reset whenever a new // request's header is read. Like ReadTimeout, it does not // let Handlers make decisions on a per-request basis. WriteTimeout time.Duration // IdleTimeout is the maximum amount of time to wait for the // next request when keep-alives are enabled. If IdleTimeout // is zero, the value of ReadTimeout is used. If both are // zero, ReadHeaderTimeout is used. IdleTimeout time.Duration // Go 1.8 // MaxHeaderBytes controls the maximum number of bytes the // server will read parsing the request header's keys and // values, including the request line. It does not limit the // size of the request body. // If zero, DefaultMaxHeaderBytes is used. MaxHeaderBytes int // TLSNextProto optionally specifies a function to take over // ownership of the provided TLS connection when an NPN/ALPN // protocol upgrade has occurred. The map key is the protocol // name negotiated. The Handler argument should be used to // handle HTTP requests and will initialize the Request's TLS // and RemoteAddr if not already set. The connection is // automatically closed when the function returns. // If TLSNextProto is not nil, HTTP/2 support is not enabled // automatically. TLSNextProto map[string]func(*Server, *tls.Conn, Handler) // Go 1.1 // ConnState specifies an optional callback function that is // called when a client connection changes state. See the // ConnState type and associated constants for details. ConnState func(net.Conn, ConnState) // Go 1.3 // ErrorLog specifies an optional logger for errors accepting // connections, unexpected behavior from handlers, and // underlying FileSystem errors. // If nil, logging is done via the log package's standard logger. ErrorLog *log.Logger // Go 1.3 // contains filtered or unexported fields }",
        "type": "net/http"
    },
    "http.Server.Close": {
        "descr": "Close immediately closes all active net.Listeners and any connections in state StateNew, StateActive, or StateIdle. For a graceful shutdown, use Shutdown.",
        "name": "http.Server.Close",
        "params": [],
        "path": "go/net/http/index#Server.Close",
        "syntax": "func (srv *Server) Close() error",
        "type": "net/http"
    },
    "http.Server.ListenAndServe": {
        "descr": "ListenAndServe listens on the TCP network address srv.Addr and then calls Serve to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives.",
        "name": "http.Server.ListenAndServe",
        "params": [],
        "path": "go/net/http/index#Server.ListenAndServe",
        "syntax": "func (srv *Server) ListenAndServe() error",
        "type": "net/http"
    },
    "http.Server.ListenAndServeTLS": {
        "descr": "ListenAndServeTLS listens on the TCP network address srv.Addr and then calls ServeTLS to handle requests on incoming TLS connections. Accepted connections are configured to enable TCP keep-alives.",
        "name": "http.Server.ListenAndServeTLS",
        "params": [],
        "path": "go/net/http/index#Server.ListenAndServeTLS",
        "syntax": "func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error",
        "type": "net/http"
    },
    "http.Server.RegisterOnShutdown": {
        "descr": "RegisterOnShutdown registers a function to call on Shutdown. This can be used to gracefully shutdown connections that have undergone NPN/ALPN protocol upgrade or that have been hijacked. This function should start protocol-specific graceful shutdown, but should not wait for shutdown to complete.",
        "name": "http.Server.RegisterOnShutdown",
        "params": [],
        "path": "go/net/http/index#Server.RegisterOnShutdown",
        "syntax": "func (srv *Server) RegisterOnShutdown(f func())",
        "type": "net/http"
    },
    "http.Server.Serve": {
        "descr": "Serve accepts incoming connections on the Listener l, creating a new service goroutine for each. The service goroutines read requests and then call srv.Handler to reply to them.",
        "name": "http.Server.Serve",
        "params": [],
        "path": "go/net/http/index#Server.Serve",
        "syntax": "func (srv *Server) Serve(l net.Listener) error",
        "type": "net/http"
    },
    "http.Server.ServeTLS": {
        "descr": "ServeTLS accepts incoming connections on the Listener l, creating a new service goroutine for each. The service goroutines perform TLS setup and then read requests, calling srv.Handler to reply to them.",
        "name": "http.Server.ServeTLS",
        "params": [],
        "path": "go/net/http/index#Server.ServeTLS",
        "syntax": "func (srv *Server) ServeTLS(l net.Listener, certFile, keyFile string) error",
        "type": "net/http"
    },
    "http.Server.SetKeepAlivesEnabled": {
        "descr": "SetKeepAlivesEnabled controls whether HTTP keep-alives are enabled. By default, keep-alives are always enabled. Only very resource-constrained environments or servers in the process of shutting down should disable them.",
        "name": "http.Server.SetKeepAlivesEnabled",
        "params": [],
        "path": "go/net/http/index#Server.SetKeepAlivesEnabled",
        "syntax": "func (srv *Server) SetKeepAlivesEnabled(v bool)",
        "type": "net/http"
    },
    "http.Server.Shutdown": {
        "descr": "Shutdown gracefully shuts down the server without interrupting any active connections. Shutdown works by first closing all open listeners, then closing all idle connections, and then waiting indefinitely for connections to return to idle and then shut down. If the provided context expires before the shutdown is complete, Shutdown returns the context's error, otherwise it returns any error returned from closing the Server's underlying Listener(s).",
        "name": "http.Server.Shutdown",
        "params": [],
        "path": "go/net/http/index#Server.Shutdown",
        "syntax": "func (srv *Server) Shutdown(ctx context.Context) error",
        "type": "net/http"
    },
    "http.SetCookie": {
        "descr": "SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers. The provided cookie must have a valid Name. Invalid cookies may be silently dropped.",
        "name": "http.SetCookie",
        "params": [],
        "path": "go/net/http/index#SetCookie",
        "syntax": "func SetCookie(w ResponseWriter, cookie *Cookie)",
        "type": "net/http"
    },
    "http.StatusText": {
        "descr": "StatusText returns a text for the HTTP status code. It returns the empty string if the code is unknown.",
        "name": "http.StatusText",
        "params": [],
        "path": "go/net/http/index#StatusText",
        "syntax": "func StatusText(code int) string",
        "type": "net/http"
    },
    "http.StripPrefix": {
        "descr": "StripPrefix returns a handler that serves HTTP requests by removing the given prefix from the request URL's Path and invoking the handler h. StripPrefix handles a request for a path that doesn't begin with prefix by replying with an HTTP 404 not found error.",
        "name": "http.StripPrefix",
        "params": [],
        "path": "go/net/http/index#StripPrefix",
        "syntax": "func StripPrefix(prefix string, h Handler) Handler",
        "type": "net/http"
    },
    "http.TimeoutHandler": {
        "descr": "TimeoutHandler returns a Handler that runs h with the given time limit.",
        "name": "http.TimeoutHandler",
        "params": [],
        "path": "go/net/http/index#TimeoutHandler",
        "syntax": "func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler",
        "type": "net/http"
    },
    "http.Transport": {
        "descr": "Transport is an implementation of RoundTripper that supports HTTP, HTTPS, and HTTP proxies (for either HTTP or HTTPS with CONNECT).",
        "name": "http.Transport",
        "params": [],
        "path": "go/net/http/index#Transport",
        "syntax": "type Transport struct { // Proxy specifies a function to return a proxy for a given // Request. If the function returns a non-nil error, the // request is aborted with the provided error. // // The proxy type is determined by the URL scheme. \"http\", // \"https\", and \"socks5\" are supported. If the scheme is empty, // \"http\" is assumed. // // If Proxy is nil or returns a nil *URL, no proxy is used. Proxy func(*Request) (*url.URL, error) // DialContext specifies the dial function for creating unencrypted TCP connections. // If DialContext is nil (and the deprecated Dial below is also nil), // then the transport dials using package net. // // DialContext runs concurrently with calls to RoundTrip. // A RoundTrip call that initiates a dial may end up using // an connection dialed previously when the earlier connection // becomes idle before the later DialContext completes. DialContext func(ctx context.Context, network, addr string) (net.Conn, error) // Go 1.7 // Dial specifies the dial function for creating unencrypted TCP connections. // // Dial runs concurrently with calls to RoundTrip. // A RoundTrip call that initiates a dial may end up using // an connection dialed previously when the earlier connection // becomes idle before the later Dial completes. // // Deprecated: Use DialContext instead, which allows the transport // to cancel dials as soon as they are no longer needed. // If both are set, DialContext takes priority. Dial func(network, addr string) (net.Conn, error) // DialTLS specifies an optional dial function for creating // TLS connections for non-proxied HTTPS requests. // // If DialTLS is nil, Dial and TLSClientConfig are used. // // If DialTLS is set, the Dial hook is not used for HTTPS // requests and the TLSClientConfig and TLSHandshakeTimeout // are ignored. The returned net.Conn is assumed to already be // past the TLS handshake. DialTLS func(network, addr string) (net.Conn, error) // Go 1.4 // TLSClientConfig specifies the TLS configuration to use with // tls.Client. // If nil, the default configuration is used. // If non-nil, HTTP/2 support may not be enabled by default. TLSClientConfig *tls.Config // TLSHandshakeTimeout specifies the maximum amount of time waiting to // wait for a TLS handshake. Zero means no timeout. TLSHandshakeTimeout time.Duration // Go 1.3 // DisableKeepAlives, if true, disables HTTP keep-alives and // will only use the connection to the server for a single // HTTP request. // // This is unrelated to the similarly named TCP keep-alives. DisableKeepAlives bool // DisableCompression, if true, prevents the Transport from // requesting compression with an \"Accept-Encoding: gzip\" // request header when the Request contains no existing // Accept-Encoding value. If the Transport requests gzip on // its own and gets a gzipped response, it's transparently // decoded in the Response.Body. However, if the user // explicitly requested gzip it is not automatically // uncompressed. DisableCompression bool // MaxIdleConns controls the maximum number of idle (keep-alive) // connections across all hosts. Zero means no limit. MaxIdleConns int // Go 1.7 // MaxIdleConnsPerHost, if non-zero, controls the maximum idle // (keep-alive) connections to keep per-host. If zero, // DefaultMaxIdleConnsPerHost is used. MaxIdleConnsPerHost int // MaxConnsPerHost optionally limits the total number of // connections per host, including connections in the dialing, // active, and idle states. On limit violation, dials will block. // // Zero means no limit. // // For HTTP/2, this currently only controls the number of new // connections being created at a time, instead of the total // number. In practice, hosts using HTTP/2 only have about one // idle connection, though. MaxConnsPerHost int // Go 1.11 // IdleConnTimeout is the maximum amount of time an idle // (keep-alive) connection will remain idle before closing // itself. // Zero means no limit. IdleConnTimeout time.Duration // Go 1.7 // ResponseHeaderTimeout, if non-zero, specifies the amount of // time to wait for a server's response headers after fully // writing the request (including its body, if any). This // time does not include the time to read the response body. ResponseHeaderTimeout time.Duration // Go 1.1 // ExpectContinueTimeout, if non-zero, specifies the amount of // time to wait for a server's first response headers after fully // writing the request headers if the request has an // \"Expect: 100-continue\" header. Zero means no timeout and // causes the body to be sent immediately, without // waiting for the server to approve. // This time does not include the time to send the request header. ExpectContinueTimeout time.Duration // Go 1.6 // TLSNextProto specifies how the Transport switches to an // alternate protocol (such as HTTP/2) after a TLS NPN/ALPN // protocol negotiation. If Transport dials an TLS connection // with a non-empty protocol name and TLSNextProto contains a // map entry for that key (such as \"h2\"), then the func is // called with the request's authority (such as \"example.com\" // or \"example.com:1234\") and the TLS connection. The function // must return a RoundTripper that then handles the request. // If TLSNextProto is not nil, HTTP/2 support is not enabled // automatically. TLSNextProto map[string]func(authority string, c *tls.Conn) RoundTripper // Go 1.6 // ProxyConnectHeader optionally specifies headers to send to // proxies during CONNECT requests. ProxyConnectHeader Header // Go 1.8 // MaxResponseHeaderBytes specifies a limit on how many // response bytes are allowed in the server's response // header. // // Zero means to use a default limit. MaxResponseHeaderBytes int64 // Go 1.7 // contains filtered or unexported fields }",
        "type": "net/http"
    },
    "http.Transport.CancelRequest": {
        "descr": "CancelRequest cancels an in-flight request by closing its connection. CancelRequest should only be called after RoundTrip has returned.",
        "name": "http.Transport.CancelRequest",
        "params": [],
        "path": "go/net/http/index#Transport.CancelRequest",
        "syntax": "func (t *Transport) CancelRequest(req *Request)",
        "type": "net/http"
    },
    "http.Transport.CloseIdleConnections": {
        "descr": "CloseIdleConnections closes any connections which were previously connected from previous requests but are now sitting idle in a \"keep-alive\" state. It does not interrupt any connections currently in use.",
        "name": "http.Transport.CloseIdleConnections",
        "params": [],
        "path": "go/net/http/index#Transport.CloseIdleConnections",
        "syntax": "func (t *Transport) CloseIdleConnections()",
        "type": "net/http"
    },
    "http.Transport.RegisterProtocol": {
        "descr": "RegisterProtocol registers a new protocol with scheme. The Transport will pass requests using the given scheme to rt. It is rt's responsibility to simulate HTTP request semantics.",
        "name": "http.Transport.RegisterProtocol",
        "params": [],
        "path": "go/net/http/index#Transport.RegisterProtocol",
        "syntax": "func (t *Transport) RegisterProtocol(scheme string, rt RoundTripper)",
        "type": "net/http"
    },
    "http.Transport.RoundTrip": {
        "descr": "RoundTrip implements the RoundTripper interface.",
        "name": "http.Transport.RoundTrip",
        "params": [],
        "path": "go/net/http/index#Transport.RoundTrip",
        "syntax": "func (t *Transport) RoundTrip(req *Request) (*Response, error)",
        "type": "net/http"
    },
    "httptest.NewRecorder": {
        "descr": "NewRecorder returns an initialized ResponseRecorder.",
        "name": "httptest.NewRecorder",
        "params": [],
        "path": "go/net/http/httptest/index#NewRecorder",
        "syntax": "func NewRecorder() *ResponseRecorder",
        "type": "net/http"
    },
    "httptest.NewRequest": {
        "descr": "NewRequest returns a new incoming server Request, suitable for passing to an http.Handler for testing.",
        "name": "httptest.NewRequest",
        "params": [],
        "path": "go/net/http/httptest/index#NewRequest",
        "syntax": "func NewRequest(method, target string, body io.Reader) *http.Request",
        "type": "net/http"
    },
    "httptest.NewServer": {
        "descr": "NewServer starts and returns a new Server. The caller should call Close when finished, to shut it down.",
        "name": "httptest.NewServer",
        "params": [],
        "path": "go/net/http/httptest/index#NewServer",
        "syntax": "func NewServer(handler http.Handler) *Server",
        "type": "net/http"
    },
    "httptest.NewTLSServer": {
        "descr": "NewTLSServer starts and returns a new Server using TLS. The caller should call Close when finished, to shut it down.",
        "name": "httptest.NewTLSServer",
        "params": [],
        "path": "go/net/http/httptest/index#NewTLSServer",
        "syntax": "func NewTLSServer(handler http.Handler) *Server",
        "type": "net/http"
    },
    "httptest.NewUnstartedServer": {
        "descr": "NewUnstartedServer returns a new Server but doesn't start it.",
        "name": "httptest.NewUnstartedServer",
        "params": [],
        "path": "go/net/http/httptest/index#NewUnstartedServer",
        "syntax": "func NewUnstartedServer(handler http.Handler) *Server",
        "type": "net/http"
    },
    "httptest.ResponseRecorder": {
        "descr": "ResponseRecorder is an implementation of http.ResponseWriter that records its mutations for later inspection in tests.",
        "name": "httptest.ResponseRecorder",
        "params": [],
        "path": "go/net/http/httptest/index#ResponseRecorder",
        "syntax": "type ResponseRecorder struct { // Code is the HTTP response code set by WriteHeader. // // Note that if a Handler never calls WriteHeader or Write, // this might end up being 0, rather than the implicit // http.StatusOK. To get the implicit value, use the Result // method. Code int // HeaderMap contains the headers explicitly set by the Handler. // It is an internal detail. // // Deprecated: HeaderMap exists for historical compatibility // and should not be used. To access the headers returned by a handler, // use the Response.Header map as returned by the Result method. HeaderMap http.Header // Body is the buffer to which the Handler's Write calls are sent. // If nil, the Writes are silently discarded. Body *bytes.Buffer // Flushed is whether the Handler called Flush. Flushed bool // contains filtered or unexported fields }",
        "type": "net/http"
    },
    "httptest.ResponseRecorder.Flush": {
        "descr": "Flush sets rw.Flushed to true.",
        "name": "httptest.ResponseRecorder.Flush",
        "params": [],
        "path": "go/net/http/httptest/index#ResponseRecorder.Flush",
        "syntax": "func (rw *ResponseRecorder) Flush()",
        "type": "net/http"
    },
    "httptest.ResponseRecorder.Header": {
        "descr": "Header returns the response headers.",
        "name": "httptest.ResponseRecorder.Header",
        "params": [],
        "path": "go/net/http/httptest/index#ResponseRecorder.Header",
        "syntax": "func (rw *ResponseRecorder) Header() http.Header",
        "type": "net/http"
    },
    "httptest.ResponseRecorder.Result": {
        "descr": "Result returns the response generated by the handler.",
        "name": "httptest.ResponseRecorder.Result",
        "params": [],
        "path": "go/net/http/httptest/index#ResponseRecorder.Result",
        "syntax": "func (rw *ResponseRecorder) Result() *http.Response",
        "type": "net/http"
    },
    "httptest.ResponseRecorder.Write": {
        "descr": "Write always succeeds and writes to rw.Body, if not nil.",
        "name": "httptest.ResponseRecorder.Write",
        "params": [],
        "path": "go/net/http/httptest/index#ResponseRecorder.Write",
        "syntax": "func (rw *ResponseRecorder) Write(buf []byte) (int, error)",
        "type": "net/http"
    },
    "httptest.ResponseRecorder.WriteHeader": {
        "descr": "WriteHeader sets rw.Code. After it is called, changing rw.Header will not affect rw.HeaderMap.",
        "name": "httptest.ResponseRecorder.WriteHeader",
        "params": [],
        "path": "go/net/http/httptest/index#ResponseRecorder.WriteHeader",
        "syntax": "func (rw *ResponseRecorder) WriteHeader(code int)",
        "type": "net/http"
    },
    "httptest.ResponseRecorder.WriteString": {
        "descr": "WriteString always succeeds and writes to rw.Body, if not nil.",
        "name": "httptest.ResponseRecorder.WriteString",
        "params": [],
        "path": "go/net/http/httptest/index#ResponseRecorder.WriteString",
        "syntax": "func (rw *ResponseRecorder) WriteString(str string) (int, error)",
        "type": "net/http"
    },
    "httptest.Server": {
        "descr": "A Server is an HTTP server listening on a system-chosen port on the local loopback interface, for use in end-to-end HTTP tests.",
        "name": "httptest.Server",
        "params": [],
        "path": "go/net/http/httptest/index#Server",
        "syntax": "type Server struct { URL string // base URL of form http://ipaddr:port with no trailing slash Listener net.Listener // TLS is the optional TLS configuration, populated with a new config // after TLS is started. If set on an unstarted server before StartTLS // is called, existing fields are copied into the new config. TLS *tls.Config // Config may be changed after calling NewUnstartedServer and // before Start or StartTLS. Config *http.Server // contains filtered or unexported fields }",
        "type": "net/http"
    },
    "httptest.Server.Certificate": {
        "descr": "Certificate returns the certificate used by the server, or nil if the server doesn't use TLS.",
        "name": "httptest.Server.Certificate",
        "params": [],
        "path": "go/net/http/httptest/index#Server.Certificate",
        "syntax": "func (s *Server) Certificate() *x509.Certificate",
        "type": "net/http"
    },
    "httptest.Server.Client": {
        "descr": "Client returns an HTTP client configured for making requests to the server. It is configured to trust the server's TLS test certificate and will close its idle connections on Server.Close.",
        "name": "httptest.Server.Client",
        "params": [],
        "path": "go/net/http/httptest/index#Server.Client",
        "syntax": "func (s *Server) Client() *http.Client",
        "type": "net/http"
    },
    "httptest.Server.Close": {
        "descr": "Close shuts down the server and blocks until all outstanding requests on this server have completed.",
        "name": "httptest.Server.Close",
        "params": [],
        "path": "go/net/http/httptest/index#Server.Close",
        "syntax": "func (s *Server) Close()",
        "type": "net/http"
    },
    "httptest.Server.CloseClientConnections": {
        "descr": "CloseClientConnections closes any open HTTP connections to the test Server.",
        "name": "httptest.Server.CloseClientConnections",
        "params": [],
        "path": "go/net/http/httptest/index#Server.CloseClientConnections",
        "syntax": "func (s *Server) CloseClientConnections()",
        "type": "net/http"
    },
    "httptest.Server.Start": {
        "descr": "Start starts a server from NewUnstartedServer.",
        "name": "httptest.Server.Start",
        "params": [],
        "path": "go/net/http/httptest/index#Server.Start",
        "syntax": "func (s *Server) Start()",
        "type": "net/http"
    },
    "httptest.Server.StartTLS": {
        "descr": "StartTLS starts TLS on a server from NewUnstartedServer.",
        "name": "httptest.Server.StartTLS",
        "params": [],
        "path": "go/net/http/httptest/index#Server.StartTLS",
        "syntax": "func (s *Server) StartTLS()",
        "type": "net/http"
    },
    "httptrace.ClientTrace": {
        "descr": "ClientTrace is a set of hooks to run at various stages of an outgoing HTTP request. Any particular hook may be nil. Functions may be called concurrently from different goroutines and some may be called after the request has completed or failed.",
        "name": "httptrace.ClientTrace",
        "params": [],
        "path": "go/net/http/httptrace/index#ClientTrace",
        "syntax": "type ClientTrace struct { // GetConn is called before a connection is created or // retrieved from an idle pool. The hostPort is the // \"host:port\" of the target or proxy. GetConn is called even // if there's already an idle cached connection available. GetConn func(hostPort string) // GotConn is called after a successful connection is // obtained. There is no hook for failure to obtain a // connection; instead, use the error from // Transport.RoundTrip. GotConn func(GotConnInfo) // PutIdleConn is called when the connection is returned to // the idle pool. If err is nil, the connection was // successfully returned to the idle pool. If err is non-nil, // it describes why not. PutIdleConn is not called if // connection reuse is disabled via Transport.DisableKeepAlives. // PutIdleConn is called before the caller's Response.Body.Close // call returns. // For HTTP/2, this hook is not currently used. PutIdleConn func(err error) // GotFirstResponseByte is called when the first byte of the response // headers is available. GotFirstResponseByte func() // Got100Continue is called if the server replies with a \"100 // Continue\" response. Got100Continue func() // Got1xxResponse is called for each 1xx informational response header // returned before the final non-1xx response. Got1xxResponse is called // for \"100 Continue\" responses, even if Got100Continue is also defined. // If it returns an error, the client request is aborted with that error value. Got1xxResponse func(code int, header textproto.MIMEHeader) error // Go 1.11 // DNSStart is called when a DNS lookup begins. DNSStart func(DNSStartInfo) // DNSDone is called when a DNS lookup ends. DNSDone func(DNSDoneInfo) // ConnectStart is called when a new connection's Dial begins. // If net.Dialer.DualStack (IPv6 \"Happy Eyeballs\") support is // enabled, this may be called multiple times. ConnectStart func(network, addr string) // ConnectDone is called when a new connection's Dial // completes. The provided err indicates whether the // connection completedly successfully. // If net.Dialer.DualStack (\"Happy Eyeballs\") support is // enabled, this may be called multiple times. ConnectDone func(network, addr string, err error) // TLSHandshakeStart is called when the TLS handshake is started. When // connecting to a HTTPS site via a HTTP proxy, the handshake happens after // the CONNECT request is processed by the proxy. TLSHandshakeStart func() // Go 1.8 // TLSHandshakeDone is called after the TLS handshake with either the // successful handshake's connection state, or a non-nil error on handshake // failure. TLSHandshakeDone func(tls.ConnectionState, error) // Go 1.8 // WroteHeaderField is called after the Transport has written // each request header. At the time of this call the values // might be buffered and not yet written to the network. WroteHeaderField func(key string, value []string) // Go 1.11 // WroteHeaders is called after the Transport has written // all request headers. WroteHeaders func() // Wait100Continue is called if the Request specified // \"Expected: 100-continue\" and the Transport has written the // request headers but is waiting for \"100 Continue\" from the // server before writing the request body. Wait100Continue func() // WroteRequest is called with the result of writing the // request and any body. It may be called multiple times // in the case of retried requests. WroteRequest func(WroteRequestInfo) }",
        "type": "net/http"
    },
    "httptrace.ContextClientTrace": {
        "descr": "ContextClientTrace returns the ClientTrace associated with the provided context. If none, it returns nil.",
        "name": "httptrace.ContextClientTrace",
        "params": [],
        "path": "go/net/http/httptrace/index#ContextClientTrace",
        "syntax": "func ContextClientTrace(ctx context.Context) *ClientTrace",
        "type": "net/http"
    },
    "httptrace.DNSDoneInfo": {
        "descr": "DNSDoneInfo contains information about the results of a DNS lookup.",
        "name": "httptrace.DNSDoneInfo",
        "params": [],
        "path": "go/net/http/httptrace/index#DNSDoneInfo",
        "syntax": "type DNSDoneInfo struct { // Addrs are the IPv4 and/or IPv6 addresses found in the DNS // lookup. The contents of the slice should not be mutated. Addrs []net.IPAddr // Err is any error that occurred during the DNS lookup. Err error // Coalesced is whether the Addrs were shared with another // caller who was doing the same DNS lookup concurrently. Coalesced bool }",
        "type": "net/http"
    },
    "httptrace.DNSStartInfo": {
        "descr": "DNSStartInfo contains information about a DNS request.",
        "name": "httptrace.DNSStartInfo",
        "params": [],
        "path": "go/net/http/httptrace/index#DNSStartInfo",
        "syntax": "type DNSStartInfo struct { Host string }",
        "type": "net/http"
    },
    "httptrace.GotConnInfo": {
        "descr": "GotConnInfo is the argument to the ClientTrace.GotConn function and contains information about the obtained connection.",
        "name": "httptrace.GotConnInfo",
        "params": [],
        "path": "go/net/http/httptrace/index#GotConnInfo",
        "syntax": "type GotConnInfo struct { // Conn is the connection that was obtained. It is owned by // the http.Transport and should not be read, written or // closed by users of ClientTrace. Conn net.Conn // Reused is whether this connection has been previously // used for another HTTP request. Reused bool // WasIdle is whether this connection was obtained from an // idle pool. WasIdle bool // IdleTime reports how long the connection was previously // idle, if WasIdle is true. IdleTime time.Duration }",
        "type": "net/http"
    },
    "httptrace.WithClientTrace": {
        "descr": "WithClientTrace returns a new context based on the provided parent ctx. HTTP client requests made with the returned context will use the provided trace hooks, in addition to any previous hooks registered with ctx. Any hooks defined in the provided trace will be called first.",
        "name": "httptrace.WithClientTrace",
        "params": [],
        "path": "go/net/http/httptrace/index#WithClientTrace",
        "syntax": "func WithClientTrace(ctx context.Context, trace *ClientTrace) context.Context",
        "type": "net/http"
    },
    "httptrace.WroteRequestInfo": {
        "descr": "WroteRequestInfo contains information provided to the WroteRequest hook.",
        "name": "httptrace.WroteRequestInfo",
        "params": [],
        "path": "go/net/http/httptrace/index#WroteRequestInfo",
        "syntax": "type WroteRequestInfo struct { // Err is any error encountered while writing the Request. Err error }",
        "type": "net/http"
    },
    "httputil.BufferPool": {
        "descr": "A BufferPool is an interface for getting and returning temporary byte slices for use by io.CopyBuffer.",
        "name": "httputil.BufferPool",
        "params": [],
        "path": "go/net/http/httputil/index#BufferPool",
        "syntax": "type BufferPool interface { Get() []byte Put([]byte) }",
        "type": "net/http"
    },
    "httputil.ClientConn": {
        "descr": "ClientConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.",
        "name": "httputil.ClientConn",
        "params": [],
        "path": "go/net/http/httputil/index#ClientConn",
        "syntax": "type ClientConn struct { // contains filtered or unexported fields }",
        "type": "net/http"
    },
    "httputil.ClientConn.Close": {
        "descr": "Close calls Hijack and then also closes the underlying connection.",
        "name": "httputil.ClientConn.Close",
        "params": [],
        "path": "go/net/http/httputil/index#ClientConn.Close",
        "syntax": "func (cc *ClientConn) Close() error",
        "type": "net/http"
    },
    "httputil.ClientConn.Do": {
        "descr": "Do is convenience method that writes a request and reads a response.",
        "name": "httputil.ClientConn.Do",
        "params": [],
        "path": "go/net/http/httputil/index#ClientConn.Do",
        "syntax": "func (cc *ClientConn) Do(req *http.Request) (*http.Response, error)",
        "type": "net/http"
    },
    "httputil.ClientConn.Hijack": {
        "descr": "Hijack detaches the ClientConn and returns the underlying connection as well as the read-side bufio which may have some left over data. Hijack may be called before the user or Read have signaled the end of the keep-alive logic. The user should not call Hijack while Read or Write is in progress.",
        "name": "httputil.ClientConn.Hijack",
        "params": [],
        "path": "go/net/http/httputil/index#ClientConn.Hijack",
        "syntax": "func (cc *ClientConn) Hijack() (c net.Conn, r *bufio.Reader)",
        "type": "net/http"
    },
    "httputil.ClientConn.Pending": {
        "descr": "Pending returns the number of unanswered requests that have been sent on the connection.",
        "name": "httputil.ClientConn.Pending",
        "params": [],
        "path": "go/net/http/httputil/index#ClientConn.Pending",
        "syntax": "func (cc *ClientConn) Pending() int",
        "type": "net/http"
    },
    "httputil.ClientConn.Read": {
        "descr": "Read reads the next response from the wire. A valid response might be returned together with an ErrPersistEOF, which means that the remote requested that this be the last request serviced. Read can be called concurrently with Write, but not with another Read.",
        "name": "httputil.ClientConn.Read",
        "params": [],
        "path": "go/net/http/httputil/index#ClientConn.Read",
        "syntax": "func (cc *ClientConn) Read(req *http.Request) (resp *http.Response, err error)",
        "type": "net/http"
    },
    "httputil.ClientConn.Write": {
        "descr": "Write writes a request. An ErrPersistEOF error is returned if the connection has been closed in an HTTP keepalive sense. If req.Close equals true, the keepalive connection is logically closed after this request and the opposing server is informed. An ErrUnexpectedEOF indicates the remote closed the underlying TCP connection, which is usually considered as graceful close.",
        "name": "httputil.ClientConn.Write",
        "params": [],
        "path": "go/net/http/httputil/index#ClientConn.Write",
        "syntax": "func (cc *ClientConn) Write(req *http.Request) error",
        "type": "net/http"
    },
    "httputil.DumpRequest": {
        "descr": "DumpRequest returns the given request in its HTTP/1.x wire representation. It should only be used by servers to debug client requests. The returned representation is an approximation only; some details of the initial request are lost while parsing it into an http.Request. In particular, the order and case of header field names are lost. The order of values in multi-valued headers is kept intact. HTTP/2 requests are dumped in HTTP/1.x form, not in their original binary representations.",
        "name": "httputil.DumpRequest",
        "params": [],
        "path": "go/net/http/httputil/index#DumpRequest",
        "syntax": "func DumpRequest(req *http.Request, body bool) ([]byte, error)",
        "type": "net/http"
    },
    "httputil.DumpRequestOut": {
        "descr": "DumpRequestOut is like DumpRequest but for outgoing client requests. It includes any headers that the standard http.Transport adds, such as User-Agent.",
        "name": "httputil.DumpRequestOut",
        "params": [],
        "path": "go/net/http/httputil/index#DumpRequestOut",
        "syntax": "func DumpRequestOut(req *http.Request, body bool) ([]byte, error)",
        "type": "net/http"
    },
    "httputil.DumpResponse": {
        "descr": "DumpResponse is like DumpRequest but dumps a response.",
        "name": "httputil.DumpResponse",
        "params": [],
        "path": "go/net/http/httputil/index#DumpResponse",
        "syntax": "func DumpResponse(resp *http.Response, body bool) ([]byte, error)",
        "type": "net/http"
    },
    "httputil.NewChunkedReader": {
        "descr": "NewChunkedReader returns a new chunkedReader that translates the data read from r out of HTTP \"chunked\" format before returning it. The chunkedReader returns io.EOF when the final 0-length chunk is read.",
        "name": "httputil.NewChunkedReader",
        "params": [],
        "path": "go/net/http/httputil/index#NewChunkedReader",
        "syntax": "func NewChunkedReader(r io.Reader) io.Reader",
        "type": "net/http"
    },
    "httputil.NewChunkedWriter": {
        "descr": "NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP \"chunked\" format before writing them to w. Closing the returned chunkedWriter sends the final 0-length chunk that marks the end of the stream but does not send the final CRLF that appears after trailers; trailers and the last CRLF must be written separately.",
        "name": "httputil.NewChunkedWriter",
        "params": [],
        "path": "go/net/http/httputil/index#NewChunkedWriter",
        "syntax": "func NewChunkedWriter(w io.Writer) io.WriteCloser",
        "type": "net/http"
    },
    "httputil.NewClientConn": {
        "descr": "NewClientConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.",
        "name": "httputil.NewClientConn",
        "params": [],
        "path": "go/net/http/httputil/index#NewClientConn",
        "syntax": "func NewClientConn(c net.Conn, r *bufio.Reader) *ClientConn",
        "type": "net/http"
    },
    "httputil.NewProxyClientConn": {
        "descr": "NewProxyClientConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.",
        "name": "httputil.NewProxyClientConn",
        "params": [],
        "path": "go/net/http/httputil/index#NewProxyClientConn",
        "syntax": "func NewProxyClientConn(c net.Conn, r *bufio.Reader) *ClientConn",
        "type": "net/http"
    },
    "httputil.NewServerConn": {
        "descr": "NewServerConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.",
        "name": "httputil.NewServerConn",
        "params": [],
        "path": "go/net/http/httputil/index#NewServerConn",
        "syntax": "func NewServerConn(c net.Conn, r *bufio.Reader) *ServerConn",
        "type": "net/http"
    },
    "httputil.NewSingleHostReverseProxy": {
        "descr": "NewSingleHostReverseProxy returns a new ReverseProxy that routes URLs to the scheme, host, and base path provided in target. If the target's path is \"/base\" and the incoming request was for \"/dir\", the target request will be for /base/dir. NewSingleHostReverseProxy does not rewrite the Host header. To rewrite Host headers, use ReverseProxy directly with a custom Director policy.",
        "name": "httputil.NewSingleHostReverseProxy",
        "params": [],
        "path": "go/net/http/httputil/index#NewSingleHostReverseProxy",
        "syntax": "func NewSingleHostReverseProxy(target *url.URL) *ReverseProxy",
        "type": "net/http"
    },
    "httputil.ReverseProxy": {
        "descr": "ReverseProxy is an HTTP Handler that takes an incoming request and sends it to another server, proxying the response back to the client.",
        "name": "httputil.ReverseProxy",
        "params": [],
        "path": "go/net/http/httputil/index#ReverseProxy",
        "syntax": "type ReverseProxy struct { // Director must be a function which modifies // the request into a new request to be sent // using Transport. Its response is then copied // back to the original client unmodified. // Director must not access the provided Request // after returning. Director func(*http.Request) // The transport used to perform proxy requests. // If nil, http.DefaultTransport is used. Transport http.RoundTripper // FlushInterval specifies the flush interval // to flush to the client while copying the // response body. // If zero, no periodic flushing is done. FlushInterval time.Duration // ErrorLog specifies an optional logger for errors // that occur when attempting to proxy the request. // If nil, logging goes to os.Stderr via the log package's // standard logger. ErrorLog *log.Logger // Go 1.4 // BufferPool optionally specifies a buffer pool to // get byte slices for use by io.CopyBuffer when // copying HTTP response bodies. BufferPool BufferPool // Go 1.6 // ModifyResponse is an optional function that modifies the // Response from the backend. It is called if the backend // returns a response at all, with any HTTP status code. // If the backend is unreachable, the optional ErrorHandler is // called without any call to ModifyResponse. // // If ModifyResponse returns an error, ErrorHandler is called // with its error value. If ErrorHandler is nil, its default // implementation is used. ModifyResponse func(*http.Response) error // Go 1.8 // ErrorHandler is an optional function that handles errors // reaching the backend or errors from ModifyResponse. // // If nil, the default is to log the provided error and return // a 502 Status Bad Gateway response. ErrorHandler func(http.ResponseWriter, *http.Request, error) // Go 1.11 }",
        "type": "net/http"
    },
    "httputil.ReverseProxy.ServeHTTP": {
        "descr": "",
        "name": "httputil.ReverseProxy.ServeHTTP",
        "params": [],
        "path": "go/net/http/httputil/index#ReverseProxy.ServeHTTP",
        "syntax": "func (p *ReverseProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request)",
        "type": "net/http"
    },
    "httputil.ServerConn": {
        "descr": "ServerConn is an artifact of Go's early HTTP implementation. It is low-level, old, and unused by Go's current HTTP stack. We should have deleted it before Go 1.",
        "name": "httputil.ServerConn",
        "params": [],
        "path": "go/net/http/httputil/index#ServerConn",
        "syntax": "type ServerConn struct { // contains filtered or unexported fields }",
        "type": "net/http"
    },
    "httputil.ServerConn.Close": {
        "descr": "Close calls Hijack and then also closes the underlying connection.",
        "name": "httputil.ServerConn.Close",
        "params": [],
        "path": "go/net/http/httputil/index#ServerConn.Close",
        "syntax": "func (sc *ServerConn) Close() error",
        "type": "net/http"
    },
    "httputil.ServerConn.Hijack": {
        "descr": "Hijack detaches the ServerConn and returns the underlying connection as well as the read-side bufio which may have some left over data. Hijack may be called before Read has signaled the end of the keep-alive logic. The user should not call Hijack while Read or Write is in progress.",
        "name": "httputil.ServerConn.Hijack",
        "params": [],
        "path": "go/net/http/httputil/index#ServerConn.Hijack",
        "syntax": "func (sc *ServerConn) Hijack() (net.Conn, *bufio.Reader)",
        "type": "net/http"
    },
    "httputil.ServerConn.Pending": {
        "descr": "Pending returns the number of unanswered requests that have been received on the connection.",
        "name": "httputil.ServerConn.Pending",
        "params": [],
        "path": "go/net/http/httputil/index#ServerConn.Pending",
        "syntax": "func (sc *ServerConn) Pending() int",
        "type": "net/http"
    },
    "httputil.ServerConn.Read": {
        "descr": "Read returns the next request on the wire. An ErrPersistEOF is returned if it is gracefully determined that there are no more requests (e.g. after the first request on an HTTP/1.0 connection, or after a Connection:close on a HTTP/1.1 connection).",
        "name": "httputil.ServerConn.Read",
        "params": [],
        "path": "go/net/http/httputil/index#ServerConn.Read",
        "syntax": "func (sc *ServerConn) Read() (*http.Request, error)",
        "type": "net/http"
    },
    "httputil.ServerConn.Write": {
        "descr": "Write writes resp in response to req. To close the connection gracefully, set the Response.Close field to true. Write should be considered operational until it returns an error, regardless of any errors returned on the Read side.",
        "name": "httputil.ServerConn.Write",
        "params": [],
        "path": "go/net/http/httputil/index#ServerConn.Write",
        "syntax": "func (sc *ServerConn) Write(req *http.Request, resp *http.Response) error",
        "type": "net/http"
    },
    "imag": {
        "descr": "The imag built-in function returns the imaginary part of the complex number c. The return value will be floating point type corresponding to the type of c.",
        "name": "builtin.imag",
        "params": [],
        "path": "go/builtin/index#imag",
        "syntax": "func imag(c ComplexType) FloatType",
        "type": "builtin"
    },
    "image": {
        "descr": "ErrFormat indicates that decoding encountered an unknown format.",
        "name": "image",
        "params": [],
        "path": "go/image/index#pkg-variables",
        "syntax": "var ( // Black is an opaque black uniform image. Black = NewUniform(color.Black) // White is an opaque white uniform image. White = NewUniform(color.White) // Transparent is a fully transparent uniform image. Transparent = NewUniform(color.Transparent) // Opaque is a fully opaque uniform image. Opaque = NewUniform(color.Opaque) )",
        "type": "image"
    },
    "image.Alpha": {
        "descr": "Alpha is an in-memory image whose At method returns color.Alpha values.",
        "name": "image.Alpha",
        "params": [],
        "path": "go/image/index#Alpha",
        "syntax": "type Alpha struct { // Pix holds the image's pixels, as alpha values. The pixel at // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1]. Pix []uint8 // Stride is the Pix stride (in bytes) between vertically adjacent pixels. Stride int // Rect is the image's bounds. Rect Rectangle }",
        "type": "image"
    },
    "image.Alpha.AlphaAt": {
        "descr": "",
        "name": "image.Alpha.AlphaAt",
        "params": [],
        "path": "go/image/index#Alpha.AlphaAt",
        "syntax": "func (p *Alpha) AlphaAt(x, y int) color.Alpha",
        "type": "image"
    },
    "image.Alpha.At": {
        "descr": "",
        "name": "image.Alpha.At",
        "params": [],
        "path": "go/image/index#Alpha.At",
        "syntax": "func (p *Alpha) At(x, y int) color.Color",
        "type": "image"
    },
    "image.Alpha.Bounds": {
        "descr": "",
        "name": "image.Alpha.Bounds",
        "params": [],
        "path": "go/image/index#Alpha.Bounds",
        "syntax": "func (p *Alpha) Bounds() Rectangle",
        "type": "image"
    },
    "image.Alpha.ColorModel": {
        "descr": "",
        "name": "image.Alpha.ColorModel",
        "params": [],
        "path": "go/image/index#Alpha.ColorModel",
        "syntax": "func (p *Alpha) ColorModel() color.Model",
        "type": "image"
    },
    "image.Alpha.Opaque": {
        "descr": "Opaque scans the entire image and reports whether it is fully opaque.",
        "name": "image.Alpha.Opaque",
        "params": [],
        "path": "go/image/index#Alpha.Opaque",
        "syntax": "func (p *Alpha) Opaque() bool",
        "type": "image"
    },
    "image.Alpha.PixOffset": {
        "descr": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y).",
        "name": "image.Alpha.PixOffset",
        "params": [],
        "path": "go/image/index#Alpha.PixOffset",
        "syntax": "func (p *Alpha) PixOffset(x, y int) int",
        "type": "image"
    },
    "image.Alpha.Set": {
        "descr": "",
        "name": "image.Alpha.Set",
        "params": [],
        "path": "go/image/index#Alpha.Set",
        "syntax": "func (p *Alpha) Set(x, y int, c color.Color)",
        "type": "image"
    },
    "image.Alpha.SetAlpha": {
        "descr": "",
        "name": "image.Alpha.SetAlpha",
        "params": [],
        "path": "go/image/index#Alpha.SetAlpha",
        "syntax": "func (p *Alpha) SetAlpha(x, y int, c color.Alpha)",
        "type": "image"
    },
    "image.Alpha.SubImage": {
        "descr": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.",
        "name": "image.Alpha.SubImage",
        "params": [],
        "path": "go/image/index#Alpha.SubImage",
        "syntax": "func (p *Alpha) SubImage(r Rectangle) Image",
        "type": "image"
    },
    "image.Alpha16": {
        "descr": "Alpha16 is an in-memory image whose At method returns color.Alpha16 values.",
        "name": "image.Alpha16",
        "params": [],
        "path": "go/image/index#Alpha16",
        "syntax": "type Alpha16 struct { // Pix holds the image's pixels, as alpha values in big-endian format. The pixel at // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*2]. Pix []uint8 // Stride is the Pix stride (in bytes) between vertically adjacent pixels. Stride int // Rect is the image's bounds. Rect Rectangle }",
        "type": "image"
    },
    "image.Alpha16.Alpha16At": {
        "descr": "",
        "name": "image.Alpha16.Alpha16At",
        "params": [],
        "path": "go/image/index#Alpha16.Alpha16At",
        "syntax": "func (p *Alpha16) Alpha16At(x, y int) color.Alpha16",
        "type": "image"
    },
    "image.Alpha16.At": {
        "descr": "",
        "name": "image.Alpha16.At",
        "params": [],
        "path": "go/image/index#Alpha16.At",
        "syntax": "func (p *Alpha16) At(x, y int) color.Color",
        "type": "image"
    },
    "image.Alpha16.Bounds": {
        "descr": "",
        "name": "image.Alpha16.Bounds",
        "params": [],
        "path": "go/image/index#Alpha16.Bounds",
        "syntax": "func (p *Alpha16) Bounds() Rectangle",
        "type": "image"
    },
    "image.Alpha16.ColorModel": {
        "descr": "",
        "name": "image.Alpha16.ColorModel",
        "params": [],
        "path": "go/image/index#Alpha16.ColorModel",
        "syntax": "func (p *Alpha16) ColorModel() color.Model",
        "type": "image"
    },
    "image.Alpha16.Opaque": {
        "descr": "Opaque scans the entire image and reports whether it is fully opaque.",
        "name": "image.Alpha16.Opaque",
        "params": [],
        "path": "go/image/index#Alpha16.Opaque",
        "syntax": "func (p *Alpha16) Opaque() bool",
        "type": "image"
    },
    "image.Alpha16.PixOffset": {
        "descr": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y).",
        "name": "image.Alpha16.PixOffset",
        "params": [],
        "path": "go/image/index#Alpha16.PixOffset",
        "syntax": "func (p *Alpha16) PixOffset(x, y int) int",
        "type": "image"
    },
    "image.Alpha16.Set": {
        "descr": "",
        "name": "image.Alpha16.Set",
        "params": [],
        "path": "go/image/index#Alpha16.Set",
        "syntax": "func (p *Alpha16) Set(x, y int, c color.Color)",
        "type": "image"
    },
    "image.Alpha16.SetAlpha16": {
        "descr": "",
        "name": "image.Alpha16.SetAlpha16",
        "params": [],
        "path": "go/image/index#Alpha16.SetAlpha16",
        "syntax": "func (p *Alpha16) SetAlpha16(x, y int, c color.Alpha16)",
        "type": "image"
    },
    "image.Alpha16.SubImage": {
        "descr": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.",
        "name": "image.Alpha16.SubImage",
        "params": [],
        "path": "go/image/index#Alpha16.SubImage",
        "syntax": "func (p *Alpha16) SubImage(r Rectangle) Image",
        "type": "image"
    },
    "image.CMYK": {
        "descr": "CMYK is an in-memory image whose At method returns color.CMYK values.",
        "name": "image.CMYK",
        "params": [],
        "path": "go/image/index#CMYK",
        "syntax": "type CMYK struct { // Pix holds the image's pixels, in C, M, Y, K order. The pixel at // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4]. Pix []uint8 // Stride is the Pix stride (in bytes) between vertically adjacent pixels. Stride int // Rect is the image's bounds. Rect Rectangle }",
        "type": "image"
    },
    "image.CMYK.At": {
        "descr": "",
        "name": "image.CMYK.At",
        "params": [],
        "path": "go/image/index#CMYK.At",
        "syntax": "func (p *CMYK) At(x, y int) color.Color",
        "type": "image"
    },
    "image.CMYK.Bounds": {
        "descr": "",
        "name": "image.CMYK.Bounds",
        "params": [],
        "path": "go/image/index#CMYK.Bounds",
        "syntax": "func (p *CMYK) Bounds() Rectangle",
        "type": "image"
    },
    "image.CMYK.CMYKAt": {
        "descr": "",
        "name": "image.CMYK.CMYKAt",
        "params": [],
        "path": "go/image/index#CMYK.CMYKAt",
        "syntax": "func (p *CMYK) CMYKAt(x, y int) color.CMYK",
        "type": "image"
    },
    "image.CMYK.ColorModel": {
        "descr": "",
        "name": "image.CMYK.ColorModel",
        "params": [],
        "path": "go/image/index#CMYK.ColorModel",
        "syntax": "func (p *CMYK) ColorModel() color.Model",
        "type": "image"
    },
    "image.CMYK.Opaque": {
        "descr": "Opaque scans the entire image and reports whether it is fully opaque.",
        "name": "image.CMYK.Opaque",
        "params": [],
        "path": "go/image/index#CMYK.Opaque",
        "syntax": "func (p *CMYK) Opaque() bool",
        "type": "image"
    },
    "image.CMYK.PixOffset": {
        "descr": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y).",
        "name": "image.CMYK.PixOffset",
        "params": [],
        "path": "go/image/index#CMYK.PixOffset",
        "syntax": "func (p *CMYK) PixOffset(x, y int) int",
        "type": "image"
    },
    "image.CMYK.Set": {
        "descr": "",
        "name": "image.CMYK.Set",
        "params": [],
        "path": "go/image/index#CMYK.Set",
        "syntax": "func (p *CMYK) Set(x, y int, c color.Color)",
        "type": "image"
    },
    "image.CMYK.SetCMYK": {
        "descr": "",
        "name": "image.CMYK.SetCMYK",
        "params": [],
        "path": "go/image/index#CMYK.SetCMYK",
        "syntax": "func (p *CMYK) SetCMYK(x, y int, c color.CMYK)",
        "type": "image"
    },
    "image.CMYK.SubImage": {
        "descr": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.",
        "name": "image.CMYK.SubImage",
        "params": [],
        "path": "go/image/index#CMYK.SubImage",
        "syntax": "func (p *CMYK) SubImage(r Rectangle) Image",
        "type": "image"
    },
    "image.Config": {
        "descr": "Config holds an image's color model and dimensions.",
        "name": "image.Config",
        "params": [],
        "path": "go/image/index#Config",
        "syntax": "type Config struct { ColorModel color.Model Width, Height int }",
        "type": "image"
    },
    "image.Decode": {
        "descr": "Decode decodes an image that has been encoded in a registered format. The string returned is the format name used during format registration. Format registration is typically done by an init function in the codec- specific package.",
        "name": "image.Decode",
        "params": [],
        "path": "go/image/index#Decode",
        "syntax": "func Decode(r io.Reader) (Image, string, error)",
        "type": "image"
    },
    "image.DecodeConfig": {
        "descr": "DecodeConfig decodes the color model and dimensions of an image that has been encoded in a registered format. The string returned is the format name used during format registration. Format registration is typically done by an init function in the codec-specific package.",
        "name": "image.DecodeConfig",
        "params": [],
        "path": "go/image/index#DecodeConfig",
        "syntax": "func DecodeConfig(r io.Reader) (Config, string, error)",
        "type": "image"
    },
    "image.Gray": {
        "descr": "Gray is an in-memory image whose At method returns color.Gray values.",
        "name": "image.Gray",
        "params": [],
        "path": "go/image/index#Gray",
        "syntax": "type Gray struct { // Pix holds the image's pixels, as gray values. The pixel at // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1]. Pix []uint8 // Stride is the Pix stride (in bytes) between vertically adjacent pixels. Stride int // Rect is the image's bounds. Rect Rectangle }",
        "type": "image"
    },
    "image.Gray.At": {
        "descr": "",
        "name": "image.Gray.At",
        "params": [],
        "path": "go/image/index#Gray.At",
        "syntax": "func (p *Gray) At(x, y int) color.Color",
        "type": "image"
    },
    "image.Gray.Bounds": {
        "descr": "",
        "name": "image.Gray.Bounds",
        "params": [],
        "path": "go/image/index#Gray.Bounds",
        "syntax": "func (p *Gray) Bounds() Rectangle",
        "type": "image"
    },
    "image.Gray.ColorModel": {
        "descr": "",
        "name": "image.Gray.ColorModel",
        "params": [],
        "path": "go/image/index#Gray.ColorModel",
        "syntax": "func (p *Gray) ColorModel() color.Model",
        "type": "image"
    },
    "image.Gray.GrayAt": {
        "descr": "",
        "name": "image.Gray.GrayAt",
        "params": [],
        "path": "go/image/index#Gray.GrayAt",
        "syntax": "func (p *Gray) GrayAt(x, y int) color.Gray",
        "type": "image"
    },
    "image.Gray.Opaque": {
        "descr": "Opaque scans the entire image and reports whether it is fully opaque.",
        "name": "image.Gray.Opaque",
        "params": [],
        "path": "go/image/index#Gray.Opaque",
        "syntax": "func (p *Gray) Opaque() bool",
        "type": "image"
    },
    "image.Gray.PixOffset": {
        "descr": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y).",
        "name": "image.Gray.PixOffset",
        "params": [],
        "path": "go/image/index#Gray.PixOffset",
        "syntax": "func (p *Gray) PixOffset(x, y int) int",
        "type": "image"
    },
    "image.Gray.Set": {
        "descr": "",
        "name": "image.Gray.Set",
        "params": [],
        "path": "go/image/index#Gray.Set",
        "syntax": "func (p *Gray) Set(x, y int, c color.Color)",
        "type": "image"
    },
    "image.Gray.SetGray": {
        "descr": "",
        "name": "image.Gray.SetGray",
        "params": [],
        "path": "go/image/index#Gray.SetGray",
        "syntax": "func (p *Gray) SetGray(x, y int, c color.Gray)",
        "type": "image"
    },
    "image.Gray.SubImage": {
        "descr": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.",
        "name": "image.Gray.SubImage",
        "params": [],
        "path": "go/image/index#Gray.SubImage",
        "syntax": "func (p *Gray) SubImage(r Rectangle) Image",
        "type": "image"
    },
    "image.Gray16": {
        "descr": "Gray16 is an in-memory image whose At method returns color.Gray16 values.",
        "name": "image.Gray16",
        "params": [],
        "path": "go/image/index#Gray16",
        "syntax": "type Gray16 struct { // Pix holds the image's pixels, as gray values in big-endian format. The pixel at // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*2]. Pix []uint8 // Stride is the Pix stride (in bytes) between vertically adjacent pixels. Stride int // Rect is the image's bounds. Rect Rectangle }",
        "type": "image"
    },
    "image.Gray16.At": {
        "descr": "",
        "name": "image.Gray16.At",
        "params": [],
        "path": "go/image/index#Gray16.At",
        "syntax": "func (p *Gray16) At(x, y int) color.Color",
        "type": "image"
    },
    "image.Gray16.Bounds": {
        "descr": "",
        "name": "image.Gray16.Bounds",
        "params": [],
        "path": "go/image/index#Gray16.Bounds",
        "syntax": "func (p *Gray16) Bounds() Rectangle",
        "type": "image"
    },
    "image.Gray16.ColorModel": {
        "descr": "",
        "name": "image.Gray16.ColorModel",
        "params": [],
        "path": "go/image/index#Gray16.ColorModel",
        "syntax": "func (p *Gray16) ColorModel() color.Model",
        "type": "image"
    },
    "image.Gray16.Gray16At": {
        "descr": "",
        "name": "image.Gray16.Gray16At",
        "params": [],
        "path": "go/image/index#Gray16.Gray16At",
        "syntax": "func (p *Gray16) Gray16At(x, y int) color.Gray16",
        "type": "image"
    },
    "image.Gray16.Opaque": {
        "descr": "Opaque scans the entire image and reports whether it is fully opaque.",
        "name": "image.Gray16.Opaque",
        "params": [],
        "path": "go/image/index#Gray16.Opaque",
        "syntax": "func (p *Gray16) Opaque() bool",
        "type": "image"
    },
    "image.Gray16.PixOffset": {
        "descr": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y).",
        "name": "image.Gray16.PixOffset",
        "params": [],
        "path": "go/image/index#Gray16.PixOffset",
        "syntax": "func (p *Gray16) PixOffset(x, y int) int",
        "type": "image"
    },
    "image.Gray16.Set": {
        "descr": "",
        "name": "image.Gray16.Set",
        "params": [],
        "path": "go/image/index#Gray16.Set",
        "syntax": "func (p *Gray16) Set(x, y int, c color.Color)",
        "type": "image"
    },
    "image.Gray16.SetGray16": {
        "descr": "",
        "name": "image.Gray16.SetGray16",
        "params": [],
        "path": "go/image/index#Gray16.SetGray16",
        "syntax": "func (p *Gray16) SetGray16(x, y int, c color.Gray16)",
        "type": "image"
    },
    "image.Gray16.SubImage": {
        "descr": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.",
        "name": "image.Gray16.SubImage",
        "params": [],
        "path": "go/image/index#Gray16.SubImage",
        "syntax": "func (p *Gray16) SubImage(r Rectangle) Image",
        "type": "image"
    },
    "image.Image": {
        "descr": "Image is a finite rectangular grid of color.Color values taken from a color model.",
        "name": "image.Image",
        "params": [],
        "path": "go/image/index#Image",
        "syntax": "type Image interface { // ColorModel returns the Image's color model. ColorModel() color.Model // Bounds returns the domain for which At can return non-zero color. // The bounds do not necessarily contain the point (0, 0). Bounds() Rectangle // At returns the color of the pixel at (x, y). // At(Bounds().Min.X, Bounds().Min.Y) returns the upper-left pixel of the grid. // At(Bounds().Max.X-1, Bounds().Max.Y-1) returns the lower-right one. At(x, y int) color.Color }",
        "type": "image"
    },
    "image.NRGBA": {
        "descr": "NRGBA is an in-memory image whose At method returns color.NRGBA values.",
        "name": "image.NRGBA",
        "params": [],
        "path": "go/image/index#NRGBA",
        "syntax": "type NRGBA struct { // Pix holds the image's pixels, in R, G, B, A order. The pixel at // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4]. Pix []uint8 // Stride is the Pix stride (in bytes) between vertically adjacent pixels. Stride int // Rect is the image's bounds. Rect Rectangle }",
        "type": "image"
    },
    "image.NRGBA.At": {
        "descr": "",
        "name": "image.NRGBA.At",
        "params": [],
        "path": "go/image/index#NRGBA.At",
        "syntax": "func (p *NRGBA) At(x, y int) color.Color",
        "type": "image"
    },
    "image.NRGBA.Bounds": {
        "descr": "",
        "name": "image.NRGBA.Bounds",
        "params": [],
        "path": "go/image/index#NRGBA.Bounds",
        "syntax": "func (p *NRGBA) Bounds() Rectangle",
        "type": "image"
    },
    "image.NRGBA.ColorModel": {
        "descr": "",
        "name": "image.NRGBA.ColorModel",
        "params": [],
        "path": "go/image/index#NRGBA.ColorModel",
        "syntax": "func (p *NRGBA) ColorModel() color.Model",
        "type": "image"
    },
    "image.NRGBA.NRGBAAt": {
        "descr": "",
        "name": "image.NRGBA.NRGBAAt",
        "params": [],
        "path": "go/image/index#NRGBA.NRGBAAt",
        "syntax": "func (p *NRGBA) NRGBAAt(x, y int) color.NRGBA",
        "type": "image"
    },
    "image.NRGBA.Opaque": {
        "descr": "Opaque scans the entire image and reports whether it is fully opaque.",
        "name": "image.NRGBA.Opaque",
        "params": [],
        "path": "go/image/index#NRGBA.Opaque",
        "syntax": "func (p *NRGBA) Opaque() bool",
        "type": "image"
    },
    "image.NRGBA.PixOffset": {
        "descr": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y).",
        "name": "image.NRGBA.PixOffset",
        "params": [],
        "path": "go/image/index#NRGBA.PixOffset",
        "syntax": "func (p *NRGBA) PixOffset(x, y int) int",
        "type": "image"
    },
    "image.NRGBA.Set": {
        "descr": "",
        "name": "image.NRGBA.Set",
        "params": [],
        "path": "go/image/index#NRGBA.Set",
        "syntax": "func (p *NRGBA) Set(x, y int, c color.Color)",
        "type": "image"
    },
    "image.NRGBA.SetNRGBA": {
        "descr": "",
        "name": "image.NRGBA.SetNRGBA",
        "params": [],
        "path": "go/image/index#NRGBA.SetNRGBA",
        "syntax": "func (p *NRGBA) SetNRGBA(x, y int, c color.NRGBA)",
        "type": "image"
    },
    "image.NRGBA.SubImage": {
        "descr": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.",
        "name": "image.NRGBA.SubImage",
        "params": [],
        "path": "go/image/index#NRGBA.SubImage",
        "syntax": "func (p *NRGBA) SubImage(r Rectangle) Image",
        "type": "image"
    },
    "image.NRGBA64": {
        "descr": "NRGBA64 is an in-memory image whose At method returns color.NRGBA64 values.",
        "name": "image.NRGBA64",
        "params": [],
        "path": "go/image/index#NRGBA64",
        "syntax": "type NRGBA64 struct { // Pix holds the image's pixels, in R, G, B, A order and big-endian format. The pixel at // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*8]. Pix []uint8 // Stride is the Pix stride (in bytes) between vertically adjacent pixels. Stride int // Rect is the image's bounds. Rect Rectangle }",
        "type": "image"
    },
    "image.NRGBA64.At": {
        "descr": "",
        "name": "image.NRGBA64.At",
        "params": [],
        "path": "go/image/index#NRGBA64.At",
        "syntax": "func (p *NRGBA64) At(x, y int) color.Color",
        "type": "image"
    },
    "image.NRGBA64.Bounds": {
        "descr": "",
        "name": "image.NRGBA64.Bounds",
        "params": [],
        "path": "go/image/index#NRGBA64.Bounds",
        "syntax": "func (p *NRGBA64) Bounds() Rectangle",
        "type": "image"
    },
    "image.NRGBA64.ColorModel": {
        "descr": "",
        "name": "image.NRGBA64.ColorModel",
        "params": [],
        "path": "go/image/index#NRGBA64.ColorModel",
        "syntax": "func (p *NRGBA64) ColorModel() color.Model",
        "type": "image"
    },
    "image.NRGBA64.NRGBA64At": {
        "descr": "",
        "name": "image.NRGBA64.NRGBA64At",
        "params": [],
        "path": "go/image/index#NRGBA64.NRGBA64At",
        "syntax": "func (p *NRGBA64) NRGBA64At(x, y int) color.NRGBA64",
        "type": "image"
    },
    "image.NRGBA64.Opaque": {
        "descr": "Opaque scans the entire image and reports whether it is fully opaque.",
        "name": "image.NRGBA64.Opaque",
        "params": [],
        "path": "go/image/index#NRGBA64.Opaque",
        "syntax": "func (p *NRGBA64) Opaque() bool",
        "type": "image"
    },
    "image.NRGBA64.PixOffset": {
        "descr": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y).",
        "name": "image.NRGBA64.PixOffset",
        "params": [],
        "path": "go/image/index#NRGBA64.PixOffset",
        "syntax": "func (p *NRGBA64) PixOffset(x, y int) int",
        "type": "image"
    },
    "image.NRGBA64.Set": {
        "descr": "",
        "name": "image.NRGBA64.Set",
        "params": [],
        "path": "go/image/index#NRGBA64.Set",
        "syntax": "func (p *NRGBA64) Set(x, y int, c color.Color)",
        "type": "image"
    },
    "image.NRGBA64.SetNRGBA64": {
        "descr": "",
        "name": "image.NRGBA64.SetNRGBA64",
        "params": [],
        "path": "go/image/index#NRGBA64.SetNRGBA64",
        "syntax": "func (p *NRGBA64) SetNRGBA64(x, y int, c color.NRGBA64)",
        "type": "image"
    },
    "image.NRGBA64.SubImage": {
        "descr": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.",
        "name": "image.NRGBA64.SubImage",
        "params": [],
        "path": "go/image/index#NRGBA64.SubImage",
        "syntax": "func (p *NRGBA64) SubImage(r Rectangle) Image",
        "type": "image"
    },
    "image.NYCbCrA": {
        "descr": "NYCbCrA is an in-memory image of non-alpha-premultiplied Y'CbCr-with-alpha colors. A and AStride are analogous to the Y and YStride fields of the embedded YCbCr.",
        "name": "image.NYCbCrA",
        "params": [],
        "path": "go/image/index#NYCbCrA",
        "syntax": "type NYCbCrA struct { YCbCr A []uint8 AStride int }",
        "type": "image"
    },
    "image.NYCbCrA.AOffset": {
        "descr": "AOffset returns the index of the first element of A that corresponds to the pixel at (x, y).",
        "name": "image.NYCbCrA.AOffset",
        "params": [],
        "path": "go/image/index#NYCbCrA.AOffset",
        "syntax": "func (p *NYCbCrA) AOffset(x, y int) int",
        "type": "image"
    },
    "image.NYCbCrA.At": {
        "descr": "",
        "name": "image.NYCbCrA.At",
        "params": [],
        "path": "go/image/index#NYCbCrA.At",
        "syntax": "func (p *NYCbCrA) At(x, y int) color.Color",
        "type": "image"
    },
    "image.NYCbCrA.ColorModel": {
        "descr": "",
        "name": "image.NYCbCrA.ColorModel",
        "params": [],
        "path": "go/image/index#NYCbCrA.ColorModel",
        "syntax": "func (p *NYCbCrA) ColorModel() color.Model",
        "type": "image"
    },
    "image.NYCbCrA.NYCbCrAAt": {
        "descr": "",
        "name": "image.NYCbCrA.NYCbCrAAt",
        "params": [],
        "path": "go/image/index#NYCbCrA.NYCbCrAAt",
        "syntax": "func (p *NYCbCrA) NYCbCrAAt(x, y int) color.NYCbCrA",
        "type": "image"
    },
    "image.NYCbCrA.Opaque": {
        "descr": "Opaque scans the entire image and reports whether it is fully opaque.",
        "name": "image.NYCbCrA.Opaque",
        "params": [],
        "path": "go/image/index#NYCbCrA.Opaque",
        "syntax": "func (p *NYCbCrA) Opaque() bool",
        "type": "image"
    },
    "image.NYCbCrA.SubImage": {
        "descr": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.",
        "name": "image.NYCbCrA.SubImage",
        "params": [],
        "path": "go/image/index#NYCbCrA.SubImage",
        "syntax": "func (p *NYCbCrA) SubImage(r Rectangle) Image",
        "type": "image"
    },
    "image.NewAlpha": {
        "descr": "NewAlpha returns a new Alpha image with the given bounds.",
        "name": "image.NewAlpha",
        "params": [],
        "path": "go/image/index#NewAlpha",
        "syntax": "func NewAlpha(r Rectangle) *Alpha",
        "type": "image"
    },
    "image.NewAlpha16": {
        "descr": "NewAlpha16 returns a new Alpha16 image with the given bounds.",
        "name": "image.NewAlpha16",
        "params": [],
        "path": "go/image/index#NewAlpha16",
        "syntax": "func NewAlpha16(r Rectangle) *Alpha16",
        "type": "image"
    },
    "image.NewCMYK": {
        "descr": "NewCMYK returns a new CMYK image with the given bounds.",
        "name": "image.NewCMYK",
        "params": [],
        "path": "go/image/index#NewCMYK",
        "syntax": "func NewCMYK(r Rectangle) *CMYK",
        "type": "image"
    },
    "image.NewGray": {
        "descr": "NewGray returns a new Gray image with the given bounds.",
        "name": "image.NewGray",
        "params": [],
        "path": "go/image/index#NewGray",
        "syntax": "func NewGray(r Rectangle) *Gray",
        "type": "image"
    },
    "image.NewGray16": {
        "descr": "NewGray16 returns a new Gray16 image with the given bounds.",
        "name": "image.NewGray16",
        "params": [],
        "path": "go/image/index#NewGray16",
        "syntax": "func NewGray16(r Rectangle) *Gray16",
        "type": "image"
    },
    "image.NewNRGBA": {
        "descr": "NewNRGBA returns a new NRGBA image with the given bounds.",
        "name": "image.NewNRGBA",
        "params": [],
        "path": "go/image/index#NewNRGBA",
        "syntax": "func NewNRGBA(r Rectangle) *NRGBA",
        "type": "image"
    },
    "image.NewNRGBA64": {
        "descr": "NewNRGBA64 returns a new NRGBA64 image with the given bounds.",
        "name": "image.NewNRGBA64",
        "params": [],
        "path": "go/image/index#NewNRGBA64",
        "syntax": "func NewNRGBA64(r Rectangle) *NRGBA64",
        "type": "image"
    },
    "image.NewNYCbCrA": {
        "descr": "NewNYCbCrA returns a new NYCbCrA image with the given bounds and subsample ratio.",
        "name": "image.NewNYCbCrA",
        "params": [],
        "path": "go/image/index#NewNYCbCrA",
        "syntax": "func NewNYCbCrA(r Rectangle, subsampleRatio YCbCrSubsampleRatio) *NYCbCrA",
        "type": "image"
    },
    "image.NewPaletted": {
        "descr": "NewPaletted returns a new Paletted image with the given width, height and palette.",
        "name": "image.NewPaletted",
        "params": [],
        "path": "go/image/index#NewPaletted",
        "syntax": "func NewPaletted(r Rectangle, p color.Palette) *Paletted",
        "type": "image"
    },
    "image.NewRGBA": {
        "descr": "NewRGBA returns a new RGBA image with the given bounds.",
        "name": "image.NewRGBA",
        "params": [],
        "path": "go/image/index#NewRGBA",
        "syntax": "func NewRGBA(r Rectangle) *RGBA",
        "type": "image"
    },
    "image.NewRGBA64": {
        "descr": "NewRGBA64 returns a new RGBA64 image with the given bounds.",
        "name": "image.NewRGBA64",
        "params": [],
        "path": "go/image/index#NewRGBA64",
        "syntax": "func NewRGBA64(r Rectangle) *RGBA64",
        "type": "image"
    },
    "image.NewUniform": {
        "descr": "",
        "name": "image.NewUniform",
        "params": [],
        "path": "go/image/index#NewUniform",
        "syntax": "func NewUniform(c color.Color) *Uniform",
        "type": "image"
    },
    "image.NewYCbCr": {
        "descr": "NewYCbCr returns a new YCbCr image with the given bounds and subsample ratio.",
        "name": "image.NewYCbCr",
        "params": [],
        "path": "go/image/index#NewYCbCr",
        "syntax": "func NewYCbCr(r Rectangle, subsampleRatio YCbCrSubsampleRatio) *YCbCr",
        "type": "image"
    },
    "image.Paletted": {
        "descr": "Paletted is an in-memory image of uint8 indices into a given palette.",
        "name": "image.Paletted",
        "params": [],
        "path": "go/image/index#Paletted",
        "syntax": "type Paletted struct { // Pix holds the image's pixels, as palette indices. The pixel at // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1]. Pix []uint8 // Stride is the Pix stride (in bytes) between vertically adjacent pixels. Stride int // Rect is the image's bounds. Rect Rectangle // Palette is the image's palette. Palette color.Palette }",
        "type": "image"
    },
    "image.Paletted.At": {
        "descr": "",
        "name": "image.Paletted.At",
        "params": [],
        "path": "go/image/index#Paletted.At",
        "syntax": "func (p *Paletted) At(x, y int) color.Color",
        "type": "image"
    },
    "image.Paletted.Bounds": {
        "descr": "",
        "name": "image.Paletted.Bounds",
        "params": [],
        "path": "go/image/index#Paletted.Bounds",
        "syntax": "func (p *Paletted) Bounds() Rectangle",
        "type": "image"
    },
    "image.Paletted.ColorIndexAt": {
        "descr": "",
        "name": "image.Paletted.ColorIndexAt",
        "params": [],
        "path": "go/image/index#Paletted.ColorIndexAt",
        "syntax": "func (p *Paletted) ColorIndexAt(x, y int) uint8",
        "type": "image"
    },
    "image.Paletted.ColorModel": {
        "descr": "",
        "name": "image.Paletted.ColorModel",
        "params": [],
        "path": "go/image/index#Paletted.ColorModel",
        "syntax": "func (p *Paletted) ColorModel() color.Model",
        "type": "image"
    },
    "image.Paletted.Opaque": {
        "descr": "Opaque scans the entire image and reports whether it is fully opaque.",
        "name": "image.Paletted.Opaque",
        "params": [],
        "path": "go/image/index#Paletted.Opaque",
        "syntax": "func (p *Paletted) Opaque() bool",
        "type": "image"
    },
    "image.Paletted.PixOffset": {
        "descr": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y).",
        "name": "image.Paletted.PixOffset",
        "params": [],
        "path": "go/image/index#Paletted.PixOffset",
        "syntax": "func (p *Paletted) PixOffset(x, y int) int",
        "type": "image"
    },
    "image.Paletted.Set": {
        "descr": "",
        "name": "image.Paletted.Set",
        "params": [],
        "path": "go/image/index#Paletted.Set",
        "syntax": "func (p *Paletted) Set(x, y int, c color.Color)",
        "type": "image"
    },
    "image.Paletted.SetColorIndex": {
        "descr": "",
        "name": "image.Paletted.SetColorIndex",
        "params": [],
        "path": "go/image/index#Paletted.SetColorIndex",
        "syntax": "func (p *Paletted) SetColorIndex(x, y int, index uint8)",
        "type": "image"
    },
    "image.Paletted.SubImage": {
        "descr": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.",
        "name": "image.Paletted.SubImage",
        "params": [],
        "path": "go/image/index#Paletted.SubImage",
        "syntax": "func (p *Paletted) SubImage(r Rectangle) Image",
        "type": "image"
    },
    "image.PalettedImage": {
        "descr": "PalettedImage is an image whose colors may come from a limited palette. If m is a PalettedImage and m.ColorModel() returns a color.Palette p, then m.At(x, y) should be equivalent to p[m.ColorIndexAt(x, y)]. If m's color model is not a color.Palette, then ColorIndexAt's behavior is undefined.",
        "name": "image.PalettedImage",
        "params": [],
        "path": "go/image/index#PalettedImage",
        "syntax": "type PalettedImage interface { // ColorIndexAt returns the palette index of the pixel at (x, y). ColorIndexAt(x, y int) uint8 Image }",
        "type": "image"
    },
    "image.Point": {
        "descr": "A Point is an X, Y coordinate pair. The axes increase right and down.",
        "name": "image.Point",
        "params": [],
        "path": "go/image/index#Point",
        "syntax": "type Point struct { X, Y int }",
        "type": "image"
    },
    "image.Point.Add": {
        "descr": "Add returns the vector p+q.",
        "name": "image.Point.Add",
        "params": [],
        "path": "go/image/index#Point.Add",
        "syntax": "func (p Point) Add(q Point) Point",
        "type": "image"
    },
    "image.Point.Div": {
        "descr": "Div returns the vector p/k.",
        "name": "image.Point.Div",
        "params": [],
        "path": "go/image/index#Point.Div",
        "syntax": "func (p Point) Div(k int) Point",
        "type": "image"
    },
    "image.Point.Eq": {
        "descr": "Eq reports whether p and q are equal.",
        "name": "image.Point.Eq",
        "params": [],
        "path": "go/image/index#Point.Eq",
        "syntax": "func (p Point) Eq(q Point) bool",
        "type": "image"
    },
    "image.Point.In": {
        "descr": "In reports whether p is in r.",
        "name": "image.Point.In",
        "params": [],
        "path": "go/image/index#Point.In",
        "syntax": "func (p Point) In(r Rectangle) bool",
        "type": "image"
    },
    "image.Point.Mod": {
        "descr": "Mod returns the point q in r such that p.X-q.X is a multiple of r's width and p.Y-q.Y is a multiple of r's height.",
        "name": "image.Point.Mod",
        "params": [],
        "path": "go/image/index#Point.Mod",
        "syntax": "func (p Point) Mod(r Rectangle) Point",
        "type": "image"
    },
    "image.Point.Mul": {
        "descr": "Mul returns the vector p*k.",
        "name": "image.Point.Mul",
        "params": [],
        "path": "go/image/index#Point.Mul",
        "syntax": "func (p Point) Mul(k int) Point",
        "type": "image"
    },
    "image.Point.String": {
        "descr": "String returns a string representation of p like \"(3,4)\".",
        "name": "image.Point.String",
        "params": [],
        "path": "go/image/index#Point.String",
        "syntax": "func (p Point) String() string",
        "type": "image"
    },
    "image.Point.Sub": {
        "descr": "Sub returns the vector p-q.",
        "name": "image.Point.Sub",
        "params": [],
        "path": "go/image/index#Point.Sub",
        "syntax": "func (p Point) Sub(q Point) Point",
        "type": "image"
    },
    "image.Pt": {
        "descr": "Pt is shorthand for Point{X, Y}.",
        "name": "image.Pt",
        "params": [],
        "path": "go/image/index#Pt",
        "syntax": "func Pt(X, Y int) Point",
        "type": "image"
    },
    "image.RGBA": {
        "descr": "RGBA is an in-memory image whose At method returns color.RGBA values.",
        "name": "image.RGBA",
        "params": [],
        "path": "go/image/index#RGBA",
        "syntax": "type RGBA struct { // Pix holds the image's pixels, in R, G, B, A order. The pixel at // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4]. Pix []uint8 // Stride is the Pix stride (in bytes) between vertically adjacent pixels. Stride int // Rect is the image's bounds. Rect Rectangle }",
        "type": "image"
    },
    "image.RGBA.At": {
        "descr": "",
        "name": "image.RGBA.At",
        "params": [],
        "path": "go/image/index#RGBA.At",
        "syntax": "func (p *RGBA) At(x, y int) color.Color",
        "type": "image"
    },
    "image.RGBA.Bounds": {
        "descr": "",
        "name": "image.RGBA.Bounds",
        "params": [],
        "path": "go/image/index#RGBA.Bounds",
        "syntax": "func (p *RGBA) Bounds() Rectangle",
        "type": "image"
    },
    "image.RGBA.ColorModel": {
        "descr": "",
        "name": "image.RGBA.ColorModel",
        "params": [],
        "path": "go/image/index#RGBA.ColorModel",
        "syntax": "func (p *RGBA) ColorModel() color.Model",
        "type": "image"
    },
    "image.RGBA.Opaque": {
        "descr": "Opaque scans the entire image and reports whether it is fully opaque.",
        "name": "image.RGBA.Opaque",
        "params": [],
        "path": "go/image/index#RGBA.Opaque",
        "syntax": "func (p *RGBA) Opaque() bool",
        "type": "image"
    },
    "image.RGBA.PixOffset": {
        "descr": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y).",
        "name": "image.RGBA.PixOffset",
        "params": [],
        "path": "go/image/index#RGBA.PixOffset",
        "syntax": "func (p *RGBA) PixOffset(x, y int) int",
        "type": "image"
    },
    "image.RGBA.RGBAAt": {
        "descr": "",
        "name": "image.RGBA.RGBAAt",
        "params": [],
        "path": "go/image/index#RGBA.RGBAAt",
        "syntax": "func (p *RGBA) RGBAAt(x, y int) color.RGBA",
        "type": "image"
    },
    "image.RGBA.Set": {
        "descr": "",
        "name": "image.RGBA.Set",
        "params": [],
        "path": "go/image/index#RGBA.Set",
        "syntax": "func (p *RGBA) Set(x, y int, c color.Color)",
        "type": "image"
    },
    "image.RGBA.SetRGBA": {
        "descr": "",
        "name": "image.RGBA.SetRGBA",
        "params": [],
        "path": "go/image/index#RGBA.SetRGBA",
        "syntax": "func (p *RGBA) SetRGBA(x, y int, c color.RGBA)",
        "type": "image"
    },
    "image.RGBA.SubImage": {
        "descr": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.",
        "name": "image.RGBA.SubImage",
        "params": [],
        "path": "go/image/index#RGBA.SubImage",
        "syntax": "func (p *RGBA) SubImage(r Rectangle) Image",
        "type": "image"
    },
    "image.RGBA64": {
        "descr": "RGBA64 is an in-memory image whose At method returns color.RGBA64 values.",
        "name": "image.RGBA64",
        "params": [],
        "path": "go/image/index#RGBA64",
        "syntax": "type RGBA64 struct { // Pix holds the image's pixels, in R, G, B, A order and big-endian format. The pixel at // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*8]. Pix []uint8 // Stride is the Pix stride (in bytes) between vertically adjacent pixels. Stride int // Rect is the image's bounds. Rect Rectangle }",
        "type": "image"
    },
    "image.RGBA64.At": {
        "descr": "",
        "name": "image.RGBA64.At",
        "params": [],
        "path": "go/image/index#RGBA64.At",
        "syntax": "func (p *RGBA64) At(x, y int) color.Color",
        "type": "image"
    },
    "image.RGBA64.Bounds": {
        "descr": "",
        "name": "image.RGBA64.Bounds",
        "params": [],
        "path": "go/image/index#RGBA64.Bounds",
        "syntax": "func (p *RGBA64) Bounds() Rectangle",
        "type": "image"
    },
    "image.RGBA64.ColorModel": {
        "descr": "",
        "name": "image.RGBA64.ColorModel",
        "params": [],
        "path": "go/image/index#RGBA64.ColorModel",
        "syntax": "func (p *RGBA64) ColorModel() color.Model",
        "type": "image"
    },
    "image.RGBA64.Opaque": {
        "descr": "Opaque scans the entire image and reports whether it is fully opaque.",
        "name": "image.RGBA64.Opaque",
        "params": [],
        "path": "go/image/index#RGBA64.Opaque",
        "syntax": "func (p *RGBA64) Opaque() bool",
        "type": "image"
    },
    "image.RGBA64.PixOffset": {
        "descr": "PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y).",
        "name": "image.RGBA64.PixOffset",
        "params": [],
        "path": "go/image/index#RGBA64.PixOffset",
        "syntax": "func (p *RGBA64) PixOffset(x, y int) int",
        "type": "image"
    },
    "image.RGBA64.RGBA64At": {
        "descr": "",
        "name": "image.RGBA64.RGBA64At",
        "params": [],
        "path": "go/image/index#RGBA64.RGBA64At",
        "syntax": "func (p *RGBA64) RGBA64At(x, y int) color.RGBA64",
        "type": "image"
    },
    "image.RGBA64.Set": {
        "descr": "",
        "name": "image.RGBA64.Set",
        "params": [],
        "path": "go/image/index#RGBA64.Set",
        "syntax": "func (p *RGBA64) Set(x, y int, c color.Color)",
        "type": "image"
    },
    "image.RGBA64.SetRGBA64": {
        "descr": "",
        "name": "image.RGBA64.SetRGBA64",
        "params": [],
        "path": "go/image/index#RGBA64.SetRGBA64",
        "syntax": "func (p *RGBA64) SetRGBA64(x, y int, c color.RGBA64)",
        "type": "image"
    },
    "image.RGBA64.SubImage": {
        "descr": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.",
        "name": "image.RGBA64.SubImage",
        "params": [],
        "path": "go/image/index#RGBA64.SubImage",
        "syntax": "func (p *RGBA64) SubImage(r Rectangle) Image",
        "type": "image"
    },
    "image.Rect": {
        "descr": "Rect is shorthand for Rectangle{Pt(x0, y0), Pt(x1, y1)}. The returned rectangle has minimum and maximum coordinates swapped if necessary so that it is well-formed.",
        "name": "image.Rect",
        "params": [],
        "path": "go/image/index#Rect",
        "syntax": "func Rect(x0, y0, x1, y1 int) Rectangle",
        "type": "image"
    },
    "image.Rectangle": {
        "descr": "A Rectangle contains the points with Min.X <= X < Max.X, Min.Y <= Y < Max.Y. It is well-formed if Min.X <= Max.X and likewise for Y. Points are always well-formed. A rectangle's methods always return well-formed outputs for well-formed inputs.",
        "name": "image.Rectangle",
        "params": [],
        "path": "go/image/index#Rectangle",
        "syntax": "type Rectangle struct { Min, Max Point }",
        "type": "image"
    },
    "image.Rectangle.Add": {
        "descr": "Add returns the rectangle r translated by p.",
        "name": "image.Rectangle.Add",
        "params": [],
        "path": "go/image/index#Rectangle.Add",
        "syntax": "func (r Rectangle) Add(p Point) Rectangle",
        "type": "image"
    },
    "image.Rectangle.At": {
        "descr": "At implements the Image interface.",
        "name": "image.Rectangle.At",
        "params": [],
        "path": "go/image/index#Rectangle.At",
        "syntax": "func (r Rectangle) At(x, y int) color.Color",
        "type": "image"
    },
    "image.Rectangle.Bounds": {
        "descr": "Bounds implements the Image interface.",
        "name": "image.Rectangle.Bounds",
        "params": [],
        "path": "go/image/index#Rectangle.Bounds",
        "syntax": "func (r Rectangle) Bounds() Rectangle",
        "type": "image"
    },
    "image.Rectangle.Canon": {
        "descr": "Canon returns the canonical version of r. The returned rectangle has minimum and maximum coordinates swapped if necessary so that it is well-formed.",
        "name": "image.Rectangle.Canon",
        "params": [],
        "path": "go/image/index#Rectangle.Canon",
        "syntax": "func (r Rectangle) Canon() Rectangle",
        "type": "image"
    },
    "image.Rectangle.ColorModel": {
        "descr": "ColorModel implements the Image interface.",
        "name": "image.Rectangle.ColorModel",
        "params": [],
        "path": "go/image/index#Rectangle.ColorModel",
        "syntax": "func (r Rectangle) ColorModel() color.Model",
        "type": "image"
    },
    "image.Rectangle.Dx": {
        "descr": "Dx returns r's width.",
        "name": "image.Rectangle.Dx",
        "params": [],
        "path": "go/image/index#Rectangle.Dx",
        "syntax": "func (r Rectangle) Dx() int",
        "type": "image"
    },
    "image.Rectangle.Dy": {
        "descr": "Dy returns r's height.",
        "name": "image.Rectangle.Dy",
        "params": [],
        "path": "go/image/index#Rectangle.Dy",
        "syntax": "func (r Rectangle) Dy() int",
        "type": "image"
    },
    "image.Rectangle.Empty": {
        "descr": "Empty reports whether the rectangle contains no points.",
        "name": "image.Rectangle.Empty",
        "params": [],
        "path": "go/image/index#Rectangle.Empty",
        "syntax": "func (r Rectangle) Empty() bool",
        "type": "image"
    },
    "image.Rectangle.Eq": {
        "descr": "Eq reports whether r and s contain the same set of points. All empty rectangles are considered equal.",
        "name": "image.Rectangle.Eq",
        "params": [],
        "path": "go/image/index#Rectangle.Eq",
        "syntax": "func (r Rectangle) Eq(s Rectangle) bool",
        "type": "image"
    },
    "image.Rectangle.In": {
        "descr": "In reports whether every point in r is in s.",
        "name": "image.Rectangle.In",
        "params": [],
        "path": "go/image/index#Rectangle.In",
        "syntax": "func (r Rectangle) In(s Rectangle) bool",
        "type": "image"
    },
    "image.Rectangle.Inset": {
        "descr": "Inset returns the rectangle r inset by n, which may be negative. If either of r's dimensions is less than 2*n then an empty rectangle near the center of r will be returned.",
        "name": "image.Rectangle.Inset",
        "params": [],
        "path": "go/image/index#Rectangle.Inset",
        "syntax": "func (r Rectangle) Inset(n int) Rectangle",
        "type": "image"
    },
    "image.Rectangle.Intersect": {
        "descr": "Intersect returns the largest rectangle contained by both r and s. If the two rectangles do not overlap then the zero rectangle will be returned.",
        "name": "image.Rectangle.Intersect",
        "params": [],
        "path": "go/image/index#Rectangle.Intersect",
        "syntax": "func (r Rectangle) Intersect(s Rectangle) Rectangle",
        "type": "image"
    },
    "image.Rectangle.Overlaps": {
        "descr": "Overlaps reports whether r and s have a non-empty intersection.",
        "name": "image.Rectangle.Overlaps",
        "params": [],
        "path": "go/image/index#Rectangle.Overlaps",
        "syntax": "func (r Rectangle) Overlaps(s Rectangle) bool",
        "type": "image"
    },
    "image.Rectangle.Size": {
        "descr": "Size returns r's width and height.",
        "name": "image.Rectangle.Size",
        "params": [],
        "path": "go/image/index#Rectangle.Size",
        "syntax": "func (r Rectangle) Size() Point",
        "type": "image"
    },
    "image.Rectangle.String": {
        "descr": "String returns a string representation of r like \"(3,4)-(6,5)\".",
        "name": "image.Rectangle.String",
        "params": [],
        "path": "go/image/index#Rectangle.String",
        "syntax": "func (r Rectangle) String() string",
        "type": "image"
    },
    "image.Rectangle.Sub": {
        "descr": "Sub returns the rectangle r translated by -p.",
        "name": "image.Rectangle.Sub",
        "params": [],
        "path": "go/image/index#Rectangle.Sub",
        "syntax": "func (r Rectangle) Sub(p Point) Rectangle",
        "type": "image"
    },
    "image.Rectangle.Union": {
        "descr": "Union returns the smallest rectangle that contains both r and s.",
        "name": "image.Rectangle.Union",
        "params": [],
        "path": "go/image/index#Rectangle.Union",
        "syntax": "func (r Rectangle) Union(s Rectangle) Rectangle",
        "type": "image"
    },
    "image.RegisterFormat": {
        "descr": "RegisterFormat registers an image format for use by Decode. Name is the name of the format, like \"jpeg\" or \"png\". Magic is the magic prefix that identifies the format's encoding. The magic string can contain \"?\" wildcards that each match any one byte. Decode is the function that decodes the encoded image. DecodeConfig is the function that decodes just its configuration.",
        "name": "image.RegisterFormat",
        "params": [],
        "path": "go/image/index#RegisterFormat",
        "syntax": "func RegisterFormat(name, magic string, decode func(io.Reader) (Image, error), decodeConfig func(io.Reader) (Config, error))",
        "type": "image"
    },
    "image.Uniform": {
        "descr": "Uniform is an infinite-sized Image of uniform color. It implements the color.Color, color.Model, and Image interfaces.",
        "name": "image.Uniform",
        "params": [],
        "path": "go/image/index#Uniform",
        "syntax": "type Uniform struct { C color.Color }",
        "type": "image"
    },
    "image.Uniform.At": {
        "descr": "",
        "name": "image.Uniform.At",
        "params": [],
        "path": "go/image/index#Uniform.At",
        "syntax": "func (c *Uniform) At(x, y int) color.Color",
        "type": "image"
    },
    "image.Uniform.Bounds": {
        "descr": "",
        "name": "image.Uniform.Bounds",
        "params": [],
        "path": "go/image/index#Uniform.Bounds",
        "syntax": "func (c *Uniform) Bounds() Rectangle",
        "type": "image"
    },
    "image.Uniform.ColorModel": {
        "descr": "",
        "name": "image.Uniform.ColorModel",
        "params": [],
        "path": "go/image/index#Uniform.ColorModel",
        "syntax": "func (c *Uniform) ColorModel() color.Model",
        "type": "image"
    },
    "image.Uniform.Convert": {
        "descr": "",
        "name": "image.Uniform.Convert",
        "params": [],
        "path": "go/image/index#Uniform.Convert",
        "syntax": "func (c *Uniform) Convert(color.Color) color.Color",
        "type": "image"
    },
    "image.Uniform.Opaque": {
        "descr": "Opaque scans the entire image and reports whether it is fully opaque.",
        "name": "image.Uniform.Opaque",
        "params": [],
        "path": "go/image/index#Uniform.Opaque",
        "syntax": "func (c *Uniform) Opaque() bool",
        "type": "image"
    },
    "image.Uniform.RGBA": {
        "descr": "",
        "name": "image.Uniform.RGBA",
        "params": [],
        "path": "go/image/index#Uniform.RGBA",
        "syntax": "func (c *Uniform) RGBA() (r, g, b, a uint32)",
        "type": "image"
    },
    "image.YCbCr": {
        "descr": "YCbCr is an in-memory image of Y'CbCr colors. There is one Y sample per pixel, but each Cb and Cr sample can span one or more pixels. YStride is the Y slice index delta between vertically adjacent pixels. CStride is the Cb and Cr slice index delta between vertically adjacent pixels that map to separate chroma samples. It is not an absolute requirement, but YStride and len(Y) are typically multiples of 8, and:",
        "name": "image.YCbCr",
        "params": [],
        "path": "go/image/index#YCbCr",
        "syntax": "For 4:4:4, CStride == YStride/1 && len(Cb) == len(Cr) == len(Y)/1. For 4:2:2, CStride == YStride/2 && len(Cb) == len(Cr) == len(Y)/2. For 4:2:0, CStride == YStride/2 && len(Cb) == len(Cr) == len(Y)/4. For 4:4:0, CStride == YStride/1 && len(Cb) == len(Cr) == len(Y)/2. For 4:1:1, CStride == YStride/4 && len(Cb) == len(Cr) == len(Y)/4. For 4:1:0, CStride == YStride/4 && len(Cb) == len(Cr) == len(Y)/8.",
        "type": "image"
    },
    "image.YCbCr.At": {
        "descr": "",
        "name": "image.YCbCr.At",
        "params": [],
        "path": "go/image/index#YCbCr.At",
        "syntax": "func (p *YCbCr) At(x, y int) color.Color",
        "type": "image"
    },
    "image.YCbCr.Bounds": {
        "descr": "",
        "name": "image.YCbCr.Bounds",
        "params": [],
        "path": "go/image/index#YCbCr.Bounds",
        "syntax": "func (p *YCbCr) Bounds() Rectangle",
        "type": "image"
    },
    "image.YCbCr.COffset": {
        "descr": "COffset returns the index of the first element of Cb or Cr that corresponds to the pixel at (x, y).",
        "name": "image.YCbCr.COffset",
        "params": [],
        "path": "go/image/index#YCbCr.COffset",
        "syntax": "func (p *YCbCr) COffset(x, y int) int",
        "type": "image"
    },
    "image.YCbCr.ColorModel": {
        "descr": "",
        "name": "image.YCbCr.ColorModel",
        "params": [],
        "path": "go/image/index#YCbCr.ColorModel",
        "syntax": "func (p *YCbCr) ColorModel() color.Model",
        "type": "image"
    },
    "image.YCbCr.Opaque": {
        "descr": "",
        "name": "image.YCbCr.Opaque",
        "params": [],
        "path": "go/image/index#YCbCr.Opaque",
        "syntax": "func (p *YCbCr) Opaque() bool",
        "type": "image"
    },
    "image.YCbCr.SubImage": {
        "descr": "SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image.",
        "name": "image.YCbCr.SubImage",
        "params": [],
        "path": "go/image/index#YCbCr.SubImage",
        "syntax": "func (p *YCbCr) SubImage(r Rectangle) Image",
        "type": "image"
    },
    "image.YCbCr.YCbCrAt": {
        "descr": "",
        "name": "image.YCbCr.YCbCrAt",
        "params": [],
        "path": "go/image/index#YCbCr.YCbCrAt",
        "syntax": "func (p *YCbCr) YCbCrAt(x, y int) color.YCbCr",
        "type": "image"
    },
    "image.YCbCr.YOffset": {
        "descr": "YOffset returns the index of the first element of Y that corresponds to the pixel at (x, y).",
        "name": "image.YCbCr.YOffset",
        "params": [],
        "path": "go/image/index#YCbCr.YOffset",
        "syntax": "func (p *YCbCr) YOffset(x, y int) int",
        "type": "image"
    },
    "image.YCbCrSubsampleRatio": {
        "descr": "YCbCrSubsampleRatio is the chroma subsample ratio used in a YCbCr image.",
        "name": "image.YCbCrSubsampleRatio",
        "params": [],
        "path": "go/image/index#YCbCrSubsampleRatio",
        "syntax": "type YCbCrSubsampleRatio int",
        "type": "image"
    },
    "image.YCbCrSubsampleRatio.String": {
        "descr": "",
        "name": "image.YCbCrSubsampleRatio.String",
        "params": [],
        "path": "go/image/index#YCbCrSubsampleRatio.String",
        "syntax": "func (s YCbCrSubsampleRatio) String() string",
        "type": "image"
    },
    "importer.Default": {
        "descr": "Default returns an Importer for the compiler that built the running binary. If available, the result implements types.ImporterFrom.",
        "name": "importer.Default",
        "params": [],
        "path": "go/go/importer/index#Default",
        "syntax": "func Default() types.Importer",
        "type": "go"
    },
    "importer.For": {
        "descr": "For returns an Importer for importing from installed packages for the compilers \"gc\" and \"gccgo\", or for importing directly from the source if the compiler argument is \"source\". In this latter case, importing may fail under circumstances where the exported API is not entirely defined in pure Go source code (if the package API depends on cgo-defined entities, the type checker won't have access to those).",
        "name": "importer.For",
        "params": [],
        "path": "go/go/importer/index#For",
        "syntax": "func For(compiler string, lookup Lookup) types.Importer",
        "type": "go"
    },
    "importer.Lookup": {
        "descr": "A Lookup function returns a reader to access package data for a given import path, or an error if no matching package is found.",
        "name": "importer.Lookup",
        "params": [],
        "path": "go/go/importer/index#Lookup",
        "syntax": "type Lookup func(path string) (io.ReadCloser, error)",
        "type": "go"
    },
    "int": {
        "descr": "int is a signed integer type that is at least 32 bits in size. It is a distinct type, however, and not an alias for, say, int32.",
        "name": "builtin.int",
        "params": [],
        "path": "go/builtin/index#int",
        "syntax": "type int int",
        "type": "builtin"
    },
    "int16": {
        "descr": "int16 is the set of all signed 16-bit integers. Range: -32768 through 32767.",
        "name": "builtin.int16",
        "params": [],
        "path": "go/builtin/index#int16",
        "syntax": "type int16 int16",
        "type": "builtin"
    },
    "int32": {
        "descr": "int32 is the set of all signed 32-bit integers. Range: -2147483648 through 2147483647.",
        "name": "builtin.int32",
        "params": [],
        "path": "go/builtin/index#int32",
        "syntax": "type int32 int32",
        "type": "builtin"
    },
    "int64": {
        "descr": "int64 is the set of all signed 64-bit integers. Range: -9223372036854775808 through 9223372036854775807.",
        "name": "builtin.int64",
        "params": [],
        "path": "go/builtin/index#int64",
        "syntax": "type int64 int64",
        "type": "builtin"
    },
    "int8": {
        "descr": "int8 is the set of all signed 8-bit integers. Range: -128 through 127.",
        "name": "builtin.int8",
        "params": [],
        "path": "go/builtin/index#int8",
        "syntax": "type int8 int8",
        "type": "builtin"
    },
    "internal.FlushAfterChunkWriter": {
        "descr": "FlushAfterChunkWriter signals from the caller of NewChunkedWriter that each chunk should be followed by a flush. It is used by the http.Transport code to keep the buffering behavior for headers and trailers, but flush out chunks aggressively in the middle for request bodies which may be generated slowly. See Issue 6574.",
        "name": "internal.FlushAfterChunkWriter",
        "params": [],
        "path": "go/net/http/internal/index#FlushAfterChunkWriter",
        "syntax": "type FlushAfterChunkWriter struct { *bufio.Writer }",
        "type": "net/http"
    },
    "internal.NewChunkedReader": {
        "descr": "NewChunkedReader returns a new chunkedReader that translates the data read from r out of HTTP \"chunked\" format before returning it. The chunkedReader returns io.EOF when the final 0-length chunk is read.",
        "name": "internal.NewChunkedReader",
        "params": [],
        "path": "go/net/http/internal/index#NewChunkedReader",
        "syntax": "func NewChunkedReader(r io.Reader) io.Reader",
        "type": "net/http"
    },
    "internal.NewChunkedWriter": {
        "descr": "NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP \"chunked\" format before writing them to w. Closing the returned chunkedWriter sends the final 0-length chunk that marks the end of the stream but does not send the final CRLF that appears after trailers; trailers and the last CRLF must be written separately.",
        "name": "internal.NewChunkedWriter",
        "params": [],
        "path": "go/net/http/internal/index#NewChunkedWriter",
        "syntax": "func NewChunkedWriter(w io.Writer) io.WriteCloser",
        "type": "net/http"
    },
    "io": {
        "descr": "EOF is the error returned by Read when no more input is available. Functions should return EOF only to signal a graceful end of input. If the EOF occurs unexpectedly in a structured data stream, the appropriate error is either ErrUnexpectedEOF or some other error giving more detail.",
        "name": "io",
        "params": [],
        "path": "go/io/index#pkg-variables",
        "syntax": "var EOF = errors.New(\"EOF\")",
        "type": "io"
    },
    "io.ByteReader": {
        "descr": "ByteReader is the interface that wraps the ReadByte method.",
        "name": "io.ByteReader",
        "params": [],
        "path": "go/io/index#ByteReader",
        "syntax": "type ByteReader interface { ReadByte() (byte, error) }",
        "type": "io"
    },
    "io.ByteScanner": {
        "descr": "ByteScanner is the interface that adds the UnreadByte method to the basic ReadByte method.",
        "name": "io.ByteScanner",
        "params": [],
        "path": "go/io/index#ByteScanner",
        "syntax": "type ByteScanner interface { ByteReader UnreadByte() error }",
        "type": "io"
    },
    "io.ByteWriter": {
        "descr": "ByteWriter is the interface that wraps the WriteByte method.",
        "name": "io.ByteWriter",
        "params": [],
        "path": "go/io/index#ByteWriter",
        "syntax": "type ByteWriter interface { WriteByte(c byte) error }",
        "type": "io"
    },
    "io.Closer": {
        "descr": "Closer is the interface that wraps the basic Close method.",
        "name": "io.Closer",
        "params": [],
        "path": "go/io/index#Closer",
        "syntax": "type Closer interface { Close() error }",
        "type": "io"
    },
    "io.Copy": {
        "descr": "Copy copies from src to dst until either EOF is reached on src or an error occurs. It returns the number of bytes copied and the first error encountered while copying, if any.",
        "name": "io.Copy",
        "params": [],
        "path": "go/io/index#Copy",
        "syntax": "func Copy(dst Writer, src Reader) (written int64, err error)",
        "type": "io"
    },
    "io.CopyBuffer": {
        "descr": "CopyBuffer is identical to Copy except that it stages through the provided buffer (if one is required) rather than allocating a temporary one. If buf is nil, one is allocated; otherwise if it has zero length, CopyBuffer panics.",
        "name": "io.CopyBuffer",
        "params": [],
        "path": "go/io/index#CopyBuffer",
        "syntax": "func CopyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error)",
        "type": "io"
    },
    "io.CopyN": {
        "descr": "CopyN copies n bytes (or until an error) from src to dst. It returns the number of bytes copied and the earliest error encountered while copying. On return, written == n if and only if err == nil.",
        "name": "io.CopyN",
        "params": [],
        "path": "go/io/index#CopyN",
        "syntax": "func CopyN(dst Writer, src Reader, n int64) (written int64, err error)",
        "type": "io"
    },
    "io.LimitReader": {
        "descr": "LimitReader returns a Reader that reads from r but stops with EOF after n bytes. The underlying implementation is a *LimitedReader.",
        "name": "io.LimitReader",
        "params": [],
        "path": "go/io/index#LimitReader",
        "syntax": "func LimitReader(r Reader, n int64) Reader",
        "type": "io"
    },
    "io.LimitedReader": {
        "descr": "A LimitedReader reads from R but limits the amount of data returned to just N bytes. Each call to Read updates N to reflect the new amount remaining. Read returns EOF when N <= 0 or when the underlying R returns EOF.",
        "name": "io.LimitedReader",
        "params": [],
        "path": "go/io/index#LimitedReader",
        "syntax": "type LimitedReader struct { R Reader // underlying reader N int64 // max bytes remaining }",
        "type": "io"
    },
    "io.LimitedReader.Read": {
        "descr": "",
        "name": "io.LimitedReader.Read",
        "params": [],
        "path": "go/io/index#LimitedReader.Read",
        "syntax": "func (l *LimitedReader) Read(p []byte) (n int, err error)",
        "type": "io"
    },
    "io.MultiReader": {
        "descr": "MultiReader returns a Reader that's the logical concatenation of the provided input readers. They're read sequentially. Once all inputs have returned EOF, Read will return EOF. If any of the readers return a non-nil, non-EOF error, Read will return that error.",
        "name": "io.MultiReader",
        "params": [],
        "path": "go/io/index#MultiReader",
        "syntax": "func MultiReader(readers ...Reader) Reader",
        "type": "io"
    },
    "io.MultiWriter": {
        "descr": "MultiWriter creates a writer that duplicates its writes to all the provided writers, similar to the Unix tee(1) command.",
        "name": "io.MultiWriter",
        "params": [],
        "path": "go/io/index#MultiWriter",
        "syntax": "func MultiWriter(writers ...Writer) Writer",
        "type": "io"
    },
    "io.NewSectionReader": {
        "descr": "NewSectionReader returns a SectionReader that reads from r starting at offset off and stops with EOF after n bytes.",
        "name": "io.NewSectionReader",
        "params": [],
        "path": "go/io/index#NewSectionReader",
        "syntax": "func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader",
        "type": "io"
    },
    "io.Pipe": {
        "descr": "Pipe creates a synchronous in-memory pipe. It can be used to connect code expecting an io.Reader with code expecting an io.Writer.",
        "name": "io.Pipe",
        "params": [],
        "path": "go/io/index#Pipe",
        "syntax": "func Pipe() (*PipeReader, *PipeWriter)",
        "type": "io"
    },
    "io.PipeReader": {
        "descr": "A PipeReader is the read half of a pipe.",
        "name": "io.PipeReader",
        "params": [],
        "path": "go/io/index#PipeReader",
        "syntax": "type PipeReader struct { // contains filtered or unexported fields }",
        "type": "io"
    },
    "io.PipeReader.Close": {
        "descr": "Close closes the reader; subsequent writes to the write half of the pipe will return the error ErrClosedPipe.",
        "name": "io.PipeReader.Close",
        "params": [],
        "path": "go/io/index#PipeReader.Close",
        "syntax": "func (r *PipeReader) Close() error",
        "type": "io"
    },
    "io.PipeReader.CloseWithError": {
        "descr": "CloseWithError closes the reader; subsequent writes to the write half of the pipe will return the error err.",
        "name": "io.PipeReader.CloseWithError",
        "params": [],
        "path": "go/io/index#PipeReader.CloseWithError",
        "syntax": "func (r *PipeReader) CloseWithError(err error) error",
        "type": "io"
    },
    "io.PipeReader.Read": {
        "descr": "Read implements the standard Read interface: it reads data from the pipe, blocking until a writer arrives or the write end is closed. If the write end is closed with an error, that error is returned as err; otherwise err is EOF.",
        "name": "io.PipeReader.Read",
        "params": [],
        "path": "go/io/index#PipeReader.Read",
        "syntax": "func (r *PipeReader) Read(data []byte) (n int, err error)",
        "type": "io"
    },
    "io.PipeWriter": {
        "descr": "A PipeWriter is the write half of a pipe.",
        "name": "io.PipeWriter",
        "params": [],
        "path": "go/io/index#PipeWriter",
        "syntax": "type PipeWriter struct { // contains filtered or unexported fields }",
        "type": "io"
    },
    "io.PipeWriter.Close": {
        "descr": "Close closes the writer; subsequent reads from the read half of the pipe will return no bytes and EOF.",
        "name": "io.PipeWriter.Close",
        "params": [],
        "path": "go/io/index#PipeWriter.Close",
        "syntax": "func (w *PipeWriter) Close() error",
        "type": "io"
    },
    "io.PipeWriter.CloseWithError": {
        "descr": "CloseWithError closes the writer; subsequent reads from the read half of the pipe will return no bytes and the error err, or EOF if err is nil.",
        "name": "io.PipeWriter.CloseWithError",
        "params": [],
        "path": "go/io/index#PipeWriter.CloseWithError",
        "syntax": "func (w *PipeWriter) CloseWithError(err error) error",
        "type": "io"
    },
    "io.PipeWriter.Write": {
        "descr": "Write implements the standard Write interface: it writes data to the pipe, blocking until one or more readers have consumed all the data or the read end is closed. If the read end is closed with an error, that err is returned as err; otherwise err is ErrClosedPipe.",
        "name": "io.PipeWriter.Write",
        "params": [],
        "path": "go/io/index#PipeWriter.Write",
        "syntax": "func (w *PipeWriter) Write(data []byte) (n int, err error)",
        "type": "io"
    },
    "io.ReadAtLeast": {
        "descr": "ReadAtLeast reads from r into buf until it has read at least min bytes. It returns the number of bytes copied and an error if fewer bytes were read. The error is EOF only if no bytes were read. If an EOF happens after reading fewer than min bytes, ReadAtLeast returns ErrUnexpectedEOF. If min is greater than the length of buf, ReadAtLeast returns ErrShortBuffer. On return, n >= min if and only if err == nil. If r returns an error having read at least min bytes, the error is dropped.",
        "name": "io.ReadAtLeast",
        "params": [],
        "path": "go/io/index#ReadAtLeast",
        "syntax": "func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)",
        "type": "io"
    },
    "io.ReadCloser": {
        "descr": "ReadCloser is the interface that groups the basic Read and Close methods.",
        "name": "io.ReadCloser",
        "params": [],
        "path": "go/io/index#ReadCloser",
        "syntax": "type ReadCloser interface { Reader Closer }",
        "type": "io"
    },
    "io.ReadFull": {
        "descr": "ReadFull reads exactly len(buf) bytes from r into buf. It returns the number of bytes copied and an error if fewer bytes were read. The error is EOF only if no bytes were read. If an EOF happens after reading some but not all the bytes, ReadFull returns ErrUnexpectedEOF. On return, n == len(buf) if and only if err == nil. If r returns an error having read at least len(buf) bytes, the error is dropped.",
        "name": "io.ReadFull",
        "params": [],
        "path": "go/io/index#ReadFull",
        "syntax": "func ReadFull(r Reader, buf []byte) (n int, err error)",
        "type": "io"
    },
    "io.ReadSeeker": {
        "descr": "ReadSeeker is the interface that groups the basic Read and Seek methods.",
        "name": "io.ReadSeeker",
        "params": [],
        "path": "go/io/index#ReadSeeker",
        "syntax": "type ReadSeeker interface { Reader Seeker }",
        "type": "io"
    },
    "io.ReadWriteCloser": {
        "descr": "ReadWriteCloser is the interface that groups the basic Read, Write and Close methods.",
        "name": "io.ReadWriteCloser",
        "params": [],
        "path": "go/io/index#ReadWriteCloser",
        "syntax": "type ReadWriteCloser interface { Reader Writer Closer }",
        "type": "io"
    },
    "io.ReadWriteSeeker": {
        "descr": "ReadWriteSeeker is the interface that groups the basic Read, Write and Seek methods.",
        "name": "io.ReadWriteSeeker",
        "params": [],
        "path": "go/io/index#ReadWriteSeeker",
        "syntax": "type ReadWriteSeeker interface { Reader Writer Seeker }",
        "type": "io"
    },
    "io.ReadWriter": {
        "descr": "ReadWriter is the interface that groups the basic Read and Write methods.",
        "name": "io.ReadWriter",
        "params": [],
        "path": "go/io/index#ReadWriter",
        "syntax": "type ReadWriter interface { Reader Writer }",
        "type": "io"
    },
    "io.Reader": {
        "descr": "Reader is the interface that wraps the basic Read method.",
        "name": "io.Reader",
        "params": [],
        "path": "go/io/index#Reader",
        "syntax": "type Reader interface { Read(p []byte) (n int, err error) }",
        "type": "io"
    },
    "io.ReaderAt": {
        "descr": "ReaderAt is the interface that wraps the basic ReadAt method.",
        "name": "io.ReaderAt",
        "params": [],
        "path": "go/io/index#ReaderAt",
        "syntax": "type ReaderAt interface { ReadAt(p []byte, off int64) (n int, err error) }",
        "type": "io"
    },
    "io.ReaderFrom": {
        "descr": "ReaderFrom is the interface that wraps the ReadFrom method.",
        "name": "io.ReaderFrom",
        "params": [],
        "path": "go/io/index#ReaderFrom",
        "syntax": "type ReaderFrom interface { ReadFrom(r Reader) (n int64, err error) }",
        "type": "io"
    },
    "io.RuneReader": {
        "descr": "RuneReader is the interface that wraps the ReadRune method.",
        "name": "io.RuneReader",
        "params": [],
        "path": "go/io/index#RuneReader",
        "syntax": "type RuneReader interface { ReadRune() (r rune, size int, err error) }",
        "type": "io"
    },
    "io.RuneScanner": {
        "descr": "RuneScanner is the interface that adds the UnreadRune method to the basic ReadRune method.",
        "name": "io.RuneScanner",
        "params": [],
        "path": "go/io/index#RuneScanner",
        "syntax": "type RuneScanner interface { RuneReader UnreadRune() error }",
        "type": "io"
    },
    "io.SectionReader": {
        "descr": "SectionReader implements Read, Seek, and ReadAt on a section of an underlying ReaderAt.",
        "name": "io.SectionReader",
        "params": [],
        "path": "go/io/index#SectionReader",
        "syntax": "type SectionReader struct { // contains filtered or unexported fields }",
        "type": "io"
    },
    "io.SectionReader.Read": {
        "descr": "",
        "name": "io.SectionReader.Read",
        "params": [],
        "path": "go/io/index#SectionReader.Read",
        "syntax": "func (s *SectionReader) Read(p []byte) (n int, err error)",
        "type": "io"
    },
    "io.SectionReader.ReadAt": {
        "descr": "",
        "name": "io.SectionReader.ReadAt",
        "params": [],
        "path": "go/io/index#SectionReader.ReadAt",
        "syntax": "func (s *SectionReader) ReadAt(p []byte, off int64) (n int, err error)",
        "type": "io"
    },
    "io.SectionReader.Seek": {
        "descr": "",
        "name": "io.SectionReader.Seek",
        "params": [],
        "path": "go/io/index#SectionReader.Seek",
        "syntax": "func (s *SectionReader) Seek(offset int64, whence int) (int64, error)",
        "type": "io"
    },
    "io.SectionReader.Size": {
        "descr": "Size returns the size of the section in bytes.",
        "name": "io.SectionReader.Size",
        "params": [],
        "path": "go/io/index#SectionReader.Size",
        "syntax": "func (s *SectionReader) Size() int64",
        "type": "io"
    },
    "io.Seeker": {
        "descr": "Seeker is the interface that wraps the basic Seek method.",
        "name": "io.Seeker",
        "params": [],
        "path": "go/io/index#Seeker",
        "syntax": "type Seeker interface { Seek(offset int64, whence int) (int64, error) }",
        "type": "io"
    },
    "io.TeeReader": {
        "descr": "TeeReader returns a Reader that writes to w what it reads from r. All reads from r performed through it are matched with corresponding writes to w. There is no internal buffering - the write must complete before the read completes. Any error encountered while writing is reported as a read error.",
        "name": "io.TeeReader",
        "params": [],
        "path": "go/io/index#TeeReader",
        "syntax": "func TeeReader(r Reader, w Writer) Reader",
        "type": "io"
    },
    "io.WriteCloser": {
        "descr": "WriteCloser is the interface that groups the basic Write and Close methods.",
        "name": "io.WriteCloser",
        "params": [],
        "path": "go/io/index#WriteCloser",
        "syntax": "type WriteCloser interface { Writer Closer }",
        "type": "io"
    },
    "io.WriteSeeker": {
        "descr": "WriteSeeker is the interface that groups the basic Write and Seek methods.",
        "name": "io.WriteSeeker",
        "params": [],
        "path": "go/io/index#WriteSeeker",
        "syntax": "type WriteSeeker interface { Writer Seeker }",
        "type": "io"
    },
    "io.WriteString": {
        "descr": "WriteString writes the contents of the string s to w, which accepts a slice of bytes. If w implements a WriteString method, it is invoked directly. Otherwise, w.Write is called exactly once.",
        "name": "io.WriteString",
        "params": [],
        "path": "go/io/index#WriteString",
        "syntax": "func WriteString(w Writer, s string) (n int, err error)",
        "type": "io"
    },
    "io.Writer": {
        "descr": "Writer is the interface that wraps the basic Write method.",
        "name": "io.Writer",
        "params": [],
        "path": "go/io/index#Writer",
        "syntax": "type Writer interface { Write(p []byte) (n int, err error) }",
        "type": "io"
    },
    "io.WriterAt": {
        "descr": "WriterAt is the interface that wraps the basic WriteAt method.",
        "name": "io.WriterAt",
        "params": [],
        "path": "go/io/index#WriterAt",
        "syntax": "type WriterAt interface { WriteAt(p []byte, off int64) (n int, err error) }",
        "type": "io"
    },
    "io.WriterTo": {
        "descr": "WriterTo is the interface that wraps the WriteTo method.",
        "name": "io.WriterTo",
        "params": [],
        "path": "go/io/index#WriterTo",
        "syntax": "type WriterTo interface { WriteTo(w Writer) (n int64, err error) }",
        "type": "io"
    },
    "iotest.DataErrReader": {
        "descr": "DataErrReader changes the way errors are handled by a Reader. Normally, a Reader returns an error (typically EOF) from the first Read call after the last piece of data is read. DataErrReader wraps a Reader and changes its behavior so the final error is returned along with the final data, instead of in the first call after the final data.",
        "name": "iotest.DataErrReader",
        "params": [],
        "path": "go/testing/iotest/index#DataErrReader",
        "syntax": "func DataErrReader(r io.Reader) io.Reader",
        "type": "testing"
    },
    "iotest.HalfReader": {
        "descr": "HalfReader returns a Reader that implements Read by reading half as many requested bytes from r.",
        "name": "iotest.HalfReader",
        "params": [],
        "path": "go/testing/iotest/index#HalfReader",
        "syntax": "func HalfReader(r io.Reader) io.Reader",
        "type": "testing"
    },
    "iotest.NewReadLogger": {
        "descr": "NewReadLogger returns a reader that behaves like r except that it logs (using log.Printf) each read to standard error, printing the prefix and the hexadecimal data read.",
        "name": "iotest.NewReadLogger",
        "params": [],
        "path": "go/testing/iotest/index#NewReadLogger",
        "syntax": "func NewReadLogger(prefix string, r io.Reader) io.Reader",
        "type": "testing"
    },
    "iotest.NewWriteLogger": {
        "descr": "NewWriteLogger returns a writer that behaves like w except that it logs (using log.Printf) each write to standard error, printing the prefix and the hexadecimal data written.",
        "name": "iotest.NewWriteLogger",
        "params": [],
        "path": "go/testing/iotest/index#NewWriteLogger",
        "syntax": "func NewWriteLogger(prefix string, w io.Writer) io.Writer",
        "type": "testing"
    },
    "iotest.OneByteReader": {
        "descr": "OneByteReader returns a Reader that implements each non-empty Read by reading one byte from r.",
        "name": "iotest.OneByteReader",
        "params": [],
        "path": "go/testing/iotest/index#OneByteReader",
        "syntax": "func OneByteReader(r io.Reader) io.Reader",
        "type": "testing"
    },
    "iotest.TimeoutReader": {
        "descr": "TimeoutReader returns ErrTimeout on the second read with no data. Subsequent calls to read succeed.",
        "name": "iotest.TimeoutReader",
        "params": [],
        "path": "go/testing/iotest/index#TimeoutReader",
        "syntax": "func TimeoutReader(r io.Reader) io.Reader",
        "type": "testing"
    },
    "iotest.TruncateWriter": {
        "descr": "TruncateWriter returns a Writer that writes to w but stops silently after n bytes.",
        "name": "iotest.TruncateWriter",
        "params": [],
        "path": "go/testing/iotest/index#TruncateWriter",
        "syntax": "func TruncateWriter(w io.Writer, n int64) io.Writer",
        "type": "testing"
    },
    "ioutil.NopCloser": {
        "descr": "NopCloser returns a ReadCloser with a no-op Close method wrapping the provided Reader r.",
        "name": "ioutil.NopCloser",
        "params": [],
        "path": "go/io/ioutil/index#NopCloser",
        "syntax": "func NopCloser(r io.Reader) io.ReadCloser",
        "type": "io"
    },
    "ioutil.ReadAll": {
        "descr": "ReadAll reads from r until an error or EOF and returns the data it read. A successful call returns err == nil, not err == EOF. Because ReadAll is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported.",
        "name": "ioutil.ReadAll",
        "params": [],
        "path": "go/io/ioutil/index#ReadAll",
        "syntax": "func ReadAll(r io.Reader) ([]byte, error)",
        "type": "io"
    },
    "ioutil.ReadDir": {
        "descr": "ReadDir reads the directory named by dirname and returns a list of directory entries sorted by filename.",
        "name": "ioutil.ReadDir",
        "params": [],
        "path": "go/io/ioutil/index#ReadDir",
        "syntax": "func ReadDir(dirname string) ([]os.FileInfo, error)",
        "type": "io"
    },
    "ioutil.ReadFile": {
        "descr": "ReadFile reads the file named by filename and returns the contents. A successful call returns err == nil, not err == EOF. Because ReadFile reads the whole file, it does not treat an EOF from Read as an error to be reported.",
        "name": "ioutil.ReadFile",
        "params": [],
        "path": "go/io/ioutil/index#ReadFile",
        "syntax": "func ReadFile(filename string) ([]byte, error)",
        "type": "io"
    },
    "ioutil.TempDir": {
        "descr": "TempDir creates a new temporary directory in the directory dir with a name beginning with prefix and returns the path of the new directory. If dir is the empty string, TempDir uses the default directory for temporary files (see os.TempDir). Multiple programs calling TempDir simultaneously will not choose the same directory. It is the caller's responsibility to remove the directory when no longer needed.",
        "name": "ioutil.TempDir",
        "params": [],
        "path": "go/io/ioutil/index#TempDir",
        "syntax": "func TempDir(dir, prefix string) (name string, err error)",
        "type": "io"
    },
    "ioutil.TempFile": {
        "descr": "TempFile creates a new temporary file in the directory dir, opens the file for reading and writing, and returns the resulting *os.File. The filename is generated by taking pattern and adding a random string to the end. If pattern includes a \"*\", the random string replaces the last \"*\". If dir is the empty string, TempFile uses the default directory for temporary files (see os.TempDir). Multiple programs calling TempFile simultaneously will not choose the same file. The caller can use f.Name() to find the pathname of the file. It is the caller's responsibility to remove the file when no longer needed.",
        "name": "ioutil.TempFile",
        "params": [],
        "path": "go/io/ioutil/index#TempFile",
        "syntax": "func TempFile(dir, pattern string) (f *os.File, err error)",
        "type": "io"
    },
    "ioutil.WriteFile": {
        "descr": "WriteFile writes data to a file named by filename. If the file does not exist, WriteFile creates it with permissions perm; otherwise WriteFile truncates it before writing.",
        "name": "ioutil.WriteFile",
        "params": [],
        "path": "go/io/ioutil/index#WriteFile",
        "syntax": "func WriteFile(filename string, data []byte, perm os.FileMode) error",
        "type": "io"
    },
    "jpeg.Decode": {
        "descr": "Decode reads a JPEG image from r and returns it as an image.Image.",
        "name": "jpeg.Decode",
        "params": [],
        "path": "go/image/jpeg/index#Decode",
        "syntax": "func Decode(r io.Reader) (image.Image, error)",
        "type": "image"
    },
    "jpeg.DecodeConfig": {
        "descr": "DecodeConfig returns the color model and dimensions of a JPEG image without decoding the entire image.",
        "name": "jpeg.DecodeConfig",
        "params": [],
        "path": "go/image/jpeg/index#DecodeConfig",
        "syntax": "func DecodeConfig(r io.Reader) (image.Config, error)",
        "type": "image"
    },
    "jpeg.Encode": {
        "descr": "Encode writes the Image m to w in JPEG 4:2:0 baseline format with the given options. Default parameters are used if a nil *Options is passed.",
        "name": "jpeg.Encode",
        "params": [],
        "path": "go/image/jpeg/index#Encode",
        "syntax": "func Encode(w io.Writer, m image.Image, o *Options) error",
        "type": "image"
    },
    "jpeg.FormatError": {
        "descr": "A FormatError reports that the input is not a valid JPEG.",
        "name": "jpeg.FormatError",
        "params": [],
        "path": "go/image/jpeg/index#FormatError",
        "syntax": "type FormatError string",
        "type": "image"
    },
    "jpeg.FormatError.Error": {
        "descr": "",
        "name": "jpeg.FormatError.Error",
        "params": [],
        "path": "go/image/jpeg/index#FormatError.Error",
        "syntax": "func (e FormatError) Error() string",
        "type": "image"
    },
    "jpeg.Options": {
        "descr": "Options are the encoding parameters. Quality ranges from 1 to 100 inclusive, higher is better.",
        "name": "jpeg.Options",
        "params": [],
        "path": "go/image/jpeg/index#Options",
        "syntax": "type Options struct { Quality int }",
        "type": "image"
    },
    "jpeg.Reader": {
        "descr": "Deprecated: Reader is not used by the image/jpeg package and should not be used by others. It is kept for compatibility.",
        "name": "jpeg.Reader",
        "params": [],
        "path": "go/image/jpeg/index#Reader",
        "syntax": "type Reader interface { io.ByteReader io.Reader }",
        "type": "image"
    },
    "jpeg.UnsupportedError": {
        "descr": "An UnsupportedError reports that the input uses a valid but unimplemented JPEG feature.",
        "name": "jpeg.UnsupportedError",
        "params": [],
        "path": "go/image/jpeg/index#UnsupportedError",
        "syntax": "type UnsupportedError string",
        "type": "image"
    },
    "jpeg.UnsupportedError.Error": {
        "descr": "",
        "name": "jpeg.UnsupportedError.Error",
        "params": [],
        "path": "go/image/jpeg/index#UnsupportedError.Error",
        "syntax": "func (e UnsupportedError) Error() string",
        "type": "image"
    },
    "js.Callback": {
        "descr": "Callback is a Go function that got wrapped for use as a JavaScript callback.",
        "name": "js.Callback",
        "params": [],
        "path": "go/syscall/js/index#Callback",
        "syntax": "type Callback struct { Value // the JavaScript function that queues the callback for execution // contains filtered or unexported fields }",
        "type": "syscall"
    },
    "js.Callback.Release": {
        "descr": "Release frees up resources allocated for the callback. The callback must not be invoked after calling Release.",
        "name": "js.Callback.Release",
        "params": [],
        "path": "go/syscall/js/index#Callback.Release",
        "syntax": "func (c Callback) Release()",
        "type": "syscall"
    },
    "js.Error": {
        "descr": "Error wraps a JavaScript error.",
        "name": "js.Error",
        "params": [],
        "path": "go/syscall/js/index#Error",
        "syntax": "type Error struct { // Value is the underlying JavaScript error value. Value }",
        "type": "syscall"
    },
    "js.Error.Error": {
        "descr": "Error implements the error interface.",
        "name": "js.Error.Error",
        "params": [],
        "path": "go/syscall/js/index#Error.Error",
        "syntax": "func (e Error) Error() string",
        "type": "syscall"
    },
    "js.EventCallbackFlag": {
        "descr": "",
        "name": "js.EventCallbackFlag",
        "params": [],
        "path": "go/syscall/js/index#EventCallbackFlag",
        "syntax": "type EventCallbackFlag int",
        "type": "syscall"
    },
    "js.Global": {
        "descr": "Global returns the JavaScript global object, usually \"window\" or \"global\".",
        "name": "js.Global",
        "params": [],
        "path": "go/syscall/js/index#Global",
        "syntax": "func Global() Value",
        "type": "syscall"
    },
    "js.NewCallback": {
        "descr": "NewCallback returns a wrapped callback function.",
        "name": "js.NewCallback",
        "params": [],
        "path": "go/syscall/js/index#NewCallback",
        "syntax": "func NewCallback(fn func(args []Value)) Callback",
        "type": "syscall"
    },
    "js.NewEventCallback": {
        "descr": "NewEventCallback returns a wrapped callback function, just like NewCallback, but the callback expects to have exactly one argument, the event. Depending on flags, it will synchronously call event.preventDefault, event.stopPropagation and/or event.stopImmediatePropagation before queuing the Go function fn for execution.",
        "name": "js.NewEventCallback",
        "params": [],
        "path": "go/syscall/js/index#NewEventCallback",
        "syntax": "func NewEventCallback(flags EventCallbackFlag, fn func(event Value)) Callback",
        "type": "syscall"
    },
    "js.Null": {
        "descr": "Null returns the JavaScript value \"null\".",
        "name": "js.Null",
        "params": [],
        "path": "go/syscall/js/index#Null",
        "syntax": "func Null() Value",
        "type": "syscall"
    },
    "js.Type": {
        "descr": "Type represents the JavaScript type of a Value.",
        "name": "js.Type",
        "params": [],
        "path": "go/syscall/js/index#Type",
        "syntax": "type Type int",
        "type": "syscall"
    },
    "js.Type.String": {
        "descr": "",
        "name": "js.Type.String",
        "params": [],
        "path": "go/syscall/js/index#Type.String",
        "syntax": "func (t Type) String() string",
        "type": "syscall"
    },
    "js.TypedArray": {
        "descr": "TypedArray represents a JavaScript typed array.",
        "name": "js.TypedArray",
        "params": [],
        "path": "go/syscall/js/index#TypedArray",
        "syntax": "type TypedArray struct { Value }",
        "type": "syscall"
    },
    "js.TypedArray.Release": {
        "descr": "Release frees up resources allocated for the typed array. The typed array and its buffer must not be accessed after calling Release.",
        "name": "js.TypedArray.Release",
        "params": [],
        "path": "go/syscall/js/index#TypedArray.Release",
        "syntax": "func (a TypedArray) Release()",
        "type": "syscall"
    },
    "js.TypedArrayOf": {
        "descr": "TypedArrayOf returns a JavaScript typed array backed by the slice's underlying array.",
        "name": "js.TypedArrayOf",
        "params": [],
        "path": "go/syscall/js/index#TypedArrayOf",
        "syntax": "func TypedArrayOf(slice interface{}) TypedArray",
        "type": "syscall"
    },
    "js.Undefined": {
        "descr": "Undefined returns the JavaScript value \"undefined\".",
        "name": "js.Undefined",
        "params": [],
        "path": "go/syscall/js/index#Undefined",
        "syntax": "func Undefined() Value",
        "type": "syscall"
    },
    "js.Value": {
        "descr": "Value represents a JavaScript value.",
        "name": "js.Value",
        "params": [],
        "path": "go/syscall/js/index#Value",
        "syntax": "type Value struct { // contains filtered or unexported fields }",
        "type": "syscall"
    },
    "js.Value.Bool": {
        "descr": "Bool returns the value v as a bool. It panics if v is not a JavaScript boolean.",
        "name": "js.Value.Bool",
        "params": [],
        "path": "go/syscall/js/index#Value.Bool",
        "syntax": "func (v Value) Bool() bool",
        "type": "syscall"
    },
    "js.Value.Call": {
        "descr": "Call does a JavaScript call to the method m of value v with the given arguments. It panics if v has no method m. The arguments get mapped to JavaScript values according to the ValueOf function.",
        "name": "js.Value.Call",
        "params": [],
        "path": "go/syscall/js/index#Value.Call",
        "syntax": "func (v Value) Call(m string, args ...interface{}) Value",
        "type": "syscall"
    },
    "js.Value.Float": {
        "descr": "Float returns the value v as a float64. It panics if v is not a JavaScript number.",
        "name": "js.Value.Float",
        "params": [],
        "path": "go/syscall/js/index#Value.Float",
        "syntax": "func (v Value) Float() float64",
        "type": "syscall"
    },
    "js.Value.Get": {
        "descr": "Get returns the JavaScript property p of value v.",
        "name": "js.Value.Get",
        "params": [],
        "path": "go/syscall/js/index#Value.Get",
        "syntax": "func (v Value) Get(p string) Value",
        "type": "syscall"
    },
    "js.Value.Index": {
        "descr": "Index returns JavaScript index i of value v.",
        "name": "js.Value.Index",
        "params": [],
        "path": "go/syscall/js/index#Value.Index",
        "syntax": "func (v Value) Index(i int) Value",
        "type": "syscall"
    },
    "js.Value.InstanceOf": {
        "descr": "InstanceOf reports whether v is an instance of type t according to JavaScript's instanceof operator.",
        "name": "js.Value.InstanceOf",
        "params": [],
        "path": "go/syscall/js/index#Value.InstanceOf",
        "syntax": "func (v Value) InstanceOf(t Value) bool",
        "type": "syscall"
    },
    "js.Value.Int": {
        "descr": "Int returns the value v truncated to an int. It panics if v is not a JavaScript number.",
        "name": "js.Value.Int",
        "params": [],
        "path": "go/syscall/js/index#Value.Int",
        "syntax": "func (v Value) Int() int",
        "type": "syscall"
    },
    "js.Value.Invoke": {
        "descr": "Invoke does a JavaScript call of the value v with the given arguments. It panics if v is not a function. The arguments get mapped to JavaScript values according to the ValueOf function.",
        "name": "js.Value.Invoke",
        "params": [],
        "path": "go/syscall/js/index#Value.Invoke",
        "syntax": "func (v Value) Invoke(args ...interface{}) Value",
        "type": "syscall"
    },
    "js.Value.Length": {
        "descr": "Length returns the JavaScript property \"length\" of v.",
        "name": "js.Value.Length",
        "params": [],
        "path": "go/syscall/js/index#Value.Length",
        "syntax": "func (v Value) Length() int",
        "type": "syscall"
    },
    "js.Value.New": {
        "descr": "New uses JavaScript's \"new\" operator with value v as constructor and the given arguments. It panics if v is not a function. The arguments get mapped to JavaScript values according to the ValueOf function.",
        "name": "js.Value.New",
        "params": [],
        "path": "go/syscall/js/index#Value.New",
        "syntax": "func (v Value) New(args ...interface{}) Value",
        "type": "syscall"
    },
    "js.Value.Set": {
        "descr": "Set sets the JavaScript property p of value v to ValueOf(x).",
        "name": "js.Value.Set",
        "params": [],
        "path": "go/syscall/js/index#Value.Set",
        "syntax": "func (v Value) Set(p string, x interface{})",
        "type": "syscall"
    },
    "js.Value.SetIndex": {
        "descr": "SetIndex sets the JavaScript index i of value v to ValueOf(x).",
        "name": "js.Value.SetIndex",
        "params": [],
        "path": "go/syscall/js/index#Value.SetIndex",
        "syntax": "func (v Value) SetIndex(i int, x interface{})",
        "type": "syscall"
    },
    "js.Value.String": {
        "descr": "String returns the value v converted to string according to JavaScript type conversions.",
        "name": "js.Value.String",
        "params": [],
        "path": "go/syscall/js/index#Value.String",
        "syntax": "func (v Value) String() string",
        "type": "syscall"
    },
    "js.Value.Type": {
        "descr": "Type returns the JavaScript type of the value v. It is similar to JavaScript's typeof operator, except that it returns TypeNull instead of TypeObject for null.",
        "name": "js.Value.Type",
        "params": [],
        "path": "go/syscall/js/index#Value.Type",
        "syntax": "func (v Value) Type() Type",
        "type": "syscall"
    },
    "js.ValueError": {
        "descr": "A ValueError occurs when a Value method is invoked on a Value that does not support it. Such cases are documented in the description of each method.",
        "name": "js.ValueError",
        "params": [],
        "path": "go/syscall/js/index#ValueError",
        "syntax": "type ValueError struct { Method string Type Type }",
        "type": "syscall"
    },
    "js.ValueError.Error": {
        "descr": "",
        "name": "js.ValueError.Error",
        "params": [],
        "path": "go/syscall/js/index#ValueError.Error",
        "syntax": "func (e *ValueError) Error() string",
        "type": "syscall"
    },
    "js.ValueOf": {
        "descr": "ValueOf returns x as a JavaScript value:",
        "name": "js.ValueOf",
        "params": [],
        "path": "go/syscall/js/index#ValueOf",
        "syntax": "func ValueOf(x interface{}) Value",
        "type": "syscall"
    },
    "json.Compact": {
        "descr": "Compact appends to dst the JSON-encoded src with insignificant space characters elided.",
        "name": "json.Compact",
        "params": [],
        "path": "go/encoding/json/index#Compact",
        "syntax": "func Compact(dst *bytes.Buffer, src []byte) error",
        "type": "encoding"
    },
    "json.Decoder": {
        "descr": "A Decoder reads and decodes JSON values from an input stream.",
        "name": "json.Decoder",
        "params": [],
        "path": "go/encoding/json/index#Decoder",
        "syntax": "type Decoder struct { // contains filtered or unexported fields }",
        "type": "encoding"
    },
    "json.Decoder.Buffered": {
        "descr": "Buffered returns a reader of the data remaining in the Decoder's buffer. The reader is valid until the next call to Decode.",
        "name": "json.Decoder.Buffered",
        "params": [],
        "path": "go/encoding/json/index#Decoder.Buffered",
        "syntax": "func (dec *Decoder) Buffered() io.Reader",
        "type": "encoding"
    },
    "json.Decoder.Decode": {
        "descr": "Decode reads the next JSON-encoded value from its input and stores it in the value pointed to by v.",
        "name": "json.Decoder.Decode",
        "params": [],
        "path": "go/encoding/json/index#Decoder.Decode",
        "syntax": "func (dec *Decoder) Decode(v interface{}) error",
        "type": "encoding"
    },
    "json.Decoder.DisallowUnknownFields": {
        "descr": "DisallowUnknownFields causes the Decoder to return an error when the destination is a struct and the input contains object keys which do not match any non-ignored, exported fields in the destination.",
        "name": "json.Decoder.DisallowUnknownFields",
        "params": [],
        "path": "go/encoding/json/index#Decoder.DisallowUnknownFields",
        "syntax": "func (dec *Decoder) DisallowUnknownFields()",
        "type": "encoding"
    },
    "json.Decoder.More": {
        "descr": "More reports whether there is another element in the current array or object being parsed.",
        "name": "json.Decoder.More",
        "params": [],
        "path": "go/encoding/json/index#Decoder.More",
        "syntax": "func (dec *Decoder) More() bool",
        "type": "encoding"
    },
    "json.Decoder.Token": {
        "descr": "Token returns the next JSON token in the input stream. At the end of the input stream, Token returns nil, io.EOF.",
        "name": "json.Decoder.Token",
        "params": [],
        "path": "go/encoding/json/index#Decoder.Token",
        "syntax": "func (dec *Decoder) Token() (Token, error)",
        "type": "encoding"
    },
    "json.Decoder.UseNumber": {
        "descr": "UseNumber causes the Decoder to unmarshal a number into an interface{} as a Number instead of as a float64.",
        "name": "json.Decoder.UseNumber",
        "params": [],
        "path": "go/encoding/json/index#Decoder.UseNumber",
        "syntax": "func (dec *Decoder) UseNumber()",
        "type": "encoding"
    },
    "json.Delim": {
        "descr": "A Delim is a JSON array or object delimiter, one of [ ] { or }.",
        "name": "json.Delim",
        "params": [],
        "path": "go/encoding/json/index#Delim",
        "syntax": "type Delim rune",
        "type": "encoding"
    },
    "json.Delim.String": {
        "descr": "",
        "name": "json.Delim.String",
        "params": [],
        "path": "go/encoding/json/index#Delim.String",
        "syntax": "func (d Delim) String() string",
        "type": "encoding"
    },
    "json.Encoder": {
        "descr": "An Encoder writes JSON values to an output stream.",
        "name": "json.Encoder",
        "params": [],
        "path": "go/encoding/json/index#Encoder",
        "syntax": "type Encoder struct { // contains filtered or unexported fields }",
        "type": "encoding"
    },
    "json.Encoder.Encode": {
        "descr": "Encode writes the JSON encoding of v to the stream, followed by a newline character.",
        "name": "json.Encoder.Encode",
        "params": [],
        "path": "go/encoding/json/index#Encoder.Encode",
        "syntax": "func (enc *Encoder) Encode(v interface{}) error",
        "type": "encoding"
    },
    "json.Encoder.SetEscapeHTML": {
        "descr": "SetEscapeHTML specifies whether problematic HTML characters should be escaped inside JSON quoted strings. The default behavior is to escape &, <, and > to \\u0026, \\u003c, and \\u003e to avoid certain safety problems that can arise when embedding JSON in HTML.",
        "name": "json.Encoder.SetEscapeHTML",
        "params": [],
        "path": "go/encoding/json/index#Encoder.SetEscapeHTML",
        "syntax": "func (enc *Encoder) SetEscapeHTML(on bool)",
        "type": "encoding"
    },
    "json.Encoder.SetIndent": {
        "descr": "SetIndent instructs the encoder to format each subsequent encoded value as if indented by the package-level function Indent(dst, src, prefix, indent). Calling SetIndent(\"\", \"\") disables indentation.",
        "name": "json.Encoder.SetIndent",
        "params": [],
        "path": "go/encoding/json/index#Encoder.SetIndent",
        "syntax": "func (enc *Encoder) SetIndent(prefix, indent string)",
        "type": "encoding"
    },
    "json.HTMLEscape": {
        "descr": "HTMLEscape appends to dst the JSON-encoded src with <, >, &, U+2028 and U+2029 characters inside string literals changed to \\u003c, \\u003e, \\u0026, \\u2028, \\u2029 so that the JSON will be safe to embed inside HTML <script> tags. For historical reasons, web browsers don't honor standard HTML escaping within <script> tags, so an alternative JSON encoding must be used.",
        "name": "json.HTMLEscape",
        "params": [],
        "path": "go/encoding/json/index#HTMLEscape",
        "syntax": "func HTMLEscape(dst *bytes.Buffer, src []byte)",
        "type": "encoding"
    },
    "json.Indent": {
        "descr": "Indent appends to dst an indented form of the JSON-encoded src. Each element in a JSON object or array begins on a new, indented line beginning with prefix followed by one or more copies of indent according to the indentation nesting. The data appended to dst does not begin with the prefix nor any indentation, to make it easier to embed inside other formatted JSON data. Although leading space characters (space, tab, carriage return, newline) at the beginning of src are dropped, trailing space characters at the end of src are preserved and copied to dst. For example, if src has no trailing spaces, neither will dst; if src ends in a trailing newline, so will dst.",
        "name": "json.Indent",
        "params": [],
        "path": "go/encoding/json/index#Indent",
        "syntax": "func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error",
        "type": "encoding"
    },
    "json.InvalidUTF8Error": {
        "descr": "Before Go 1.2, an InvalidUTF8Error was returned by Marshal when attempting to encode a string value with invalid UTF-8 sequences. As of Go 1.2, Marshal instead coerces the string to valid UTF-8 by replacing invalid bytes with the Unicode replacement rune U+FFFD.",
        "name": "json.InvalidUTF8Error",
        "params": [],
        "path": "go/encoding/json/index#InvalidUTF8Error",
        "syntax": "type InvalidUTF8Error struct { S string // the whole string value that caused the error }",
        "type": "encoding"
    },
    "json.InvalidUTF8Error.Error": {
        "descr": "",
        "name": "json.InvalidUTF8Error.Error",
        "params": [],
        "path": "go/encoding/json/index#InvalidUTF8Error.Error",
        "syntax": "func (e *InvalidUTF8Error) Error() string",
        "type": "encoding"
    },
    "json.InvalidUnmarshalError": {
        "descr": "An InvalidUnmarshalError describes an invalid argument passed to Unmarshal. (The argument to Unmarshal must be a non-nil pointer.)",
        "name": "json.InvalidUnmarshalError",
        "params": [],
        "path": "go/encoding/json/index#InvalidUnmarshalError",
        "syntax": "type InvalidUnmarshalError struct { Type reflect.Type }",
        "type": "encoding"
    },
    "json.InvalidUnmarshalError.Error": {
        "descr": "",
        "name": "json.InvalidUnmarshalError.Error",
        "params": [],
        "path": "go/encoding/json/index#InvalidUnmarshalError.Error",
        "syntax": "func (e *InvalidUnmarshalError) Error() string",
        "type": "encoding"
    },
    "json.Marshal": {
        "descr": "Marshal returns the JSON encoding of v.",
        "name": "json.Marshal",
        "params": [],
        "path": "go/encoding/json/index#Marshal",
        "syntax": "func Marshal(v interface{}) ([]byte, error)",
        "type": "encoding"
    },
    "json.MarshalIndent": {
        "descr": "MarshalIndent is like Marshal but applies Indent to format the output. Each JSON element in the output will begin on a new line beginning with prefix followed by one or more copies of indent according to the indentation nesting.",
        "name": "json.MarshalIndent",
        "params": [],
        "path": "go/encoding/json/index#MarshalIndent",
        "syntax": "func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)",
        "type": "encoding"
    },
    "json.Marshaler": {
        "descr": "Marshaler is the interface implemented by types that can marshal themselves into valid JSON.",
        "name": "json.Marshaler",
        "params": [],
        "path": "go/encoding/json/index#Marshaler",
        "syntax": "type Marshaler interface { MarshalJSON() ([]byte, error) }",
        "type": "encoding"
    },
    "json.MarshalerError": {
        "descr": "",
        "name": "json.MarshalerError",
        "params": [],
        "path": "go/encoding/json/index#MarshalerError",
        "syntax": "type MarshalerError struct { Type reflect.Type Err error }",
        "type": "encoding"
    },
    "json.MarshalerError.Error": {
        "descr": "",
        "name": "json.MarshalerError.Error",
        "params": [],
        "path": "go/encoding/json/index#MarshalerError.Error",
        "syntax": "func (e *MarshalerError) Error() string",
        "type": "encoding"
    },
    "json.NewDecoder": {
        "descr": "NewDecoder returns a new decoder that reads from r.",
        "name": "json.NewDecoder",
        "params": [],
        "path": "go/encoding/json/index#NewDecoder",
        "syntax": "func NewDecoder(r io.Reader) *Decoder",
        "type": "encoding"
    },
    "json.NewEncoder": {
        "descr": "NewEncoder returns a new encoder that writes to w.",
        "name": "json.NewEncoder",
        "params": [],
        "path": "go/encoding/json/index#NewEncoder",
        "syntax": "func NewEncoder(w io.Writer) *Encoder",
        "type": "encoding"
    },
    "json.Number": {
        "descr": "A Number represents a JSON number literal.",
        "name": "json.Number",
        "params": [],
        "path": "go/encoding/json/index#Number",
        "syntax": "type Number string",
        "type": "encoding"
    },
    "json.Number.Float64": {
        "descr": "Float64 returns the number as a float64.",
        "name": "json.Number.Float64",
        "params": [],
        "path": "go/encoding/json/index#Number.Float64",
        "syntax": "func (n Number) Float64() (float64, error)",
        "type": "encoding"
    },
    "json.Number.Int64": {
        "descr": "Int64 returns the number as an int64.",
        "name": "json.Number.Int64",
        "params": [],
        "path": "go/encoding/json/index#Number.Int64",
        "syntax": "func (n Number) Int64() (int64, error)",
        "type": "encoding"
    },
    "json.Number.String": {
        "descr": "String returns the literal text of the number.",
        "name": "json.Number.String",
        "params": [],
        "path": "go/encoding/json/index#Number.String",
        "syntax": "func (n Number) String() string",
        "type": "encoding"
    },
    "json.RawMessage": {
        "descr": "RawMessage is a raw encoded JSON value. It implements Marshaler and Unmarshaler and can be used to delay JSON decoding or precompute a JSON encoding.",
        "name": "json.RawMessage",
        "params": [],
        "path": "go/encoding/json/index#RawMessage",
        "syntax": "type RawMessage []byte",
        "type": "encoding"
    },
    "json.RawMessage.MarshalJSON": {
        "descr": "MarshalJSON returns m as the JSON encoding of m.",
        "name": "json.RawMessage.MarshalJSON",
        "params": [],
        "path": "go/encoding/json/index#RawMessage.MarshalJSON",
        "syntax": "func (m RawMessage) MarshalJSON() ([]byte, error)",
        "type": "encoding"
    },
    "json.RawMessage.UnmarshalJSON": {
        "descr": "UnmarshalJSON sets *m to a copy of data.",
        "name": "json.RawMessage.UnmarshalJSON",
        "params": [],
        "path": "go/encoding/json/index#RawMessage.UnmarshalJSON",
        "syntax": "func (m *RawMessage) UnmarshalJSON(data []byte) error",
        "type": "encoding"
    },
    "json.SyntaxError": {
        "descr": "A SyntaxError is a description of a JSON syntax error.",
        "name": "json.SyntaxError",
        "params": [],
        "path": "go/encoding/json/index#SyntaxError",
        "syntax": "type SyntaxError struct { Offset int64 // error occurred after reading Offset bytes // contains filtered or unexported fields }",
        "type": "encoding"
    },
    "json.SyntaxError.Error": {
        "descr": "",
        "name": "json.SyntaxError.Error",
        "params": [],
        "path": "go/encoding/json/index#SyntaxError.Error",
        "syntax": "func (e *SyntaxError) Error() string",
        "type": "encoding"
    },
    "json.Token": {
        "descr": "A Token holds a value of one of these types:",
        "name": "json.Token",
        "params": [],
        "path": "go/encoding/json/index#Token",
        "syntax": "Delim, for the four JSON delimiters [ ] { } bool, for JSON booleans float64, for JSON numbers Number, for JSON numbers string, for JSON string literals nil, for JSON null",
        "type": "encoding"
    },
    "json.Unmarshal": {
        "descr": "Unmarshal parses the JSON-encoded data and stores the result in the value pointed to by v. If v is nil or not a pointer, Unmarshal returns an InvalidUnmarshalError.",
        "name": "json.Unmarshal",
        "params": [],
        "path": "go/encoding/json/index#Unmarshal",
        "syntax": "func Unmarshal(data []byte, v interface{}) error",
        "type": "encoding"
    },
    "json.UnmarshalFieldError": {
        "descr": "An UnmarshalFieldError describes a JSON object key that led to an unexported (and therefore unwritable) struct field.",
        "name": "json.UnmarshalFieldError",
        "params": [],
        "path": "go/encoding/json/index#UnmarshalFieldError",
        "syntax": "type UnmarshalFieldError struct { Key string Type reflect.Type Field reflect.StructField }",
        "type": "encoding"
    },
    "json.UnmarshalFieldError.Error": {
        "descr": "",
        "name": "json.UnmarshalFieldError.Error",
        "params": [],
        "path": "go/encoding/json/index#UnmarshalFieldError.Error",
        "syntax": "func (e *UnmarshalFieldError) Error() string",
        "type": "encoding"
    },
    "json.UnmarshalTypeError": {
        "descr": "An UnmarshalTypeError describes a JSON value that was not appropriate for a value of a specific Go type.",
        "name": "json.UnmarshalTypeError",
        "params": [],
        "path": "go/encoding/json/index#UnmarshalTypeError",
        "syntax": "type UnmarshalTypeError struct { Value string // description of JSON value - \"bool\", \"array\", \"number -5\" Type reflect.Type // type of Go value it could not be assigned to Offset int64 // error occurred after reading Offset bytes; added in Go 1.5 Struct string // name of the struct type containing the field; added in Go 1.8 Field string // name of the field holding the Go value; added in Go 1.8 }",
        "type": "encoding"
    },
    "json.UnmarshalTypeError.Error": {
        "descr": "",
        "name": "json.UnmarshalTypeError.Error",
        "params": [],
        "path": "go/encoding/json/index#UnmarshalTypeError.Error",
        "syntax": "func (e *UnmarshalTypeError) Error() string",
        "type": "encoding"
    },
    "json.Unmarshaler": {
        "descr": "Unmarshaler is the interface implemented by types that can unmarshal a JSON description of themselves. The input can be assumed to be a valid encoding of a JSON value. UnmarshalJSON must copy the JSON data if it wishes to retain the data after returning.",
        "name": "json.Unmarshaler",
        "params": [],
        "path": "go/encoding/json/index#Unmarshaler",
        "syntax": "type Unmarshaler interface { UnmarshalJSON([]byte) error }",
        "type": "encoding"
    },
    "json.UnsupportedTypeError": {
        "descr": "An UnsupportedTypeError is returned by Marshal when attempting to encode an unsupported value type.",
        "name": "json.UnsupportedTypeError",
        "params": [],
        "path": "go/encoding/json/index#UnsupportedTypeError",
        "syntax": "type UnsupportedTypeError struct { Type reflect.Type }",
        "type": "encoding"
    },
    "json.UnsupportedTypeError.Error": {
        "descr": "",
        "name": "json.UnsupportedTypeError.Error",
        "params": [],
        "path": "go/encoding/json/index#UnsupportedTypeError.Error",
        "syntax": "func (e *UnsupportedTypeError) Error() string",
        "type": "encoding"
    },
    "json.UnsupportedValueError": {
        "descr": "",
        "name": "json.UnsupportedValueError",
        "params": [],
        "path": "go/encoding/json/index#UnsupportedValueError",
        "syntax": "type UnsupportedValueError struct { Value reflect.Value Str string }",
        "type": "encoding"
    },
    "json.UnsupportedValueError.Error": {
        "descr": "",
        "name": "json.UnsupportedValueError.Error",
        "params": [],
        "path": "go/encoding/json/index#UnsupportedValueError.Error",
        "syntax": "func (e *UnsupportedValueError) Error() string",
        "type": "encoding"
    },
    "json.Valid": {
        "descr": "Valid reports whether data is a valid JSON encoding.",
        "name": "json.Valid",
        "params": [],
        "path": "go/encoding/json/index#Valid",
        "syntax": "func Valid(data []byte) bool",
        "type": "encoding"
    },
    "jsonrpc.Dial": {
        "descr": "Dial connects to a JSON-RPC server at the specified network address.",
        "name": "jsonrpc.Dial",
        "params": [],
        "path": "go/net/rpc/jsonrpc/index#Dial",
        "syntax": "func Dial(network, address string) (*rpc.Client, error)",
        "type": "net/rpc"
    },
    "jsonrpc.NewClient": {
        "descr": "NewClient returns a new rpc.Client to handle requests to the set of services at the other end of the connection.",
        "name": "jsonrpc.NewClient",
        "params": [],
        "path": "go/net/rpc/jsonrpc/index#NewClient",
        "syntax": "func NewClient(conn io.ReadWriteCloser) *rpc.Client",
        "type": "net/rpc"
    },
    "jsonrpc.NewClientCodec": {
        "descr": "NewClientCodec returns a new rpc.ClientCodec using JSON-RPC on conn.",
        "name": "jsonrpc.NewClientCodec",
        "params": [],
        "path": "go/net/rpc/jsonrpc/index#NewClientCodec",
        "syntax": "func NewClientCodec(conn io.ReadWriteCloser) rpc.ClientCodec",
        "type": "net/rpc"
    },
    "jsonrpc.NewServerCodec": {
        "descr": "NewServerCodec returns a new rpc.ServerCodec using JSON-RPC on conn.",
        "name": "jsonrpc.NewServerCodec",
        "params": [],
        "path": "go/net/rpc/jsonrpc/index#NewServerCodec",
        "syntax": "func NewServerCodec(conn io.ReadWriteCloser) rpc.ServerCodec",
        "type": "net/rpc"
    },
    "jsonrpc.ServeConn": {
        "descr": "ServeConn runs the JSON-RPC server on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement.",
        "name": "jsonrpc.ServeConn",
        "params": [],
        "path": "go/net/rpc/jsonrpc/index#ServeConn",
        "syntax": "func ServeConn(conn io.ReadWriteCloser)",
        "type": "net/rpc"
    },
    "len": {
        "descr": "The len built-in function returns the length of v, according to its type:",
        "name": "builtin.len",
        "params": [],
        "path": "go/builtin/index#len",
        "syntax": "func len(v Type) int",
        "type": "builtin"
    },
    "list.Element": {
        "descr": "Element is an element of a linked list.",
        "name": "list.Element",
        "params": [],
        "path": "go/container/list/index#Element",
        "syntax": "type Element struct { // The value stored with this element. Value interface{} // contains filtered or unexported fields }",
        "type": "container"
    },
    "list.Element.Next": {
        "descr": "Next returns the next list element or nil.",
        "name": "list.Element.Next",
        "params": [],
        "path": "go/container/list/index#Element.Next",
        "syntax": "func (e *Element) Next() *Element",
        "type": "container"
    },
    "list.Element.Prev": {
        "descr": "Prev returns the previous list element or nil.",
        "name": "list.Element.Prev",
        "params": [],
        "path": "go/container/list/index#Element.Prev",
        "syntax": "func (e *Element) Prev() *Element",
        "type": "container"
    },
    "list.List": {
        "descr": "List represents a doubly linked list. The zero value for List is an empty list ready to use.",
        "name": "list.List",
        "params": [],
        "path": "go/container/list/index#List",
        "syntax": "type List struct { // contains filtered or unexported fields }",
        "type": "container"
    },
    "list.List.Back": {
        "descr": "Back returns the last element of list l or nil if the list is empty.",
        "name": "list.List.Back",
        "params": [],
        "path": "go/container/list/index#List.Back",
        "syntax": "func (l *List) Back() *Element",
        "type": "container"
    },
    "list.List.Front": {
        "descr": "Front returns the first element of list l or nil if the list is empty.",
        "name": "list.List.Front",
        "params": [],
        "path": "go/container/list/index#List.Front",
        "syntax": "func (l *List) Front() *Element",
        "type": "container"
    },
    "list.List.Init": {
        "descr": "Init initializes or clears list l.",
        "name": "list.List.Init",
        "params": [],
        "path": "go/container/list/index#List.Init",
        "syntax": "func (l *List) Init() *List",
        "type": "container"
    },
    "list.List.InsertAfter": {
        "descr": "InsertAfter inserts a new element e with value v immediately after mark and returns e. If mark is not an element of l, the list is not modified. The mark must not be nil.",
        "name": "list.List.InsertAfter",
        "params": [],
        "path": "go/container/list/index#List.InsertAfter",
        "syntax": "func (l *List) InsertAfter(v interface{}, mark *Element) *Element",
        "type": "container"
    },
    "list.List.InsertBefore": {
        "descr": "InsertBefore inserts a new element e with value v immediately before mark and returns e. If mark is not an element of l, the list is not modified. The mark must not be nil.",
        "name": "list.List.InsertBefore",
        "params": [],
        "path": "go/container/list/index#List.InsertBefore",
        "syntax": "func (l *List) InsertBefore(v interface{}, mark *Element) *Element",
        "type": "container"
    },
    "list.List.Len": {
        "descr": "Len returns the number of elements of list l. The complexity is O(1).",
        "name": "list.List.Len",
        "params": [],
        "path": "go/container/list/index#List.Len",
        "syntax": "func (l *List) Len() int",
        "type": "container"
    },
    "list.List.MoveAfter": {
        "descr": "MoveAfter moves element e to its new position after mark. If e or mark is not an element of l, or e == mark, the list is not modified. The element and mark must not be nil.",
        "name": "list.List.MoveAfter",
        "params": [],
        "path": "go/container/list/index#List.MoveAfter",
        "syntax": "func (l *List) MoveAfter(e, mark *Element)",
        "type": "container"
    },
    "list.List.MoveBefore": {
        "descr": "MoveBefore moves element e to its new position before mark. If e or mark is not an element of l, or e == mark, the list is not modified. The element and mark must not be nil.",
        "name": "list.List.MoveBefore",
        "params": [],
        "path": "go/container/list/index#List.MoveBefore",
        "syntax": "func (l *List) MoveBefore(e, mark *Element)",
        "type": "container"
    },
    "list.List.MoveToBack": {
        "descr": "MoveToBack moves element e to the back of list l. If e is not an element of l, the list is not modified. The element must not be nil.",
        "name": "list.List.MoveToBack",
        "params": [],
        "path": "go/container/list/index#List.MoveToBack",
        "syntax": "func (l *List) MoveToBack(e *Element)",
        "type": "container"
    },
    "list.List.MoveToFront": {
        "descr": "MoveToFront moves element e to the front of list l. If e is not an element of l, the list is not modified. The element must not be nil.",
        "name": "list.List.MoveToFront",
        "params": [],
        "path": "go/container/list/index#List.MoveToFront",
        "syntax": "func (l *List) MoveToFront(e *Element)",
        "type": "container"
    },
    "list.List.PushBack": {
        "descr": "PushBack inserts a new element e with value v at the back of list l and returns e.",
        "name": "list.List.PushBack",
        "params": [],
        "path": "go/container/list/index#List.PushBack",
        "syntax": "func (l *List) PushBack(v interface{}) *Element",
        "type": "container"
    },
    "list.List.PushBackList": {
        "descr": "PushBackList inserts a copy of an other list at the back of list l. The lists l and other may be the same. They must not be nil.",
        "name": "list.List.PushBackList",
        "params": [],
        "path": "go/container/list/index#List.PushBackList",
        "syntax": "func (l *List) PushBackList(other *List)",
        "type": "container"
    },
    "list.List.PushFront": {
        "descr": "PushFront inserts a new element e with value v at the front of list l and returns e.",
        "name": "list.List.PushFront",
        "params": [],
        "path": "go/container/list/index#List.PushFront",
        "syntax": "func (l *List) PushFront(v interface{}) *Element",
        "type": "container"
    },
    "list.List.PushFrontList": {
        "descr": "PushFrontList inserts a copy of an other list at the front of list l. The lists l and other may be the same. They must not be nil.",
        "name": "list.List.PushFrontList",
        "params": [],
        "path": "go/container/list/index#List.PushFrontList",
        "syntax": "func (l *List) PushFrontList(other *List)",
        "type": "container"
    },
    "list.List.Remove": {
        "descr": "Remove removes e from l if e is an element of list l. It returns the element value e.Value. The element must not be nil.",
        "name": "list.List.Remove",
        "params": [],
        "path": "go/container/list/index#List.Remove",
        "syntax": "func (l *List) Remove(e *Element) interface{}",
        "type": "container"
    },
    "list.New": {
        "descr": "New returns an initialized list.",
        "name": "list.New",
        "params": [],
        "path": "go/container/list/index#New",
        "syntax": "func New() *List",
        "type": "container"
    },
    "log": {
        "descr": "These flags define which text to prefix to each log entry generated by the Logger. Bits are or'ed together to control what's printed. There is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce,",
        "name": "log",
        "params": [],
        "path": "go/log/index#pkg-constants",
        "syntax": "2009/01/23 01:23:23 message",
        "type": "log"
    },
    "log.Fatal": {
        "descr": "Fatal is equivalent to Print() followed by a call to os.Exit(1).",
        "name": "log.Fatal",
        "params": [],
        "path": "go/log/index#Fatal",
        "syntax": "func Fatal(v ...interface{})",
        "type": "log"
    },
    "log.Fatalf": {
        "descr": "Fatalf is equivalent to Printf() followed by a call to os.Exit(1).",
        "name": "log.Fatalf",
        "params": [],
        "path": "go/log/index#Fatalf",
        "syntax": "func Fatalf(format string, v ...interface{})",
        "type": "log"
    },
    "log.Fatalln": {
        "descr": "Fatalln is equivalent to Println() followed by a call to os.Exit(1).",
        "name": "log.Fatalln",
        "params": [],
        "path": "go/log/index#Fatalln",
        "syntax": "func Fatalln(v ...interface{})",
        "type": "log"
    },
    "log.Flags": {
        "descr": "Flags returns the output flags for the standard logger.",
        "name": "log.Flags",
        "params": [],
        "path": "go/log/index#Flags",
        "syntax": "func Flags() int",
        "type": "log"
    },
    "log.Logger": {
        "descr": "A Logger represents an active logging object that generates lines of output to an io.Writer. Each logging operation makes a single call to the Writer's Write method. A Logger can be used simultaneously from multiple goroutines; it guarantees to serialize access to the Writer.",
        "name": "log.Logger",
        "params": [],
        "path": "go/log/index#Logger",
        "syntax": "type Logger struct { // contains filtered or unexported fields }",
        "type": "log"
    },
    "log.Logger.Fatal": {
        "descr": "Fatal is equivalent to l.Print() followed by a call to os.Exit(1).",
        "name": "log.Logger.Fatal",
        "params": [],
        "path": "go/log/index#Logger.Fatal",
        "syntax": "func (l *Logger) Fatal(v ...interface{})",
        "type": "log"
    },
    "log.Logger.Fatalf": {
        "descr": "Fatalf is equivalent to l.Printf() followed by a call to os.Exit(1).",
        "name": "log.Logger.Fatalf",
        "params": [],
        "path": "go/log/index#Logger.Fatalf",
        "syntax": "func (l *Logger) Fatalf(format string, v ...interface{})",
        "type": "log"
    },
    "log.Logger.Fatalln": {
        "descr": "Fatalln is equivalent to l.Println() followed by a call to os.Exit(1).",
        "name": "log.Logger.Fatalln",
        "params": [],
        "path": "go/log/index#Logger.Fatalln",
        "syntax": "func (l *Logger) Fatalln(v ...interface{})",
        "type": "log"
    },
    "log.Logger.Flags": {
        "descr": "Flags returns the output flags for the logger.",
        "name": "log.Logger.Flags",
        "params": [],
        "path": "go/log/index#Logger.Flags",
        "syntax": "func (l *Logger) Flags() int",
        "type": "log"
    },
    "log.Logger.Output": {
        "descr": "Output writes the output for a logging event. The string s contains the text to print after the prefix specified by the flags of the Logger. A newline is appended if the last character of s is not already a newline. Calldepth is used to recover the PC and is provided for generality, although at the moment on all pre-defined paths it will be 2.",
        "name": "log.Logger.Output",
        "params": [],
        "path": "go/log/index#Logger.Output",
        "syntax": "func (l *Logger) Output(calldepth int, s string) error",
        "type": "log"
    },
    "log.Logger.Panic": {
        "descr": "Panic is equivalent to l.Print() followed by a call to panic().",
        "name": "log.Logger.Panic",
        "params": [],
        "path": "go/log/index#Logger.Panic",
        "syntax": "func (l *Logger) Panic(v ...interface{})",
        "type": "log"
    },
    "log.Logger.Panicf": {
        "descr": "Panicf is equivalent to l.Printf() followed by a call to panic().",
        "name": "log.Logger.Panicf",
        "params": [],
        "path": "go/log/index#Logger.Panicf",
        "syntax": "func (l *Logger) Panicf(format string, v ...interface{})",
        "type": "log"
    },
    "log.Logger.Panicln": {
        "descr": "Panicln is equivalent to l.Println() followed by a call to panic().",
        "name": "log.Logger.Panicln",
        "params": [],
        "path": "go/log/index#Logger.Panicln",
        "syntax": "func (l *Logger) Panicln(v ...interface{})",
        "type": "log"
    },
    "log.Logger.Prefix": {
        "descr": "Prefix returns the output prefix for the logger.",
        "name": "log.Logger.Prefix",
        "params": [],
        "path": "go/log/index#Logger.Prefix",
        "syntax": "func (l *Logger) Prefix() string",
        "type": "log"
    },
    "log.Logger.Print": {
        "descr": "Print calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Print.",
        "name": "log.Logger.Print",
        "params": [],
        "path": "go/log/index#Logger.Print",
        "syntax": "func (l *Logger) Print(v ...interface{})",
        "type": "log"
    },
    "log.Logger.Printf": {
        "descr": "Printf calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Printf.",
        "name": "log.Logger.Printf",
        "params": [],
        "path": "go/log/index#Logger.Printf",
        "syntax": "func (l *Logger) Printf(format string, v ...interface{})",
        "type": "log"
    },
    "log.Logger.Println": {
        "descr": "Println calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Println.",
        "name": "log.Logger.Println",
        "params": [],
        "path": "go/log/index#Logger.Println",
        "syntax": "func (l *Logger) Println(v ...interface{})",
        "type": "log"
    },
    "log.Logger.SetFlags": {
        "descr": "SetFlags sets the output flags for the logger.",
        "name": "log.Logger.SetFlags",
        "params": [],
        "path": "go/log/index#Logger.SetFlags",
        "syntax": "func (l *Logger) SetFlags(flag int)",
        "type": "log"
    },
    "log.Logger.SetOutput": {
        "descr": "SetOutput sets the output destination for the logger.",
        "name": "log.Logger.SetOutput",
        "params": [],
        "path": "go/log/index#Logger.SetOutput",
        "syntax": "func (l *Logger) SetOutput(w io.Writer)",
        "type": "log"
    },
    "log.Logger.SetPrefix": {
        "descr": "SetPrefix sets the output prefix for the logger.",
        "name": "log.Logger.SetPrefix",
        "params": [],
        "path": "go/log/index#Logger.SetPrefix",
        "syntax": "func (l *Logger) SetPrefix(prefix string)",
        "type": "log"
    },
    "log.New": {
        "descr": "New creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line. The flag argument defines the logging properties.",
        "name": "log.New",
        "params": [],
        "path": "go/log/index#New",
        "syntax": "func New(out io.Writer, prefix string, flag int) *Logger",
        "type": "log"
    },
    "log.Output": {
        "descr": "Output writes the output for a logging event. The string s contains the text to print after the prefix specified by the flags of the Logger. A newline is appended if the last character of s is not already a newline. Calldepth is the count of the number of frames to skip when computing the file name and line number if Llongfile or Lshortfile is set; a value of 1 will print the details for the caller of Output.",
        "name": "log.Output",
        "params": [],
        "path": "go/log/index#Output",
        "syntax": "func Output(calldepth int, s string) error",
        "type": "log"
    },
    "log.Panic": {
        "descr": "Panic is equivalent to Print() followed by a call to panic().",
        "name": "log.Panic",
        "params": [],
        "path": "go/log/index#Panic",
        "syntax": "func Panic(v ...interface{})",
        "type": "log"
    },
    "log.Panicf": {
        "descr": "Panicf is equivalent to Printf() followed by a call to panic().",
        "name": "log.Panicf",
        "params": [],
        "path": "go/log/index#Panicf",
        "syntax": "func Panicf(format string, v ...interface{})",
        "type": "log"
    },
    "log.Panicln": {
        "descr": "Panicln is equivalent to Println() followed by a call to panic().",
        "name": "log.Panicln",
        "params": [],
        "path": "go/log/index#Panicln",
        "syntax": "func Panicln(v ...interface{})",
        "type": "log"
    },
    "log.Prefix": {
        "descr": "Prefix returns the output prefix for the standard logger.",
        "name": "log.Prefix",
        "params": [],
        "path": "go/log/index#Prefix",
        "syntax": "func Prefix() string",
        "type": "log"
    },
    "log.Print": {
        "descr": "Print calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Print.",
        "name": "log.Print",
        "params": [],
        "path": "go/log/index#Print",
        "syntax": "func Print(v ...interface{})",
        "type": "log"
    },
    "log.Printf": {
        "descr": "Printf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf.",
        "name": "log.Printf",
        "params": [],
        "path": "go/log/index#Printf",
        "syntax": "func Printf(format string, v ...interface{})",
        "type": "log"
    },
    "log.Println": {
        "descr": "Println calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Println.",
        "name": "log.Println",
        "params": [],
        "path": "go/log/index#Println",
        "syntax": "func Println(v ...interface{})",
        "type": "log"
    },
    "log.SetFlags": {
        "descr": "SetFlags sets the output flags for the standard logger.",
        "name": "log.SetFlags",
        "params": [],
        "path": "go/log/index#SetFlags",
        "syntax": "func SetFlags(flag int)",
        "type": "log"
    },
    "log.SetOutput": {
        "descr": "SetOutput sets the output destination for the standard logger.",
        "name": "log.SetOutput",
        "params": [],
        "path": "go/log/index#SetOutput",
        "syntax": "func SetOutput(w io.Writer)",
        "type": "log"
    },
    "log.SetPrefix": {
        "descr": "SetPrefix sets the output prefix for the standard logger.",
        "name": "log.SetPrefix",
        "params": [],
        "path": "go/log/index#SetPrefix",
        "syntax": "func SetPrefix(prefix string)",
        "type": "log"
    },
    "lzw.NewReader": {
        "descr": "NewReader creates a new io.ReadCloser. Reads from the returned io.ReadCloser read and decompress data from r. If r does not also implement io.ByteReader, the decompressor may read more data than necessary from r. It is the caller's responsibility to call Close on the ReadCloser when finished reading. The number of bits to use for literal codes, litWidth, must be in the range [2,8] and is typically 8. It must equal the litWidth used during compression.",
        "name": "lzw.NewReader",
        "params": [],
        "path": "go/compress/lzw/index#NewReader",
        "syntax": "func NewReader(r io.Reader, order Order, litWidth int) io.ReadCloser",
        "type": "compress"
    },
    "lzw.NewWriter": {
        "descr": "NewWriter creates a new io.WriteCloser. Writes to the returned io.WriteCloser are compressed and written to w. It is the caller's responsibility to call Close on the WriteCloser when finished writing. The number of bits to use for literal codes, litWidth, must be in the range [2,8] and is typically 8. Input bytes must be less than 1<<litWidth.",
        "name": "lzw.NewWriter",
        "params": [],
        "path": "go/compress/lzw/index#NewWriter",
        "syntax": "func NewWriter(w io.Writer, order Order, litWidth int) io.WriteCloser",
        "type": "compress"
    },
    "lzw.Order": {
        "descr": "Order specifies the bit ordering in an LZW data stream.",
        "name": "lzw.Order",
        "params": [],
        "path": "go/compress/lzw/index#Order",
        "syntax": "type Order int",
        "type": "compress"
    },
    "macho.Cpu": {
        "descr": "A Cpu is a Mach-O cpu type.",
        "name": "macho.Cpu",
        "params": [],
        "path": "go/debug/macho/index#Cpu",
        "syntax": "type Cpu uint32",
        "type": "debug"
    },
    "macho.Cpu.GoString": {
        "descr": "",
        "name": "macho.Cpu.GoString",
        "params": [],
        "path": "go/debug/macho/index#Cpu.GoString",
        "syntax": "func (i Cpu) GoString() string",
        "type": "debug"
    },
    "macho.Cpu.String": {
        "descr": "",
        "name": "macho.Cpu.String",
        "params": [],
        "path": "go/debug/macho/index#Cpu.String",
        "syntax": "func (i Cpu) String() string",
        "type": "debug"
    },
    "macho.Dylib": {
        "descr": "A Dylib represents a Mach-O load dynamic library command.",
        "name": "macho.Dylib",
        "params": [],
        "path": "go/debug/macho/index#Dylib",
        "syntax": "type Dylib struct { LoadBytes Name string Time uint32 CurrentVersion uint32 CompatVersion uint32 }",
        "type": "debug"
    },
    "macho.DylibCmd": {
        "descr": "A DylibCmd is a Mach-O load dynamic library command.",
        "name": "macho.DylibCmd",
        "params": [],
        "path": "go/debug/macho/index#DylibCmd",
        "syntax": "type DylibCmd struct { Cmd LoadCmd Len uint32 Name uint32 Time uint32 CurrentVersion uint32 CompatVersion uint32 }",
        "type": "debug"
    },
    "macho.Dysymtab": {
        "descr": "A Dysymtab represents a Mach-O dynamic symbol table command.",
        "name": "macho.Dysymtab",
        "params": [],
        "path": "go/debug/macho/index#Dysymtab",
        "syntax": "type Dysymtab struct { LoadBytes DysymtabCmd IndirectSyms []uint32 // indices into Symtab.Syms }",
        "type": "debug"
    },
    "macho.DysymtabCmd": {
        "descr": "A DysymtabCmd is a Mach-O dynamic symbol table command.",
        "name": "macho.DysymtabCmd",
        "params": [],
        "path": "go/debug/macho/index#DysymtabCmd",
        "syntax": "type DysymtabCmd struct { Cmd LoadCmd Len uint32 Ilocalsym uint32 Nlocalsym uint32 Iextdefsym uint32 Nextdefsym uint32 Iundefsym uint32 Nundefsym uint32 Tocoffset uint32 Ntoc uint32 Modtaboff uint32 Nmodtab uint32 Extrefsymoff uint32 Nextrefsyms uint32 Indirectsymoff uint32 Nindirectsyms uint32 Extreloff uint32 Nextrel uint32 Locreloff uint32 Nlocrel uint32 }",
        "type": "debug"
    },
    "macho.FatArch": {
        "descr": "A FatArch is a Mach-O File inside a FatFile.",
        "name": "macho.FatArch",
        "params": [],
        "path": "go/debug/macho/index#FatArch",
        "syntax": "type FatArch struct { FatArchHeader *File }",
        "type": "debug"
    },
    "macho.FatArchHeader": {
        "descr": "A FatArchHeader represents a fat header for a specific image architecture.",
        "name": "macho.FatArchHeader",
        "params": [],
        "path": "go/debug/macho/index#FatArchHeader",
        "syntax": "type FatArchHeader struct { Cpu Cpu SubCpu uint32 Offset uint32 Size uint32 Align uint32 }",
        "type": "debug"
    },
    "macho.FatFile": {
        "descr": "A FatFile is a Mach-O universal binary that contains at least one architecture.",
        "name": "macho.FatFile",
        "params": [],
        "path": "go/debug/macho/index#FatFile",
        "syntax": "type FatFile struct { Magic uint32 Arches []FatArch // contains filtered or unexported fields }",
        "type": "debug"
    },
    "macho.FatFile.Close": {
        "descr": "",
        "name": "macho.FatFile.Close",
        "params": [],
        "path": "go/debug/macho/index#FatFile.Close",
        "syntax": "func (ff *FatFile) Close() error",
        "type": "debug"
    },
    "macho.File": {
        "descr": "A File represents an open Mach-O file.",
        "name": "macho.File",
        "params": [],
        "path": "go/debug/macho/index#File",
        "syntax": "type File struct { FileHeader ByteOrder binary.ByteOrder Loads []Load Sections []*Section Symtab *Symtab Dysymtab *Dysymtab // contains filtered or unexported fields }",
        "type": "debug"
    },
    "macho.File.Close": {
        "descr": "Close closes the File. If the File was created using NewFile directly instead of Open, Close has no effect.",
        "name": "macho.File.Close",
        "params": [],
        "path": "go/debug/macho/index#File.Close",
        "syntax": "func (f *File) Close() error",
        "type": "debug"
    },
    "macho.File.DWARF": {
        "descr": "DWARF returns the DWARF debug information for the Mach-O file.",
        "name": "macho.File.DWARF",
        "params": [],
        "path": "go/debug/macho/index#File.DWARF",
        "syntax": "func (f *File) DWARF() (*dwarf.Data, error)",
        "type": "debug"
    },
    "macho.File.ImportedLibraries": {
        "descr": "ImportedLibraries returns the paths of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time.",
        "name": "macho.File.ImportedLibraries",
        "params": [],
        "path": "go/debug/macho/index#File.ImportedLibraries",
        "syntax": "func (f *File) ImportedLibraries() ([]string, error)",
        "type": "debug"
    },
    "macho.File.ImportedSymbols": {
        "descr": "ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time.",
        "name": "macho.File.ImportedSymbols",
        "params": [],
        "path": "go/debug/macho/index#File.ImportedSymbols",
        "syntax": "func (f *File) ImportedSymbols() ([]string, error)",
        "type": "debug"
    },
    "macho.File.Section": {
        "descr": "Section returns the first section with the given name, or nil if no such section exists.",
        "name": "macho.File.Section",
        "params": [],
        "path": "go/debug/macho/index#File.Section",
        "syntax": "func (f *File) Section(name string) *Section",
        "type": "debug"
    },
    "macho.File.Segment": {
        "descr": "Segment returns the first Segment with the given name, or nil if no such segment exists.",
        "name": "macho.File.Segment",
        "params": [],
        "path": "go/debug/macho/index#File.Segment",
        "syntax": "func (f *File) Segment(name string) *Segment",
        "type": "debug"
    },
    "macho.FileHeader": {
        "descr": "A FileHeader represents a Mach-O file header.",
        "name": "macho.FileHeader",
        "params": [],
        "path": "go/debug/macho/index#FileHeader",
        "syntax": "type FileHeader struct { Magic uint32 Cpu Cpu SubCpu uint32 Type Type Ncmd uint32 Cmdsz uint32 Flags uint32 }",
        "type": "debug"
    },
    "macho.FormatError": {
        "descr": "FormatError is returned by some operations if the data does not have the correct format for an object file.",
        "name": "macho.FormatError",
        "params": [],
        "path": "go/debug/macho/index#FormatError",
        "syntax": "type FormatError struct { // contains filtered or unexported fields }",
        "type": "debug"
    },
    "macho.FormatError.Error": {
        "descr": "",
        "name": "macho.FormatError.Error",
        "params": [],
        "path": "go/debug/macho/index#FormatError.Error",
        "syntax": "func (e *FormatError) Error() string",
        "type": "debug"
    },
    "macho.Load": {
        "descr": "A Load represents any Mach-O load command.",
        "name": "macho.Load",
        "params": [],
        "path": "go/debug/macho/index#Load",
        "syntax": "type Load interface { Raw() []byte }",
        "type": "debug"
    },
    "macho.LoadBytes": {
        "descr": "A LoadBytes is the uninterpreted bytes of a Mach-O load command.",
        "name": "macho.LoadBytes",
        "params": [],
        "path": "go/debug/macho/index#LoadBytes",
        "syntax": "type LoadBytes []byte",
        "type": "debug"
    },
    "macho.LoadBytes.Raw": {
        "descr": "",
        "name": "macho.LoadBytes.Raw",
        "params": [],
        "path": "go/debug/macho/index#LoadBytes.Raw",
        "syntax": "func (b LoadBytes) Raw() []byte",
        "type": "debug"
    },
    "macho.LoadCmd": {
        "descr": "A LoadCmd is a Mach-O load command.",
        "name": "macho.LoadCmd",
        "params": [],
        "path": "go/debug/macho/index#LoadCmd",
        "syntax": "type LoadCmd uint32",
        "type": "debug"
    },
    "macho.LoadCmd.GoString": {
        "descr": "",
        "name": "macho.LoadCmd.GoString",
        "params": [],
        "path": "go/debug/macho/index#LoadCmd.GoString",
        "syntax": "func (i LoadCmd) GoString() string",
        "type": "debug"
    },
    "macho.LoadCmd.String": {
        "descr": "",
        "name": "macho.LoadCmd.String",
        "params": [],
        "path": "go/debug/macho/index#LoadCmd.String",
        "syntax": "func (i LoadCmd) String() string",
        "type": "debug"
    },
    "macho.NewFatFile": {
        "descr": "NewFatFile creates a new FatFile for accessing all the Mach-O images in a universal binary. The Mach-O binary is expected to start at position 0 in the ReaderAt.",
        "name": "macho.NewFatFile",
        "params": [],
        "path": "go/debug/macho/index#NewFatFile",
        "syntax": "func NewFatFile(r io.ReaderAt) (*FatFile, error)",
        "type": "debug"
    },
    "macho.NewFile": {
        "descr": "NewFile creates a new File for accessing a Mach-O binary in an underlying reader. The Mach-O binary is expected to start at position 0 in the ReaderAt.",
        "name": "macho.NewFile",
        "params": [],
        "path": "go/debug/macho/index#NewFile",
        "syntax": "func NewFile(r io.ReaderAt) (*File, error)",
        "type": "debug"
    },
    "macho.Nlist32": {
        "descr": "An Nlist32 is a Mach-O 32-bit symbol table entry.",
        "name": "macho.Nlist32",
        "params": [],
        "path": "go/debug/macho/index#Nlist32",
        "syntax": "type Nlist32 struct { Name uint32 Type uint8 Sect uint8 Desc uint16 Value uint32 }",
        "type": "debug"
    },
    "macho.Nlist64": {
        "descr": "An Nlist64 is a Mach-O 64-bit symbol table entry.",
        "name": "macho.Nlist64",
        "params": [],
        "path": "go/debug/macho/index#Nlist64",
        "syntax": "type Nlist64 struct { Name uint32 Type uint8 Sect uint8 Desc uint16 Value uint64 }",
        "type": "debug"
    },
    "macho.Open": {
        "descr": "Open opens the named file using os.Open and prepares it for use as a Mach-O binary.",
        "name": "macho.Open",
        "params": [],
        "path": "go/debug/macho/index#Open",
        "syntax": "func Open(name string) (*File, error)",
        "type": "debug"
    },
    "macho.OpenFat": {
        "descr": "OpenFat opens the named file using os.Open and prepares it for use as a Mach-O universal binary.",
        "name": "macho.OpenFat",
        "params": [],
        "path": "go/debug/macho/index#OpenFat",
        "syntax": "func OpenFat(name string) (*FatFile, error)",
        "type": "debug"
    },
    "macho.Regs386": {
        "descr": "Regs386 is the Mach-O 386 register structure.",
        "name": "macho.Regs386",
        "params": [],
        "path": "go/debug/macho/index#Regs386",
        "syntax": "type Regs386 struct { AX uint32 BX uint32 CX uint32 DX uint32 DI uint32 SI uint32 BP uint32 SP uint32 SS uint32 FLAGS uint32 IP uint32 CS uint32 DS uint32 ES uint32 FS uint32 GS uint32 }",
        "type": "debug"
    },
    "macho.RegsAMD64": {
        "descr": "RegsAMD64 is the Mach-O AMD64 register structure.",
        "name": "macho.RegsAMD64",
        "params": [],
        "path": "go/debug/macho/index#RegsAMD64",
        "syntax": "type RegsAMD64 struct { AX uint64 BX uint64 CX uint64 DX uint64 DI uint64 SI uint64 BP uint64 SP uint64 R8 uint64 R9 uint64 R10 uint64 R11 uint64 R12 uint64 R13 uint64 R14 uint64 R15 uint64 IP uint64 FLAGS uint64 CS uint64 FS uint64 GS uint64 }",
        "type": "debug"
    },
    "macho.Reloc": {
        "descr": "A Reloc represents a Mach-O relocation.",
        "name": "macho.Reloc",
        "params": [],
        "path": "go/debug/macho/index#Reloc",
        "syntax": "type Reloc struct { Addr uint32 Value uint32 // when Scattered == false && Extern == true, Value is the symbol number. // when Scattered == false && Extern == false, Value is the section number. // when Scattered == true, Value is the value that this reloc refers to. Type uint8 Len uint8 // 0=byte, 1=word, 2=long, 3=quad Pcrel bool Extern bool // valid if Scattered == false Scattered bool }",
        "type": "debug"
    },
    "macho.RelocTypeARM": {
        "descr": "",
        "name": "macho.RelocTypeARM",
        "params": [],
        "path": "go/debug/macho/index#RelocTypeARM",
        "syntax": "type RelocTypeARM int",
        "type": "debug"
    },
    "macho.RelocTypeARM.GoString": {
        "descr": "",
        "name": "macho.RelocTypeARM.GoString",
        "params": [],
        "path": "go/debug/macho/index#RelocTypeARM.GoString",
        "syntax": "func (r RelocTypeARM) GoString() string",
        "type": "debug"
    },
    "macho.RelocTypeARM.String": {
        "descr": "",
        "name": "macho.RelocTypeARM.String",
        "params": [],
        "path": "go/debug/macho/index#RelocTypeARM.String",
        "syntax": "func (i RelocTypeARM) String() string",
        "type": "debug"
    },
    "macho.RelocTypeARM64": {
        "descr": "",
        "name": "macho.RelocTypeARM64",
        "params": [],
        "path": "go/debug/macho/index#RelocTypeARM64",
        "syntax": "type RelocTypeARM64 int",
        "type": "debug"
    },
    "macho.RelocTypeARM64.GoString": {
        "descr": "",
        "name": "macho.RelocTypeARM64.GoString",
        "params": [],
        "path": "go/debug/macho/index#RelocTypeARM64.GoString",
        "syntax": "func (r RelocTypeARM64) GoString() string",
        "type": "debug"
    },
    "macho.RelocTypeARM64.String": {
        "descr": "",
        "name": "macho.RelocTypeARM64.String",
        "params": [],
        "path": "go/debug/macho/index#RelocTypeARM64.String",
        "syntax": "func (i RelocTypeARM64) String() string",
        "type": "debug"
    },
    "macho.RelocTypeGeneric": {
        "descr": "",
        "name": "macho.RelocTypeGeneric",
        "params": [],
        "path": "go/debug/macho/index#RelocTypeGeneric",
        "syntax": "type RelocTypeGeneric int",
        "type": "debug"
    },
    "macho.RelocTypeGeneric.GoString": {
        "descr": "",
        "name": "macho.RelocTypeGeneric.GoString",
        "params": [],
        "path": "go/debug/macho/index#RelocTypeGeneric.GoString",
        "syntax": "func (r RelocTypeGeneric) GoString() string",
        "type": "debug"
    },
    "macho.RelocTypeGeneric.String": {
        "descr": "",
        "name": "macho.RelocTypeGeneric.String",
        "params": [],
        "path": "go/debug/macho/index#RelocTypeGeneric.String",
        "syntax": "func (i RelocTypeGeneric) String() string",
        "type": "debug"
    },
    "macho.RelocTypeX86_64": {
        "descr": "",
        "name": "macho.RelocTypeX86_64",
        "params": [],
        "path": "go/debug/macho/index#RelocTypeX86_64",
        "syntax": "type RelocTypeX86_64 int",
        "type": "debug"
    },
    "macho.RelocTypeX86_64.GoString": {
        "descr": "",
        "name": "macho.RelocTypeX86_64.GoString",
        "params": [],
        "path": "go/debug/macho/index#RelocTypeX86_64.GoString",
        "syntax": "func (r RelocTypeX86_64) GoString() string",
        "type": "debug"
    },
    "macho.RelocTypeX86_64.String": {
        "descr": "",
        "name": "macho.RelocTypeX86_64.String",
        "params": [],
        "path": "go/debug/macho/index#RelocTypeX86_64.String",
        "syntax": "func (i RelocTypeX86_64) String() string",
        "type": "debug"
    },
    "macho.Rpath": {
        "descr": "A Rpath represents a Mach-O rpath command.",
        "name": "macho.Rpath",
        "params": [],
        "path": "go/debug/macho/index#Rpath",
        "syntax": "type Rpath struct { LoadBytes Path string }",
        "type": "debug"
    },
    "macho.RpathCmd": {
        "descr": "A RpathCmd is a Mach-O rpath command.",
        "name": "macho.RpathCmd",
        "params": [],
        "path": "go/debug/macho/index#RpathCmd",
        "syntax": "type RpathCmd struct { Cmd LoadCmd Len uint32 Path uint32 }",
        "type": "debug"
    },
    "macho.Section": {
        "descr": "",
        "name": "macho.Section",
        "params": [],
        "path": "go/debug/macho/index#Section",
        "syntax": "type Section struct { SectionHeader Relocs []Reloc // Go 1.10 // Embed ReaderAt for ReadAt method. // Do not embed SectionReader directly // to avoid having Read and Seek. // If a client wants Read and Seek it must use // Open() to avoid fighting over the seek offset // with other clients. io.ReaderAt // contains filtered or unexported fields }",
        "type": "debug"
    },
    "macho.Section.Data": {
        "descr": "Data reads and returns the contents of the Mach-O section.",
        "name": "macho.Section.Data",
        "params": [],
        "path": "go/debug/macho/index#Section.Data",
        "syntax": "func (s *Section) Data() ([]byte, error)",
        "type": "debug"
    },
    "macho.Section.Open": {
        "descr": "Open returns a new ReadSeeker reading the Mach-O section.",
        "name": "macho.Section.Open",
        "params": [],
        "path": "go/debug/macho/index#Section.Open",
        "syntax": "func (s *Section) Open() io.ReadSeeker",
        "type": "debug"
    },
    "macho.Section32": {
        "descr": "A Section32 is a 32-bit Mach-O section header.",
        "name": "macho.Section32",
        "params": [],
        "path": "go/debug/macho/index#Section32",
        "syntax": "type Section32 struct { Name [16]byte Seg [16]byte Addr uint32 Size uint32 Offset uint32 Align uint32 Reloff uint32 Nreloc uint32 Flags uint32 Reserve1 uint32 Reserve2 uint32 }",
        "type": "debug"
    },
    "macho.Section64": {
        "descr": "A Section64 is a 64-bit Mach-O section header.",
        "name": "macho.Section64",
        "params": [],
        "path": "go/debug/macho/index#Section64",
        "syntax": "type Section64 struct { Name [16]byte Seg [16]byte Addr uint64 Size uint64 Offset uint32 Align uint32 Reloff uint32 Nreloc uint32 Flags uint32 Reserve1 uint32 Reserve2 uint32 Reserve3 uint32 }",
        "type": "debug"
    },
    "macho.SectionHeader": {
        "descr": "",
        "name": "macho.SectionHeader",
        "params": [],
        "path": "go/debug/macho/index#SectionHeader",
        "syntax": "type SectionHeader struct { Name string Seg string Addr uint64 Size uint64 Offset uint32 Align uint32 Reloff uint32 Nreloc uint32 Flags uint32 }",
        "type": "debug"
    },
    "macho.Segment": {
        "descr": "A Segment represents a Mach-O 32-bit or 64-bit load segment command.",
        "name": "macho.Segment",
        "params": [],
        "path": "go/debug/macho/index#Segment",
        "syntax": "type Segment struct { LoadBytes SegmentHeader // Embed ReaderAt for ReadAt method. // Do not embed SectionReader directly // to avoid having Read and Seek. // If a client wants Read and Seek it must use // Open() to avoid fighting over the seek offset // with other clients. io.ReaderAt // contains filtered or unexported fields }",
        "type": "debug"
    },
    "macho.Segment.Data": {
        "descr": "Data reads and returns the contents of the segment.",
        "name": "macho.Segment.Data",
        "params": [],
        "path": "go/debug/macho/index#Segment.Data",
        "syntax": "func (s *Segment) Data() ([]byte, error)",
        "type": "debug"
    },
    "macho.Segment.Open": {
        "descr": "Open returns a new ReadSeeker reading the segment.",
        "name": "macho.Segment.Open",
        "params": [],
        "path": "go/debug/macho/index#Segment.Open",
        "syntax": "func (s *Segment) Open() io.ReadSeeker",
        "type": "debug"
    },
    "macho.Segment32": {
        "descr": "A Segment32 is a 32-bit Mach-O segment load command.",
        "name": "macho.Segment32",
        "params": [],
        "path": "go/debug/macho/index#Segment32",
        "syntax": "type Segment32 struct { Cmd LoadCmd Len uint32 Name [16]byte Addr uint32 Memsz uint32 Offset uint32 Filesz uint32 Maxprot uint32 Prot uint32 Nsect uint32 Flag uint32 }",
        "type": "debug"
    },
    "macho.Segment64": {
        "descr": "A Segment64 is a 64-bit Mach-O segment load command.",
        "name": "macho.Segment64",
        "params": [],
        "path": "go/debug/macho/index#Segment64",
        "syntax": "type Segment64 struct { Cmd LoadCmd Len uint32 Name [16]byte Addr uint64 Memsz uint64 Offset uint64 Filesz uint64 Maxprot uint32 Prot uint32 Nsect uint32 Flag uint32 }",
        "type": "debug"
    },
    "macho.SegmentHeader": {
        "descr": "A SegmentHeader is the header for a Mach-O 32-bit or 64-bit load segment command.",
        "name": "macho.SegmentHeader",
        "params": [],
        "path": "go/debug/macho/index#SegmentHeader",
        "syntax": "type SegmentHeader struct { Cmd LoadCmd Len uint32 Name string Addr uint64 Memsz uint64 Offset uint64 Filesz uint64 Maxprot uint32 Prot uint32 Nsect uint32 Flag uint32 }",
        "type": "debug"
    },
    "macho.Symbol": {
        "descr": "A Symbol is a Mach-O 32-bit or 64-bit symbol table entry.",
        "name": "macho.Symbol",
        "params": [],
        "path": "go/debug/macho/index#Symbol",
        "syntax": "type Symbol struct { Name string Type uint8 Sect uint8 Desc uint16 Value uint64 }",
        "type": "debug"
    },
    "macho.Symtab": {
        "descr": "A Symtab represents a Mach-O symbol table command.",
        "name": "macho.Symtab",
        "params": [],
        "path": "go/debug/macho/index#Symtab",
        "syntax": "type Symtab struct { LoadBytes SymtabCmd Syms []Symbol }",
        "type": "debug"
    },
    "macho.SymtabCmd": {
        "descr": "A SymtabCmd is a Mach-O symbol table command.",
        "name": "macho.SymtabCmd",
        "params": [],
        "path": "go/debug/macho/index#SymtabCmd",
        "syntax": "type SymtabCmd struct { Cmd LoadCmd Len uint32 Symoff uint32 Nsyms uint32 Stroff uint32 Strsize uint32 }",
        "type": "debug"
    },
    "macho.Thread": {
        "descr": "A Thread is a Mach-O thread state command.",
        "name": "macho.Thread",
        "params": [],
        "path": "go/debug/macho/index#Thread",
        "syntax": "type Thread struct { Cmd LoadCmd Len uint32 Type uint32 Data []uint32 }",
        "type": "debug"
    },
    "macho.Type": {
        "descr": "A Type is the Mach-O file type, e.g. an object file, executable, or dynamic library.",
        "name": "macho.Type",
        "params": [],
        "path": "go/debug/macho/index#Type",
        "syntax": "type Type uint32",
        "type": "debug"
    },
    "macho.Type.GoString": {
        "descr": "",
        "name": "macho.Type.GoString",
        "params": [],
        "path": "go/debug/macho/index#Type.GoString",
        "syntax": "func (t Type) GoString() string",
        "type": "debug"
    },
    "macho.Type.String": {
        "descr": "",
        "name": "macho.Type.String",
        "params": [],
        "path": "go/debug/macho/index#Type.String",
        "syntax": "func (t Type) String() string",
        "type": "debug"
    },
    "mail.Address": {
        "descr": "Address represents a single mail address. An address such as \"Barry Gibbs <bg@example.com>\" is represented as Address{Name: \"Barry Gibbs\", Address: \"bg@example.com\"}.",
        "name": "mail.Address",
        "params": [],
        "path": "go/net/mail/index#Address",
        "syntax": "type Address struct { Name string // Proper name; may be empty. Address string // user@domain }",
        "type": "net/mail"
    },
    "mail.Address.String": {
        "descr": "String formats the address as a valid RFC 5322 address. If the address's name contains non-ASCII characters the name will be rendered according to RFC 2047.",
        "name": "mail.Address.String",
        "params": [],
        "path": "go/net/mail/index#Address.String",
        "syntax": "func (a *Address) String() string",
        "type": "net/mail"
    },
    "mail.AddressParser": {
        "descr": "An AddressParser is an RFC 5322 address parser.",
        "name": "mail.AddressParser",
        "params": [],
        "path": "go/net/mail/index#AddressParser",
        "syntax": "type AddressParser struct { // WordDecoder optionally specifies a decoder for RFC 2047 encoded-words. WordDecoder *mime.WordDecoder }",
        "type": "net/mail"
    },
    "mail.AddressParser.Parse": {
        "descr": "Parse parses a single RFC 5322 address of the form \"Gogh Fir <gf@example.com>\" or \"foo@example.com\".",
        "name": "mail.AddressParser.Parse",
        "params": [],
        "path": "go/net/mail/index#AddressParser.Parse",
        "syntax": "func (p *AddressParser) Parse(address string) (*Address, error)",
        "type": "net/mail"
    },
    "mail.AddressParser.ParseList": {
        "descr": "ParseList parses the given string as a list of comma-separated addresses of the form \"Gogh Fir <gf@example.com>\" or \"foo@example.com\".",
        "name": "mail.AddressParser.ParseList",
        "params": [],
        "path": "go/net/mail/index#AddressParser.ParseList",
        "syntax": "func (p *AddressParser) ParseList(list string) ([]*Address, error)",
        "type": "net/mail"
    },
    "mail.Header": {
        "descr": "A Header represents the key-value pairs in a mail message header.",
        "name": "mail.Header",
        "params": [],
        "path": "go/net/mail/index#Header",
        "syntax": "type Header map[string][]string",
        "type": "net/mail"
    },
    "mail.Header.AddressList": {
        "descr": "AddressList parses the named header field as a list of addresses.",
        "name": "mail.Header.AddressList",
        "params": [],
        "path": "go/net/mail/index#Header.AddressList",
        "syntax": "func (h Header) AddressList(key string) ([]*Address, error)",
        "type": "net/mail"
    },
    "mail.Header.Date": {
        "descr": "Date parses the Date header field.",
        "name": "mail.Header.Date",
        "params": [],
        "path": "go/net/mail/index#Header.Date",
        "syntax": "func (h Header) Date() (time.Time, error)",
        "type": "net/mail"
    },
    "mail.Header.Get": {
        "descr": "Get gets the first value associated with the given key. It is case insensitive; CanonicalMIMEHeaderKey is used to canonicalize the provided key. If there are no values associated with the key, Get returns \"\". To access multiple values of a key, or to use non-canonical keys, access the map directly.",
        "name": "mail.Header.Get",
        "params": [],
        "path": "go/net/mail/index#Header.Get",
        "syntax": "func (h Header) Get(key string) string",
        "type": "net/mail"
    },
    "mail.Message": {
        "descr": "A Message represents a parsed mail message.",
        "name": "mail.Message",
        "params": [],
        "path": "go/net/mail/index#Message",
        "syntax": "type Message struct { Header Header Body io.Reader }",
        "type": "net/mail"
    },
    "mail.ParseAddress": {
        "descr": "Parses a single RFC 5322 address, e.g. \"Barry Gibbs <bg@example.com>\"",
        "name": "mail.ParseAddress",
        "params": [],
        "path": "go/net/mail/index#ParseAddress",
        "syntax": "func ParseAddress(address string) (*Address, error)",
        "type": "net/mail"
    },
    "mail.ParseAddressList": {
        "descr": "ParseAddressList parses the given string as a list of addresses.",
        "name": "mail.ParseAddressList",
        "params": [],
        "path": "go/net/mail/index#ParseAddressList",
        "syntax": "func ParseAddressList(list string) ([]*Address, error)",
        "type": "net/mail"
    },
    "mail.ParseDate": {
        "descr": "ParseDate parses an RFC 5322 date string.",
        "name": "mail.ParseDate",
        "params": [],
        "path": "go/net/mail/index#ParseDate",
        "syntax": "func ParseDate(date string) (time.Time, error)",
        "type": "net/mail"
    },
    "mail.ReadMessage": {
        "descr": "ReadMessage reads a message from r. The headers are parsed, and the body of the message will be available for reading from msg.Body.",
        "name": "mail.ReadMessage",
        "params": [],
        "path": "go/net/mail/index#ReadMessage",
        "syntax": "func ReadMessage(r io.Reader) (msg *Message, err error)",
        "type": "net/mail"
    },
    "make": {
        "descr": "The make built-in function allocates and initializes an object of type slice, map, or chan (only). Like new, the first argument is a type, not a value. Unlike new, make's return type is the same as the type of its argument, not a pointer to it. The specification of the result depends on the type:",
        "name": "builtin.make",
        "params": [],
        "path": "go/builtin/index#make",
        "syntax": "func make(t Type, size ...IntegerType) Type",
        "type": "builtin"
    },
    "math": {
        "descr": "Mathematical constants.",
        "name": "math",
        "params": [],
        "path": "go/math/index#pkg-constants",
        "syntax": "const ( E = 2.71828182845904523536028747135266249775724709369995957496696763 // https://oeis.org/A001113 Pi = 3.14159265358979323846264338327950288419716939937510582097494459 // https://oeis.org/A000796 Phi = 1.61803398874989484820458683436563811772030917980576286213544862 // https://oeis.org/A001622 Sqrt2 = 1.41421356237309504880168872420969807856967187537694807317667974 // https://oeis.org/A002193 SqrtE = 1.64872127070012814684865078781416357165377610071014801157507931 // https://oeis.org/A019774 SqrtPi = 1.77245385090551602729816748334114518279754945612238712821380779 // https://oeis.org/A002161 SqrtPhi = 1.27201964951406896425242246173749149171560804184009624861664038 // https://oeis.org/A139339 Ln2 = 0.693147180559945309417232121458176568075500134360255254120680009 // https://oeis.org/A002162 Log2E = 1 / Ln2 Ln10 = 2.30258509299404568401799145468436420760110148862877297603332790 // https://oeis.org/A002392 Log10E = 1 / Ln10 )",
        "type": "math"
    },
    "math.Abs": {
        "descr": "Abs returns the absolute value of x.",
        "name": "math.Abs",
        "params": [],
        "path": "go/math/index#Abs",
        "syntax": "func Abs(x float64) float64",
        "type": "math"
    },
    "math.Acos": {
        "descr": "Acos returns the arccosine, in radians, of x.",
        "name": "math.Acos",
        "params": [],
        "path": "go/math/index#Acos",
        "syntax": "func Acos(x float64) float64",
        "type": "math"
    },
    "math.Acosh": {
        "descr": "Acosh returns the inverse hyperbolic cosine of x.",
        "name": "math.Acosh",
        "params": [],
        "path": "go/math/index#Acosh",
        "syntax": "func Acosh(x float64) float64",
        "type": "math"
    },
    "math.Asin": {
        "descr": "Asin returns the arcsine, in radians, of x.",
        "name": "math.Asin",
        "params": [],
        "path": "go/math/index#Asin",
        "syntax": "func Asin(x float64) float64",
        "type": "math"
    },
    "math.Asinh": {
        "descr": "Asinh returns the inverse hyperbolic sine of x.",
        "name": "math.Asinh",
        "params": [],
        "path": "go/math/index#Asinh",
        "syntax": "func Asinh(x float64) float64",
        "type": "math"
    },
    "math.Atan": {
        "descr": "Atan returns the arctangent, in radians, of x.",
        "name": "math.Atan",
        "params": [],
        "path": "go/math/index#Atan",
        "syntax": "func Atan(x float64) float64",
        "type": "math"
    },
    "math.Atan2": {
        "descr": "Atan2 returns the arc tangent of y/x, using the signs of the two to determine the quadrant of the return value.",
        "name": "math.Atan2",
        "params": [],
        "path": "go/math/index#Atan2",
        "syntax": "func Atan2(y, x float64) float64",
        "type": "math"
    },
    "math.Atanh": {
        "descr": "Atanh returns the inverse hyperbolic tangent of x.",
        "name": "math.Atanh",
        "params": [],
        "path": "go/math/index#Atanh",
        "syntax": "func Atanh(x float64) float64",
        "type": "math"
    },
    "math.Cbrt": {
        "descr": "Cbrt returns the cube root of x.",
        "name": "math.Cbrt",
        "params": [],
        "path": "go/math/index#Cbrt",
        "syntax": "func Cbrt(x float64) float64",
        "type": "math"
    },
    "math.Ceil": {
        "descr": "Ceil returns the least integer value greater than or equal to x.",
        "name": "math.Ceil",
        "params": [],
        "path": "go/math/index#Ceil",
        "syntax": "func Ceil(x float64) float64",
        "type": "math"
    },
    "math.Copysign": {
        "descr": "Copysign returns a value with the magnitude of x and the sign of y.",
        "name": "math.Copysign",
        "params": [],
        "path": "go/math/index#Copysign",
        "syntax": "func Copysign(x, y float64) float64",
        "type": "math"
    },
    "math.Cos": {
        "descr": "Cos returns the cosine of the radian argument x.",
        "name": "math.Cos",
        "params": [],
        "path": "go/math/index#Cos",
        "syntax": "func Cos(x float64) float64",
        "type": "math"
    },
    "math.Cosh": {
        "descr": "Cosh returns the hyperbolic cosine of x.",
        "name": "math.Cosh",
        "params": [],
        "path": "go/math/index#Cosh",
        "syntax": "func Cosh(x float64) float64",
        "type": "math"
    },
    "math.Dim": {
        "descr": "Dim returns the maximum of x-y or 0.",
        "name": "math.Dim",
        "params": [],
        "path": "go/math/index#Dim",
        "syntax": "func Dim(x, y float64) float64",
        "type": "math"
    },
    "math.Erf": {
        "descr": "Erf returns the error function of x.",
        "name": "math.Erf",
        "params": [],
        "path": "go/math/index#Erf",
        "syntax": "func Erf(x float64) float64",
        "type": "math"
    },
    "math.Erfc": {
        "descr": "Erfc returns the complementary error function of x.",
        "name": "math.Erfc",
        "params": [],
        "path": "go/math/index#Erfc",
        "syntax": "func Erfc(x float64) float64",
        "type": "math"
    },
    "math.Erfcinv": {
        "descr": "Erfcinv returns the inverse of Erfc(x).",
        "name": "math.Erfcinv",
        "params": [],
        "path": "go/math/index#Erfcinv",
        "syntax": "func Erfcinv(x float64) float64",
        "type": "math"
    },
    "math.Erfinv": {
        "descr": "Erfinv returns the inverse error function of x.",
        "name": "math.Erfinv",
        "params": [],
        "path": "go/math/index#Erfinv",
        "syntax": "func Erfinv(x float64) float64",
        "type": "math"
    },
    "math.Exp": {
        "descr": "Exp returns e**x, the base-e exponential of x.",
        "name": "math.Exp",
        "params": [],
        "path": "go/math/index#Exp",
        "syntax": "func Exp(x float64) float64",
        "type": "math"
    },
    "math.Exp2": {
        "descr": "Exp2 returns 2**x, the base-2 exponential of x.",
        "name": "math.Exp2",
        "params": [],
        "path": "go/math/index#Exp2",
        "syntax": "func Exp2(x float64) float64",
        "type": "math"
    },
    "math.Expm1": {
        "descr": "Expm1 returns e**x - 1, the base-e exponential of x minus 1. It is more accurate than Exp(x) - 1 when x is near zero.",
        "name": "math.Expm1",
        "params": [],
        "path": "go/math/index#Expm1",
        "syntax": "func Expm1(x float64) float64",
        "type": "math"
    },
    "math.Float32bits": {
        "descr": "Float32bits returns the IEEE 754 binary representation of f.",
        "name": "math.Float32bits",
        "params": [],
        "path": "go/math/index#Float32bits",
        "syntax": "func Float32bits(f float32) uint32",
        "type": "math"
    },
    "math.Float32frombits": {
        "descr": "Float32frombits returns the floating point number corresponding to the IEEE 754 binary representation b.",
        "name": "math.Float32frombits",
        "params": [],
        "path": "go/math/index#Float32frombits",
        "syntax": "func Float32frombits(b uint32) float32",
        "type": "math"
    },
    "math.Float64bits": {
        "descr": "Float64bits returns the IEEE 754 binary representation of f.",
        "name": "math.Float64bits",
        "params": [],
        "path": "go/math/index#Float64bits",
        "syntax": "func Float64bits(f float64) uint64",
        "type": "math"
    },
    "math.Float64frombits": {
        "descr": "Float64frombits returns the floating point number corresponding the IEEE 754 binary representation b.",
        "name": "math.Float64frombits",
        "params": [],
        "path": "go/math/index#Float64frombits",
        "syntax": "func Float64frombits(b uint64) float64",
        "type": "math"
    },
    "math.Floor": {
        "descr": "Floor returns the greatest integer value less than or equal to x.",
        "name": "math.Floor",
        "params": [],
        "path": "go/math/index#Floor",
        "syntax": "func Floor(x float64) float64",
        "type": "math"
    },
    "math.Frexp": {
        "descr": "Frexp breaks f into a normalized fraction and an integral power of two. It returns frac and exp satisfying f == frac  2**exp, with the absolute value of frac in the interval [, 1).",
        "name": "math.Frexp",
        "params": [],
        "path": "go/math/index#Frexp",
        "syntax": "func Frexp(f float64) (frac float64, exp int)",
        "type": "math"
    },
    "math.Gamma": {
        "descr": "Gamma returns the Gamma function of x.",
        "name": "math.Gamma",
        "params": [],
        "path": "go/math/index#Gamma",
        "syntax": "func Gamma(x float64) float64",
        "type": "math"
    },
    "math.Hypot": {
        "descr": "Hypot returns Sqrt(p*p + q*q), taking care to avoid unnecessary overflow and underflow.",
        "name": "math.Hypot",
        "params": [],
        "path": "go/math/index#Hypot",
        "syntax": "func Hypot(p, q float64) float64",
        "type": "math"
    },
    "math.Ilogb": {
        "descr": "Ilogb returns the binary exponent of x as an integer.",
        "name": "math.Ilogb",
        "params": [],
        "path": "go/math/index#Ilogb",
        "syntax": "func Ilogb(x float64) int",
        "type": "math"
    },
    "math.Inf": {
        "descr": "Inf returns positive infinity if sign >= 0, negative infinity if sign < 0.",
        "name": "math.Inf",
        "params": [],
        "path": "go/math/index#Inf",
        "syntax": "func Inf(sign int) float64",
        "type": "math"
    },
    "math.IsInf": {
        "descr": "IsInf reports whether f is an infinity, according to sign. If sign > 0, IsInf reports whether f is positive infinity. If sign < 0, IsInf reports whether f is negative infinity. If sign == 0, IsInf reports whether f is either infinity.",
        "name": "math.IsInf",
        "params": [],
        "path": "go/math/index#IsInf",
        "syntax": "func IsInf(f float64, sign int) bool",
        "type": "math"
    },
    "math.IsNaN": {
        "descr": "IsNaN reports whether f is an IEEE 754 not-a-number value.",
        "name": "math.IsNaN",
        "params": [],
        "path": "go/math/index#IsNaN",
        "syntax": "func IsNaN(f float64) (is bool)",
        "type": "math"
    },
    "math.J0": {
        "descr": "J0 returns the order-zero Bessel function of the first kind.",
        "name": "math.J0",
        "params": [],
        "path": "go/math/index#J0",
        "syntax": "func J0(x float64) float64",
        "type": "math"
    },
    "math.J1": {
        "descr": "J1 returns the order-one Bessel function of the first kind.",
        "name": "math.J1",
        "params": [],
        "path": "go/math/index#J1",
        "syntax": "func J1(x float64) float64",
        "type": "math"
    },
    "math.Jn": {
        "descr": "Jn returns the order-n Bessel function of the first kind.",
        "name": "math.Jn",
        "params": [],
        "path": "go/math/index#Jn",
        "syntax": "func Jn(n int, x float64) float64",
        "type": "math"
    },
    "math.Ldexp": {
        "descr": "Ldexp is the inverse of Frexp. It returns frac  2**exp.",
        "name": "math.Ldexp",
        "params": [],
        "path": "go/math/index#Ldexp",
        "syntax": "func Ldexp(frac float64, exp int) float64",
        "type": "math"
    },
    "math.Lgamma": {
        "descr": "Lgamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).",
        "name": "math.Lgamma",
        "params": [],
        "path": "go/math/index#Lgamma",
        "syntax": "func Lgamma(x float64) (lgamma float64, sign int)",
        "type": "math"
    },
    "math.Log": {
        "descr": "Log returns the natural logarithm of x.",
        "name": "math.Log",
        "params": [],
        "path": "go/math/index#Log",
        "syntax": "func Log(x float64) float64",
        "type": "math"
    },
    "math.Log10": {
        "descr": "Log10 returns the decimal logarithm of x. The special cases are the same as for Log.",
        "name": "math.Log10",
        "params": [],
        "path": "go/math/index#Log10",
        "syntax": "func Log10(x float64) float64",
        "type": "math"
    },
    "math.Log1p": {
        "descr": "Log1p returns the natural logarithm of 1 plus its argument x. It is more accurate than Log(1 + x) when x is near zero.",
        "name": "math.Log1p",
        "params": [],
        "path": "go/math/index#Log1p",
        "syntax": "func Log1p(x float64) float64",
        "type": "math"
    },
    "math.Log2": {
        "descr": "Log2 returns the binary logarithm of x. The special cases are the same as for Log.",
        "name": "math.Log2",
        "params": [],
        "path": "go/math/index#Log2",
        "syntax": "func Log2(x float64) float64",
        "type": "math"
    },
    "math.Logb": {
        "descr": "Logb returns the binary exponent of x.",
        "name": "math.Logb",
        "params": [],
        "path": "go/math/index#Logb",
        "syntax": "func Logb(x float64) float64",
        "type": "math"
    },
    "math.Max": {
        "descr": "Max returns the larger of x or y.",
        "name": "math.Max",
        "params": [],
        "path": "go/math/index#Max",
        "syntax": "func Max(x, y float64) float64",
        "type": "math"
    },
    "math.Min": {
        "descr": "Min returns the smaller of x or y.",
        "name": "math.Min",
        "params": [],
        "path": "go/math/index#Min",
        "syntax": "func Min(x, y float64) float64",
        "type": "math"
    },
    "math.Mod": {
        "descr": "Mod returns the floating-point remainder of x/y. The magnitude of the result is less than y and its sign agrees with that of x.",
        "name": "math.Mod",
        "params": [],
        "path": "go/math/index#Mod",
        "syntax": "func Mod(x, y float64) float64",
        "type": "math"
    },
    "math.Modf": {
        "descr": "Modf returns integer and fractional floating-point numbers that sum to f. Both values have the same sign as f.",
        "name": "math.Modf",
        "params": [],
        "path": "go/math/index#Modf",
        "syntax": "func Modf(f float64) (int float64, frac float64)",
        "type": "math"
    },
    "math.NaN": {
        "descr": "NaN returns an IEEE 754 not-a-number value.",
        "name": "math.NaN",
        "params": [],
        "path": "go/math/index#NaN",
        "syntax": "func NaN() float64",
        "type": "math"
    },
    "math.Nextafter": {
        "descr": "Nextafter returns the next representable float64 value after x towards y.",
        "name": "math.Nextafter",
        "params": [],
        "path": "go/math/index#Nextafter",
        "syntax": "func Nextafter(x, y float64) (r float64)",
        "type": "math"
    },
    "math.Nextafter32": {
        "descr": "Nextafter32 returns the next representable float32 value after x towards y.",
        "name": "math.Nextafter32",
        "params": [],
        "path": "go/math/index#Nextafter32",
        "syntax": "func Nextafter32(x, y float32) (r float32)",
        "type": "math"
    },
    "math.Pow": {
        "descr": "Pow returns x**y, the base-x exponential of y.",
        "name": "math.Pow",
        "params": [],
        "path": "go/math/index#Pow",
        "syntax": "func Pow(x, y float64) float64",
        "type": "math"
    },
    "math.Pow10": {
        "descr": "Pow10 returns 10**n, the base-10 exponential of n.",
        "name": "math.Pow10",
        "params": [],
        "path": "go/math/index#Pow10",
        "syntax": "func Pow10(n int) float64",
        "type": "math"
    },
    "math.Remainder": {
        "descr": "Remainder returns the IEEE 754 floating-point remainder of x/y.",
        "name": "math.Remainder",
        "params": [],
        "path": "go/math/index#Remainder",
        "syntax": "func Remainder(x, y float64) float64",
        "type": "math"
    },
    "math.Round": {
        "descr": "Round returns the nearest integer, rounding half away from zero.",
        "name": "math.Round",
        "params": [],
        "path": "go/math/index#Round",
        "syntax": "func Round(x float64) float64",
        "type": "math"
    },
    "math.RoundToEven": {
        "descr": "RoundToEven returns the nearest integer, rounding ties to even.",
        "name": "math.RoundToEven",
        "params": [],
        "path": "go/math/index#RoundToEven",
        "syntax": "func RoundToEven(x float64) float64",
        "type": "math"
    },
    "math.Signbit": {
        "descr": "Signbit returns true if x is negative or negative zero.",
        "name": "math.Signbit",
        "params": [],
        "path": "go/math/index#Signbit",
        "syntax": "func Signbit(x float64) bool",
        "type": "math"
    },
    "math.Sin": {
        "descr": "Sin returns the sine of the radian argument x.",
        "name": "math.Sin",
        "params": [],
        "path": "go/math/index#Sin",
        "syntax": "func Sin(x float64) float64",
        "type": "math"
    },
    "math.Sincos": {
        "descr": "Sincos returns Sin(x), Cos(x).",
        "name": "math.Sincos",
        "params": [],
        "path": "go/math/index#Sincos",
        "syntax": "func Sincos(x float64) (sin, cos float64)",
        "type": "math"
    },
    "math.Sinh": {
        "descr": "Sinh returns the hyperbolic sine of x.",
        "name": "math.Sinh",
        "params": [],
        "path": "go/math/index#Sinh",
        "syntax": "func Sinh(x float64) float64",
        "type": "math"
    },
    "math.Sqrt": {
        "descr": "Sqrt returns the square root of x.",
        "name": "math.Sqrt",
        "params": [],
        "path": "go/math/index#Sqrt",
        "syntax": "func Sqrt(x float64) float64",
        "type": "math"
    },
    "math.Tan": {
        "descr": "Tan returns the tangent of the radian argument x.",
        "name": "math.Tan",
        "params": [],
        "path": "go/math/index#Tan",
        "syntax": "func Tan(x float64) float64",
        "type": "math"
    },
    "math.Tanh": {
        "descr": "Tanh returns the hyperbolic tangent of x.",
        "name": "math.Tanh",
        "params": [],
        "path": "go/math/index#Tanh",
        "syntax": "func Tanh(x float64) float64",
        "type": "math"
    },
    "math.Trunc": {
        "descr": "Trunc returns the integer value of x.",
        "name": "math.Trunc",
        "params": [],
        "path": "go/math/index#Trunc",
        "syntax": "func Trunc(x float64) float64",
        "type": "math"
    },
    "math.Y0": {
        "descr": "Y0 returns the order-zero Bessel function of the second kind.",
        "name": "math.Y0",
        "params": [],
        "path": "go/math/index#Y0",
        "syntax": "func Y0(x float64) float64",
        "type": "math"
    },
    "math.Y1": {
        "descr": "Y1 returns the order-one Bessel function of the second kind.",
        "name": "math.Y1",
        "params": [],
        "path": "go/math/index#Y1",
        "syntax": "func Y1(x float64) float64",
        "type": "math"
    },
    "math.Yn": {
        "descr": "Yn returns the order-n Bessel function of the second kind.",
        "name": "math.Yn",
        "params": [],
        "path": "go/math/index#Yn",
        "syntax": "func Yn(n int, x float64) float64",
        "type": "math"
    },
    "md5.New": {
        "descr": "New returns a new hash.Hash computing the MD5 checksum. The Hash also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.",
        "name": "md5.New",
        "params": [],
        "path": "go/crypto/md5/index#New",
        "syntax": "func New() hash.Hash",
        "type": "crypto"
    },
    "md5.Sum": {
        "descr": "Sum returns the MD5 checksum of the data.",
        "name": "md5.Sum",
        "params": [],
        "path": "go/crypto/md5/index#Sum",
        "syntax": "func Sum(data []byte) [Size]byte",
        "type": "crypto"
    },
    "mime": {
        "descr": "ErrInvalidMediaParameter is returned by ParseMediaType if the media type value was found but there was an error parsing the optional parameters",
        "name": "mime",
        "params": [],
        "path": "go/mime/index#pkg-variables",
        "syntax": "var ErrInvalidMediaParameter = errors.New(\"mime: invalid media parameter\")",
        "type": "mime"
    },
    "mime.AddExtensionType": {
        "descr": "AddExtensionType sets the MIME type associated with the extension ext to typ. The extension should begin with a leading dot, as in \".html\".",
        "name": "mime.AddExtensionType",
        "params": [],
        "path": "go/mime/index#AddExtensionType",
        "syntax": "func AddExtensionType(ext, typ string) error",
        "type": "mime"
    },
    "mime.ExtensionsByType": {
        "descr": "ExtensionsByType returns the extensions known to be associated with the MIME type typ. The returned extensions will each begin with a leading dot, as in \".html\". When typ has no associated extensions, ExtensionsByType returns an nil slice.",
        "name": "mime.ExtensionsByType",
        "params": [],
        "path": "go/mime/index#ExtensionsByType",
        "syntax": "func ExtensionsByType(typ string) ([]string, error)",
        "type": "mime"
    },
    "mime.FormatMediaType": {
        "descr": "FormatMediaType serializes mediatype t and the parameters param as a media type conforming to RFC 2045 and RFC 2616. The type and parameter names are written in lower-case. When any of the arguments result in a standard violation then FormatMediaType returns the empty string.",
        "name": "mime.FormatMediaType",
        "params": [],
        "path": "go/mime/index#FormatMediaType",
        "syntax": "func FormatMediaType(t string, param map[string]string) string",
        "type": "mime"
    },
    "mime.TypeByExtension": {
        "descr": "TypeByExtension returns the MIME type associated with the file extension ext. The extension ext should begin with a leading dot, as in \".html\". When ext has no associated type, TypeByExtension returns \"\".",
        "name": "mime.TypeByExtension",
        "params": [],
        "path": "go/mime/index#TypeByExtension",
        "syntax": "func TypeByExtension(ext string) string",
        "type": "mime"
    },
    "mime.WordDecoder": {
        "descr": "A WordDecoder decodes MIME headers containing RFC 2047 encoded-words.",
        "name": "mime.WordDecoder",
        "params": [],
        "path": "go/mime/index#WordDecoder",
        "syntax": "type WordDecoder struct { // CharsetReader, if non-nil, defines a function to generate // charset-conversion readers, converting from the provided // charset into UTF-8. // Charsets are always lower-case. utf-8, iso-8859-1 and us-ascii charsets // are handled by default. // One of the CharsetReader's result values must be non-nil. CharsetReader func(charset string, input io.Reader) (io.Reader, error) }",
        "type": "mime"
    },
    "mime.WordDecoder.Decode": {
        "descr": "Decode decodes an RFC 2047 encoded-word.",
        "name": "mime.WordDecoder.Decode",
        "params": [],
        "path": "go/mime/index#WordDecoder.Decode",
        "syntax": "func (d *WordDecoder) Decode(word string) (string, error)",
        "type": "mime"
    },
    "mime.WordDecoder.DecodeHeader": {
        "descr": "DecodeHeader decodes all encoded-words of the given string. It returns an error if and only if CharsetReader of d returns an error.",
        "name": "mime.WordDecoder.DecodeHeader",
        "params": [],
        "path": "go/mime/index#WordDecoder.DecodeHeader",
        "syntax": "func (d *WordDecoder) DecodeHeader(header string) (string, error)",
        "type": "mime"
    },
    "mime.WordEncoder": {
        "descr": "A WordEncoder is an RFC 2047 encoded-word encoder.",
        "name": "mime.WordEncoder",
        "params": [],
        "path": "go/mime/index#WordEncoder",
        "syntax": "type WordEncoder byte",
        "type": "mime"
    },
    "mime.WordEncoder.Encode": {
        "descr": "Encode returns the encoded-word form of s. If s is ASCII without special characters, it is returned unchanged. The provided charset is the IANA charset name of s. It is case insensitive.",
        "name": "mime.WordEncoder.Encode",
        "params": [],
        "path": "go/mime/index#WordEncoder.Encode",
        "syntax": "func (e WordEncoder) Encode(charset, s string) string",
        "type": "mime"
    },
    "mime.string": {
        "descr": "ParseMediaType parses a media type value and any optional parameters, per RFC 1521. Media types are the values in Content-Type and Content-Disposition headers (RFC 2183). On success, ParseMediaType returns the media type converted to lowercase and trimmed of white space and a non-nil map. If there is an error parsing the optional parameter, the media type will be returned along with the error ErrInvalidMediaParameter. The returned map, params, maps from the lowercase attribute to the attribute value with its case preserved.",
        "name": "mime.string",
        "params": [],
        "path": "go/mime/index#ParseMediaType",
        "syntax": "func ParseMediaType(v string) (mediatype string, params map[string]string, err error)",
        "type": "mime"
    },
    "multipart.File": {
        "descr": "File is an interface to access the file part of a multipart message. Its contents may be either stored in memory or on disk. If stored on disk, the File's underlying concrete type will be an *os.File.",
        "name": "multipart.File",
        "params": [],
        "path": "go/mime/multipart/index#File",
        "syntax": "type File interface { io.Reader io.ReaderAt io.Seeker io.Closer }",
        "type": "mime"
    },
    "multipart.FileHeader": {
        "descr": "A FileHeader describes a file part of a multipart request.",
        "name": "multipart.FileHeader",
        "params": [],
        "path": "go/mime/multipart/index#FileHeader",
        "syntax": "type FileHeader struct { Filename string Header textproto.MIMEHeader Size int64 // Go 1.9 // contains filtered or unexported fields }",
        "type": "mime"
    },
    "multipart.FileHeader.Open": {
        "descr": "Open opens and returns the FileHeader's associated File.",
        "name": "multipart.FileHeader.Open",
        "params": [],
        "path": "go/mime/multipart/index#FileHeader.Open",
        "syntax": "func (fh *FileHeader) Open() (File, error)",
        "type": "mime"
    },
    "multipart.Form": {
        "descr": "Form is a parsed multipart form. Its File parts are stored either in memory or on disk, and are accessible via the *FileHeader's Open method. Its Value parts are stored as strings. Both are keyed by field name.",
        "name": "multipart.Form",
        "params": [],
        "path": "go/mime/multipart/index#Form",
        "syntax": "type Form struct { Value map[string][]string File map[string][]*FileHeader }",
        "type": "mime"
    },
    "multipart.Form.RemoveAll": {
        "descr": "RemoveAll removes any temporary files associated with a Form.",
        "name": "multipart.Form.RemoveAll",
        "params": [],
        "path": "go/mime/multipart/index#Form.RemoveAll",
        "syntax": "func (f *Form) RemoveAll() error",
        "type": "mime"
    },
    "multipart.NewReader": {
        "descr": "NewReader creates a new multipart Reader reading from r using the given MIME boundary.",
        "name": "multipart.NewReader",
        "params": [],
        "path": "go/mime/multipart/index#NewReader",
        "syntax": "func NewReader(r io.Reader, boundary string) *Reader",
        "type": "mime"
    },
    "multipart.NewWriter": {
        "descr": "NewWriter returns a new multipart Writer with a random boundary, writing to w.",
        "name": "multipart.NewWriter",
        "params": [],
        "path": "go/mime/multipart/index#NewWriter",
        "syntax": "func NewWriter(w io.Writer) *Writer",
        "type": "mime"
    },
    "multipart.Part": {
        "descr": "A Part represents a single part in a multipart body.",
        "name": "multipart.Part",
        "params": [],
        "path": "go/mime/multipart/index#Part",
        "syntax": "type Part struct { // The headers of the body, if any, with the keys canonicalized // in the same fashion that the Go http.Request headers are. // For example, \"foo-bar\" changes case to \"Foo-Bar\" // // As a special case, if the \"Content-Transfer-Encoding\" header // has a value of \"quoted-printable\", that header is instead // hidden from this map and the body is transparently decoded // during Read calls. Header textproto.MIMEHeader // contains filtered or unexported fields }",
        "type": "mime"
    },
    "multipart.Part.Close": {
        "descr": "",
        "name": "multipart.Part.Close",
        "params": [],
        "path": "go/mime/multipart/index#Part.Close",
        "syntax": "func (p *Part) Close() error",
        "type": "mime"
    },
    "multipart.Part.FileName": {
        "descr": "FileName returns the filename parameter of the Part's Content-Disposition header.",
        "name": "multipart.Part.FileName",
        "params": [],
        "path": "go/mime/multipart/index#Part.FileName",
        "syntax": "func (p *Part) FileName() string",
        "type": "mime"
    },
    "multipart.Part.FormName": {
        "descr": "FormName returns the name parameter if p has a Content-Disposition of type \"form-data\". Otherwise it returns the empty string.",
        "name": "multipart.Part.FormName",
        "params": [],
        "path": "go/mime/multipart/index#Part.FormName",
        "syntax": "func (p *Part) FormName() string",
        "type": "mime"
    },
    "multipart.Part.Read": {
        "descr": "Read reads the body of a part, after its headers and before the next part (if any) begins.",
        "name": "multipart.Part.Read",
        "params": [],
        "path": "go/mime/multipart/index#Part.Read",
        "syntax": "func (p *Part) Read(d []byte) (n int, err error)",
        "type": "mime"
    },
    "multipart.Reader": {
        "descr": "Reader is an iterator over parts in a MIME multipart body. Reader's underlying parser consumes its input as needed. Seeking isn't supported.",
        "name": "multipart.Reader",
        "params": [],
        "path": "go/mime/multipart/index#Reader",
        "syntax": "type Reader struct { // contains filtered or unexported fields }",
        "type": "mime"
    },
    "multipart.Reader.NextPart": {
        "descr": "NextPart returns the next part in the multipart or an error. When there are no more parts, the error io.EOF is returned.",
        "name": "multipart.Reader.NextPart",
        "params": [],
        "path": "go/mime/multipart/index#Reader.NextPart",
        "syntax": "func (r *Reader) NextPart() (*Part, error)",
        "type": "mime"
    },
    "multipart.Reader.ReadForm": {
        "descr": "ReadForm parses an entire multipart message whose parts have a Content-Disposition of \"form-data\". It stores up to maxMemory bytes + 10MB (reserved for non-file parts) in memory. File parts which can't be stored in memory will be stored on disk in temporary files. It returns ErrMessageTooLarge if all non-file parts can't be stored in memory.",
        "name": "multipart.Reader.ReadForm",
        "params": [],
        "path": "go/mime/multipart/index#Reader.ReadForm",
        "syntax": "func (r *Reader) ReadForm(maxMemory int64) (*Form, error)",
        "type": "mime"
    },
    "multipart.Writer": {
        "descr": "A Writer generates multipart messages.",
        "name": "multipart.Writer",
        "params": [],
        "path": "go/mime/multipart/index#Writer",
        "syntax": "type Writer struct { // contains filtered or unexported fields }",
        "type": "mime"
    },
    "multipart.Writer.Boundary": {
        "descr": "Boundary returns the Writer's boundary.",
        "name": "multipart.Writer.Boundary",
        "params": [],
        "path": "go/mime/multipart/index#Writer.Boundary",
        "syntax": "func (w *Writer) Boundary() string",
        "type": "mime"
    },
    "multipart.Writer.Close": {
        "descr": "Close finishes the multipart message and writes the trailing boundary end line to the output.",
        "name": "multipart.Writer.Close",
        "params": [],
        "path": "go/mime/multipart/index#Writer.Close",
        "syntax": "func (w *Writer) Close() error",
        "type": "mime"
    },
    "multipart.Writer.CreateFormField": {
        "descr": "CreateFormField calls CreatePart with a header using the given field name.",
        "name": "multipart.Writer.CreateFormField",
        "params": [],
        "path": "go/mime/multipart/index#Writer.CreateFormField",
        "syntax": "func (w *Writer) CreateFormField(fieldname string) (io.Writer, error)",
        "type": "mime"
    },
    "multipart.Writer.CreateFormFile": {
        "descr": "CreateFormFile is a convenience wrapper around CreatePart. It creates a new form-data header with the provided field name and file name.",
        "name": "multipart.Writer.CreateFormFile",
        "params": [],
        "path": "go/mime/multipart/index#Writer.CreateFormFile",
        "syntax": "func (w *Writer) CreateFormFile(fieldname, filename string) (io.Writer, error)",
        "type": "mime"
    },
    "multipart.Writer.CreatePart": {
        "descr": "CreatePart creates a new multipart section with the provided header. The body of the part should be written to the returned Writer. After calling CreatePart, any previous part may no longer be written to.",
        "name": "multipart.Writer.CreatePart",
        "params": [],
        "path": "go/mime/multipart/index#Writer.CreatePart",
        "syntax": "func (w *Writer) CreatePart(header textproto.MIMEHeader) (io.Writer, error)",
        "type": "mime"
    },
    "multipart.Writer.FormDataContentType": {
        "descr": "FormDataContentType returns the Content-Type for an HTTP multipart/form-data with this Writer's Boundary.",
        "name": "multipart.Writer.FormDataContentType",
        "params": [],
        "path": "go/mime/multipart/index#Writer.FormDataContentType",
        "syntax": "func (w *Writer) FormDataContentType() string",
        "type": "mime"
    },
    "multipart.Writer.SetBoundary": {
        "descr": "SetBoundary overrides the Writer's default randomly-generated boundary separator with an explicit value.",
        "name": "multipart.Writer.SetBoundary",
        "params": [],
        "path": "go/mime/multipart/index#Writer.SetBoundary",
        "syntax": "func (w *Writer) SetBoundary(boundary string) error",
        "type": "mime"
    },
    "multipart.Writer.WriteField": {
        "descr": "WriteField calls CreateFormField and then writes the given value.",
        "name": "multipart.Writer.WriteField",
        "params": [],
        "path": "go/mime/multipart/index#Writer.WriteField",
        "syntax": "func (w *Writer) WriteField(fieldname, value string) error",
        "type": "mime"
    },
    "net": {
        "descr": "Well-known IPv4 addresses",
        "name": "net",
        "params": [],
        "path": "go/net/index#pkg-variables",
        "syntax": "var ( IPv4bcast = IPv4(255, 255, 255, 255) // limited broadcast IPv4allsys = IPv4(224, 0, 0, 1) // all systems IPv4allrouter = IPv4(224, 0, 0, 2) // all routers IPv4zero = IPv4(0, 0, 0, 0) // all zeros )",
        "type": "net"
    },
    "net.Addr": {
        "descr": "Addr represents a network end point address.",
        "name": "net.Addr",
        "params": [],
        "path": "go/net/index#Addr",
        "syntax": "type Addr interface { Network() string // name of the network (for example, \"tcp\", \"udp\") String() string // string form of address (for example, \"192.0.2.1:25\", \"[2001:db8::1]:80\") }",
        "type": "net"
    },
    "net.AddrError": {
        "descr": "",
        "name": "net.AddrError",
        "params": [],
        "path": "go/net/index#AddrError",
        "syntax": "type AddrError struct { Err string Addr string }",
        "type": "net"
    },
    "net.AddrError.Error": {
        "descr": "",
        "name": "net.AddrError.Error",
        "params": [],
        "path": "go/net/index#AddrError.Error",
        "syntax": "func (e *AddrError) Error() string",
        "type": "net"
    },
    "net.AddrError.Temporary": {
        "descr": "",
        "name": "net.AddrError.Temporary",
        "params": [],
        "path": "go/net/index#AddrError.Temporary",
        "syntax": "func (e *AddrError) Temporary() bool",
        "type": "net"
    },
    "net.AddrError.Timeout": {
        "descr": "",
        "name": "net.AddrError.Timeout",
        "params": [],
        "path": "go/net/index#AddrError.Timeout",
        "syntax": "func (e *AddrError) Timeout() bool",
        "type": "net"
    },
    "net.Buffers": {
        "descr": "Buffers contains zero or more runs of bytes to write.",
        "name": "net.Buffers",
        "params": [],
        "path": "go/net/index#Buffers",
        "syntax": "type Buffers [][]byte",
        "type": "net"
    },
    "net.Buffers.Read": {
        "descr": "",
        "name": "net.Buffers.Read",
        "params": [],
        "path": "go/net/index#Buffers.Read",
        "syntax": "func (v *Buffers) Read(p []byte) (n int, err error)",
        "type": "net"
    },
    "net.Buffers.WriteTo": {
        "descr": "",
        "name": "net.Buffers.WriteTo",
        "params": [],
        "path": "go/net/index#Buffers.WriteTo",
        "syntax": "func (v *Buffers) WriteTo(w io.Writer) (n int64, err error)",
        "type": "net"
    },
    "net.CIDRMask": {
        "descr": "CIDRMask returns an IPMask consisting of `ones' 1 bits followed by 0s up to a total length of `bits' bits. For a mask of this form, CIDRMask is the inverse of IPMask.Size.",
        "name": "net.CIDRMask",
        "params": [],
        "path": "go/net/index#CIDRMask",
        "syntax": "func CIDRMask(ones, bits int) IPMask",
        "type": "net"
    },
    "net.Conn": {
        "descr": "Conn is a generic stream-oriented network connection.",
        "name": "net.Conn",
        "params": [],
        "path": "go/net/index#Conn",
        "syntax": "type Conn interface { // Read reads data from the connection. // Read can be made to time out and return an Error with Timeout() == true // after a fixed time limit; see SetDeadline and SetReadDeadline. Read(b []byte) (n int, err error) // Write writes data to the connection. // Write can be made to time out and return an Error with Timeout() == true // after a fixed time limit; see SetDeadline and SetWriteDeadline. Write(b []byte) (n int, err error) // Close closes the connection. // Any blocked Read or Write operations will be unblocked and return errors. Close() error // LocalAddr returns the local network address. LocalAddr() Addr // RemoteAddr returns the remote network address. RemoteAddr() Addr // SetDeadline sets the read and write deadlines associated // with the connection. It is equivalent to calling both // SetReadDeadline and SetWriteDeadline. // // A deadline is an absolute time after which I/O operations // fail with a timeout (see type Error) instead of // blocking. The deadline applies to all future and pending // I/O, not just the immediately following call to Read or // Write. After a deadline has been exceeded, the connection // can be refreshed by setting a deadline in the future. // // An idle timeout can be implemented by repeatedly extending // the deadline after successful Read or Write calls. // // A zero value for t means I/O operations will not time out. SetDeadline(t time.Time) error // SetReadDeadline sets the deadline for future Read calls // and any currently-blocked Read call. // A zero value for t means Read will not time out. SetReadDeadline(t time.Time) error // SetWriteDeadline sets the deadline for future Write calls // and any currently-blocked Write call. // Even if write times out, it may return n > 0, indicating that // some of the data was successfully written. // A zero value for t means Write will not time out. SetWriteDeadline(t time.Time) error }",
        "type": "net"
    },
    "net.DNSConfigError": {
        "descr": "DNSConfigError represents an error reading the machine's DNS configuration. (No longer used; kept for compatibility.)",
        "name": "net.DNSConfigError",
        "params": [],
        "path": "go/net/index#DNSConfigError",
        "syntax": "type DNSConfigError struct { Err error }",
        "type": "net"
    },
    "net.DNSConfigError.Error": {
        "descr": "",
        "name": "net.DNSConfigError.Error",
        "params": [],
        "path": "go/net/index#DNSConfigError.Error",
        "syntax": "func (e *DNSConfigError) Error() string",
        "type": "net"
    },
    "net.DNSConfigError.Temporary": {
        "descr": "",
        "name": "net.DNSConfigError.Temporary",
        "params": [],
        "path": "go/net/index#DNSConfigError.Temporary",
        "syntax": "func (e *DNSConfigError) Temporary() bool",
        "type": "net"
    },
    "net.DNSConfigError.Timeout": {
        "descr": "",
        "name": "net.DNSConfigError.Timeout",
        "params": [],
        "path": "go/net/index#DNSConfigError.Timeout",
        "syntax": "func (e *DNSConfigError) Timeout() bool",
        "type": "net"
    },
    "net.DNSError": {
        "descr": "DNSError represents a DNS lookup error.",
        "name": "net.DNSError",
        "params": [],
        "path": "go/net/index#DNSError",
        "syntax": "type DNSError struct { Err string // description of the error Name string // name looked for Server string // server used IsTimeout bool // if true, timed out; not all timeouts set this IsTemporary bool // if true, error is temporary; not all errors set this; added in Go 1.6 }",
        "type": "net"
    },
    "net.DNSError.Error": {
        "descr": "",
        "name": "net.DNSError.Error",
        "params": [],
        "path": "go/net/index#DNSError.Error",
        "syntax": "func (e *DNSError) Error() string",
        "type": "net"
    },
    "net.DNSError.Temporary": {
        "descr": "Temporary reports whether the DNS error is known to be temporary. This is not always known; a DNS lookup may fail due to a temporary error and return a DNSError for which Temporary returns false.",
        "name": "net.DNSError.Temporary",
        "params": [],
        "path": "go/net/index#DNSError.Temporary",
        "syntax": "func (e *DNSError) Temporary() bool",
        "type": "net"
    },
    "net.DNSError.Timeout": {
        "descr": "Timeout reports whether the DNS lookup is known to have timed out. This is not always known; a DNS lookup may fail due to a timeout and return a DNSError for which Timeout returns false.",
        "name": "net.DNSError.Timeout",
        "params": [],
        "path": "go/net/index#DNSError.Timeout",
        "syntax": "func (e *DNSError) Timeout() bool",
        "type": "net"
    },
    "net.Dial": {
        "descr": "Dial connects to the address on the named network.",
        "name": "net.Dial",
        "params": [],
        "path": "go/net/index#Dial",
        "syntax": "func Dial(network, address string) (Conn, error)",
        "type": "net"
    },
    "net.DialIP": {
        "descr": "DialIP acts like Dial for IP networks.",
        "name": "net.DialIP",
        "params": [],
        "path": "go/net/index#DialIP",
        "syntax": "func DialIP(network string, laddr, raddr *IPAddr) (*IPConn, error)",
        "type": "net"
    },
    "net.DialTCP": {
        "descr": "DialTCP acts like Dial for TCP networks.",
        "name": "net.DialTCP",
        "params": [],
        "path": "go/net/index#DialTCP",
        "syntax": "func DialTCP(network string, laddr, raddr *TCPAddr) (*TCPConn, error)",
        "type": "net"
    },
    "net.DialTimeout": {
        "descr": "DialTimeout acts like Dial but takes a timeout.",
        "name": "net.DialTimeout",
        "params": [],
        "path": "go/net/index#DialTimeout",
        "syntax": "func DialTimeout(network, address string, timeout time.Duration) (Conn, error)",
        "type": "net"
    },
    "net.DialUDP": {
        "descr": "DialUDP acts like Dial for UDP networks.",
        "name": "net.DialUDP",
        "params": [],
        "path": "go/net/index#DialUDP",
        "syntax": "func DialUDP(network string, laddr, raddr *UDPAddr) (*UDPConn, error)",
        "type": "net"
    },
    "net.DialUnix": {
        "descr": "DialUnix acts like Dial for Unix networks.",
        "name": "net.DialUnix",
        "params": [],
        "path": "go/net/index#DialUnix",
        "syntax": "func DialUnix(network string, laddr, raddr *UnixAddr) (*UnixConn, error)",
        "type": "net"
    },
    "net.Dialer": {
        "descr": "A Dialer contains options for connecting to an address.",
        "name": "net.Dialer",
        "params": [],
        "path": "go/net/index#Dialer",
        "syntax": "type Dialer struct { // Timeout is the maximum amount of time a dial will wait for // a connect to complete. If Deadline is also set, it may fail // earlier. // // The default is no timeout. // // When using TCP and dialing a host name with multiple IP // addresses, the timeout may be divided between them. // // With or without a timeout, the operating system may impose // its own earlier timeout. For instance, TCP timeouts are // often around 3 minutes. Timeout time.Duration // Deadline is the absolute point in time after which dials // will fail. If Timeout is set, it may fail earlier. // Zero means no deadline, or dependent on the operating system // as with the Timeout option. Deadline time.Time // LocalAddr is the local address to use when dialing an // address. The address must be of a compatible type for the // network being dialed. // If nil, a local address is automatically chosen. LocalAddr Addr // DualStack enables RFC 6555-compliant \"Happy Eyeballs\" // dialing when the network is \"tcp\" and the host in the // address parameter resolves to both IPv4 and IPv6 addresses. // This allows a client to tolerate networks where one address // family is silently broken. DualStack bool // Go 1.2 // FallbackDelay specifies the length of time to wait before // spawning a fallback connection, when DualStack is enabled. // If zero, a default delay of 300ms is used. FallbackDelay time.Duration // Go 1.5 // KeepAlive specifies the keep-alive period for an active // network connection. // If zero, keep-alives are not enabled. Network protocols // that do not support keep-alives ignore this field. KeepAlive time.Duration // Go 1.3 // Resolver optionally specifies an alternate resolver to use. Resolver *Resolver // Go 1.8 // Cancel is an optional channel whose closure indicates that // the dial should be canceled. Not all types of dials support // cancelation. // // Deprecated: Use DialContext instead. Cancel <-chan struct{} // Go 1.6 // If Control is not nil, it is called after creating the network // connection but before actually dialing. // // Network and address parameters passed to Control method are not // necessarily the ones passed to Dial. For example, passing \"tcp\" to Dial // will cause the Control function to be called with \"tcp4\" or \"tcp6\". Control func(network, address string, c syscall.RawConn) error // Go 1.11 }",
        "type": "net"
    },
    "net.Dialer.Dial": {
        "descr": "Dial connects to the address on the named network.",
        "name": "net.Dialer.Dial",
        "params": [],
        "path": "go/net/index#Dialer.Dial",
        "syntax": "func (d *Dialer) Dial(network, address string) (Conn, error)",
        "type": "net"
    },
    "net.Dialer.DialContext": {
        "descr": "DialContext connects to the address on the named network using the provided context.",
        "name": "net.Dialer.DialContext",
        "params": [],
        "path": "go/net/index#Dialer.DialContext",
        "syntax": "func (d *Dialer) DialContext(ctx context.Context, network, address string) (Conn, error)",
        "type": "net"
    },
    "net.Error": {
        "descr": "An Error represents a network error.",
        "name": "net.Error",
        "params": [],
        "path": "go/net/index#Error",
        "syntax": "type Error interface { error Timeout() bool // Is the error a timeout? Temporary() bool // Is the error temporary? }",
        "type": "net"
    },
    "net.FileConn": {
        "descr": "FileConn returns a copy of the network connection corresponding to the open file f. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.",
        "name": "net.FileConn",
        "params": [],
        "path": "go/net/index#FileConn",
        "syntax": "func FileConn(f *os.File) (c Conn, err error)",
        "type": "net"
    },
    "net.FileListener": {
        "descr": "FileListener returns a copy of the network listener corresponding to the open file f. It is the caller's responsibility to close ln when finished. Closing ln does not affect f, and closing f does not affect ln.",
        "name": "net.FileListener",
        "params": [],
        "path": "go/net/index#FileListener",
        "syntax": "func FileListener(f *os.File) (ln Listener, err error)",
        "type": "net"
    },
    "net.FilePacketConn": {
        "descr": "FilePacketConn returns a copy of the packet network connection corresponding to the open file f. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.",
        "name": "net.FilePacketConn",
        "params": [],
        "path": "go/net/index#FilePacketConn",
        "syntax": "func FilePacketConn(f *os.File) (c PacketConn, err error)",
        "type": "net"
    },
    "net.Flags": {
        "descr": "",
        "name": "net.Flags",
        "params": [],
        "path": "go/net/index#Flags",
        "syntax": "type Flags uint",
        "type": "net"
    },
    "net.Flags.String": {
        "descr": "",
        "name": "net.Flags.String",
        "params": [],
        "path": "go/net/index#Flags.String",
        "syntax": "func (f Flags) String() string",
        "type": "net"
    },
    "net.HardwareAddr": {
        "descr": "A HardwareAddr represents a physical hardware address.",
        "name": "net.HardwareAddr",
        "params": [],
        "path": "go/net/index#HardwareAddr",
        "syntax": "type HardwareAddr []byte",
        "type": "net"
    },
    "net.HardwareAddr.String": {
        "descr": "",
        "name": "net.HardwareAddr.String",
        "params": [],
        "path": "go/net/index#HardwareAddr.String",
        "syntax": "func (a HardwareAddr) String() string",
        "type": "net"
    },
    "net.IP": {
        "descr": "An IP is a single IP address, a slice of bytes. Functions in this package accept either 4-byte (IPv4) or 16-byte (IPv6) slices as input.",
        "name": "net.IP",
        "params": [],
        "path": "go/net/index#IP",
        "syntax": "type IP []byte",
        "type": "net"
    },
    "net.IP.DefaultMask": {
        "descr": "DefaultMask returns the default IP mask for the IP address ip. Only IPv4 addresses have default masks; DefaultMask returns nil if ip is not a valid IPv4 address.",
        "name": "net.IP.DefaultMask",
        "params": [],
        "path": "go/net/index#IP.DefaultMask",
        "syntax": "func (ip IP) DefaultMask() IPMask",
        "type": "net"
    },
    "net.IP.Equal": {
        "descr": "Equal reports whether ip and x are the same IP address. An IPv4 address and that same address in IPv6 form are considered to be equal.",
        "name": "net.IP.Equal",
        "params": [],
        "path": "go/net/index#IP.Equal",
        "syntax": "func (ip IP) Equal(x IP) bool",
        "type": "net"
    },
    "net.IP.IsGlobalUnicast": {
        "descr": "IsGlobalUnicast reports whether ip is a global unicast address.",
        "name": "net.IP.IsGlobalUnicast",
        "params": [],
        "path": "go/net/index#IP.IsGlobalUnicast",
        "syntax": "func (ip IP) IsGlobalUnicast() bool",
        "type": "net"
    },
    "net.IP.IsInterfaceLocalMulticast": {
        "descr": "IsInterfaceLocalMulticast reports whether ip is an interface-local multicast address.",
        "name": "net.IP.IsInterfaceLocalMulticast",
        "params": [],
        "path": "go/net/index#IP.IsInterfaceLocalMulticast",
        "syntax": "func (ip IP) IsInterfaceLocalMulticast() bool",
        "type": "net"
    },
    "net.IP.IsLinkLocalMulticast": {
        "descr": "IsLinkLocalMulticast reports whether ip is a link-local multicast address.",
        "name": "net.IP.IsLinkLocalMulticast",
        "params": [],
        "path": "go/net/index#IP.IsLinkLocalMulticast",
        "syntax": "func (ip IP) IsLinkLocalMulticast() bool",
        "type": "net"
    },
    "net.IP.IsLinkLocalUnicast": {
        "descr": "IsLinkLocalUnicast reports whether ip is a link-local unicast address.",
        "name": "net.IP.IsLinkLocalUnicast",
        "params": [],
        "path": "go/net/index#IP.IsLinkLocalUnicast",
        "syntax": "func (ip IP) IsLinkLocalUnicast() bool",
        "type": "net"
    },
    "net.IP.IsLoopback": {
        "descr": "IsLoopback reports whether ip is a loopback address.",
        "name": "net.IP.IsLoopback",
        "params": [],
        "path": "go/net/index#IP.IsLoopback",
        "syntax": "func (ip IP) IsLoopback() bool",
        "type": "net"
    },
    "net.IP.IsMulticast": {
        "descr": "IsMulticast reports whether ip is a multicast address.",
        "name": "net.IP.IsMulticast",
        "params": [],
        "path": "go/net/index#IP.IsMulticast",
        "syntax": "func (ip IP) IsMulticast() bool",
        "type": "net"
    },
    "net.IP.IsUnspecified": {
        "descr": "IsUnspecified reports whether ip is an unspecified address, either the IPv4 address \"0.0.0.0\" or the IPv6 address \"::\".",
        "name": "net.IP.IsUnspecified",
        "params": [],
        "path": "go/net/index#IP.IsUnspecified",
        "syntax": "func (ip IP) IsUnspecified() bool",
        "type": "net"
    },
    "net.IP.MarshalText": {
        "descr": "MarshalText implements the encoding.TextMarshaler interface. The encoding is the same as returned by String, with one exception: When len(ip) is zero, it returns an empty slice.",
        "name": "net.IP.MarshalText",
        "params": [],
        "path": "go/net/index#IP.MarshalText",
        "syntax": "func (ip IP) MarshalText() ([]byte, error)",
        "type": "net"
    },
    "net.IP.Mask": {
        "descr": "Mask returns the result of masking the IP address ip with mask.",
        "name": "net.IP.Mask",
        "params": [],
        "path": "go/net/index#IP.Mask",
        "syntax": "func (ip IP) Mask(mask IPMask) IP",
        "type": "net"
    },
    "net.IP.String": {
        "descr": "String returns the string form of the IP address ip. It returns one of 4 forms:",
        "name": "net.IP.String",
        "params": [],
        "path": "go/net/index#IP.String",
        "syntax": "func (ip IP) String() string",
        "type": "net"
    },
    "net.IP.To16": {
        "descr": "To16 converts the IP address ip to a 16-byte representation. If ip is not an IP address (it is the wrong length), To16 returns nil.",
        "name": "net.IP.To16",
        "params": [],
        "path": "go/net/index#IP.To16",
        "syntax": "func (ip IP) To16() IP",
        "type": "net"
    },
    "net.IP.To4": {
        "descr": "To4 converts the IPv4 address ip to a 4-byte representation. If ip is not an IPv4 address, To4 returns nil.",
        "name": "net.IP.To4",
        "params": [],
        "path": "go/net/index#IP.To4",
        "syntax": "func (ip IP) To4() IP",
        "type": "net"
    },
    "net.IP.UnmarshalText": {
        "descr": "UnmarshalText implements the encoding.TextUnmarshaler interface. The IP address is expected in a form accepted by ParseIP.",
        "name": "net.IP.UnmarshalText",
        "params": [],
        "path": "go/net/index#IP.UnmarshalText",
        "syntax": "func (ip *IP) UnmarshalText(text []byte) error",
        "type": "net"
    },
    "net.IPAddr": {
        "descr": "IPAddr represents the address of an IP end point.",
        "name": "net.IPAddr",
        "params": [],
        "path": "go/net/index#IPAddr",
        "syntax": "type IPAddr struct { IP IP Zone string // IPv6 scoped addressing zone; added in Go 1.1 }",
        "type": "net"
    },
    "net.IPAddr.Network": {
        "descr": "Network returns the address's network name, \"ip\".",
        "name": "net.IPAddr.Network",
        "params": [],
        "path": "go/net/index#IPAddr.Network",
        "syntax": "func (a *IPAddr) Network() string",
        "type": "net"
    },
    "net.IPAddr.String": {
        "descr": "",
        "name": "net.IPAddr.String",
        "params": [],
        "path": "go/net/index#IPAddr.String",
        "syntax": "func (a *IPAddr) String() string",
        "type": "net"
    },
    "net.IPConn": {
        "descr": "IPConn is the implementation of the Conn and PacketConn interfaces for IP network connections.",
        "name": "net.IPConn",
        "params": [],
        "path": "go/net/index#IPConn",
        "syntax": "type IPConn struct { // contains filtered or unexported fields }",
        "type": "net"
    },
    "net.IPConn.Close": {
        "descr": "Close closes the connection.",
        "name": "net.IPConn.Close",
        "params": [],
        "path": "go/net/index#IPConn.Close",
        "syntax": "func (c *IPConn) Close() error",
        "type": "net"
    },
    "net.IPConn.File": {
        "descr": "File returns a copy of the underlying os.File It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.",
        "name": "net.IPConn.File",
        "params": [],
        "path": "go/net/index#IPConn.File",
        "syntax": "func (c *IPConn) File() (f *os.File, err error)",
        "type": "net"
    },
    "net.IPConn.LocalAddr": {
        "descr": "LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it.",
        "name": "net.IPConn.LocalAddr",
        "params": [],
        "path": "go/net/index#IPConn.LocalAddr",
        "syntax": "func (c *IPConn) LocalAddr() Addr",
        "type": "net"
    },
    "net.IPConn.Read": {
        "descr": "Read implements the Conn Read method.",
        "name": "net.IPConn.Read",
        "params": [],
        "path": "go/net/index#IPConn.Read",
        "syntax": "func (c *IPConn) Read(b []byte) (int, error)",
        "type": "net"
    },
    "net.IPConn.ReadFrom": {
        "descr": "ReadFrom implements the PacketConn ReadFrom method.",
        "name": "net.IPConn.ReadFrom",
        "params": [],
        "path": "go/net/index#IPConn.ReadFrom",
        "syntax": "func (c *IPConn) ReadFrom(b []byte) (int, Addr, error)",
        "type": "net"
    },
    "net.IPConn.ReadFromIP": {
        "descr": "ReadFromIP acts like ReadFrom but returns an IPAddr.",
        "name": "net.IPConn.ReadFromIP",
        "params": [],
        "path": "go/net/index#IPConn.ReadFromIP",
        "syntax": "func (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error)",
        "type": "net"
    },
    "net.IPConn.ReadMsgIP": {
        "descr": "ReadMsgIP reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message.",
        "name": "net.IPConn.ReadMsgIP",
        "params": [],
        "path": "go/net/index#IPConn.ReadMsgIP",
        "syntax": "func (c *IPConn) ReadMsgIP(b, oob []byte) (n, oobn, flags int, addr *IPAddr, err error)",
        "type": "net"
    },
    "net.IPConn.RemoteAddr": {
        "descr": "RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it.",
        "name": "net.IPConn.RemoteAddr",
        "params": [],
        "path": "go/net/index#IPConn.RemoteAddr",
        "syntax": "func (c *IPConn) RemoteAddr() Addr",
        "type": "net"
    },
    "net.IPConn.SetDeadline": {
        "descr": "SetDeadline implements the Conn SetDeadline method.",
        "name": "net.IPConn.SetDeadline",
        "params": [],
        "path": "go/net/index#IPConn.SetDeadline",
        "syntax": "func (c *IPConn) SetDeadline(t time.Time) error",
        "type": "net"
    },
    "net.IPConn.SetReadBuffer": {
        "descr": "SetReadBuffer sets the size of the operating system's receive buffer associated with the connection.",
        "name": "net.IPConn.SetReadBuffer",
        "params": [],
        "path": "go/net/index#IPConn.SetReadBuffer",
        "syntax": "func (c *IPConn) SetReadBuffer(bytes int) error",
        "type": "net"
    },
    "net.IPConn.SetReadDeadline": {
        "descr": "SetReadDeadline implements the Conn SetReadDeadline method.",
        "name": "net.IPConn.SetReadDeadline",
        "params": [],
        "path": "go/net/index#IPConn.SetReadDeadline",
        "syntax": "func (c *IPConn) SetReadDeadline(t time.Time) error",
        "type": "net"
    },
    "net.IPConn.SetWriteBuffer": {
        "descr": "SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection.",
        "name": "net.IPConn.SetWriteBuffer",
        "params": [],
        "path": "go/net/index#IPConn.SetWriteBuffer",
        "syntax": "func (c *IPConn) SetWriteBuffer(bytes int) error",
        "type": "net"
    },
    "net.IPConn.SetWriteDeadline": {
        "descr": "SetWriteDeadline implements the Conn SetWriteDeadline method.",
        "name": "net.IPConn.SetWriteDeadline",
        "params": [],
        "path": "go/net/index#IPConn.SetWriteDeadline",
        "syntax": "func (c *IPConn) SetWriteDeadline(t time.Time) error",
        "type": "net"
    },
    "net.IPConn.SyscallConn": {
        "descr": "SyscallConn returns a raw network connection. This implements the syscall.Conn interface.",
        "name": "net.IPConn.SyscallConn",
        "params": [],
        "path": "go/net/index#IPConn.SyscallConn",
        "syntax": "func (c *IPConn) SyscallConn() (syscall.RawConn, error)",
        "type": "net"
    },
    "net.IPConn.Write": {
        "descr": "Write implements the Conn Write method.",
        "name": "net.IPConn.Write",
        "params": [],
        "path": "go/net/index#IPConn.Write",
        "syntax": "func (c *IPConn) Write(b []byte) (int, error)",
        "type": "net"
    },
    "net.IPConn.WriteMsgIP": {
        "descr": "WriteMsgIP writes a message to addr via c, copying the payload from b and the associated out-of-band data from oob. It returns the number of payload and out-of-band bytes written.",
        "name": "net.IPConn.WriteMsgIP",
        "params": [],
        "path": "go/net/index#IPConn.WriteMsgIP",
        "syntax": "func (c *IPConn) WriteMsgIP(b, oob []byte, addr *IPAddr) (n, oobn int, err error)",
        "type": "net"
    },
    "net.IPConn.WriteTo": {
        "descr": "WriteTo implements the PacketConn WriteTo method.",
        "name": "net.IPConn.WriteTo",
        "params": [],
        "path": "go/net/index#IPConn.WriteTo",
        "syntax": "func (c *IPConn) WriteTo(b []byte, addr Addr) (int, error)",
        "type": "net"
    },
    "net.IPConn.WriteToIP": {
        "descr": "WriteToIP acts like WriteTo but takes an IPAddr.",
        "name": "net.IPConn.WriteToIP",
        "params": [],
        "path": "go/net/index#IPConn.WriteToIP",
        "syntax": "func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (int, error)",
        "type": "net"
    },
    "net.IPMask": {
        "descr": "An IP mask is an IP address.",
        "name": "net.IPMask",
        "params": [],
        "path": "go/net/index#IPMask",
        "syntax": "type IPMask []byte",
        "type": "net"
    },
    "net.IPMask.Size": {
        "descr": "Size returns the number of leading ones and total bits in the mask. If the mask is not in the canonical form--ones followed by zeros--then Size returns 0, 0.",
        "name": "net.IPMask.Size",
        "params": [],
        "path": "go/net/index#IPMask.Size",
        "syntax": "func (m IPMask) Size() (ones, bits int)",
        "type": "net"
    },
    "net.IPMask.String": {
        "descr": "String returns the hexadecimal form of m, with no punctuation.",
        "name": "net.IPMask.String",
        "params": [],
        "path": "go/net/index#IPMask.String",
        "syntax": "func (m IPMask) String() string",
        "type": "net"
    },
    "net.IPNet": {
        "descr": "An IPNet represents an IP network.",
        "name": "net.IPNet",
        "params": [],
        "path": "go/net/index#IPNet",
        "syntax": "type IPNet struct { IP IP // network number Mask IPMask // network mask }",
        "type": "net"
    },
    "net.IPNet.Contains": {
        "descr": "Contains reports whether the network includes ip.",
        "name": "net.IPNet.Contains",
        "params": [],
        "path": "go/net/index#IPNet.Contains",
        "syntax": "func (n *IPNet) Contains(ip IP) bool",
        "type": "net"
    },
    "net.IPNet.Network": {
        "descr": "Network returns the address's network name, \"ip+net\".",
        "name": "net.IPNet.Network",
        "params": [],
        "path": "go/net/index#IPNet.Network",
        "syntax": "func (n *IPNet) Network() string",
        "type": "net"
    },
    "net.IPNet.String": {
        "descr": "String returns the CIDR notation of n like \"192.0.2.1/24\" or \"2001:db8::/48\" as defined in RFC 4632 and RFC 4291. If the mask is not in the canonical form, it returns the string which consists of an IP address, followed by a slash character and a mask expressed as hexadecimal form with no punctuation like \"198.51.100.1/c000ff00\".",
        "name": "net.IPNet.String",
        "params": [],
        "path": "go/net/index#IPNet.String",
        "syntax": "func (n *IPNet) String() string",
        "type": "net"
    },
    "net.IPv4": {
        "descr": "IPv4 returns the IP address (in 16-byte form) of the IPv4 address a.b.c.d.",
        "name": "net.IPv4",
        "params": [],
        "path": "go/net/index#IPv4",
        "syntax": "func IPv4(a, b, c, d byte) IP",
        "type": "net"
    },
    "net.IPv4Mask": {
        "descr": "IPv4Mask returns the IP mask (in 4-byte form) of the IPv4 mask a.b.c.d.",
        "name": "net.IPv4Mask",
        "params": [],
        "path": "go/net/index#IPv4Mask",
        "syntax": "func IPv4Mask(a, b, c, d byte) IPMask",
        "type": "net"
    },
    "net.Interface": {
        "descr": "Interface represents a mapping between network interface name and index. It also represents network interface facility information.",
        "name": "net.Interface",
        "params": [],
        "path": "go/net/index#Interface",
        "syntax": "type Interface struct { Index int // positive integer that starts at one, zero is never used MTU int // maximum transmission unit Name string // e.g., \"en0\", \"lo0\", \"eth0.100\" HardwareAddr HardwareAddr // IEEE MAC-48, EUI-48 and EUI-64 form Flags Flags // e.g., FlagUp, FlagLoopback, FlagMulticast }",
        "type": "net"
    },
    "net.Interface.Addrs": {
        "descr": "Addrs returns a list of unicast interface addresses for a specific interface.",
        "name": "net.Interface.Addrs",
        "params": [],
        "path": "go/net/index#Interface.Addrs",
        "syntax": "func (ifi *Interface) Addrs() ([]Addr, error)",
        "type": "net"
    },
    "net.Interface.MulticastAddrs": {
        "descr": "MulticastAddrs returns a list of multicast, joined group addresses for a specific interface.",
        "name": "net.Interface.MulticastAddrs",
        "params": [],
        "path": "go/net/index#Interface.MulticastAddrs",
        "syntax": "func (ifi *Interface) MulticastAddrs() ([]Addr, error)",
        "type": "net"
    },
    "net.InterfaceAddrs": {
        "descr": "InterfaceAddrs returns a list of the system's unicast interface addresses.",
        "name": "net.InterfaceAddrs",
        "params": [],
        "path": "go/net/index#InterfaceAddrs",
        "syntax": "func InterfaceAddrs() ([]Addr, error)",
        "type": "net"
    },
    "net.InterfaceByIndex": {
        "descr": "InterfaceByIndex returns the interface specified by index.",
        "name": "net.InterfaceByIndex",
        "params": [],
        "path": "go/net/index#InterfaceByIndex",
        "syntax": "func InterfaceByIndex(index int) (*Interface, error)",
        "type": "net"
    },
    "net.InterfaceByName": {
        "descr": "InterfaceByName returns the interface specified by name.",
        "name": "net.InterfaceByName",
        "params": [],
        "path": "go/net/index#InterfaceByName",
        "syntax": "func InterfaceByName(name string) (*Interface, error)",
        "type": "net"
    },
    "net.Interfaces": {
        "descr": "Interfaces returns a list of the system's network interfaces.",
        "name": "net.Interfaces",
        "params": [],
        "path": "go/net/index#Interfaces",
        "syntax": "func Interfaces() ([]Interface, error)",
        "type": "net"
    },
    "net.InvalidAddrError": {
        "descr": "",
        "name": "net.InvalidAddrError",
        "params": [],
        "path": "go/net/index#InvalidAddrError",
        "syntax": "type InvalidAddrError string",
        "type": "net"
    },
    "net.InvalidAddrError.Error": {
        "descr": "",
        "name": "net.InvalidAddrError.Error",
        "params": [],
        "path": "go/net/index#InvalidAddrError.Error",
        "syntax": "func (e InvalidAddrError) Error() string",
        "type": "net"
    },
    "net.InvalidAddrError.Temporary": {
        "descr": "",
        "name": "net.InvalidAddrError.Temporary",
        "params": [],
        "path": "go/net/index#InvalidAddrError.Temporary",
        "syntax": "func (e InvalidAddrError) Temporary() bool",
        "type": "net"
    },
    "net.InvalidAddrError.Timeout": {
        "descr": "",
        "name": "net.InvalidAddrError.Timeout",
        "params": [],
        "path": "go/net/index#InvalidAddrError.Timeout",
        "syntax": "func (e InvalidAddrError) Timeout() bool",
        "type": "net"
    },
    "net.JoinHostPort": {
        "descr": "JoinHostPort combines host and port into a network address of the form \"host:port\". If host contains a colon, as found in literal IPv6 addresses, then JoinHostPort returns \"[host]:port\".",
        "name": "net.JoinHostPort",
        "params": [],
        "path": "go/net/index#JoinHostPort",
        "syntax": "func JoinHostPort(host, port string) string",
        "type": "net"
    },
    "net.Listen": {
        "descr": "Listen announces on the local network address.",
        "name": "net.Listen",
        "params": [],
        "path": "go/net/index#Listen",
        "syntax": "func Listen(network, address string) (Listener, error)",
        "type": "net"
    },
    "net.ListenConfig": {
        "descr": "ListenConfig contains options for listening to an address.",
        "name": "net.ListenConfig",
        "params": [],
        "path": "go/net/index#ListenConfig",
        "syntax": "type ListenConfig struct { // If Control is not nil, it is called after creating the network // connection but before binding it to the operating system. // // Network and address parameters passed to Control method are not // necessarily the ones passed to Listen. For example, passing \"tcp\" to // Listen will cause the Control function to be called with \"tcp4\" or \"tcp6\". Control func(network, address string, c syscall.RawConn) error }",
        "type": "net"
    },
    "net.ListenConfig.Listen": {
        "descr": "Listen announces on the local network address.",
        "name": "net.ListenConfig.Listen",
        "params": [],
        "path": "go/net/index#ListenConfig.Listen",
        "syntax": "func (lc *ListenConfig) Listen(ctx context.Context, network, address string) (Listener, error)",
        "type": "net"
    },
    "net.ListenConfig.ListenPacket": {
        "descr": "ListenPacket announces on the local network address.",
        "name": "net.ListenConfig.ListenPacket",
        "params": [],
        "path": "go/net/index#ListenConfig.ListenPacket",
        "syntax": "func (lc *ListenConfig) ListenPacket(ctx context.Context, network, address string) (PacketConn, error)",
        "type": "net"
    },
    "net.ListenIP": {
        "descr": "ListenIP acts like ListenPacket for IP networks.",
        "name": "net.ListenIP",
        "params": [],
        "path": "go/net/index#ListenIP",
        "syntax": "func ListenIP(network string, laddr *IPAddr) (*IPConn, error)",
        "type": "net"
    },
    "net.ListenMulticastUDP": {
        "descr": "ListenMulticastUDP acts like ListenPacket for UDP networks but takes a group address on a specific network interface.",
        "name": "net.ListenMulticastUDP",
        "params": [],
        "path": "go/net/index#ListenMulticastUDP",
        "syntax": "func ListenMulticastUDP(network string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)",
        "type": "net"
    },
    "net.ListenPacket": {
        "descr": "ListenPacket announces on the local network address.",
        "name": "net.ListenPacket",
        "params": [],
        "path": "go/net/index#ListenPacket",
        "syntax": "func ListenPacket(network, address string) (PacketConn, error)",
        "type": "net"
    },
    "net.ListenTCP": {
        "descr": "ListenTCP acts like Listen for TCP networks.",
        "name": "net.ListenTCP",
        "params": [],
        "path": "go/net/index#ListenTCP",
        "syntax": "func ListenTCP(network string, laddr *TCPAddr) (*TCPListener, error)",
        "type": "net"
    },
    "net.ListenUDP": {
        "descr": "ListenUDP acts like ListenPacket for UDP networks.",
        "name": "net.ListenUDP",
        "params": [],
        "path": "go/net/index#ListenUDP",
        "syntax": "func ListenUDP(network string, laddr *UDPAddr) (*UDPConn, error)",
        "type": "net"
    },
    "net.ListenUnix": {
        "descr": "ListenUnix acts like Listen for Unix networks.",
        "name": "net.ListenUnix",
        "params": [],
        "path": "go/net/index#ListenUnix",
        "syntax": "func ListenUnix(network string, laddr *UnixAddr) (*UnixListener, error)",
        "type": "net"
    },
    "net.ListenUnixgram": {
        "descr": "ListenUnixgram acts like ListenPacket for Unix networks.",
        "name": "net.ListenUnixgram",
        "params": [],
        "path": "go/net/index#ListenUnixgram",
        "syntax": "func ListenUnixgram(network string, laddr *UnixAddr) (*UnixConn, error)",
        "type": "net"
    },
    "net.Listener": {
        "descr": "A Listener is a generic network listener for stream-oriented protocols.",
        "name": "net.Listener",
        "params": [],
        "path": "go/net/index#Listener",
        "syntax": "type Listener interface { // Accept waits for and returns the next connection to the listener. Accept() (Conn, error) // Close closes the listener. // Any blocked Accept operations will be unblocked and return errors. Close() error // Addr returns the listener's network address. Addr() Addr }",
        "type": "net"
    },
    "net.LookupAddr": {
        "descr": "LookupAddr performs a reverse lookup for the given address, returning a list of names mapping to that address.",
        "name": "net.LookupAddr",
        "params": [],
        "path": "go/net/index#LookupAddr",
        "syntax": "func LookupAddr(addr string) (names []string, err error)",
        "type": "net"
    },
    "net.LookupCNAME": {
        "descr": "LookupCNAME returns the canonical name for the given host. Callers that do not care about the canonical name can call LookupHost or LookupIP directly; both take care of resolving the canonical name as part of the lookup.",
        "name": "net.LookupCNAME",
        "params": [],
        "path": "go/net/index#LookupCNAME",
        "syntax": "func LookupCNAME(host string) (cname string, err error)",
        "type": "net"
    },
    "net.LookupHost": {
        "descr": "LookupHost looks up the given host using the local resolver. It returns a slice of that host's addresses.",
        "name": "net.LookupHost",
        "params": [],
        "path": "go/net/index#LookupHost",
        "syntax": "func LookupHost(host string) (addrs []string, err error)",
        "type": "net"
    },
    "net.LookupIP": {
        "descr": "LookupIP looks up host using the local resolver. It returns a slice of that host's IPv4 and IPv6 addresses.",
        "name": "net.LookupIP",
        "params": [],
        "path": "go/net/index#LookupIP",
        "syntax": "func LookupIP(host string) ([]IP, error)",
        "type": "net"
    },
    "net.LookupMX": {
        "descr": "LookupMX returns the DNS MX records for the given domain name sorted by preference.",
        "name": "net.LookupMX",
        "params": [],
        "path": "go/net/index#LookupMX",
        "syntax": "func LookupMX(name string) ([]*MX, error)",
        "type": "net"
    },
    "net.LookupNS": {
        "descr": "LookupNS returns the DNS NS records for the given domain name.",
        "name": "net.LookupNS",
        "params": [],
        "path": "go/net/index#LookupNS",
        "syntax": "func LookupNS(name string) ([]*NS, error)",
        "type": "net"
    },
    "net.LookupPort": {
        "descr": "LookupPort looks up the port for the given network and service.",
        "name": "net.LookupPort",
        "params": [],
        "path": "go/net/index#LookupPort",
        "syntax": "func LookupPort(network, service string) (port int, err error)",
        "type": "net"
    },
    "net.LookupSRV": {
        "descr": "LookupSRV tries to resolve an SRV query of the given service, protocol, and domain name. The proto is \"tcp\" or \"udp\". The returned records are sorted by priority and randomized by weight within a priority.",
        "name": "net.LookupSRV",
        "params": [],
        "path": "go/net/index#LookupSRV",
        "syntax": "func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error)",
        "type": "net"
    },
    "net.LookupTXT": {
        "descr": "LookupTXT returns the DNS TXT records for the given domain name.",
        "name": "net.LookupTXT",
        "params": [],
        "path": "go/net/index#LookupTXT",
        "syntax": "func LookupTXT(name string) ([]string, error)",
        "type": "net"
    },
    "net.MX": {
        "descr": "An MX represents a single DNS MX record.",
        "name": "net.MX",
        "params": [],
        "path": "go/net/index#MX",
        "syntax": "type MX struct { Host string Pref uint16 }",
        "type": "net"
    },
    "net.NS": {
        "descr": "An NS represents a single DNS NS record.",
        "name": "net.NS",
        "params": [],
        "path": "go/net/index#NS",
        "syntax": "type NS struct { Host string }",
        "type": "net"
    },
    "net.OpError": {
        "descr": "OpError is the error type usually returned by functions in the net package. It describes the operation, network type, and address of an error.",
        "name": "net.OpError",
        "params": [],
        "path": "go/net/index#OpError",
        "syntax": "type OpError struct { // Op is the operation which caused the error, such as // \"read\" or \"write\". Op string // Net is the network type on which this error occurred, // such as \"tcp\" or \"udp6\". Net string // For operations involving a remote network connection, like // Dial, Read, or Write, Source is the corresponding local // network address. Source Addr // Go 1.5 // Addr is the network address for which this error occurred. // For local operations, like Listen or SetDeadline, Addr is // the address of the local endpoint being manipulated. // For operations involving a remote network connection, like // Dial, Read, or Write, Addr is the remote address of that // connection. Addr Addr // Err is the error that occurred during the operation. Err error }",
        "type": "net"
    },
    "net.OpError.Error": {
        "descr": "",
        "name": "net.OpError.Error",
        "params": [],
        "path": "go/net/index#OpError.Error",
        "syntax": "func (e *OpError) Error() string",
        "type": "net"
    },
    "net.OpError.Temporary": {
        "descr": "",
        "name": "net.OpError.Temporary",
        "params": [],
        "path": "go/net/index#OpError.Temporary",
        "syntax": "func (e *OpError) Temporary() bool",
        "type": "net"
    },
    "net.OpError.Timeout": {
        "descr": "",
        "name": "net.OpError.Timeout",
        "params": [],
        "path": "go/net/index#OpError.Timeout",
        "syntax": "func (e *OpError) Timeout() bool",
        "type": "net"
    },
    "net.PacketConn": {
        "descr": "PacketConn is a generic packet-oriented network connection.",
        "name": "net.PacketConn",
        "params": [],
        "path": "go/net/index#PacketConn",
        "syntax": "type PacketConn interface { // ReadFrom reads a packet from the connection, // copying the payload into p. It returns the number of // bytes copied into p and the return address that // was on the packet. // It returns the number of bytes read (0 <= n <= len(p)) // and any error encountered. Callers should always process // the n > 0 bytes returned before considering the error err. // ReadFrom can be made to time out and return // an Error with Timeout() == true after a fixed time limit; // see SetDeadline and SetReadDeadline. ReadFrom(p []byte) (n int, addr Addr, err error) // WriteTo writes a packet with payload p to addr. // WriteTo can be made to time out and return // an Error with Timeout() == true after a fixed time limit; // see SetDeadline and SetWriteDeadline. // On packet-oriented connections, write timeouts are rare. WriteTo(p []byte, addr Addr) (n int, err error) // Close closes the connection. // Any blocked ReadFrom or WriteTo operations will be unblocked and return errors. Close() error // LocalAddr returns the local network address. LocalAddr() Addr // SetDeadline sets the read and write deadlines associated // with the connection. It is equivalent to calling both // SetReadDeadline and SetWriteDeadline. // // A deadline is an absolute time after which I/O operations // fail with a timeout (see type Error) instead of // blocking. The deadline applies to all future and pending // I/O, not just the immediately following call to ReadFrom or // WriteTo. After a deadline has been exceeded, the connection // can be refreshed by setting a deadline in the future. // // An idle timeout can be implemented by repeatedly extending // the deadline after successful ReadFrom or WriteTo calls. // // A zero value for t means I/O operations will not time out. SetDeadline(t time.Time) error // SetReadDeadline sets the deadline for future ReadFrom calls // and any currently-blocked ReadFrom call. // A zero value for t means ReadFrom will not time out. SetReadDeadline(t time.Time) error // SetWriteDeadline sets the deadline for future WriteTo calls // and any currently-blocked WriteTo call. // Even if write times out, it may return n > 0, indicating that // some of the data was successfully written. // A zero value for t means WriteTo will not time out. SetWriteDeadline(t time.Time) error }",
        "type": "net"
    },
    "net.ParseCIDR": {
        "descr": "ParseCIDR parses s as a CIDR notation IP address and prefix length, like \"192.0.2.0/24\" or \"2001:db8::/32\", as defined in RFC 4632 and RFC 4291.",
        "name": "net.ParseCIDR",
        "params": [],
        "path": "go/net/index#ParseCIDR",
        "syntax": "func ParseCIDR(s string) (IP, *IPNet, error)",
        "type": "net"
    },
    "net.ParseError": {
        "descr": "A ParseError is the error type of literal network address parsers.",
        "name": "net.ParseError",
        "params": [],
        "path": "go/net/index#ParseError",
        "syntax": "type ParseError struct { // Type is the type of string that was expected, such as // \"IP address\", \"CIDR address\". Type string // Text is the malformed text string. Text string }",
        "type": "net"
    },
    "net.ParseError.Error": {
        "descr": "",
        "name": "net.ParseError.Error",
        "params": [],
        "path": "go/net/index#ParseError.Error",
        "syntax": "func (e *ParseError) Error() string",
        "type": "net"
    },
    "net.ParseIP": {
        "descr": "ParseIP parses s as an IP address, returning the result. The string s can be in dotted decimal (\"192.0.2.1\") or IPv6 (\"2001:db8::68\") form. If s is not a valid textual representation of an IP address, ParseIP returns nil.",
        "name": "net.ParseIP",
        "params": [],
        "path": "go/net/index#ParseIP",
        "syntax": "func ParseIP(s string) IP",
        "type": "net"
    },
    "net.ParseMAC": {
        "descr": "ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet IP over InfiniBand link-layer address using one of the following formats:",
        "name": "net.ParseMAC",
        "params": [],
        "path": "go/net/index#ParseMAC",
        "syntax": "func ParseMAC(s string) (hw HardwareAddr, err error)",
        "type": "net"
    },
    "net.Pipe": {
        "descr": "Pipe creates a synchronous, in-memory, full duplex network connection; both ends implement the Conn interface. Reads on one end are matched with writes on the other, copying data directly between the two; there is no internal buffering.",
        "name": "net.Pipe",
        "params": [],
        "path": "go/net/index#Pipe",
        "syntax": "func Pipe() (Conn, Conn)",
        "type": "net"
    },
    "net.ResolveIPAddr": {
        "descr": "ResolveIPAddr returns an address of IP end point.",
        "name": "net.ResolveIPAddr",
        "params": [],
        "path": "go/net/index#ResolveIPAddr",
        "syntax": "func ResolveIPAddr(network, address string) (*IPAddr, error)",
        "type": "net"
    },
    "net.ResolveTCPAddr": {
        "descr": "ResolveTCPAddr returns an address of TCP end point.",
        "name": "net.ResolveTCPAddr",
        "params": [],
        "path": "go/net/index#ResolveTCPAddr",
        "syntax": "func ResolveTCPAddr(network, address string) (*TCPAddr, error)",
        "type": "net"
    },
    "net.ResolveUDPAddr": {
        "descr": "ResolveUDPAddr returns an address of UDP end point.",
        "name": "net.ResolveUDPAddr",
        "params": [],
        "path": "go/net/index#ResolveUDPAddr",
        "syntax": "func ResolveUDPAddr(network, address string) (*UDPAddr, error)",
        "type": "net"
    },
    "net.ResolveUnixAddr": {
        "descr": "ResolveUnixAddr returns an address of Unix domain socket end point.",
        "name": "net.ResolveUnixAddr",
        "params": [],
        "path": "go/net/index#ResolveUnixAddr",
        "syntax": "func ResolveUnixAddr(network, address string) (*UnixAddr, error)",
        "type": "net"
    },
    "net.Resolver": {
        "descr": "A Resolver looks up names and numbers.",
        "name": "net.Resolver",
        "params": [],
        "path": "go/net/index#Resolver",
        "syntax": "type Resolver struct { // PreferGo controls whether Go's built-in DNS resolver is preferred // on platforms where it's available. It is equivalent to setting // GODEBUG=netdns=go, but scoped to just this resolver. PreferGo bool // StrictErrors controls the behavior of temporary errors // (including timeout, socket errors, and SERVFAIL) when using // Go's built-in resolver. For a query composed of multiple // sub-queries (such as an A+AAAA address lookup, or walking the // DNS search list), this option causes such errors to abort the // whole query instead of returning a partial result. This is // not enabled by default because it may affect compatibility // with resolvers that process AAAA queries incorrectly. StrictErrors bool // Go 1.9 // Dial optionally specifies an alternate dialer for use by // Go's built-in DNS resolver to make TCP and UDP connections // to DNS services. The host in the address parameter will // always be a literal IP address and not a host name, and the // port in the address parameter will be a literal port number // and not a service name. // If the Conn returned is also a PacketConn, sent and received DNS // messages must adhere to RFC 1035 section 4.2.1, \"UDP usage\". // Otherwise, DNS messages transmitted over Conn must adhere // to RFC 7766 section 5, \"Transport Protocol Selection\". // If nil, the default dialer is used. Dial func(ctx context.Context, network, address string) (Conn, error) // Go 1.9 // contains filtered or unexported fields }",
        "type": "net"
    },
    "net.Resolver.LookupAddr": {
        "descr": "LookupAddr performs a reverse lookup for the given address, returning a list of names mapping to that address.",
        "name": "net.Resolver.LookupAddr",
        "params": [],
        "path": "go/net/index#Resolver.LookupAddr",
        "syntax": "func (r *Resolver) LookupAddr(ctx context.Context, addr string) (names []string, err error)",
        "type": "net"
    },
    "net.Resolver.LookupCNAME": {
        "descr": "LookupCNAME returns the canonical name for the given host. Callers that do not care about the canonical name can call LookupHost or LookupIP directly; both take care of resolving the canonical name as part of the lookup.",
        "name": "net.Resolver.LookupCNAME",
        "params": [],
        "path": "go/net/index#Resolver.LookupCNAME",
        "syntax": "func (r *Resolver) LookupCNAME(ctx context.Context, host string) (cname string, err error)",
        "type": "net"
    },
    "net.Resolver.LookupHost": {
        "descr": "LookupHost looks up the given host using the local resolver. It returns a slice of that host's addresses.",
        "name": "net.Resolver.LookupHost",
        "params": [],
        "path": "go/net/index#Resolver.LookupHost",
        "syntax": "func (r *Resolver) LookupHost(ctx context.Context, host string) (addrs []string, err error)",
        "type": "net"
    },
    "net.Resolver.LookupIPAddr": {
        "descr": "LookupIPAddr looks up host using the local resolver. It returns a slice of that host's IPv4 and IPv6 addresses.",
        "name": "net.Resolver.LookupIPAddr",
        "params": [],
        "path": "go/net/index#Resolver.LookupIPAddr",
        "syntax": "func (r *Resolver) LookupIPAddr(ctx context.Context, host string) ([]IPAddr, error)",
        "type": "net"
    },
    "net.Resolver.LookupMX": {
        "descr": "LookupMX returns the DNS MX records for the given domain name sorted by preference.",
        "name": "net.Resolver.LookupMX",
        "params": [],
        "path": "go/net/index#Resolver.LookupMX",
        "syntax": "func (r *Resolver) LookupMX(ctx context.Context, name string) ([]*MX, error)",
        "type": "net"
    },
    "net.Resolver.LookupNS": {
        "descr": "LookupNS returns the DNS NS records for the given domain name.",
        "name": "net.Resolver.LookupNS",
        "params": [],
        "path": "go/net/index#Resolver.LookupNS",
        "syntax": "func (r *Resolver) LookupNS(ctx context.Context, name string) ([]*NS, error)",
        "type": "net"
    },
    "net.Resolver.LookupPort": {
        "descr": "LookupPort looks up the port for the given network and service.",
        "name": "net.Resolver.LookupPort",
        "params": [],
        "path": "go/net/index#Resolver.LookupPort",
        "syntax": "func (r *Resolver) LookupPort(ctx context.Context, network, service string) (port int, err error)",
        "type": "net"
    },
    "net.Resolver.LookupSRV": {
        "descr": "LookupSRV tries to resolve an SRV query of the given service, protocol, and domain name. The proto is \"tcp\" or \"udp\". The returned records are sorted by priority and randomized by weight within a priority.",
        "name": "net.Resolver.LookupSRV",
        "params": [],
        "path": "go/net/index#Resolver.LookupSRV",
        "syntax": "func (r *Resolver) LookupSRV(ctx context.Context, service, proto, name string) (cname string, addrs []*SRV, err error)",
        "type": "net"
    },
    "net.Resolver.LookupTXT": {
        "descr": "LookupTXT returns the DNS TXT records for the given domain name.",
        "name": "net.Resolver.LookupTXT",
        "params": [],
        "path": "go/net/index#Resolver.LookupTXT",
        "syntax": "func (r *Resolver) LookupTXT(ctx context.Context, name string) ([]string, error)",
        "type": "net"
    },
    "net.SRV": {
        "descr": "An SRV represents a single DNS SRV record.",
        "name": "net.SRV",
        "params": [],
        "path": "go/net/index#SRV",
        "syntax": "type SRV struct { Target string Port uint16 Priority uint16 Weight uint16 }",
        "type": "net"
    },
    "net.SplitHostPort": {
        "descr": "SplitHostPort splits a network address of the form \"host:port\", \"host%zone:port\", \"[host]:port\" or \"[host%zone]:port\" into host or host%zone and port.",
        "name": "net.SplitHostPort",
        "params": [],
        "path": "go/net/index#SplitHostPort",
        "syntax": "func SplitHostPort(hostport string) (host, port string, err error)",
        "type": "net"
    },
    "net.TCPAddr": {
        "descr": "TCPAddr represents the address of a TCP end point.",
        "name": "net.TCPAddr",
        "params": [],
        "path": "go/net/index#TCPAddr",
        "syntax": "type TCPAddr struct { IP IP Port int Zone string // IPv6 scoped addressing zone; added in Go 1.1 }",
        "type": "net"
    },
    "net.TCPAddr.Network": {
        "descr": "Network returns the address's network name, \"tcp\".",
        "name": "net.TCPAddr.Network",
        "params": [],
        "path": "go/net/index#TCPAddr.Network",
        "syntax": "func (a *TCPAddr) Network() string",
        "type": "net"
    },
    "net.TCPAddr.String": {
        "descr": "",
        "name": "net.TCPAddr.String",
        "params": [],
        "path": "go/net/index#TCPAddr.String",
        "syntax": "func (a *TCPAddr) String() string",
        "type": "net"
    },
    "net.TCPConn": {
        "descr": "TCPConn is an implementation of the Conn interface for TCP network connections.",
        "name": "net.TCPConn",
        "params": [],
        "path": "go/net/index#TCPConn",
        "syntax": "type TCPConn struct { // contains filtered or unexported fields }",
        "type": "net"
    },
    "net.TCPConn.Close": {
        "descr": "Close closes the connection.",
        "name": "net.TCPConn.Close",
        "params": [],
        "path": "go/net/index#TCPConn.Close",
        "syntax": "func (c *TCPConn) Close() error",
        "type": "net"
    },
    "net.TCPConn.CloseRead": {
        "descr": "CloseRead shuts down the reading side of the TCP connection. Most callers should just use Close.",
        "name": "net.TCPConn.CloseRead",
        "params": [],
        "path": "go/net/index#TCPConn.CloseRead",
        "syntax": "func (c *TCPConn) CloseRead() error",
        "type": "net"
    },
    "net.TCPConn.CloseWrite": {
        "descr": "CloseWrite shuts down the writing side of the TCP connection. Most callers should just use Close.",
        "name": "net.TCPConn.CloseWrite",
        "params": [],
        "path": "go/net/index#TCPConn.CloseWrite",
        "syntax": "func (c *TCPConn) CloseWrite() error",
        "type": "net"
    },
    "net.TCPConn.File": {
        "descr": "File returns a copy of the underlying os.File It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.",
        "name": "net.TCPConn.File",
        "params": [],
        "path": "go/net/index#TCPConn.File",
        "syntax": "func (c *TCPConn) File() (f *os.File, err error)",
        "type": "net"
    },
    "net.TCPConn.LocalAddr": {
        "descr": "LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it.",
        "name": "net.TCPConn.LocalAddr",
        "params": [],
        "path": "go/net/index#TCPConn.LocalAddr",
        "syntax": "func (c *TCPConn) LocalAddr() Addr",
        "type": "net"
    },
    "net.TCPConn.Read": {
        "descr": "Read implements the Conn Read method.",
        "name": "net.TCPConn.Read",
        "params": [],
        "path": "go/net/index#TCPConn.Read",
        "syntax": "func (c *TCPConn) Read(b []byte) (int, error)",
        "type": "net"
    },
    "net.TCPConn.ReadFrom": {
        "descr": "ReadFrom implements the io.ReaderFrom ReadFrom method.",
        "name": "net.TCPConn.ReadFrom",
        "params": [],
        "path": "go/net/index#TCPConn.ReadFrom",
        "syntax": "func (c *TCPConn) ReadFrom(r io.Reader) (int64, error)",
        "type": "net"
    },
    "net.TCPConn.RemoteAddr": {
        "descr": "RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it.",
        "name": "net.TCPConn.RemoteAddr",
        "params": [],
        "path": "go/net/index#TCPConn.RemoteAddr",
        "syntax": "func (c *TCPConn) RemoteAddr() Addr",
        "type": "net"
    },
    "net.TCPConn.SetDeadline": {
        "descr": "SetDeadline implements the Conn SetDeadline method.",
        "name": "net.TCPConn.SetDeadline",
        "params": [],
        "path": "go/net/index#TCPConn.SetDeadline",
        "syntax": "func (c *TCPConn) SetDeadline(t time.Time) error",
        "type": "net"
    },
    "net.TCPConn.SetKeepAlive": {
        "descr": "SetKeepAlive sets whether the operating system should send keepalive messages on the connection.",
        "name": "net.TCPConn.SetKeepAlive",
        "params": [],
        "path": "go/net/index#TCPConn.SetKeepAlive",
        "syntax": "func (c *TCPConn) SetKeepAlive(keepalive bool) error",
        "type": "net"
    },
    "net.TCPConn.SetKeepAlivePeriod": {
        "descr": "SetKeepAlivePeriod sets period between keep alives.",
        "name": "net.TCPConn.SetKeepAlivePeriod",
        "params": [],
        "path": "go/net/index#TCPConn.SetKeepAlivePeriod",
        "syntax": "func (c *TCPConn) SetKeepAlivePeriod(d time.Duration) error",
        "type": "net"
    },
    "net.TCPConn.SetLinger": {
        "descr": "SetLinger sets the behavior of Close on a connection which still has data waiting to be sent or to be acknowledged.",
        "name": "net.TCPConn.SetLinger",
        "params": [],
        "path": "go/net/index#TCPConn.SetLinger",
        "syntax": "func (c *TCPConn) SetLinger(sec int) error",
        "type": "net"
    },
    "net.TCPConn.SetNoDelay": {
        "descr": "SetNoDelay controls whether the operating system should delay packet transmission in hopes of sending fewer packets (Nagle's algorithm). The default is true (no delay), meaning that data is sent as soon as possible after a Write.",
        "name": "net.TCPConn.SetNoDelay",
        "params": [],
        "path": "go/net/index#TCPConn.SetNoDelay",
        "syntax": "func (c *TCPConn) SetNoDelay(noDelay bool) error",
        "type": "net"
    },
    "net.TCPConn.SetReadBuffer": {
        "descr": "SetReadBuffer sets the size of the operating system's receive buffer associated with the connection.",
        "name": "net.TCPConn.SetReadBuffer",
        "params": [],
        "path": "go/net/index#TCPConn.SetReadBuffer",
        "syntax": "func (c *TCPConn) SetReadBuffer(bytes int) error",
        "type": "net"
    },
    "net.TCPConn.SetReadDeadline": {
        "descr": "SetReadDeadline implements the Conn SetReadDeadline method.",
        "name": "net.TCPConn.SetReadDeadline",
        "params": [],
        "path": "go/net/index#TCPConn.SetReadDeadline",
        "syntax": "func (c *TCPConn) SetReadDeadline(t time.Time) error",
        "type": "net"
    },
    "net.TCPConn.SetWriteBuffer": {
        "descr": "SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection.",
        "name": "net.TCPConn.SetWriteBuffer",
        "params": [],
        "path": "go/net/index#TCPConn.SetWriteBuffer",
        "syntax": "func (c *TCPConn) SetWriteBuffer(bytes int) error",
        "type": "net"
    },
    "net.TCPConn.SetWriteDeadline": {
        "descr": "SetWriteDeadline implements the Conn SetWriteDeadline method.",
        "name": "net.TCPConn.SetWriteDeadline",
        "params": [],
        "path": "go/net/index#TCPConn.SetWriteDeadline",
        "syntax": "func (c *TCPConn) SetWriteDeadline(t time.Time) error",
        "type": "net"
    },
    "net.TCPConn.SyscallConn": {
        "descr": "SyscallConn returns a raw network connection. This implements the syscall.Conn interface.",
        "name": "net.TCPConn.SyscallConn",
        "params": [],
        "path": "go/net/index#TCPConn.SyscallConn",
        "syntax": "func (c *TCPConn) SyscallConn() (syscall.RawConn, error)",
        "type": "net"
    },
    "net.TCPConn.Write": {
        "descr": "Write implements the Conn Write method.",
        "name": "net.TCPConn.Write",
        "params": [],
        "path": "go/net/index#TCPConn.Write",
        "syntax": "func (c *TCPConn) Write(b []byte) (int, error)",
        "type": "net"
    },
    "net.TCPListener": {
        "descr": "TCPListener is a TCP network listener. Clients should typically use variables of type Listener instead of assuming TCP.",
        "name": "net.TCPListener",
        "params": [],
        "path": "go/net/index#TCPListener",
        "syntax": "type TCPListener struct { // contains filtered or unexported fields }",
        "type": "net"
    },
    "net.TCPListener.Accept": {
        "descr": "Accept implements the Accept method in the Listener interface; it waits for the next call and returns a generic Conn.",
        "name": "net.TCPListener.Accept",
        "params": [],
        "path": "go/net/index#TCPListener.Accept",
        "syntax": "func (l *TCPListener) Accept() (Conn, error)",
        "type": "net"
    },
    "net.TCPListener.AcceptTCP": {
        "descr": "AcceptTCP accepts the next incoming call and returns the new connection.",
        "name": "net.TCPListener.AcceptTCP",
        "params": [],
        "path": "go/net/index#TCPListener.AcceptTCP",
        "syntax": "func (l *TCPListener) AcceptTCP() (*TCPConn, error)",
        "type": "net"
    },
    "net.TCPListener.Addr": {
        "descr": "Addr returns the listener's network address, a *TCPAddr. The Addr returned is shared by all invocations of Addr, so do not modify it.",
        "name": "net.TCPListener.Addr",
        "params": [],
        "path": "go/net/index#TCPListener.Addr",
        "syntax": "func (l *TCPListener) Addr() Addr",
        "type": "net"
    },
    "net.TCPListener.Close": {
        "descr": "Close stops listening on the TCP address. Already Accepted connections are not closed.",
        "name": "net.TCPListener.Close",
        "params": [],
        "path": "go/net/index#TCPListener.Close",
        "syntax": "func (l *TCPListener) Close() error",
        "type": "net"
    },
    "net.TCPListener.File": {
        "descr": "File returns a copy of the underlying os.File. It is the caller's responsibility to close f when finished. Closing l does not affect f, and closing f does not affect l.",
        "name": "net.TCPListener.File",
        "params": [],
        "path": "go/net/index#TCPListener.File",
        "syntax": "func (l *TCPListener) File() (f *os.File, err error)",
        "type": "net"
    },
    "net.TCPListener.SetDeadline": {
        "descr": "SetDeadline sets the deadline associated with the listener. A zero time value disables the deadline.",
        "name": "net.TCPListener.SetDeadline",
        "params": [],
        "path": "go/net/index#TCPListener.SetDeadline",
        "syntax": "func (l *TCPListener) SetDeadline(t time.Time) error",
        "type": "net"
    },
    "net.TCPListener.SyscallConn": {
        "descr": "SyscallConn returns a raw network connection. This implements the syscall.Conn interface.",
        "name": "net.TCPListener.SyscallConn",
        "params": [],
        "path": "go/net/index#TCPListener.SyscallConn",
        "syntax": "func (l *TCPListener) SyscallConn() (syscall.RawConn, error)",
        "type": "net"
    },
    "net.UDPAddr": {
        "descr": "UDPAddr represents the address of a UDP end point.",
        "name": "net.UDPAddr",
        "params": [],
        "path": "go/net/index#UDPAddr",
        "syntax": "type UDPAddr struct { IP IP Port int Zone string // IPv6 scoped addressing zone; added in Go 1.1 }",
        "type": "net"
    },
    "net.UDPAddr.Network": {
        "descr": "Network returns the address's network name, \"udp\".",
        "name": "net.UDPAddr.Network",
        "params": [],
        "path": "go/net/index#UDPAddr.Network",
        "syntax": "func (a *UDPAddr) Network() string",
        "type": "net"
    },
    "net.UDPAddr.String": {
        "descr": "",
        "name": "net.UDPAddr.String",
        "params": [],
        "path": "go/net/index#UDPAddr.String",
        "syntax": "func (a *UDPAddr) String() string",
        "type": "net"
    },
    "net.UDPConn": {
        "descr": "UDPConn is the implementation of the Conn and PacketConn interfaces for UDP network connections.",
        "name": "net.UDPConn",
        "params": [],
        "path": "go/net/index#UDPConn",
        "syntax": "type UDPConn struct { // contains filtered or unexported fields }",
        "type": "net"
    },
    "net.UDPConn.Close": {
        "descr": "Close closes the connection.",
        "name": "net.UDPConn.Close",
        "params": [],
        "path": "go/net/index#UDPConn.Close",
        "syntax": "func (c *UDPConn) Close() error",
        "type": "net"
    },
    "net.UDPConn.File": {
        "descr": "File returns a copy of the underlying os.File It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.",
        "name": "net.UDPConn.File",
        "params": [],
        "path": "go/net/index#UDPConn.File",
        "syntax": "func (c *UDPConn) File() (f *os.File, err error)",
        "type": "net"
    },
    "net.UDPConn.LocalAddr": {
        "descr": "LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it.",
        "name": "net.UDPConn.LocalAddr",
        "params": [],
        "path": "go/net/index#UDPConn.LocalAddr",
        "syntax": "func (c *UDPConn) LocalAddr() Addr",
        "type": "net"
    },
    "net.UDPConn.Read": {
        "descr": "Read implements the Conn Read method.",
        "name": "net.UDPConn.Read",
        "params": [],
        "path": "go/net/index#UDPConn.Read",
        "syntax": "func (c *UDPConn) Read(b []byte) (int, error)",
        "type": "net"
    },
    "net.UDPConn.ReadFrom": {
        "descr": "ReadFrom implements the PacketConn ReadFrom method.",
        "name": "net.UDPConn.ReadFrom",
        "params": [],
        "path": "go/net/index#UDPConn.ReadFrom",
        "syntax": "func (c *UDPConn) ReadFrom(b []byte) (int, Addr, error)",
        "type": "net"
    },
    "net.UDPConn.ReadFromUDP": {
        "descr": "ReadFromUDP acts like ReadFrom but returns a UDPAddr.",
        "name": "net.UDPConn.ReadFromUDP",
        "params": [],
        "path": "go/net/index#UDPConn.ReadFromUDP",
        "syntax": "func (c *UDPConn) ReadFromUDP(b []byte) (int, *UDPAddr, error)",
        "type": "net"
    },
    "net.UDPConn.ReadMsgUDP": {
        "descr": "ReadMsgUDP reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message.",
        "name": "net.UDPConn.ReadMsgUDP",
        "params": [],
        "path": "go/net/index#UDPConn.ReadMsgUDP",
        "syntax": "func (c *UDPConn) ReadMsgUDP(b, oob []byte) (n, oobn, flags int, addr *UDPAddr, err error)",
        "type": "net"
    },
    "net.UDPConn.RemoteAddr": {
        "descr": "RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it.",
        "name": "net.UDPConn.RemoteAddr",
        "params": [],
        "path": "go/net/index#UDPConn.RemoteAddr",
        "syntax": "func (c *UDPConn) RemoteAddr() Addr",
        "type": "net"
    },
    "net.UDPConn.SetDeadline": {
        "descr": "SetDeadline implements the Conn SetDeadline method.",
        "name": "net.UDPConn.SetDeadline",
        "params": [],
        "path": "go/net/index#UDPConn.SetDeadline",
        "syntax": "func (c *UDPConn) SetDeadline(t time.Time) error",
        "type": "net"
    },
    "net.UDPConn.SetReadBuffer": {
        "descr": "SetReadBuffer sets the size of the operating system's receive buffer associated with the connection.",
        "name": "net.UDPConn.SetReadBuffer",
        "params": [],
        "path": "go/net/index#UDPConn.SetReadBuffer",
        "syntax": "func (c *UDPConn) SetReadBuffer(bytes int) error",
        "type": "net"
    },
    "net.UDPConn.SetReadDeadline": {
        "descr": "SetReadDeadline implements the Conn SetReadDeadline method.",
        "name": "net.UDPConn.SetReadDeadline",
        "params": [],
        "path": "go/net/index#UDPConn.SetReadDeadline",
        "syntax": "func (c *UDPConn) SetReadDeadline(t time.Time) error",
        "type": "net"
    },
    "net.UDPConn.SetWriteBuffer": {
        "descr": "SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection.",
        "name": "net.UDPConn.SetWriteBuffer",
        "params": [],
        "path": "go/net/index#UDPConn.SetWriteBuffer",
        "syntax": "func (c *UDPConn) SetWriteBuffer(bytes int) error",
        "type": "net"
    },
    "net.UDPConn.SetWriteDeadline": {
        "descr": "SetWriteDeadline implements the Conn SetWriteDeadline method.",
        "name": "net.UDPConn.SetWriteDeadline",
        "params": [],
        "path": "go/net/index#UDPConn.SetWriteDeadline",
        "syntax": "func (c *UDPConn) SetWriteDeadline(t time.Time) error",
        "type": "net"
    },
    "net.UDPConn.SyscallConn": {
        "descr": "SyscallConn returns a raw network connection. This implements the syscall.Conn interface.",
        "name": "net.UDPConn.SyscallConn",
        "params": [],
        "path": "go/net/index#UDPConn.SyscallConn",
        "syntax": "func (c *UDPConn) SyscallConn() (syscall.RawConn, error)",
        "type": "net"
    },
    "net.UDPConn.Write": {
        "descr": "Write implements the Conn Write method.",
        "name": "net.UDPConn.Write",
        "params": [],
        "path": "go/net/index#UDPConn.Write",
        "syntax": "func (c *UDPConn) Write(b []byte) (int, error)",
        "type": "net"
    },
    "net.UDPConn.WriteMsgUDP": {
        "descr": "WriteMsgUDP writes a message to addr via c if c isn't connected, or to c's remote address if c is connected (in which case addr must be nil). The payload is copied from b and the associated out-of-band data is copied from oob. It returns the number of payload and out-of-band bytes written.",
        "name": "net.UDPConn.WriteMsgUDP",
        "params": [],
        "path": "go/net/index#UDPConn.WriteMsgUDP",
        "syntax": "func (c *UDPConn) WriteMsgUDP(b, oob []byte, addr *UDPAddr) (n, oobn int, err error)",
        "type": "net"
    },
    "net.UDPConn.WriteTo": {
        "descr": "WriteTo implements the PacketConn WriteTo method.",
        "name": "net.UDPConn.WriteTo",
        "params": [],
        "path": "go/net/index#UDPConn.WriteTo",
        "syntax": "func (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error)",
        "type": "net"
    },
    "net.UDPConn.WriteToUDP": {
        "descr": "WriteToUDP acts like WriteTo but takes a UDPAddr.",
        "name": "net.UDPConn.WriteToUDP",
        "params": [],
        "path": "go/net/index#UDPConn.WriteToUDP",
        "syntax": "func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error)",
        "type": "net"
    },
    "net.UnixAddr": {
        "descr": "UnixAddr represents the address of a Unix domain socket end point.",
        "name": "net.UnixAddr",
        "params": [],
        "path": "go/net/index#UnixAddr",
        "syntax": "type UnixAddr struct { Name string Net string }",
        "type": "net"
    },
    "net.UnixAddr.Network": {
        "descr": "Network returns the address's network name, \"unix\", \"unixgram\" or \"unixpacket\".",
        "name": "net.UnixAddr.Network",
        "params": [],
        "path": "go/net/index#UnixAddr.Network",
        "syntax": "func (a *UnixAddr) Network() string",
        "type": "net"
    },
    "net.UnixAddr.String": {
        "descr": "",
        "name": "net.UnixAddr.String",
        "params": [],
        "path": "go/net/index#UnixAddr.String",
        "syntax": "func (a *UnixAddr) String() string",
        "type": "net"
    },
    "net.UnixConn": {
        "descr": "UnixConn is an implementation of the Conn interface for connections to Unix domain sockets.",
        "name": "net.UnixConn",
        "params": [],
        "path": "go/net/index#UnixConn",
        "syntax": "type UnixConn struct { // contains filtered or unexported fields }",
        "type": "net"
    },
    "net.UnixConn.Close": {
        "descr": "Close closes the connection.",
        "name": "net.UnixConn.Close",
        "params": [],
        "path": "go/net/index#UnixConn.Close",
        "syntax": "func (c *UnixConn) Close() error",
        "type": "net"
    },
    "net.UnixConn.CloseRead": {
        "descr": "CloseRead shuts down the reading side of the Unix domain connection. Most callers should just use Close.",
        "name": "net.UnixConn.CloseRead",
        "params": [],
        "path": "go/net/index#UnixConn.CloseRead",
        "syntax": "func (c *UnixConn) CloseRead() error",
        "type": "net"
    },
    "net.UnixConn.CloseWrite": {
        "descr": "CloseWrite shuts down the writing side of the Unix domain connection. Most callers should just use Close.",
        "name": "net.UnixConn.CloseWrite",
        "params": [],
        "path": "go/net/index#UnixConn.CloseWrite",
        "syntax": "func (c *UnixConn) CloseWrite() error",
        "type": "net"
    },
    "net.UnixConn.File": {
        "descr": "File returns a copy of the underlying os.File It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c.",
        "name": "net.UnixConn.File",
        "params": [],
        "path": "go/net/index#UnixConn.File",
        "syntax": "func (c *UnixConn) File() (f *os.File, err error)",
        "type": "net"
    },
    "net.UnixConn.LocalAddr": {
        "descr": "LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it.",
        "name": "net.UnixConn.LocalAddr",
        "params": [],
        "path": "go/net/index#UnixConn.LocalAddr",
        "syntax": "func (c *UnixConn) LocalAddr() Addr",
        "type": "net"
    },
    "net.UnixConn.Read": {
        "descr": "Read implements the Conn Read method.",
        "name": "net.UnixConn.Read",
        "params": [],
        "path": "go/net/index#UnixConn.Read",
        "syntax": "func (c *UnixConn) Read(b []byte) (int, error)",
        "type": "net"
    },
    "net.UnixConn.ReadFrom": {
        "descr": "ReadFrom implements the PacketConn ReadFrom method.",
        "name": "net.UnixConn.ReadFrom",
        "params": [],
        "path": "go/net/index#UnixConn.ReadFrom",
        "syntax": "func (c *UnixConn) ReadFrom(b []byte) (int, Addr, error)",
        "type": "net"
    },
    "net.UnixConn.ReadFromUnix": {
        "descr": "ReadFromUnix acts like ReadFrom but returns a UnixAddr.",
        "name": "net.UnixConn.ReadFromUnix",
        "params": [],
        "path": "go/net/index#UnixConn.ReadFromUnix",
        "syntax": "func (c *UnixConn) ReadFromUnix(b []byte) (int, *UnixAddr, error)",
        "type": "net"
    },
    "net.UnixConn.ReadMsgUnix": {
        "descr": "ReadMsgUnix reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message.",
        "name": "net.UnixConn.ReadMsgUnix",
        "params": [],
        "path": "go/net/index#UnixConn.ReadMsgUnix",
        "syntax": "func (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err error)",
        "type": "net"
    },
    "net.UnixConn.RemoteAddr": {
        "descr": "RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it.",
        "name": "net.UnixConn.RemoteAddr",
        "params": [],
        "path": "go/net/index#UnixConn.RemoteAddr",
        "syntax": "func (c *UnixConn) RemoteAddr() Addr",
        "type": "net"
    },
    "net.UnixConn.SetDeadline": {
        "descr": "SetDeadline implements the Conn SetDeadline method.",
        "name": "net.UnixConn.SetDeadline",
        "params": [],
        "path": "go/net/index#UnixConn.SetDeadline",
        "syntax": "func (c *UnixConn) SetDeadline(t time.Time) error",
        "type": "net"
    },
    "net.UnixConn.SetReadBuffer": {
        "descr": "SetReadBuffer sets the size of the operating system's receive buffer associated with the connection.",
        "name": "net.UnixConn.SetReadBuffer",
        "params": [],
        "path": "go/net/index#UnixConn.SetReadBuffer",
        "syntax": "func (c *UnixConn) SetReadBuffer(bytes int) error",
        "type": "net"
    },
    "net.UnixConn.SetReadDeadline": {
        "descr": "SetReadDeadline implements the Conn SetReadDeadline method.",
        "name": "net.UnixConn.SetReadDeadline",
        "params": [],
        "path": "go/net/index#UnixConn.SetReadDeadline",
        "syntax": "func (c *UnixConn) SetReadDeadline(t time.Time) error",
        "type": "net"
    },
    "net.UnixConn.SetWriteBuffer": {
        "descr": "SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection.",
        "name": "net.UnixConn.SetWriteBuffer",
        "params": [],
        "path": "go/net/index#UnixConn.SetWriteBuffer",
        "syntax": "func (c *UnixConn) SetWriteBuffer(bytes int) error",
        "type": "net"
    },
    "net.UnixConn.SetWriteDeadline": {
        "descr": "SetWriteDeadline implements the Conn SetWriteDeadline method.",
        "name": "net.UnixConn.SetWriteDeadline",
        "params": [],
        "path": "go/net/index#UnixConn.SetWriteDeadline",
        "syntax": "func (c *UnixConn) SetWriteDeadline(t time.Time) error",
        "type": "net"
    },
    "net.UnixConn.SyscallConn": {
        "descr": "SyscallConn returns a raw network connection. This implements the syscall.Conn interface.",
        "name": "net.UnixConn.SyscallConn",
        "params": [],
        "path": "go/net/index#UnixConn.SyscallConn",
        "syntax": "func (c *UnixConn) SyscallConn() (syscall.RawConn, error)",
        "type": "net"
    },
    "net.UnixConn.Write": {
        "descr": "Write implements the Conn Write method.",
        "name": "net.UnixConn.Write",
        "params": [],
        "path": "go/net/index#UnixConn.Write",
        "syntax": "func (c *UnixConn) Write(b []byte) (int, error)",
        "type": "net"
    },
    "net.UnixConn.WriteMsgUnix": {
        "descr": "WriteMsgUnix writes a message to addr via c, copying the payload from b and the associated out-of-band data from oob. It returns the number of payload and out-of-band bytes written.",
        "name": "net.UnixConn.WriteMsgUnix",
        "params": [],
        "path": "go/net/index#UnixConn.WriteMsgUnix",
        "syntax": "func (c *UnixConn) WriteMsgUnix(b, oob []byte, addr *UnixAddr) (n, oobn int, err error)",
        "type": "net"
    },
    "net.UnixConn.WriteTo": {
        "descr": "WriteTo implements the PacketConn WriteTo method.",
        "name": "net.UnixConn.WriteTo",
        "params": [],
        "path": "go/net/index#UnixConn.WriteTo",
        "syntax": "func (c *UnixConn) WriteTo(b []byte, addr Addr) (int, error)",
        "type": "net"
    },
    "net.UnixConn.WriteToUnix": {
        "descr": "WriteToUnix acts like WriteTo but takes a UnixAddr.",
        "name": "net.UnixConn.WriteToUnix",
        "params": [],
        "path": "go/net/index#UnixConn.WriteToUnix",
        "syntax": "func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (int, error)",
        "type": "net"
    },
    "net.UnixListener": {
        "descr": "UnixListener is a Unix domain socket listener. Clients should typically use variables of type Listener instead of assuming Unix domain sockets.",
        "name": "net.UnixListener",
        "params": [],
        "path": "go/net/index#UnixListener",
        "syntax": "type UnixListener struct { // contains filtered or unexported fields }",
        "type": "net"
    },
    "net.UnixListener.Accept": {
        "descr": "Accept implements the Accept method in the Listener interface. Returned connections will be of type *UnixConn.",
        "name": "net.UnixListener.Accept",
        "params": [],
        "path": "go/net/index#UnixListener.Accept",
        "syntax": "func (l *UnixListener) Accept() (Conn, error)",
        "type": "net"
    },
    "net.UnixListener.AcceptUnix": {
        "descr": "AcceptUnix accepts the next incoming call and returns the new connection.",
        "name": "net.UnixListener.AcceptUnix",
        "params": [],
        "path": "go/net/index#UnixListener.AcceptUnix",
        "syntax": "func (l *UnixListener) AcceptUnix() (*UnixConn, error)",
        "type": "net"
    },
    "net.UnixListener.Addr": {
        "descr": "Addr returns the listener's network address. The Addr returned is shared by all invocations of Addr, so do not modify it.",
        "name": "net.UnixListener.Addr",
        "params": [],
        "path": "go/net/index#UnixListener.Addr",
        "syntax": "func (l *UnixListener) Addr() Addr",
        "type": "net"
    },
    "net.UnixListener.Close": {
        "descr": "Close stops listening on the Unix address. Already accepted connections are not closed.",
        "name": "net.UnixListener.Close",
        "params": [],
        "path": "go/net/index#UnixListener.Close",
        "syntax": "func (l *UnixListener) Close() error",
        "type": "net"
    },
    "net.UnixListener.File": {
        "descr": "File returns a copy of the underlying os.File. It is the caller's responsibility to close f when finished. Closing l does not affect f, and closing f does not affect l.",
        "name": "net.UnixListener.File",
        "params": [],
        "path": "go/net/index#UnixListener.File",
        "syntax": "func (l *UnixListener) File() (f *os.File, err error)",
        "type": "net"
    },
    "net.UnixListener.SetDeadline": {
        "descr": "SetDeadline sets the deadline associated with the listener. A zero time value disables the deadline.",
        "name": "net.UnixListener.SetDeadline",
        "params": [],
        "path": "go/net/index#UnixListener.SetDeadline",
        "syntax": "func (l *UnixListener) SetDeadline(t time.Time) error",
        "type": "net"
    },
    "net.UnixListener.SetUnlinkOnClose": {
        "descr": "SetUnlinkOnClose sets whether the underlying socket file should be removed from the file system when the listener is closed.",
        "name": "net.UnixListener.SetUnlinkOnClose",
        "params": [],
        "path": "go/net/index#UnixListener.SetUnlinkOnClose",
        "syntax": "func (l *UnixListener) SetUnlinkOnClose(unlink bool)",
        "type": "net"
    },
    "net.UnixListener.SyscallConn": {
        "descr": "SyscallConn returns a raw network connection. This implements the syscall.Conn interface.",
        "name": "net.UnixListener.SyscallConn",
        "params": [],
        "path": "go/net/index#UnixListener.SyscallConn",
        "syntax": "func (l *UnixListener) SyscallConn() (syscall.RawConn, error)",
        "type": "net"
    },
    "net.UnknownNetworkError": {
        "descr": "",
        "name": "net.UnknownNetworkError",
        "params": [],
        "path": "go/net/index#UnknownNetworkError",
        "syntax": "type UnknownNetworkError string",
        "type": "net"
    },
    "net.UnknownNetworkError.Error": {
        "descr": "",
        "name": "net.UnknownNetworkError.Error",
        "params": [],
        "path": "go/net/index#UnknownNetworkError.Error",
        "syntax": "func (e UnknownNetworkError) Error() string",
        "type": "net"
    },
    "net.UnknownNetworkError.Temporary": {
        "descr": "",
        "name": "net.UnknownNetworkError.Temporary",
        "params": [],
        "path": "go/net/index#UnknownNetworkError.Temporary",
        "syntax": "func (e UnknownNetworkError) Temporary() bool",
        "type": "net"
    },
    "net.UnknownNetworkError.Timeout": {
        "descr": "",
        "name": "net.UnknownNetworkError.Timeout",
        "params": [],
        "path": "go/net/index#UnknownNetworkError.Timeout",
        "syntax": "func (e UnknownNetworkError) Timeout() bool",
        "type": "net"
    },
    "new": {
        "descr": "The new built-in function allocates memory. The first argument is a type, not a value, and the value returned is a pointer to a newly allocated zero value of that type.",
        "name": "builtin.new",
        "params": [],
        "path": "go/builtin/index#new",
        "syntax": "func new(Type) *Type",
        "type": "builtin"
    },
    "os": {
        "descr": "Portable analogs of some common system call errors.",
        "name": "os",
        "params": [],
        "path": "go/os/index#pkg-variables",
        "syntax": "var ( ErrInvalid = errors.New(\"invalid argument\") // methods on File will return this error when the receiver is nil ErrPermission = errors.New(\"permission denied\") ErrExist = errors.New(\"file already exists\") ErrNotExist = errors.New(\"file does not exist\") ErrClosed = errors.New(\"file already closed\") ErrNoDeadline = poll.ErrNoDeadline )",
        "type": "os"
    },
    "os.Chdir": {
        "descr": "Chdir changes the current working directory to the named directory. If there is an error, it will be of type *PathError.",
        "name": "os.Chdir",
        "params": [],
        "path": "go/os/index#Chdir",
        "syntax": "func Chdir(dir string) error",
        "type": "os"
    },
    "os.Chmod": {
        "descr": "Chmod changes the mode of the named file to mode. If the file is a symbolic link, it changes the mode of the link's target. If there is an error, it will be of type *PathError.",
        "name": "os.Chmod",
        "params": [],
        "path": "go/os/index#Chmod",
        "syntax": "func Chmod(name string, mode FileMode) error",
        "type": "os"
    },
    "os.Chown": {
        "descr": "Chown changes the numeric uid and gid of the named file. If the file is a symbolic link, it changes the uid and gid of the link's target. A uid or gid of -1 means to not change that value. If there is an error, it will be of type *PathError.",
        "name": "os.Chown",
        "params": [],
        "path": "go/os/index#Chown",
        "syntax": "func Chown(name string, uid, gid int) error",
        "type": "os"
    },
    "os.Chtimes": {
        "descr": "Chtimes changes the access and modification times of the named file, similar to the Unix utime() or utimes() functions.",
        "name": "os.Chtimes",
        "params": [],
        "path": "go/os/index#Chtimes",
        "syntax": "func Chtimes(name string, atime time.Time, mtime time.Time) error",
        "type": "os"
    },
    "os.Clearenv": {
        "descr": "Clearenv deletes all environment variables.",
        "name": "os.Clearenv",
        "params": [],
        "path": "go/os/index#Clearenv",
        "syntax": "func Clearenv()",
        "type": "os"
    },
    "os.Create": {
        "descr": "Create creates the named file with mode 0666 (before umask), truncating it if it already exists. If successful, methods on the returned File can be used for I/O; the associated file descriptor has mode O_RDWR. If there is an error, it will be of type *PathError.",
        "name": "os.Create",
        "params": [],
        "path": "go/os/index#Create",
        "syntax": "func Create(name string) (*File, error)",
        "type": "os"
    },
    "os.Environ": {
        "descr": "Environ returns a copy of strings representing the environment, in the form \"key=value\".",
        "name": "os.Environ",
        "params": [],
        "path": "go/os/index#Environ",
        "syntax": "func Environ() []string",
        "type": "os"
    },
    "os.Executable": {
        "descr": "Executable returns the path name for the executable that started the current process. There is no guarantee that the path is still pointing to the correct executable. If a symlink was used to start the process, depending on the operating system, the result might be the symlink or the path it pointed to. If a stable result is needed, path/filepath.EvalSymlinks might help.",
        "name": "os.Executable",
        "params": [],
        "path": "go/os/index#Executable",
        "syntax": "func Executable() (string, error)",
        "type": "os"
    },
    "os.Exit": {
        "descr": "Exit causes the current program to exit with the given status code. Conventionally, code zero indicates success, non-zero an error. The program terminates immediately; deferred functions are not run.",
        "name": "os.Exit",
        "params": [],
        "path": "go/os/index#Exit",
        "syntax": "func Exit(code int)",
        "type": "os"
    },
    "os.Expand": {
        "descr": "Expand replaces ${var} or $var in the string based on the mapping function. For example, os.ExpandEnv(s) is equivalent to os.Expand(s, os.Getenv).",
        "name": "os.Expand",
        "params": [],
        "path": "go/os/index#Expand",
        "syntax": "func Expand(s string, mapping func(string) string) string",
        "type": "os"
    },
    "os.ExpandEnv": {
        "descr": "ExpandEnv replaces ${var} or $var in the string according to the values of the current environment variables. References to undefined variables are replaced by the empty string.",
        "name": "os.ExpandEnv",
        "params": [],
        "path": "go/os/index#ExpandEnv",
        "syntax": "func ExpandEnv(s string) string",
        "type": "os"
    },
    "os.File": {
        "descr": "File represents an open file descriptor.",
        "name": "os.File",
        "params": [],
        "path": "go/os/index#File",
        "syntax": "type File struct { // contains filtered or unexported fields }",
        "type": "os"
    },
    "os.File.Chdir": {
        "descr": "Chdir changes the current working directory to the file, which must be a directory. If there is an error, it will be of type *PathError.",
        "name": "os.File.Chdir",
        "params": [],
        "path": "go/os/index#File.Chdir",
        "syntax": "func (f *File) Chdir() error",
        "type": "os"
    },
    "os.File.Chmod": {
        "descr": "Chmod changes the mode of the file to mode. If there is an error, it will be of type *PathError.",
        "name": "os.File.Chmod",
        "params": [],
        "path": "go/os/index#File.Chmod",
        "syntax": "func (f *File) Chmod(mode FileMode) error",
        "type": "os"
    },
    "os.File.Chown": {
        "descr": "Chown changes the numeric uid and gid of the named file. If there is an error, it will be of type *PathError.",
        "name": "os.File.Chown",
        "params": [],
        "path": "go/os/index#File.Chown",
        "syntax": "func (f *File) Chown(uid, gid int) error",
        "type": "os"
    },
    "os.File.Close": {
        "descr": "Close closes the File, rendering it unusable for I/O. On files that support SetDeadline, any pending I/O operations will be canceled and return immediately with an error.",
        "name": "os.File.Close",
        "params": [],
        "path": "go/os/index#File.Close",
        "syntax": "func (f *File) Close() error",
        "type": "os"
    },
    "os.File.Fd": {
        "descr": "Fd returns the integer Unix file descriptor referencing the open file. The file descriptor is valid only until f.Close is called or f is garbage collected. On Unix systems this will cause the SetDeadline methods to stop working.",
        "name": "os.File.Fd",
        "params": [],
        "path": "go/os/index#File.Fd",
        "syntax": "func (f *File) Fd() uintptr",
        "type": "os"
    },
    "os.File.Name": {
        "descr": "Name returns the name of the file as presented to Open.",
        "name": "os.File.Name",
        "params": [],
        "path": "go/os/index#File.Name",
        "syntax": "func (f *File) Name() string",
        "type": "os"
    },
    "os.File.Read": {
        "descr": "Read reads up to len(b) bytes from the File. It returns the number of bytes read and any error encountered. At end of file, Read returns 0, io.EOF.",
        "name": "os.File.Read",
        "params": [],
        "path": "go/os/index#File.Read",
        "syntax": "func (f *File) Read(b []byte) (n int, err error)",
        "type": "os"
    },
    "os.File.ReadAt": {
        "descr": "ReadAt reads len(b) bytes from the File starting at byte offset off. It returns the number of bytes read and the error, if any. ReadAt always returns a non-nil error when n < len(b). At end of file, that error is io.EOF.",
        "name": "os.File.ReadAt",
        "params": [],
        "path": "go/os/index#File.ReadAt",
        "syntax": "func (f *File) ReadAt(b []byte, off int64) (n int, err error)",
        "type": "os"
    },
    "os.File.Readdir": {
        "descr": "Readdir reads the contents of the directory associated with file and returns a slice of up to n FileInfo values, as would be returned by Lstat, in directory order. Subsequent calls on the same file will yield further FileInfos.",
        "name": "os.File.Readdir",
        "params": [],
        "path": "go/os/index#File.Readdir",
        "syntax": "func (f *File) Readdir(n int) ([]FileInfo, error)",
        "type": "os"
    },
    "os.File.Readdirnames": {
        "descr": "Readdirnames reads and returns a slice of names from the directory f.",
        "name": "os.File.Readdirnames",
        "params": [],
        "path": "go/os/index#File.Readdirnames",
        "syntax": "func (f *File) Readdirnames(n int) (names []string, err error)",
        "type": "os"
    },
    "os.File.Seek": {
        "descr": "Seek sets the offset for the next Read or Write on file to offset, interpreted according to whence: 0 means relative to the origin of the file, 1 means relative to the current offset, and 2 means relative to the end. It returns the new offset and an error, if any. The behavior of Seek on a file opened with O_APPEND is not specified.",
        "name": "os.File.Seek",
        "params": [],
        "path": "go/os/index#File.Seek",
        "syntax": "func (f *File) Seek(offset int64, whence int) (ret int64, err error)",
        "type": "os"
    },
    "os.File.SetDeadline": {
        "descr": "SetDeadline sets the read and write deadlines for a File. It is equivalent to calling both SetReadDeadline and SetWriteDeadline.",
        "name": "os.File.SetDeadline",
        "params": [],
        "path": "go/os/index#File.SetDeadline",
        "syntax": "func (f *File) SetDeadline(t time.Time) error",
        "type": "os"
    },
    "os.File.SetReadDeadline": {
        "descr": "SetReadDeadline sets the deadline for future Read calls and any currently-blocked Read call. A zero value for t means Read will not time out. Not all files support setting deadlines; see SetDeadline.",
        "name": "os.File.SetReadDeadline",
        "params": [],
        "path": "go/os/index#File.SetReadDeadline",
        "syntax": "func (f *File) SetReadDeadline(t time.Time) error",
        "type": "os"
    },
    "os.File.SetWriteDeadline": {
        "descr": "SetWriteDeadline sets the deadline for any future Write calls and any currently-blocked Write call. Even if Write times out, it may return n > 0, indicating that some of the data was successfully written. A zero value for t means Write will not time out. Not all files support setting deadlines; see SetDeadline.",
        "name": "os.File.SetWriteDeadline",
        "params": [],
        "path": "go/os/index#File.SetWriteDeadline",
        "syntax": "func (f *File) SetWriteDeadline(t time.Time) error",
        "type": "os"
    },
    "os.File.Stat": {
        "descr": "Stat returns the FileInfo structure describing file. If there is an error, it will be of type *PathError.",
        "name": "os.File.Stat",
        "params": [],
        "path": "go/os/index#File.Stat",
        "syntax": "func (f *File) Stat() (FileInfo, error)",
        "type": "os"
    },
    "os.File.Sync": {
        "descr": "Sync commits the current contents of the file to stable storage. Typically, this means flushing the file system's in-memory copy of recently written data to disk.",
        "name": "os.File.Sync",
        "params": [],
        "path": "go/os/index#File.Sync",
        "syntax": "func (f *File) Sync() error",
        "type": "os"
    },
    "os.File.Truncate": {
        "descr": "Truncate changes the size of the file. It does not change the I/O offset. If there is an error, it will be of type *PathError.",
        "name": "os.File.Truncate",
        "params": [],
        "path": "go/os/index#File.Truncate",
        "syntax": "func (f *File) Truncate(size int64) error",
        "type": "os"
    },
    "os.File.Write": {
        "descr": "Write writes len(b) bytes to the File. It returns the number of bytes written and an error, if any. Write returns a non-nil error when n != len(b).",
        "name": "os.File.Write",
        "params": [],
        "path": "go/os/index#File.Write",
        "syntax": "func (f *File) Write(b []byte) (n int, err error)",
        "type": "os"
    },
    "os.File.WriteAt": {
        "descr": "WriteAt writes len(b) bytes to the File starting at byte offset off. It returns the number of bytes written and an error, if any. WriteAt returns a non-nil error when n != len(b).",
        "name": "os.File.WriteAt",
        "params": [],
        "path": "go/os/index#File.WriteAt",
        "syntax": "func (f *File) WriteAt(b []byte, off int64) (n int, err error)",
        "type": "os"
    },
    "os.File.WriteString": {
        "descr": "WriteString is like Write, but writes the contents of string s rather than a slice of bytes.",
        "name": "os.File.WriteString",
        "params": [],
        "path": "go/os/index#File.WriteString",
        "syntax": "func (f *File) WriteString(s string) (n int, err error)",
        "type": "os"
    },
    "os.FileInfo": {
        "descr": "A FileInfo describes a file and is returned by Stat and Lstat.",
        "name": "os.FileInfo",
        "params": [],
        "path": "go/os/index#FileInfo",
        "syntax": "type FileInfo interface { Name() string // base name of the file Size() int64 // length in bytes for regular files; system-dependent for others Mode() FileMode // file mode bits ModTime() time.Time // modification time IsDir() bool // abbreviation for Mode().IsDir() Sys() interface{} // underlying data source (can return nil) }",
        "type": "os"
    },
    "os.FileMode": {
        "descr": "A FileMode represents a file's mode and permission bits. The bits have the same definition on all systems, so that information about files can be moved from one system to another portably. Not all bits apply to all systems. The only required bit is ModeDir for directories.",
        "name": "os.FileMode",
        "params": [],
        "path": "go/os/index#FileMode",
        "syntax": "type FileMode uint32",
        "type": "os"
    },
    "os.FileMode.IsDir": {
        "descr": "IsDir reports whether m describes a directory. That is, it tests for the ModeDir bit being set in m.",
        "name": "os.FileMode.IsDir",
        "params": [],
        "path": "go/os/index#FileMode.IsDir",
        "syntax": "func (m FileMode) IsDir() bool",
        "type": "os"
    },
    "os.FileMode.IsRegular": {
        "descr": "IsRegular reports whether m describes a regular file. That is, it tests that no mode type bits are set.",
        "name": "os.FileMode.IsRegular",
        "params": [],
        "path": "go/os/index#FileMode.IsRegular",
        "syntax": "func (m FileMode) IsRegular() bool",
        "type": "os"
    },
    "os.FileMode.Perm": {
        "descr": "Perm returns the Unix permission bits in m.",
        "name": "os.FileMode.Perm",
        "params": [],
        "path": "go/os/index#FileMode.Perm",
        "syntax": "func (m FileMode) Perm() FileMode",
        "type": "os"
    },
    "os.FileMode.String": {
        "descr": "",
        "name": "os.FileMode.String",
        "params": [],
        "path": "go/os/index#FileMode.String",
        "syntax": "func (m FileMode) String() string",
        "type": "os"
    },
    "os.FindProcess": {
        "descr": "FindProcess looks for a running process by its pid.",
        "name": "os.FindProcess",
        "params": [],
        "path": "go/os/index#FindProcess",
        "syntax": "func FindProcess(pid int) (*Process, error)",
        "type": "os"
    },
    "os.Getegid": {
        "descr": "Getegid returns the numeric effective group id of the caller.",
        "name": "os.Getegid",
        "params": [],
        "path": "go/os/index#Getegid",
        "syntax": "func Getegid() int",
        "type": "os"
    },
    "os.Getenv": {
        "descr": "Getenv retrieves the value of the environment variable named by the key. It returns the value, which will be empty if the variable is not present. To distinguish between an empty value and an unset value, use LookupEnv.",
        "name": "os.Getenv",
        "params": [],
        "path": "go/os/index#Getenv",
        "syntax": "func Getenv(key string) string",
        "type": "os"
    },
    "os.Geteuid": {
        "descr": "Geteuid returns the numeric effective user id of the caller.",
        "name": "os.Geteuid",
        "params": [],
        "path": "go/os/index#Geteuid",
        "syntax": "func Geteuid() int",
        "type": "os"
    },
    "os.Getgid": {
        "descr": "Getgid returns the numeric group id of the caller.",
        "name": "os.Getgid",
        "params": [],
        "path": "go/os/index#Getgid",
        "syntax": "func Getgid() int",
        "type": "os"
    },
    "os.Getgroups": {
        "descr": "Getgroups returns a list of the numeric ids of groups that the caller belongs to.",
        "name": "os.Getgroups",
        "params": [],
        "path": "go/os/index#Getgroups",
        "syntax": "func Getgroups() ([]int, error)",
        "type": "os"
    },
    "os.Getpagesize": {
        "descr": "Getpagesize returns the underlying system's memory page size.",
        "name": "os.Getpagesize",
        "params": [],
        "path": "go/os/index#Getpagesize",
        "syntax": "func Getpagesize() int",
        "type": "os"
    },
    "os.Getpid": {
        "descr": "Getpid returns the process id of the caller.",
        "name": "os.Getpid",
        "params": [],
        "path": "go/os/index#Getpid",
        "syntax": "func Getpid() int",
        "type": "os"
    },
    "os.Getppid": {
        "descr": "Getppid returns the process id of the caller's parent.",
        "name": "os.Getppid",
        "params": [],
        "path": "go/os/index#Getppid",
        "syntax": "func Getppid() int",
        "type": "os"
    },
    "os.Getuid": {
        "descr": "Getuid returns the numeric user id of the caller.",
        "name": "os.Getuid",
        "params": [],
        "path": "go/os/index#Getuid",
        "syntax": "func Getuid() int",
        "type": "os"
    },
    "os.Getwd": {
        "descr": "Getwd returns a rooted path name corresponding to the current directory. If the current directory can be reached via multiple paths (due to symbolic links), Getwd may return any one of them.",
        "name": "os.Getwd",
        "params": [],
        "path": "go/os/index#Getwd",
        "syntax": "func Getwd() (dir string, err error)",
        "type": "os"
    },
    "os.Hostname": {
        "descr": "Hostname returns the host name reported by the kernel.",
        "name": "os.Hostname",
        "params": [],
        "path": "go/os/index#Hostname",
        "syntax": "func Hostname() (name string, err error)",
        "type": "os"
    },
    "os.IsExist": {
        "descr": "IsExist returns a boolean indicating whether the error is known to report that a file or directory already exists. It is satisfied by ErrExist as well as some syscall errors.",
        "name": "os.IsExist",
        "params": [],
        "path": "go/os/index#IsExist",
        "syntax": "func IsExist(err error) bool",
        "type": "os"
    },
    "os.IsNotExist": {
        "descr": "IsNotExist returns a boolean indicating whether the error is known to report that a file or directory does not exist. It is satisfied by ErrNotExist as well as some syscall errors.",
        "name": "os.IsNotExist",
        "params": [],
        "path": "go/os/index#IsNotExist",
        "syntax": "func IsNotExist(err error) bool",
        "type": "os"
    },
    "os.IsPathSeparator": {
        "descr": "IsPathSeparator reports whether c is a directory separator character.",
        "name": "os.IsPathSeparator",
        "params": [],
        "path": "go/os/index#IsPathSeparator",
        "syntax": "func IsPathSeparator(c uint8) bool",
        "type": "os"
    },
    "os.IsPermission": {
        "descr": "IsPermission returns a boolean indicating whether the error is known to report that permission is denied. It is satisfied by ErrPermission as well as some syscall errors.",
        "name": "os.IsPermission",
        "params": [],
        "path": "go/os/index#IsPermission",
        "syntax": "func IsPermission(err error) bool",
        "type": "os"
    },
    "os.IsTimeout": {
        "descr": "IsTimeout returns a boolean indicating whether the error is known to report that a timeout occurred.",
        "name": "os.IsTimeout",
        "params": [],
        "path": "go/os/index#IsTimeout",
        "syntax": "func IsTimeout(err error) bool",
        "type": "os"
    },
    "os.Lchown": {
        "descr": "Lchown changes the numeric uid and gid of the named file. If the file is a symbolic link, it changes the uid and gid of the link itself. If there is an error, it will be of type *PathError.",
        "name": "os.Lchown",
        "params": [],
        "path": "go/os/index#Lchown",
        "syntax": "func Lchown(name string, uid, gid int) error",
        "type": "os"
    },
    "os.Link": {
        "descr": "Link creates newname as a hard link to the oldname file. If there is an error, it will be of type *LinkError.",
        "name": "os.Link",
        "params": [],
        "path": "go/os/index#Link",
        "syntax": "func Link(oldname, newname string) error",
        "type": "os"
    },
    "os.LinkError": {
        "descr": "LinkError records an error during a link or symlink or rename system call and the paths that caused it.",
        "name": "os.LinkError",
        "params": [],
        "path": "go/os/index#LinkError",
        "syntax": "type LinkError struct { Op string Old string New string Err error }",
        "type": "os"
    },
    "os.LinkError.Error": {
        "descr": "",
        "name": "os.LinkError.Error",
        "params": [],
        "path": "go/os/index#LinkError.Error",
        "syntax": "func (e *LinkError) Error() string",
        "type": "os"
    },
    "os.LookupEnv": {
        "descr": "LookupEnv retrieves the value of the environment variable named by the key. If the variable is present in the environment the value (which may be empty) is returned and the boolean is true. Otherwise the returned value will be empty and the boolean will be false.",
        "name": "os.LookupEnv",
        "params": [],
        "path": "go/os/index#LookupEnv",
        "syntax": "func LookupEnv(key string) (string, bool)",
        "type": "os"
    },
    "os.Lstat": {
        "descr": "Lstat returns a FileInfo describing the named file. If the file is a symbolic link, the returned FileInfo describes the symbolic link. Lstat makes no attempt to follow the link. If there is an error, it will be of type *PathError.",
        "name": "os.Lstat",
        "params": [],
        "path": "go/os/index#Lstat",
        "syntax": "func Lstat(name string) (FileInfo, error)",
        "type": "os"
    },
    "os.Mkdir": {
        "descr": "Mkdir creates a new directory with the specified name and permission bits (before umask). If there is an error, it will be of type *PathError.",
        "name": "os.Mkdir",
        "params": [],
        "path": "go/os/index#Mkdir",
        "syntax": "func Mkdir(name string, perm FileMode) error",
        "type": "os"
    },
    "os.MkdirAll": {
        "descr": "MkdirAll creates a directory named path, along with any necessary parents, and returns nil, or else returns an error. The permission bits perm (before umask) are used for all directories that MkdirAll creates. If path is already a directory, MkdirAll does nothing and returns nil.",
        "name": "os.MkdirAll",
        "params": [],
        "path": "go/os/index#MkdirAll",
        "syntax": "func MkdirAll(path string, perm FileMode) error",
        "type": "os"
    },
    "os.NewFile": {
        "descr": "NewFile returns a new File with the given file descriptor and name. The returned value will be nil if fd is not a valid file descriptor. On Unix systems, if the file descriptor is in non-blocking mode, NewFile will attempt to return a pollable File (one for which the SetDeadline methods work).",
        "name": "os.NewFile",
        "params": [],
        "path": "go/os/index#NewFile",
        "syntax": "func NewFile(fd uintptr, name string) *File",
        "type": "os"
    },
    "os.NewSyscallError": {
        "descr": "NewSyscallError returns, as an error, a new SyscallError with the given system call name and error details. As a convenience, if err is nil, NewSyscallError returns nil.",
        "name": "os.NewSyscallError",
        "params": [],
        "path": "go/os/index#NewSyscallError",
        "syntax": "func NewSyscallError(syscall string, err error) error",
        "type": "os"
    },
    "os.Open": {
        "descr": "Open opens the named file for reading. If successful, methods on the returned file can be used for reading; the associated file descriptor has mode O_RDONLY. If there is an error, it will be of type *PathError.",
        "name": "os.Open",
        "params": [],
        "path": "go/os/index#Open",
        "syntax": "func Open(name string) (*File, error)",
        "type": "os"
    },
    "os.OpenFile": {
        "descr": "OpenFile is the generalized open call; most users will use Open or Create instead. It opens the named file with specified flag (O_RDONLY etc.) and perm (before umask), if applicable. If successful, methods on the returned File can be used for I/O. If there is an error, it will be of type *PathError.",
        "name": "os.OpenFile",
        "params": [],
        "path": "go/os/index#OpenFile",
        "syntax": "func OpenFile(name string, flag int, perm FileMode) (*File, error)",
        "type": "os"
    },
    "os.PathError": {
        "descr": "PathError records an error and the operation and file path that caused it.",
        "name": "os.PathError",
        "params": [],
        "path": "go/os/index#PathError",
        "syntax": "type PathError struct { Op string Path string Err error }",
        "type": "os"
    },
    "os.PathError.Error": {
        "descr": "",
        "name": "os.PathError.Error",
        "params": [],
        "path": "go/os/index#PathError.Error",
        "syntax": "func (e *PathError) Error() string",
        "type": "os"
    },
    "os.PathError.Timeout": {
        "descr": "Timeout reports whether this error represents a timeout.",
        "name": "os.PathError.Timeout",
        "params": [],
        "path": "go/os/index#PathError.Timeout",
        "syntax": "func (e *PathError) Timeout() bool",
        "type": "os"
    },
    "os.Pipe": {
        "descr": "Pipe returns a connected pair of Files; reads from r return bytes written to w. It returns the files and an error, if any.",
        "name": "os.Pipe",
        "params": [],
        "path": "go/os/index#Pipe",
        "syntax": "func Pipe() (r *File, w *File, err error)",
        "type": "os"
    },
    "os.ProcAttr": {
        "descr": "ProcAttr holds the attributes that will be applied to a new process started by StartProcess.",
        "name": "os.ProcAttr",
        "params": [],
        "path": "go/os/index#ProcAttr",
        "syntax": "type ProcAttr struct { // If Dir is non-empty, the child changes into the directory before // creating the process. Dir string // If Env is non-nil, it gives the environment variables for the // new process in the form returned by Environ. // If it is nil, the result of Environ will be used. Env []string // Files specifies the open files inherited by the new process. The // first three entries correspond to standard input, standard output, and // standard error. An implementation may support additional entries, // depending on the underlying operating system. A nil entry corresponds // to that file being closed when the process starts. Files []*File // Operating system-specific process creation attributes. // Note that setting this field means that your program // may not execute properly or even compile on some // operating systems. Sys *syscall.SysProcAttr }",
        "type": "os"
    },
    "os.Process": {
        "descr": "Process stores the information about a process created by StartProcess.",
        "name": "os.Process",
        "params": [],
        "path": "go/os/index#Process",
        "syntax": "type Process struct { Pid int // contains filtered or unexported fields }",
        "type": "os"
    },
    "os.Process.Kill": {
        "descr": "Kill causes the Process to exit immediately. Kill does not wait until the Process has actually exited. This only kills the Process itself, not any other processes it may have started.",
        "name": "os.Process.Kill",
        "params": [],
        "path": "go/os/index#Process.Kill",
        "syntax": "func (p *Process) Kill() error",
        "type": "os"
    },
    "os.Process.Release": {
        "descr": "Release releases any resources associated with the Process p, rendering it unusable in the future. Release only needs to be called if Wait is not.",
        "name": "os.Process.Release",
        "params": [],
        "path": "go/os/index#Process.Release",
        "syntax": "func (p *Process) Release() error",
        "type": "os"
    },
    "os.Process.Signal": {
        "descr": "Signal sends a signal to the Process. Sending Interrupt on Windows is not implemented.",
        "name": "os.Process.Signal",
        "params": [],
        "path": "go/os/index#Process.Signal",
        "syntax": "func (p *Process) Signal(sig Signal) error",
        "type": "os"
    },
    "os.Process.Wait": {
        "descr": "Wait waits for the Process to exit, and then returns a ProcessState describing its status and an error, if any. Wait releases any resources associated with the Process. On most operating systems, the Process must be a child of the current process or an error will be returned.",
        "name": "os.Process.Wait",
        "params": [],
        "path": "go/os/index#Process.Wait",
        "syntax": "func (p *Process) Wait() (*ProcessState, error)",
        "type": "os"
    },
    "os.ProcessState": {
        "descr": "ProcessState stores information about a process, as reported by Wait.",
        "name": "os.ProcessState",
        "params": [],
        "path": "go/os/index#ProcessState",
        "syntax": "type ProcessState struct { // contains filtered or unexported fields }",
        "type": "os"
    },
    "os.ProcessState.Exited": {
        "descr": "Exited reports whether the program has exited.",
        "name": "os.ProcessState.Exited",
        "params": [],
        "path": "go/os/index#ProcessState.Exited",
        "syntax": "func (p *ProcessState) Exited() bool",
        "type": "os"
    },
    "os.ProcessState.Pid": {
        "descr": "Pid returns the process id of the exited process.",
        "name": "os.ProcessState.Pid",
        "params": [],
        "path": "go/os/index#ProcessState.Pid",
        "syntax": "func (p *ProcessState) Pid() int",
        "type": "os"
    },
    "os.ProcessState.String": {
        "descr": "",
        "name": "os.ProcessState.String",
        "params": [],
        "path": "go/os/index#ProcessState.String",
        "syntax": "func (p *ProcessState) String() string",
        "type": "os"
    },
    "os.ProcessState.Success": {
        "descr": "Success reports whether the program exited successfully, such as with exit status 0 on Unix.",
        "name": "os.ProcessState.Success",
        "params": [],
        "path": "go/os/index#ProcessState.Success",
        "syntax": "func (p *ProcessState) Success() bool",
        "type": "os"
    },
    "os.ProcessState.Sys": {
        "descr": "Sys returns system-dependent exit information about the process. Convert it to the appropriate underlying type, such as syscall.WaitStatus on Unix, to access its contents.",
        "name": "os.ProcessState.Sys",
        "params": [],
        "path": "go/os/index#ProcessState.Sys",
        "syntax": "func (p *ProcessState) Sys() interface{}",
        "type": "os"
    },
    "os.ProcessState.SysUsage": {
        "descr": "SysUsage returns system-dependent resource usage information about the exited process. Convert it to the appropriate underlying type, such as *syscall.Rusage on Unix, to access its contents. (On Unix, *syscall.Rusage matches struct rusage as defined in the getrusage(2) manual page.)",
        "name": "os.ProcessState.SysUsage",
        "params": [],
        "path": "go/os/index#ProcessState.SysUsage",
        "syntax": "func (p *ProcessState) SysUsage() interface{}",
        "type": "os"
    },
    "os.ProcessState.SystemTime": {
        "descr": "SystemTime returns the system CPU time of the exited process and its children.",
        "name": "os.ProcessState.SystemTime",
        "params": [],
        "path": "go/os/index#ProcessState.SystemTime",
        "syntax": "func (p *ProcessState) SystemTime() time.Duration",
        "type": "os"
    },
    "os.ProcessState.UserTime": {
        "descr": "UserTime returns the user CPU time of the exited process and its children.",
        "name": "os.ProcessState.UserTime",
        "params": [],
        "path": "go/os/index#ProcessState.UserTime",
        "syntax": "func (p *ProcessState) UserTime() time.Duration",
        "type": "os"
    },
    "os.Readlink": {
        "descr": "Readlink returns the destination of the named symbolic link. If there is an error, it will be of type *PathError.",
        "name": "os.Readlink",
        "params": [],
        "path": "go/os/index#Readlink",
        "syntax": "func Readlink(name string) (string, error)",
        "type": "os"
    },
    "os.Remove": {
        "descr": "Remove removes the named file or (empty) directory. If there is an error, it will be of type *PathError.",
        "name": "os.Remove",
        "params": [],
        "path": "go/os/index#Remove",
        "syntax": "func Remove(name string) error",
        "type": "os"
    },
    "os.RemoveAll": {
        "descr": "RemoveAll removes path and any children it contains. It removes everything it can but returns the first error it encounters. If the path does not exist, RemoveAll returns nil (no error).",
        "name": "os.RemoveAll",
        "params": [],
        "path": "go/os/index#RemoveAll",
        "syntax": "func RemoveAll(path string) error",
        "type": "os"
    },
    "os.Rename": {
        "descr": "Rename renames (moves) oldpath to newpath. If newpath already exists and is not a directory, Rename replaces it. OS-specific restrictions may apply when oldpath and newpath are in different directories. If there is an error, it will be of type *LinkError.",
        "name": "os.Rename",
        "params": [],
        "path": "go/os/index#Rename",
        "syntax": "func Rename(oldpath, newpath string) error",
        "type": "os"
    },
    "os.SameFile": {
        "descr": "SameFile reports whether fi1 and fi2 describe the same file. For example, on Unix this means that the device and inode fields of the two underlying structures are identical; on other systems the decision may be based on the path names. SameFile only applies to results returned by this package's Stat. It returns false in other cases.",
        "name": "os.SameFile",
        "params": [],
        "path": "go/os/index#SameFile",
        "syntax": "func SameFile(fi1, fi2 FileInfo) bool",
        "type": "os"
    },
    "os.Setenv": {
        "descr": "Setenv sets the value of the environment variable named by the key. It returns an error, if any.",
        "name": "os.Setenv",
        "params": [],
        "path": "go/os/index#Setenv",
        "syntax": "func Setenv(key, value string) error",
        "type": "os"
    },
    "os.Signal": {
        "descr": "A Signal represents an operating system signal. The usual underlying implementation is operating system-dependent: on Unix it is syscall.Signal.",
        "name": "os.Signal",
        "params": [],
        "path": "go/os/index#Signal",
        "syntax": "type Signal interface { String() string Signal() // to distinguish from other Stringers }",
        "type": "os"
    },
    "os.StartProcess": {
        "descr": "StartProcess starts a new process with the program, arguments and attributes specified by name, argv and attr. The argv slice will become os.Args in the new process, so it normally starts with the program name.",
        "name": "os.StartProcess",
        "params": [],
        "path": "go/os/index#StartProcess",
        "syntax": "func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)",
        "type": "os"
    },
    "os.Stat": {
        "descr": "Stat returns a FileInfo describing the named file. If there is an error, it will be of type *PathError.",
        "name": "os.Stat",
        "params": [],
        "path": "go/os/index#Stat",
        "syntax": "func Stat(name string) (FileInfo, error)",
        "type": "os"
    },
    "os.Symlink": {
        "descr": "Symlink creates newname as a symbolic link to oldname. If there is an error, it will be of type *LinkError.",
        "name": "os.Symlink",
        "params": [],
        "path": "go/os/index#Symlink",
        "syntax": "func Symlink(oldname, newname string) error",
        "type": "os"
    },
    "os.SyscallError": {
        "descr": "SyscallError records an error from a specific system call.",
        "name": "os.SyscallError",
        "params": [],
        "path": "go/os/index#SyscallError",
        "syntax": "type SyscallError struct { Syscall string Err error }",
        "type": "os"
    },
    "os.SyscallError.Error": {
        "descr": "",
        "name": "os.SyscallError.Error",
        "params": [],
        "path": "go/os/index#SyscallError.Error",
        "syntax": "func (e *SyscallError) Error() string",
        "type": "os"
    },
    "os.SyscallError.Timeout": {
        "descr": "Timeout reports whether this error represents a timeout.",
        "name": "os.SyscallError.Timeout",
        "params": [],
        "path": "go/os/index#SyscallError.Timeout",
        "syntax": "func (e *SyscallError) Timeout() bool",
        "type": "os"
    },
    "os.TempDir": {
        "descr": "TempDir returns the default directory to use for temporary files.",
        "name": "os.TempDir",
        "params": [],
        "path": "go/os/index#TempDir",
        "syntax": "func TempDir() string",
        "type": "os"
    },
    "os.Truncate": {
        "descr": "Truncate changes the size of the named file. If the file is a symbolic link, it changes the size of the link's target. If there is an error, it will be of type *PathError.",
        "name": "os.Truncate",
        "params": [],
        "path": "go/os/index#Truncate",
        "syntax": "func Truncate(name string, size int64) error",
        "type": "os"
    },
    "os.Unsetenv": {
        "descr": "Unsetenv unsets a single environment variable.",
        "name": "os.Unsetenv",
        "params": [],
        "path": "go/os/index#Unsetenv",
        "syntax": "func Unsetenv(key string) error",
        "type": "os"
    },
    "os.UserCacheDir": {
        "descr": "UserCacheDir returns the default root directory to use for user-specific cached data. Users should create their own application-specific subdirectory within this one and use that.",
        "name": "os.UserCacheDir",
        "params": [],
        "path": "go/os/index#UserCacheDir",
        "syntax": "func UserCacheDir() (string, error)",
        "type": "os"
    },
    "panic": {
        "descr": "The panic built-in function stops normal execution of the current goroutine. When a function F calls panic, normal execution of F stops immediately. Any functions whose execution was deferred by F are run in the usual way, and then F returns to its caller. To the caller G, the invocation of F then behaves like a call to panic, terminating G's execution and running any deferred functions. This continues until all functions in the executing goroutine have stopped, in reverse order. At that point, the program is terminated and the error condition is reported, including the value of the argument to panic. This termination sequence is called panicking and can be controlled by the built-in function recover.",
        "name": "builtin.panic",
        "params": [],
        "path": "go/builtin/index#panic",
        "syntax": "func panic(v interface{})",
        "type": "builtin"
    },
    "parse.ActionNode": {
        "descr": "ActionNode holds an action (something bounded by delimiters). Control actions have their own nodes; ActionNode represents simple ones such as field evaluations and parenthesized pipelines.",
        "name": "parse.ActionNode",
        "params": [],
        "path": "go/text/template/parse/index#ActionNode",
        "syntax": "type ActionNode struct { NodeType Pos Line int // The line number in the input. Deprecated: Kept for compatibility. Pipe *PipeNode // The pipeline in the action. // contains filtered or unexported fields }",
        "type": "text"
    },
    "parse.ActionNode.Copy": {
        "descr": "",
        "name": "parse.ActionNode.Copy",
        "params": [],
        "path": "go/text/template/parse/index#ActionNode.Copy",
        "syntax": "func (a *ActionNode) Copy() Node",
        "type": "text"
    },
    "parse.ActionNode.String": {
        "descr": "",
        "name": "parse.ActionNode.String",
        "params": [],
        "path": "go/text/template/parse/index#ActionNode.String",
        "syntax": "func (a *ActionNode) String() string",
        "type": "text"
    },
    "parse.BoolNode": {
        "descr": "BoolNode holds a boolean constant.",
        "name": "parse.BoolNode",
        "params": [],
        "path": "go/text/template/parse/index#BoolNode",
        "syntax": "type BoolNode struct { NodeType Pos True bool // The value of the boolean constant. // contains filtered or unexported fields }",
        "type": "text"
    },
    "parse.BoolNode.Copy": {
        "descr": "",
        "name": "parse.BoolNode.Copy",
        "params": [],
        "path": "go/text/template/parse/index#BoolNode.Copy",
        "syntax": "func (b *BoolNode) Copy() Node",
        "type": "text"
    },
    "parse.BoolNode.String": {
        "descr": "",
        "name": "parse.BoolNode.String",
        "params": [],
        "path": "go/text/template/parse/index#BoolNode.String",
        "syntax": "func (b *BoolNode) String() string",
        "type": "text"
    },
    "parse.BranchNode": {
        "descr": "BranchNode is the common representation of if, range, and with.",
        "name": "parse.BranchNode",
        "params": [],
        "path": "go/text/template/parse/index#BranchNode",
        "syntax": "type BranchNode struct { NodeType Pos Line int // The line number in the input. Deprecated: Kept for compatibility. Pipe *PipeNode // The pipeline to be evaluated. List *ListNode // What to execute if the value is non-empty. ElseList *ListNode // What to execute if the value is empty (nil if absent). // contains filtered or unexported fields }",
        "type": "text"
    },
    "parse.BranchNode.Copy": {
        "descr": "",
        "name": "parse.BranchNode.Copy",
        "params": [],
        "path": "go/text/template/parse/index#BranchNode.Copy",
        "syntax": "func (b *BranchNode) Copy() Node",
        "type": "text"
    },
    "parse.BranchNode.String": {
        "descr": "",
        "name": "parse.BranchNode.String",
        "params": [],
        "path": "go/text/template/parse/index#BranchNode.String",
        "syntax": "func (b *BranchNode) String() string",
        "type": "text"
    },
    "parse.ChainNode": {
        "descr": "ChainNode holds a term followed by a chain of field accesses (identifier starting with '.'). The names may be chained ('.x.y'). The periods are dropped from each ident.",
        "name": "parse.ChainNode",
        "params": [],
        "path": "go/text/template/parse/index#ChainNode",
        "syntax": "type ChainNode struct { NodeType Pos Node Node Field []string // The identifiers in lexical order. // contains filtered or unexported fields }",
        "type": "text"
    },
    "parse.ChainNode.Add": {
        "descr": "Add adds the named field (which should start with a period) to the end of the chain.",
        "name": "parse.ChainNode.Add",
        "params": [],
        "path": "go/text/template/parse/index#ChainNode.Add",
        "syntax": "func (c *ChainNode) Add(field string)",
        "type": "text"
    },
    "parse.ChainNode.Copy": {
        "descr": "",
        "name": "parse.ChainNode.Copy",
        "params": [],
        "path": "go/text/template/parse/index#ChainNode.Copy",
        "syntax": "func (c *ChainNode) Copy() Node",
        "type": "text"
    },
    "parse.ChainNode.String": {
        "descr": "",
        "name": "parse.ChainNode.String",
        "params": [],
        "path": "go/text/template/parse/index#ChainNode.String",
        "syntax": "func (c *ChainNode) String() string",
        "type": "text"
    },
    "parse.CommandNode": {
        "descr": "CommandNode holds a command (a pipeline inside an evaluating action).",
        "name": "parse.CommandNode",
        "params": [],
        "path": "go/text/template/parse/index#CommandNode",
        "syntax": "type CommandNode struct { NodeType Pos Args []Node // Arguments in lexical order: Identifier, field, or constant. // contains filtered or unexported fields }",
        "type": "text"
    },
    "parse.CommandNode.Copy": {
        "descr": "",
        "name": "parse.CommandNode.Copy",
        "params": [],
        "path": "go/text/template/parse/index#CommandNode.Copy",
        "syntax": "func (c *CommandNode) Copy() Node",
        "type": "text"
    },
    "parse.CommandNode.String": {
        "descr": "",
        "name": "parse.CommandNode.String",
        "params": [],
        "path": "go/text/template/parse/index#CommandNode.String",
        "syntax": "func (c *CommandNode) String() string",
        "type": "text"
    },
    "parse.DotNode": {
        "descr": "DotNode holds the special identifier '.'.",
        "name": "parse.DotNode",
        "params": [],
        "path": "go/text/template/parse/index#DotNode",
        "syntax": "type DotNode struct { NodeType Pos // contains filtered or unexported fields }",
        "type": "text"
    },
    "parse.DotNode.Copy": {
        "descr": "",
        "name": "parse.DotNode.Copy",
        "params": [],
        "path": "go/text/template/parse/index#DotNode.Copy",
        "syntax": "func (d *DotNode) Copy() Node",
        "type": "text"
    },
    "parse.DotNode.String": {
        "descr": "",
        "name": "parse.DotNode.String",
        "params": [],
        "path": "go/text/template/parse/index#DotNode.String",
        "syntax": "func (d *DotNode) String() string",
        "type": "text"
    },
    "parse.DotNode.Type": {
        "descr": "",
        "name": "parse.DotNode.Type",
        "params": [],
        "path": "go/text/template/parse/index#DotNode.Type",
        "syntax": "func (d *DotNode) Type() NodeType",
        "type": "text"
    },
    "parse.FieldNode": {
        "descr": "FieldNode holds a field (identifier starting with '.'). The names may be chained ('.x.y'). The period is dropped from each ident.",
        "name": "parse.FieldNode",
        "params": [],
        "path": "go/text/template/parse/index#FieldNode",
        "syntax": "type FieldNode struct { NodeType Pos Ident []string // The identifiers in lexical order. // contains filtered or unexported fields }",
        "type": "text"
    },
    "parse.FieldNode.Copy": {
        "descr": "",
        "name": "parse.FieldNode.Copy",
        "params": [],
        "path": "go/text/template/parse/index#FieldNode.Copy",
        "syntax": "func (f *FieldNode) Copy() Node",
        "type": "text"
    },
    "parse.FieldNode.String": {
        "descr": "",
        "name": "parse.FieldNode.String",
        "params": [],
        "path": "go/text/template/parse/index#FieldNode.String",
        "syntax": "func (f *FieldNode) String() string",
        "type": "text"
    },
    "parse.IdentifierNode": {
        "descr": "IdentifierNode holds an identifier.",
        "name": "parse.IdentifierNode",
        "params": [],
        "path": "go/text/template/parse/index#IdentifierNode",
        "syntax": "type IdentifierNode struct { NodeType Pos Ident string // The identifier's name. // contains filtered or unexported fields }",
        "type": "text"
    },
    "parse.IdentifierNode.Copy": {
        "descr": "",
        "name": "parse.IdentifierNode.Copy",
        "params": [],
        "path": "go/text/template/parse/index#IdentifierNode.Copy",
        "syntax": "func (i *IdentifierNode) Copy() Node",
        "type": "text"
    },
    "parse.IdentifierNode.SetPos": {
        "descr": "SetPos sets the position. NewIdentifier is a public method so we can't modify its signature. Chained for convenience. TODO: fix one day?",
        "name": "parse.IdentifierNode.SetPos",
        "params": [],
        "path": "go/text/template/parse/index#IdentifierNode.SetPos",
        "syntax": "func (i *IdentifierNode) SetPos(pos Pos) *IdentifierNode",
        "type": "text"
    },
    "parse.IdentifierNode.SetTree": {
        "descr": "SetTree sets the parent tree for the node. NewIdentifier is a public method so we can't modify its signature. Chained for convenience. TODO: fix one day?",
        "name": "parse.IdentifierNode.SetTree",
        "params": [],
        "path": "go/text/template/parse/index#IdentifierNode.SetTree",
        "syntax": "func (i *IdentifierNode) SetTree(t *Tree) *IdentifierNode",
        "type": "text"
    },
    "parse.IdentifierNode.String": {
        "descr": "",
        "name": "parse.IdentifierNode.String",
        "params": [],
        "path": "go/text/template/parse/index#IdentifierNode.String",
        "syntax": "func (i *IdentifierNode) String() string",
        "type": "text"
    },
    "parse.IfNode": {
        "descr": "IfNode represents an {{if}} action and its commands.",
        "name": "parse.IfNode",
        "params": [],
        "path": "go/text/template/parse/index#IfNode",
        "syntax": "type IfNode struct { BranchNode }",
        "type": "text"
    },
    "parse.IfNode.Copy": {
        "descr": "",
        "name": "parse.IfNode.Copy",
        "params": [],
        "path": "go/text/template/parse/index#IfNode.Copy",
        "syntax": "func (i *IfNode) Copy() Node",
        "type": "text"
    },
    "parse.IsEmptyTree": {
        "descr": "IsEmptyTree reports whether this tree (node) is empty of everything but space.",
        "name": "parse.IsEmptyTree",
        "params": [],
        "path": "go/text/template/parse/index#IsEmptyTree",
        "syntax": "func IsEmptyTree(n Node) bool",
        "type": "text"
    },
    "parse.ListNode": {
        "descr": "ListNode holds a sequence of nodes.",
        "name": "parse.ListNode",
        "params": [],
        "path": "go/text/template/parse/index#ListNode",
        "syntax": "type ListNode struct { NodeType Pos Nodes []Node // The element nodes in lexical order. // contains filtered or unexported fields }",
        "type": "text"
    },
    "parse.ListNode.Copy": {
        "descr": "",
        "name": "parse.ListNode.Copy",
        "params": [],
        "path": "go/text/template/parse/index#ListNode.Copy",
        "syntax": "func (l *ListNode) Copy() Node",
        "type": "text"
    },
    "parse.ListNode.CopyList": {
        "descr": "",
        "name": "parse.ListNode.CopyList",
        "params": [],
        "path": "go/text/template/parse/index#ListNode.CopyList",
        "syntax": "func (l *ListNode) CopyList() *ListNode",
        "type": "text"
    },
    "parse.ListNode.String": {
        "descr": "",
        "name": "parse.ListNode.String",
        "params": [],
        "path": "go/text/template/parse/index#ListNode.String",
        "syntax": "func (l *ListNode) String() string",
        "type": "text"
    },
    "parse.New": {
        "descr": "New allocates a new parse tree with the given name.",
        "name": "parse.New",
        "params": [],
        "path": "go/text/template/parse/index#New",
        "syntax": "func New(name string, funcs ...map[string]interface{}) *Tree",
        "type": "text"
    },
    "parse.NewIdentifier": {
        "descr": "NewIdentifier returns a new IdentifierNode with the given identifier name.",
        "name": "parse.NewIdentifier",
        "params": [],
        "path": "go/text/template/parse/index#NewIdentifier",
        "syntax": "func NewIdentifier(ident string) *IdentifierNode",
        "type": "text"
    },
    "parse.NilNode": {
        "descr": "NilNode holds the special identifier 'nil' representing an untyped nil constant.",
        "name": "parse.NilNode",
        "params": [],
        "path": "go/text/template/parse/index#NilNode",
        "syntax": "type NilNode struct { NodeType Pos // contains filtered or unexported fields }",
        "type": "text"
    },
    "parse.NilNode.Copy": {
        "descr": "",
        "name": "parse.NilNode.Copy",
        "params": [],
        "path": "go/text/template/parse/index#NilNode.Copy",
        "syntax": "func (n *NilNode) Copy() Node",
        "type": "text"
    },
    "parse.NilNode.String": {
        "descr": "",
        "name": "parse.NilNode.String",
        "params": [],
        "path": "go/text/template/parse/index#NilNode.String",
        "syntax": "func (n *NilNode) String() string",
        "type": "text"
    },
    "parse.NilNode.Type": {
        "descr": "",
        "name": "parse.NilNode.Type",
        "params": [],
        "path": "go/text/template/parse/index#NilNode.Type",
        "syntax": "func (n *NilNode) Type() NodeType",
        "type": "text"
    },
    "parse.Node": {
        "descr": "A Node is an element in the parse tree. The interface is trivial. The interface contains an unexported method so that only types local to this package can satisfy it.",
        "name": "parse.Node",
        "params": [],
        "path": "go/text/template/parse/index#Node",
        "syntax": "type Node interface { Type() NodeType String() string // Copy does a deep copy of the Node and all its components. // To avoid type assertions, some XxxNodes also have specialized // CopyXxx methods that return *XxxNode. Copy() Node Position() Pos // byte position of start of node in full original input string // contains filtered or unexported methods }",
        "type": "text"
    },
    "parse.NodeType": {
        "descr": "NodeType identifies the type of a parse tree node.",
        "name": "parse.NodeType",
        "params": [],
        "path": "go/text/template/parse/index#NodeType",
        "syntax": "type NodeType int",
        "type": "text"
    },
    "parse.NodeType.Type": {
        "descr": "Type returns itself and provides an easy default implementation for embedding in a Node. Embedded in all non-trivial Nodes.",
        "name": "parse.NodeType.Type",
        "params": [],
        "path": "go/text/template/parse/index#NodeType.Type",
        "syntax": "func (t NodeType) Type() NodeType",
        "type": "text"
    },
    "parse.NumberNode": {
        "descr": "NumberNode holds a number: signed or unsigned integer, float, or complex. The value is parsed and stored under all the types that can represent the value. This simulates in a small amount of code the behavior of Go's ideal constants.",
        "name": "parse.NumberNode",
        "params": [],
        "path": "go/text/template/parse/index#NumberNode",
        "syntax": "type NumberNode struct { NodeType Pos IsInt bool // Number has an integral value. IsUint bool // Number has an unsigned integral value. IsFloat bool // Number has a floating-point value. IsComplex bool // Number is complex. Int64 int64 // The signed integer value. Uint64 uint64 // The unsigned integer value. Float64 float64 // The floating-point value. Complex128 complex128 // The complex value. Text string // The original textual representation from the input. // contains filtered or unexported fields }",
        "type": "text"
    },
    "parse.NumberNode.Copy": {
        "descr": "",
        "name": "parse.NumberNode.Copy",
        "params": [],
        "path": "go/text/template/parse/index#NumberNode.Copy",
        "syntax": "func (n *NumberNode) Copy() Node",
        "type": "text"
    },
    "parse.NumberNode.String": {
        "descr": "",
        "name": "parse.NumberNode.String",
        "params": [],
        "path": "go/text/template/parse/index#NumberNode.String",
        "syntax": "func (n *NumberNode) String() string",
        "type": "text"
    },
    "parse.Parse": {
        "descr": "Parse returns a map from template name to parse.Tree, created by parsing the templates described in the argument string. The top-level template will be given the specified name. If an error is encountered, parsing stops and an empty map is returned with the error.",
        "name": "parse.Parse",
        "params": [],
        "path": "go/text/template/parse/index#Parse",
        "syntax": "func Parse(name, text, leftDelim, rightDelim string, funcs ...map[string]interface{}) (map[string]*Tree, error)",
        "type": "text"
    },
    "parse.PipeNode": {
        "descr": "PipeNode holds a pipeline with optional declaration",
        "name": "parse.PipeNode",
        "params": [],
        "path": "go/text/template/parse/index#PipeNode",
        "syntax": "type PipeNode struct { NodeType Pos Line int // The line number in the input. Deprecated: Kept for compatibility. IsAssign bool // The variables are being assigned, not declared; added in Go 1.11 Decl []*VariableNode // Variables in lexical order. Cmds []*CommandNode // The commands in lexical order. // contains filtered or unexported fields }",
        "type": "text"
    },
    "parse.PipeNode.Copy": {
        "descr": "",
        "name": "parse.PipeNode.Copy",
        "params": [],
        "path": "go/text/template/parse/index#PipeNode.Copy",
        "syntax": "func (p *PipeNode) Copy() Node",
        "type": "text"
    },
    "parse.PipeNode.CopyPipe": {
        "descr": "",
        "name": "parse.PipeNode.CopyPipe",
        "params": [],
        "path": "go/text/template/parse/index#PipeNode.CopyPipe",
        "syntax": "func (p *PipeNode) CopyPipe() *PipeNode",
        "type": "text"
    },
    "parse.PipeNode.String": {
        "descr": "",
        "name": "parse.PipeNode.String",
        "params": [],
        "path": "go/text/template/parse/index#PipeNode.String",
        "syntax": "func (p *PipeNode) String() string",
        "type": "text"
    },
    "parse.Pos": {
        "descr": "Pos represents a byte position in the original input text from which this template was parsed.",
        "name": "parse.Pos",
        "params": [],
        "path": "go/text/template/parse/index#Pos",
        "syntax": "type Pos int",
        "type": "text"
    },
    "parse.Pos.Position": {
        "descr": "",
        "name": "parse.Pos.Position",
        "params": [],
        "path": "go/text/template/parse/index#Pos.Position",
        "syntax": "func (p Pos) Position() Pos",
        "type": "text"
    },
    "parse.RangeNode": {
        "descr": "RangeNode represents a {{range}} action and its commands.",
        "name": "parse.RangeNode",
        "params": [],
        "path": "go/text/template/parse/index#RangeNode",
        "syntax": "type RangeNode struct { BranchNode }",
        "type": "text"
    },
    "parse.RangeNode.Copy": {
        "descr": "",
        "name": "parse.RangeNode.Copy",
        "params": [],
        "path": "go/text/template/parse/index#RangeNode.Copy",
        "syntax": "func (r *RangeNode) Copy() Node",
        "type": "text"
    },
    "parse.StringNode": {
        "descr": "StringNode holds a string constant. The value has been \"unquoted\".",
        "name": "parse.StringNode",
        "params": [],
        "path": "go/text/template/parse/index#StringNode",
        "syntax": "type StringNode struct { NodeType Pos Quoted string // The original text of the string, with quotes. Text string // The string, after quote processing. // contains filtered or unexported fields }",
        "type": "text"
    },
    "parse.StringNode.Copy": {
        "descr": "",
        "name": "parse.StringNode.Copy",
        "params": [],
        "path": "go/text/template/parse/index#StringNode.Copy",
        "syntax": "func (s *StringNode) Copy() Node",
        "type": "text"
    },
    "parse.StringNode.String": {
        "descr": "",
        "name": "parse.StringNode.String",
        "params": [],
        "path": "go/text/template/parse/index#StringNode.String",
        "syntax": "func (s *StringNode) String() string",
        "type": "text"
    },
    "parse.TemplateNode": {
        "descr": "TemplateNode represents a {{template}} action.",
        "name": "parse.TemplateNode",
        "params": [],
        "path": "go/text/template/parse/index#TemplateNode",
        "syntax": "type TemplateNode struct { NodeType Pos Line int // The line number in the input. Deprecated: Kept for compatibility. Name string // The name of the template (unquoted). Pipe *PipeNode // The command to evaluate as dot for the template. // contains filtered or unexported fields }",
        "type": "text"
    },
    "parse.TemplateNode.Copy": {
        "descr": "",
        "name": "parse.TemplateNode.Copy",
        "params": [],
        "path": "go/text/template/parse/index#TemplateNode.Copy",
        "syntax": "func (t *TemplateNode) Copy() Node",
        "type": "text"
    },
    "parse.TemplateNode.String": {
        "descr": "",
        "name": "parse.TemplateNode.String",
        "params": [],
        "path": "go/text/template/parse/index#TemplateNode.String",
        "syntax": "func (t *TemplateNode) String() string",
        "type": "text"
    },
    "parse.TextNode": {
        "descr": "TextNode holds plain text.",
        "name": "parse.TextNode",
        "params": [],
        "path": "go/text/template/parse/index#TextNode",
        "syntax": "type TextNode struct { NodeType Pos Text []byte // The text; may span newlines. // contains filtered or unexported fields }",
        "type": "text"
    },
    "parse.TextNode.Copy": {
        "descr": "",
        "name": "parse.TextNode.Copy",
        "params": [],
        "path": "go/text/template/parse/index#TextNode.Copy",
        "syntax": "func (t *TextNode) Copy() Node",
        "type": "text"
    },
    "parse.TextNode.String": {
        "descr": "",
        "name": "parse.TextNode.String",
        "params": [],
        "path": "go/text/template/parse/index#TextNode.String",
        "syntax": "func (t *TextNode) String() string",
        "type": "text"
    },
    "parse.Tree": {
        "descr": "Tree is the representation of a single parsed template.",
        "name": "parse.Tree",
        "params": [],
        "path": "go/text/template/parse/index#Tree",
        "syntax": "type Tree struct { Name string // name of the template represented by the tree. ParseName string // name of the top-level template during parsing, for error messages; added in Go 1.1 Root *ListNode // top-level root of the tree. // contains filtered or unexported fields }",
        "type": "text"
    },
    "parse.Tree.Copy": {
        "descr": "Copy returns a copy of the Tree. Any parsing state is discarded.",
        "name": "parse.Tree.Copy",
        "params": [],
        "path": "go/text/template/parse/index#Tree.Copy",
        "syntax": "func (t *Tree) Copy() *Tree",
        "type": "text"
    },
    "parse.Tree.ErrorContext": {
        "descr": "ErrorContext returns a textual representation of the location of the node in the input text. The receiver is only used when the node does not have a pointer to the tree inside, which can occur in old code.",
        "name": "parse.Tree.ErrorContext",
        "params": [],
        "path": "go/text/template/parse/index#Tree.ErrorContext",
        "syntax": "func (t *Tree) ErrorContext(n Node) (location, context string)",
        "type": "text"
    },
    "parse.Tree.Parse": {
        "descr": "Parse parses the template definition string to construct a representation of the template for execution. If either action delimiter string is empty, the default (\"{{\" or \"}}\") is used. Embedded template definitions are added to the treeSet map.",
        "name": "parse.Tree.Parse",
        "params": [],
        "path": "go/text/template/parse/index#Tree.Parse",
        "syntax": "func (t *Tree) Parse(text, leftDelim, rightDelim string, treeSet map[string]*Tree, funcs ...map[string]interface{}) (tree *Tree, err error)",
        "type": "text"
    },
    "parse.VariableNode": {
        "descr": "AssignNode holds a list of variable names, possibly with chained field accesses. The dollar sign is part of the (first) name.",
        "name": "parse.VariableNode",
        "params": [],
        "path": "go/text/template/parse/index#VariableNode",
        "syntax": "type VariableNode struct { NodeType Pos Ident []string // Variable name and fields in lexical order. // contains filtered or unexported fields }",
        "type": "text"
    },
    "parse.VariableNode.Copy": {
        "descr": "",
        "name": "parse.VariableNode.Copy",
        "params": [],
        "path": "go/text/template/parse/index#VariableNode.Copy",
        "syntax": "func (v *VariableNode) Copy() Node",
        "type": "text"
    },
    "parse.VariableNode.String": {
        "descr": "",
        "name": "parse.VariableNode.String",
        "params": [],
        "path": "go/text/template/parse/index#VariableNode.String",
        "syntax": "func (v *VariableNode) String() string",
        "type": "text"
    },
    "parse.WithNode": {
        "descr": "WithNode represents a {{with}} action and its commands.",
        "name": "parse.WithNode",
        "params": [],
        "path": "go/text/template/parse/index#WithNode",
        "syntax": "type WithNode struct { BranchNode }",
        "type": "text"
    },
    "parse.WithNode.Copy": {
        "descr": "",
        "name": "parse.WithNode.Copy",
        "params": [],
        "path": "go/text/template/parse/index#WithNode.Copy",
        "syntax": "func (w *WithNode) Copy() Node",
        "type": "text"
    },
    "parser.Mode": {
        "descr": "A Mode value is a set of flags (or 0). They control the amount of source code parsed and other optional parser functionality.",
        "name": "parser.Mode",
        "params": [],
        "path": "go/go/parser/index#Mode",
        "syntax": "type Mode uint",
        "type": "go"
    },
    "parser.ParseDir": {
        "descr": "ParseDir calls ParseFile for all files with names ending in \".go\" in the directory specified by path and returns a map of package name -> package AST with all the packages found.",
        "name": "parser.ParseDir",
        "params": [],
        "path": "go/go/parser/index#ParseDir",
        "syntax": "func ParseDir(fset *token.FileSet, path string, filter func(os.FileInfo) bool, mode Mode) (pkgs map[string]*ast.Package, first error)",
        "type": "go"
    },
    "parser.ParseExpr": {
        "descr": "ParseExpr is a convenience function for obtaining the AST of an expression x. The position information recorded in the AST is undefined. The filename used in error messages is the empty string.",
        "name": "parser.ParseExpr",
        "params": [],
        "path": "go/go/parser/index#ParseExpr",
        "syntax": "func ParseExpr(x string) (ast.Expr, error)",
        "type": "go"
    },
    "parser.ParseExprFrom": {
        "descr": "ParseExprFrom is a convenience function for parsing an expression. The arguments have the same meaning as for ParseFile, but the source must be a valid Go (type or value) expression. Specifically, fset must not be nil.",
        "name": "parser.ParseExprFrom",
        "params": [],
        "path": "go/go/parser/index#ParseExprFrom",
        "syntax": "func ParseExprFrom(fset *token.FileSet, filename string, src interface{}, mode Mode) (ast.Expr, error)",
        "type": "go"
    },
    "parser.ParseFile": {
        "descr": "ParseFile parses the source code of a single Go source file and returns the corresponding ast.File node. The source code may be provided via the filename of the source file, or via the src parameter.",
        "name": "parser.ParseFile",
        "params": [],
        "path": "go/go/parser/index#ParseFile",
        "syntax": "func ParseFile(fset *token.FileSet, filename string, src interface{}, mode Mode) (f *ast.File, err error)",
        "type": "go"
    },
    "path": {
        "descr": "ErrBadPattern indicates a pattern was malformed.",
        "name": "path",
        "params": [],
        "path": "go/path/index#pkg-variables",
        "syntax": "var ErrBadPattern = errors.New(\"syntax error in pattern\")",
        "type": "path"
    },
    "path.Base": {
        "descr": "Base returns the last element of path. Trailing slashes are removed before extracting the last element. If the path is empty, Base returns \".\". If the path consists entirely of slashes, Base returns \"/\".",
        "name": "path.Base",
        "params": [],
        "path": "go/path/index#Base",
        "syntax": "func Base(path string) string",
        "type": "path"
    },
    "path.Clean": {
        "descr": "Clean returns the shortest path name equivalent to path by purely lexical processing. It applies the following rules iteratively until no further processing can be done:",
        "name": "path.Clean",
        "params": [],
        "path": "go/path/index#Clean",
        "syntax": "func Clean(path string) string",
        "type": "path"
    },
    "path.Dir": {
        "descr": "Dir returns all but the last element of path, typically the path's directory. After dropping the final element using Split, the path is Cleaned and trailing slashes are removed. If the path is empty, Dir returns \".\". If the path consists entirely of slashes followed by non-slash bytes, Dir returns a single slash. In any other case, the returned path does not end in a slash.",
        "name": "path.Dir",
        "params": [],
        "path": "go/path/index#Dir",
        "syntax": "func Dir(path string) string",
        "type": "path"
    },
    "path.Ext": {
        "descr": "Ext returns the file name extension used by path. The extension is the suffix beginning at the final dot in the final slash-separated element of path; it is empty if there is no dot.",
        "name": "path.Ext",
        "params": [],
        "path": "go/path/index#Ext",
        "syntax": "func Ext(path string) string",
        "type": "path"
    },
    "path.IsAbs": {
        "descr": "IsAbs reports whether the path is absolute.",
        "name": "path.IsAbs",
        "params": [],
        "path": "go/path/index#IsAbs",
        "syntax": "func IsAbs(path string) bool",
        "type": "path"
    },
    "path.Join": {
        "descr": "Join joins any number of path elements into a single path, adding a separating slash if necessary. The result is Cleaned; in particular, all empty strings are ignored.",
        "name": "path.Join",
        "params": [],
        "path": "go/path/index#Join",
        "syntax": "func Join(elem ...string) string",
        "type": "path"
    },
    "path.Match": {
        "descr": "Match reports whether name matches the shell pattern. The pattern syntax is:",
        "name": "path.Match",
        "params": [],
        "path": "go/path/index#Match",
        "syntax": "func Match(pattern, name string) (matched bool, err error)",
        "type": "path"
    },
    "path.Split": {
        "descr": "Split splits path immediately following the final slash, separating it into a directory and file name component. If there is no slash in path, Split returns an empty dir and file set to path. The returned values have the property that path = dir+file.",
        "name": "path.Split",
        "params": [],
        "path": "go/path/index#Split",
        "syntax": "func Split(path string) (dir, file string)",
        "type": "path"
    },
    "pe.COFFSymbol": {
        "descr": "COFFSymbol represents single COFF symbol table record.",
        "name": "pe.COFFSymbol",
        "params": [],
        "path": "go/debug/pe/index#COFFSymbol",
        "syntax": "type COFFSymbol struct { Name [8]uint8 Value uint32 SectionNumber int16 Type uint16 StorageClass uint8 NumberOfAuxSymbols uint8 }",
        "type": "debug"
    },
    "pe.COFFSymbol.FullName": {
        "descr": "FullName finds real name of symbol sym. Normally name is stored in sym.Name, but if it is longer then 8 characters, it is stored in COFF string table st instead.",
        "name": "pe.COFFSymbol.FullName",
        "params": [],
        "path": "go/debug/pe/index#COFFSymbol.FullName",
        "syntax": "func (sym *COFFSymbol) FullName(st StringTable) (string, error)",
        "type": "debug"
    },
    "pe.DataDirectory": {
        "descr": "",
        "name": "pe.DataDirectory",
        "params": [],
        "path": "go/debug/pe/index#DataDirectory",
        "syntax": "type DataDirectory struct { VirtualAddress uint32 Size uint32 }",
        "type": "debug"
    },
    "pe.File": {
        "descr": "A File represents an open PE file.",
        "name": "pe.File",
        "params": [],
        "path": "go/debug/pe/index#File",
        "syntax": "type File struct { FileHeader OptionalHeader interface{} // of type *OptionalHeader32 or *OptionalHeader64; added in Go 1.3 Sections []*Section Symbols []*Symbol // COFF symbols with auxiliary symbol records removed; added in Go 1.1 COFFSymbols []COFFSymbol // all COFF symbols (including auxiliary symbol records);\n or  added in Go 1.8 StringTable StringTable // Go 1.8 // contains filtered or unexported fields });",
        "type": "debug"
    },
    "pe.File.Close": {
        "descr": "Close closes the File. If the File was created using NewFile directly instead of Open, Close has no effect.",
        "name": "pe.File.Close",
        "params": [],
        "path": "go/debug/pe/index#File.Close",
        "syntax": "func (f *File) Close() error",
        "type": "debug"
    },
    "pe.File.DWARF": {
        "descr": "",
        "name": "pe.File.DWARF",
        "params": [],
        "path": "go/debug/pe/index#File.DWARF",
        "syntax": "func (f *File) DWARF() (*dwarf.Data, error)",
        "type": "debug"
    },
    "pe.File.ImportedLibraries": {
        "descr": "ImportedLibraries returns the names of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time.",
        "name": "pe.File.ImportedLibraries",
        "params": [],
        "path": "go/debug/pe/index#File.ImportedLibraries",
        "syntax": "func (f *File) ImportedLibraries() ([]string, error)",
        "type": "debug"
    },
    "pe.File.ImportedSymbols": {
        "descr": "ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time. It does not return weak symbols.",
        "name": "pe.File.ImportedSymbols",
        "params": [],
        "path": "go/debug/pe/index#File.ImportedSymbols",
        "syntax": "func (f *File) ImportedSymbols() ([]string, error)",
        "type": "debug"
    },
    "pe.File.Section": {
        "descr": "Section returns the first section with the given name, or nil if no such section exists.",
        "name": "pe.File.Section",
        "params": [],
        "path": "go/debug/pe/index#File.Section",
        "syntax": "func (f *File) Section(name string) *Section",
        "type": "debug"
    },
    "pe.FileHeader": {
        "descr": "",
        "name": "pe.FileHeader",
        "params": [],
        "path": "go/debug/pe/index#FileHeader",
        "syntax": "type FileHeader struct { Machine uint16 NumberOfSections uint16 TimeDateStamp uint32 PointerToSymbolTable uint32 NumberOfSymbols uint32 SizeOfOptionalHeader uint16 Characteristics uint16 }",
        "type": "debug"
    },
    "pe.FormatError": {
        "descr": "FormatError is unused. The type is retained for compatibility.",
        "name": "pe.FormatError",
        "params": [],
        "path": "go/debug/pe/index#FormatError",
        "syntax": "type FormatError struct { }",
        "type": "debug"
    },
    "pe.FormatError.Error": {
        "descr": "",
        "name": "pe.FormatError.Error",
        "params": [],
        "path": "go/debug/pe/index#FormatError.Error",
        "syntax": "func (e *FormatError) Error() string",
        "type": "debug"
    },
    "pe.ImportDirectory": {
        "descr": "",
        "name": "pe.ImportDirectory",
        "params": [],
        "path": "go/debug/pe/index#ImportDirectory",
        "syntax": "type ImportDirectory struct { OriginalFirstThunk uint32 TimeDateStamp uint32 ForwarderChain uint32 Name uint32 FirstThunk uint32 // contains filtered or unexported fields }",
        "type": "debug"
    },
    "pe.NewFile": {
        "descr": "NewFile creates a new File for accessing a PE binary in an underlying reader.",
        "name": "pe.NewFile",
        "params": [],
        "path": "go/debug/pe/index#NewFile",
        "syntax": "func NewFile(r io.ReaderAt) (*File, error)",
        "type": "debug"
    },
    "pe.Open": {
        "descr": "Open opens the named file using os.Open and prepares it for use as a PE binary.",
        "name": "pe.Open",
        "params": [],
        "path": "go/debug/pe/index#Open",
        "syntax": "func Open(name string) (*File, error)",
        "type": "debug"
    },
    "pe.OptionalHeader32": {
        "descr": "",
        "name": "pe.OptionalHeader32",
        "params": [],
        "path": "go/debug/pe/index#OptionalHeader32",
        "syntax": "type OptionalHeader32 struct { Magic uint16 MajorLinkerVersion uint8 MinorLinkerVersion uint8 SizeOfCode uint32 SizeOfInitializedData uint32 SizeOfUninitializedData uint32 AddressOfEntryPoint uint32 BaseOfCode uint32 BaseOfData uint32 ImageBase uint32 SectionAlignment uint32 FileAlignment uint32 MajorOperatingSystemVersion uint16 MinorOperatingSystemVersion uint16 MajorImageVersion uint16 MinorImageVersion uint16 MajorSubsystemVersion uint16 MinorSubsystemVersion uint16 Win32VersionValue uint32 SizeOfImage uint32 SizeOfHeaders uint32 CheckSum uint32 Subsystem uint16 DllCharacteristics uint16 SizeOfStackReserve uint32 SizeOfStackCommit uint32 SizeOfHeapReserve uint32 SizeOfHeapCommit uint32 LoaderFlags uint32 NumberOfRvaAndSizes uint32 DataDirectory [16]DataDirectory }",
        "type": "debug"
    },
    "pe.OptionalHeader64": {
        "descr": "",
        "name": "pe.OptionalHeader64",
        "params": [],
        "path": "go/debug/pe/index#OptionalHeader64",
        "syntax": "type OptionalHeader64 struct { Magic uint16 MajorLinkerVersion uint8 MinorLinkerVersion uint8 SizeOfCode uint32 SizeOfInitializedData uint32 SizeOfUninitializedData uint32 AddressOfEntryPoint uint32 BaseOfCode uint32 ImageBase uint64 SectionAlignment uint32 FileAlignment uint32 MajorOperatingSystemVersion uint16 MinorOperatingSystemVersion uint16 MajorImageVersion uint16 MinorImageVersion uint16 MajorSubsystemVersion uint16 MinorSubsystemVersion uint16 Win32VersionValue uint32 SizeOfImage uint32 SizeOfHeaders uint32 CheckSum uint32 Subsystem uint16 DllCharacteristics uint16 SizeOfStackReserve uint64 SizeOfStackCommit uint64 SizeOfHeapReserve uint64 SizeOfHeapCommit uint64 LoaderFlags uint32 NumberOfRvaAndSizes uint32 DataDirectory [16]DataDirectory }",
        "type": "debug"
    },
    "pe.Reloc": {
        "descr": "Reloc represents a PE COFF relocation. Each section contains its own relocation list.",
        "name": "pe.Reloc",
        "params": [],
        "path": "go/debug/pe/index#Reloc",
        "syntax": "type Reloc struct { VirtualAddress uint32 SymbolTableIndex uint32 Type uint16 }",
        "type": "debug"
    },
    "pe.Section": {
        "descr": "Section provides access to PE COFF section.",
        "name": "pe.Section",
        "params": [],
        "path": "go/debug/pe/index#Section",
        "syntax": "type Section struct { SectionHeader Relocs []Reloc // Go 1.8 // Embed ReaderAt for ReadAt method. // Do not embed SectionReader directly // to avoid having Read and Seek. // If a client wants Read and Seek it must use // Open() to avoid fighting over the seek offset // with other clients. io.ReaderAt // contains filtered or unexported fields }",
        "type": "debug"
    },
    "pe.Section.Data": {
        "descr": "Data reads and returns the contents of the PE section s.",
        "name": "pe.Section.Data",
        "params": [],
        "path": "go/debug/pe/index#Section.Data",
        "syntax": "func (s *Section) Data() ([]byte, error)",
        "type": "debug"
    },
    "pe.Section.Open": {
        "descr": "Open returns a new ReadSeeker reading the PE section s.",
        "name": "pe.Section.Open",
        "params": [],
        "path": "go/debug/pe/index#Section.Open",
        "syntax": "func (s *Section) Open() io.ReadSeeker",
        "type": "debug"
    },
    "pe.SectionHeader": {
        "descr": "SectionHeader is similar to SectionHeader32 with Name field replaced by Go string.",
        "name": "pe.SectionHeader",
        "params": [],
        "path": "go/debug/pe/index#SectionHeader",
        "syntax": "type SectionHeader struct { Name string VirtualSize uint32 VirtualAddress uint32 Size uint32 Offset uint32 PointerToRelocations uint32 PointerToLineNumbers uint32 NumberOfRelocations uint16 NumberOfLineNumbers uint16 Characteristics uint32 }",
        "type": "debug"
    },
    "pe.SectionHeader32": {
        "descr": "SectionHeader32 represents real PE COFF section header.",
        "name": "pe.SectionHeader32",
        "params": [],
        "path": "go/debug/pe/index#SectionHeader32",
        "syntax": "type SectionHeader32 struct { Name [8]uint8 VirtualSize uint32 VirtualAddress uint32 SizeOfRawData uint32 PointerToRawData uint32 PointerToRelocations uint32 PointerToLineNumbers uint32 NumberOfRelocations uint16 NumberOfLineNumbers uint16 Characteristics uint32 }",
        "type": "debug"
    },
    "pe.StringTable": {
        "descr": "StringTable is a COFF string table.",
        "name": "pe.StringTable",
        "params": [],
        "path": "go/debug/pe/index#StringTable",
        "syntax": "type StringTable []byte",
        "type": "debug"
    },
    "pe.StringTable.String": {
        "descr": "String extracts string from COFF string table st at offset start.",
        "name": "pe.StringTable.String",
        "params": [],
        "path": "go/debug/pe/index#StringTable.String",
        "syntax": "func (st StringTable) String(start uint32) (string, error)",
        "type": "debug"
    },
    "pe.Symbol": {
        "descr": "Symbol is similar to COFFSymbol with Name field replaced by Go string. Symbol also does not have NumberOfAuxSymbols.",
        "name": "pe.Symbol",
        "params": [],
        "path": "go/debug/pe/index#Symbol",
        "syntax": "type Symbol struct { Name string Value uint32 SectionNumber int16 Type uint16 StorageClass uint8 }",
        "type": "debug"
    },
    "pem.Block": {
        "descr": "A Block represents a PEM encoded structure.",
        "name": "pem.Block",
        "params": [],
        "path": "go/encoding/pem/index#Block",
        "syntax": "-----BEGIN Type----- Headers base64-encoded Bytes -----END Type-----",
        "type": "encoding"
    },
    "pem.Decode": {
        "descr": "Decode will find the next PEM formatted block (certificate, private key etc) in the input. It returns that block and the remainder of the input. If no PEM data is found, p is nil and the whole of the input is returned in rest.",
        "name": "pem.Decode",
        "params": [],
        "path": "go/encoding/pem/index#Decode",
        "syntax": "func Decode(data []byte) (p *Block, rest []byte)",
        "type": "encoding"
    },
    "pem.Encode": {
        "descr": "Encode writes the PEM encoding of b to out.",
        "name": "pem.Encode",
        "params": [],
        "path": "go/encoding/pem/index#Encode",
        "syntax": "func Encode(out io.Writer, b *Block) error",
        "type": "encoding"
    },
    "pem.EncodeToMemory": {
        "descr": "EncodeToMemory returns the PEM encoding of b.",
        "name": "pem.EncodeToMemory",
        "params": [],
        "path": "go/encoding/pem/index#EncodeToMemory",
        "syntax": "func EncodeToMemory(b *Block) []byte",
        "type": "encoding"
    },
    "pkix.AlgorithmIdentifier": {
        "descr": "AlgorithmIdentifier represents the ASN.1 structure of the same name. See RFC 5280, section 4.1.1.2.",
        "name": "pkix.AlgorithmIdentifier",
        "params": [],
        "path": "go/crypto/x509/pkix/index#AlgorithmIdentifier",
        "syntax": "type AlgorithmIdentifier struct { Algorithm asn1.ObjectIdentifier Parameters asn1.RawValue `asn1:\"optional\"` }",
        "type": "crypto"
    },
    "pkix.AttributeTypeAndValue": {
        "descr": "AttributeTypeAndValue mirrors the ASN.1 structure of the same name in https://tools.ietf.org/html/rfc5280#section-4.1.2.4",
        "name": "pkix.AttributeTypeAndValue",
        "params": [],
        "path": "go/crypto/x509/pkix/index#AttributeTypeAndValue",
        "syntax": "type AttributeTypeAndValue struct { Type asn1.ObjectIdentifier Value interface{} }",
        "type": "crypto"
    },
    "pkix.AttributeTypeAndValueSET": {
        "descr": "AttributeTypeAndValueSET represents a set of ASN.1 sequences of AttributeTypeAndValue sequences from RFC 2986 (PKCS #10).",
        "name": "pkix.AttributeTypeAndValueSET",
        "params": [],
        "path": "go/crypto/x509/pkix/index#AttributeTypeAndValueSET",
        "syntax": "type AttributeTypeAndValueSET struct { Type asn1.ObjectIdentifier Value [][]AttributeTypeAndValue `asn1:\"set\"` }",
        "type": "crypto"
    },
    "pkix.CertificateList": {
        "descr": "CertificateList represents the ASN.1 structure of the same name. See RFC 5280, section 5.1. Use Certificate.CheckCRLSignature to verify the signature.",
        "name": "pkix.CertificateList",
        "params": [],
        "path": "go/crypto/x509/pkix/index#CertificateList",
        "syntax": "type CertificateList struct { TBSCertList TBSCertificateList SignatureAlgorithm AlgorithmIdentifier SignatureValue asn1.BitString }",
        "type": "crypto"
    },
    "pkix.CertificateList.HasExpired": {
        "descr": "HasExpired reports whether certList should have been updated by now.",
        "name": "pkix.CertificateList.HasExpired",
        "params": [],
        "path": "go/crypto/x509/pkix/index#CertificateList.HasExpired",
        "syntax": "func (certList *CertificateList) HasExpired(now time.Time) bool",
        "type": "crypto"
    },
    "pkix.Extension": {
        "descr": "Extension represents the ASN.1 structure of the same name. See RFC 5280, section 4.2.",
        "name": "pkix.Extension",
        "params": [],
        "path": "go/crypto/x509/pkix/index#Extension",
        "syntax": "type Extension struct { Id asn1.ObjectIdentifier Critical bool `asn1:\"optional\"` Value []byte }",
        "type": "crypto"
    },
    "pkix.Name": {
        "descr": "Name represents an X.509 distinguished name. This only includes the common elements of a DN. When parsing, all elements are stored in Names and non-standard elements can be extracted from there. When marshaling, elements in ExtraNames are appended and override other values with the same OID.",
        "name": "pkix.Name",
        "params": [],
        "path": "go/crypto/x509/pkix/index#Name",
        "syntax": "type Name struct { Country, Organization, OrganizationalUnit []string Locality, Province []string StreetAddress, PostalCode []string SerialNumber, CommonName string Names []AttributeTypeAndValue ExtraNames []AttributeTypeAndValue // Go 1.5 }",
        "type": "crypto"
    },
    "pkix.Name.FillFromRDNSequence": {
        "descr": "",
        "name": "pkix.Name.FillFromRDNSequence",
        "params": [],
        "path": "go/crypto/x509/pkix/index#Name.FillFromRDNSequence",
        "syntax": "func (n *Name) FillFromRDNSequence(rdns *RDNSequence)",
        "type": "crypto"
    },
    "pkix.Name.String": {
        "descr": "String returns the string form of n, roughly following the RFC 2253 Distinguished Names syntax.",
        "name": "pkix.Name.String",
        "params": [],
        "path": "go/crypto/x509/pkix/index#Name.String",
        "syntax": "func (n Name) String() string",
        "type": "crypto"
    },
    "pkix.Name.ToRDNSequence": {
        "descr": "",
        "name": "pkix.Name.ToRDNSequence",
        "params": [],
        "path": "go/crypto/x509/pkix/index#Name.ToRDNSequence",
        "syntax": "func (n Name) ToRDNSequence() (ret RDNSequence)",
        "type": "crypto"
    },
    "pkix.RDNSequence": {
        "descr": "",
        "name": "pkix.RDNSequence",
        "params": [],
        "path": "go/crypto/x509/pkix/index#RDNSequence",
        "syntax": "type RDNSequence []RelativeDistinguishedNameSET",
        "type": "crypto"
    },
    "pkix.RDNSequence.String": {
        "descr": "String returns a string representation of the sequence r, roughly following the RFC 2253 Distinguished Names syntax.",
        "name": "pkix.RDNSequence.String",
        "params": [],
        "path": "go/crypto/x509/pkix/index#RDNSequence.String",
        "syntax": "func (r RDNSequence) String() string",
        "type": "crypto"
    },
    "pkix.RelativeDistinguishedNameSET": {
        "descr": "",
        "name": "pkix.RelativeDistinguishedNameSET",
        "params": [],
        "path": "go/crypto/x509/pkix/index#RelativeDistinguishedNameSET",
        "syntax": "type RelativeDistinguishedNameSET []AttributeTypeAndValue",
        "type": "crypto"
    },
    "pkix.RevokedCertificate": {
        "descr": "RevokedCertificate represents the ASN.1 structure of the same name. See RFC 5280, section 5.1.",
        "name": "pkix.RevokedCertificate",
        "params": [],
        "path": "go/crypto/x509/pkix/index#RevokedCertificate",
        "syntax": "type RevokedCertificate struct { SerialNumber *big.Int RevocationTime time.Time Extensions []Extension `asn1:\"optional\"` }",
        "type": "crypto"
    },
    "pkix.TBSCertificateList": {
        "descr": "TBSCertificateList represents the ASN.1 structure of the same name. See RFC 5280, section 5.1.",
        "name": "pkix.TBSCertificateList",
        "params": [],
        "path": "go/crypto/x509/pkix/index#TBSCertificateList",
        "syntax": "type TBSCertificateList struct { Raw asn1.RawContent Version int `asn1:\"optional,default:0\"` Signature AlgorithmIdentifier Issuer RDNSequence ThisUpdate time.Time NextUpdate time.Time `asn1:\"optional\"` RevokedCertificates []RevokedCertificate `asn1:\"optional\"` Extensions []Extension `asn1:\"tag:0,optional,explicit\"` }",
        "type": "crypto"
    },
    "plan9obj.File": {
        "descr": "A File represents an open Plan 9 a.out file.",
        "name": "plan9obj.File",
        "params": [],
        "path": "go/debug/plan9obj/index#File",
        "syntax": "type File struct { FileHeader Sections []*Section // contains filtered or unexported fields }",
        "type": "debug"
    },
    "plan9obj.File.Close": {
        "descr": "Close closes the File. If the File was created using NewFile directly instead of Open, Close has no effect.",
        "name": "plan9obj.File.Close",
        "params": [],
        "path": "go/debug/plan9obj/index#File.Close",
        "syntax": "func (f *File) Close() error",
        "type": "debug"
    },
    "plan9obj.File.Section": {
        "descr": "Section returns a section with the given name, or nil if no such section exists.",
        "name": "plan9obj.File.Section",
        "params": [],
        "path": "go/debug/plan9obj/index#File.Section",
        "syntax": "func (f *File) Section(name string) *Section",
        "type": "debug"
    },
    "plan9obj.File.Symbols": {
        "descr": "Symbols returns the symbol table for f.",
        "name": "plan9obj.File.Symbols",
        "params": [],
        "path": "go/debug/plan9obj/index#File.Symbols",
        "syntax": "func (f *File) Symbols() ([]Sym, error)",
        "type": "debug"
    },
    "plan9obj.FileHeader": {
        "descr": "A FileHeader represents a Plan 9 a.out file header.",
        "name": "plan9obj.FileHeader",
        "params": [],
        "path": "go/debug/plan9obj/index#FileHeader",
        "syntax": "type FileHeader struct { Magic uint32 Bss uint32 Entry uint64 PtrSize int LoadAddress uint64 // Go 1.4 HdrSize uint64 // Go 1.4 }",
        "type": "debug"
    },
    "plan9obj.NewFile": {
        "descr": "NewFile creates a new File for accessing a Plan 9 binary in an underlying reader. The Plan 9 binary is expected to start at position 0 in the ReaderAt.",
        "name": "plan9obj.NewFile",
        "params": [],
        "path": "go/debug/plan9obj/index#NewFile",
        "syntax": "func NewFile(r io.ReaderAt) (*File, error)",
        "type": "debug"
    },
    "plan9obj.Open": {
        "descr": "Open opens the named file using os.Open and prepares it for use as a Plan 9 a.out binary.",
        "name": "plan9obj.Open",
        "params": [],
        "path": "go/debug/plan9obj/index#Open",
        "syntax": "func Open(name string) (*File, error)",
        "type": "debug"
    },
    "plan9obj.Section": {
        "descr": "A Section represents a single section in a Plan 9 a.out file.",
        "name": "plan9obj.Section",
        "params": [],
        "path": "go/debug/plan9obj/index#Section",
        "syntax": "type Section struct { SectionHeader // Embed ReaderAt for ReadAt method. // Do not embed SectionReader directly // to avoid having Read and Seek. // If a client wants Read and Seek it must use // Open() to avoid fighting over the seek offset // with other clients. io.ReaderAt // contains filtered or unexported fields }",
        "type": "debug"
    },
    "plan9obj.Section.Data": {
        "descr": "Data reads and returns the contents of the Plan 9 a.out section.",
        "name": "plan9obj.Section.Data",
        "params": [],
        "path": "go/debug/plan9obj/index#Section.Data",
        "syntax": "func (s *Section) Data() ([]byte, error)",
        "type": "debug"
    },
    "plan9obj.Section.Open": {
        "descr": "Open returns a new ReadSeeker reading the Plan 9 a.out section.",
        "name": "plan9obj.Section.Open",
        "params": [],
        "path": "go/debug/plan9obj/index#Section.Open",
        "syntax": "func (s *Section) Open() io.ReadSeeker",
        "type": "debug"
    },
    "plan9obj.SectionHeader": {
        "descr": "A SectionHeader represents a single Plan 9 a.out section header. This structure doesn't exist on-disk, but eases navigation through the object file.",
        "name": "plan9obj.SectionHeader",
        "params": [],
        "path": "go/debug/plan9obj/index#SectionHeader",
        "syntax": "type SectionHeader struct { Name string Size uint32 Offset uint32 }",
        "type": "debug"
    },
    "plan9obj.Sym": {
        "descr": "A Symbol represents an entry in a Plan 9 a.out symbol table section.",
        "name": "plan9obj.Sym",
        "params": [],
        "path": "go/debug/plan9obj/index#Sym",
        "syntax": "type Sym struct { Value uint64 Type rune Name string }",
        "type": "debug"
    },
    "plugin.Open": {
        "descr": "Open opens a Go plugin. If a path has already been opened, then the existing *Plugin is returned. It is safe for concurrent use by multiple goroutines.",
        "name": "plugin.Open",
        "params": [],
        "path": "go/plugin/index#Open",
        "syntax": "func Open(path string) (*Plugin, error)",
        "type": "plugin"
    },
    "plugin.Plugin": {
        "descr": "Plugin is a loaded Go plugin.",
        "name": "plugin.Plugin",
        "params": [],
        "path": "go/plugin/index#Plugin",
        "syntax": "type Plugin struct { // contains filtered or unexported fields }",
        "type": "plugin"
    },
    "plugin.Plugin.Lookup": {
        "descr": "Lookup searches for a symbol named symName in plugin p. A symbol is any exported variable or function. It reports an error if the symbol is not found. It is safe for concurrent use by multiple goroutines.",
        "name": "plugin.Plugin.Lookup",
        "params": [],
        "path": "go/plugin/index#Plugin.Lookup",
        "syntax": "func (p *Plugin) Lookup(symName string) (Symbol, error)",
        "type": "plugin"
    },
    "plugin.Symbol": {
        "descr": "A Symbol is a pointer to a variable or function.",
        "name": "plugin.Symbol",
        "params": [],
        "path": "go/plugin/index#Symbol",
        "syntax": "package main import \"fmt\" var V int func F() { fmt.Printf(\"Hello, number %d\\n\", V) }",
        "type": "plugin"
    },
    "png.CompressionLevel": {
        "descr": "",
        "name": "png.CompressionLevel",
        "params": [],
        "path": "go/image/png/index#CompressionLevel",
        "syntax": "type CompressionLevel int",
        "type": "image"
    },
    "png.Decode": {
        "descr": "Decode reads a PNG image from r and returns it as an image.Image. The type of Image returned depends on the PNG contents.",
        "name": "png.Decode",
        "params": [],
        "path": "go/image/png/index#Decode",
        "syntax": "func Decode(r io.Reader) (image.Image, error)",
        "type": "image"
    },
    "png.DecodeConfig": {
        "descr": "DecodeConfig returns the color model and dimensions of a PNG image without decoding the entire image.",
        "name": "png.DecodeConfig",
        "params": [],
        "path": "go/image/png/index#DecodeConfig",
        "syntax": "func DecodeConfig(r io.Reader) (image.Config, error)",
        "type": "image"
    },
    "png.Encode": {
        "descr": "Encode writes the Image m to w in PNG format. Any Image may be encoded, but images that are not image.NRGBA might be encoded lossily.",
        "name": "png.Encode",
        "params": [],
        "path": "go/image/png/index#Encode",
        "syntax": "func Encode(w io.Writer, m image.Image) error",
        "type": "image"
    },
    "png.Encoder": {
        "descr": "Encoder configures encoding PNG images.",
        "name": "png.Encoder",
        "params": [],
        "path": "go/image/png/index#Encoder",
        "syntax": "type Encoder struct { CompressionLevel CompressionLevel // BufferPool optionally specifies a buffer pool to get temporary // EncoderBuffers when encoding an image. BufferPool EncoderBufferPool // Go 1.9 }",
        "type": "image"
    },
    "png.Encoder.Encode": {
        "descr": "Encode writes the Image m to w in PNG format.",
        "name": "png.Encoder.Encode",
        "params": [],
        "path": "go/image/png/index#Encoder.Encode",
        "syntax": "func (enc *Encoder) Encode(w io.Writer, m image.Image) error",
        "type": "image"
    },
    "png.EncoderBuffer": {
        "descr": "EncoderBuffer holds the buffers used for encoding PNG images.",
        "name": "png.EncoderBuffer",
        "params": [],
        "path": "go/image/png/index#EncoderBuffer",
        "syntax": "type EncoderBuffer encoder",
        "type": "image"
    },
    "png.EncoderBufferPool": {
        "descr": "EncoderBufferPool is an interface for getting and returning temporary instances of the EncoderBuffer struct. This can be used to reuse buffers when encoding multiple images.",
        "name": "png.EncoderBufferPool",
        "params": [],
        "path": "go/image/png/index#EncoderBufferPool",
        "syntax": "type EncoderBufferPool interface { Get() *EncoderBuffer Put(*EncoderBuffer) }",
        "type": "image"
    },
    "png.FormatError": {
        "descr": "A FormatError reports that the input is not a valid PNG.",
        "name": "png.FormatError",
        "params": [],
        "path": "go/image/png/index#FormatError",
        "syntax": "type FormatError string",
        "type": "image"
    },
    "png.FormatError.Error": {
        "descr": "",
        "name": "png.FormatError.Error",
        "params": [],
        "path": "go/image/png/index#FormatError.Error",
        "syntax": "func (e FormatError) Error() string",
        "type": "image"
    },
    "png.UnsupportedError": {
        "descr": "An UnsupportedError reports that the input uses a valid but unimplemented PNG feature.",
        "name": "png.UnsupportedError",
        "params": [],
        "path": "go/image/png/index#UnsupportedError",
        "syntax": "type UnsupportedError string",
        "type": "image"
    },
    "png.UnsupportedError.Error": {
        "descr": "",
        "name": "png.UnsupportedError.Error",
        "params": [],
        "path": "go/image/png/index#UnsupportedError.Error",
        "syntax": "func (e UnsupportedError) Error() string",
        "type": "image"
    },
    "poll.DupCloseOnExec": {
        "descr": "DupCloseOnExec dups fd and marks it close-on-exec.",
        "name": "poll.DupCloseOnExec",
        "params": [],
        "path": "go/internal/poll/index#DupCloseOnExec",
        "syntax": "func DupCloseOnExec(fd int) (int, string, error)",
        "type": "internal"
    },
    "poll.FD": {
        "descr": "FD is a file descriptor. The net and os packages use this type as a field of a larger type representing a network connection or OS file.",
        "name": "poll.FD",
        "params": [],
        "path": "go/internal/poll/index#FD",
        "syntax": "type FD struct { // System file descriptor. Immutable until Close. Sysfd int // Whether this is a streaming descriptor, as opposed to a // packet-based descriptor like a UDP socket. Immutable. IsStream bool // Whether a zero byte read indicates EOF. This is false for a // message based socket connection. ZeroReadIsEOF bool // contains filtered or unexported fields }",
        "type": "internal"
    },
    "poll.FD.Accept": {
        "descr": "Accept wraps the accept network call.",
        "name": "poll.FD.Accept",
        "params": [],
        "path": "go/internal/poll/index#FD.Accept",
        "syntax": "func (fd *FD) Accept() (int, syscall.Sockaddr, string, error)",
        "type": "internal"
    },
    "poll.FD.Close": {
        "descr": "Close closes the FD. The underlying file descriptor is closed by the destroy method when there are no remaining references.",
        "name": "poll.FD.Close",
        "params": [],
        "path": "go/internal/poll/index#FD.Close",
        "syntax": "func (fd *FD) Close() error",
        "type": "internal"
    },
    "poll.FD.Dup": {
        "descr": "Dup duplicates the file descriptor.",
        "name": "poll.FD.Dup",
        "params": [],
        "path": "go/internal/poll/index#FD.Dup",
        "syntax": "func (fd *FD) Dup() (int, string, error)",
        "type": "internal"
    },
    "poll.FD.Fchdir": {
        "descr": "Fchdir wraps syscall.Fchdir.",
        "name": "poll.FD.Fchdir",
        "params": [],
        "path": "go/internal/poll/index#FD.Fchdir",
        "syntax": "func (fd *FD) Fchdir() error",
        "type": "internal"
    },
    "poll.FD.Fchmod": {
        "descr": "Fchmod wraps syscall.Fchmod.",
        "name": "poll.FD.Fchmod",
        "params": [],
        "path": "go/internal/poll/index#FD.Fchmod",
        "syntax": "func (fd *FD) Fchmod(mode uint32) error",
        "type": "internal"
    },
    "poll.FD.Fchown": {
        "descr": "Fchown wraps syscall.Fchown.",
        "name": "poll.FD.Fchown",
        "params": [],
        "path": "go/internal/poll/index#FD.Fchown",
        "syntax": "func (fd *FD) Fchown(uid, gid int) error",
        "type": "internal"
    },
    "poll.FD.Fstat": {
        "descr": "Fstat wraps syscall.Fstat",
        "name": "poll.FD.Fstat",
        "params": [],
        "path": "go/internal/poll/index#FD.Fstat",
        "syntax": "func (fd *FD) Fstat(s *syscall.Stat_t) error",
        "type": "internal"
    },
    "poll.FD.Fsync": {
        "descr": "Fsync wraps syscall.Fsync.",
        "name": "poll.FD.Fsync",
        "params": [],
        "path": "go/internal/poll/index#FD.Fsync",
        "syntax": "func (fd *FD) Fsync() error",
        "type": "internal"
    },
    "poll.FD.Ftruncate": {
        "descr": "Ftruncate wraps syscall.Ftruncate.",
        "name": "poll.FD.Ftruncate",
        "params": [],
        "path": "go/internal/poll/index#FD.Ftruncate",
        "syntax": "func (fd *FD) Ftruncate(size int64) error",
        "type": "internal"
    },
    "poll.FD.Init": {
        "descr": "Init initializes the FD. The Sysfd field should already be set. This can be called multiple times on a single FD. The net argument is a network name from the net package (e.g., \"tcp\"), or \"file\". Set pollable to true if fd should be managed by runtime netpoll.",
        "name": "poll.FD.Init",
        "params": [],
        "path": "go/internal/poll/index#FD.Init",
        "syntax": "func (fd *FD) Init(net string, pollable bool) error",
        "type": "internal"
    },
    "poll.FD.Pread": {
        "descr": "Pread wraps the pread system call.",
        "name": "poll.FD.Pread",
        "params": [],
        "path": "go/internal/poll/index#FD.Pread",
        "syntax": "func (fd *FD) Pread(p []byte, off int64) (int, error)",
        "type": "internal"
    },
    "poll.FD.Pwrite": {
        "descr": "Pwrite wraps the pwrite system call.",
        "name": "poll.FD.Pwrite",
        "params": [],
        "path": "go/internal/poll/index#FD.Pwrite",
        "syntax": "func (fd *FD) Pwrite(p []byte, off int64) (int, error)",
        "type": "internal"
    },
    "poll.FD.RawControl": {
        "descr": "RawControl invokes the user-defined function f for a non-IO operation.",
        "name": "poll.FD.RawControl",
        "params": [],
        "path": "go/internal/poll/index#FD.RawControl",
        "syntax": "func (fd *FD) RawControl(f func(uintptr)) error",
        "type": "internal"
    },
    "poll.FD.RawRead": {
        "descr": "RawRead invokes the user-defined function f for a read operation.",
        "name": "poll.FD.RawRead",
        "params": [],
        "path": "go/internal/poll/index#FD.RawRead",
        "syntax": "func (fd *FD) RawRead(f func(uintptr) bool) error",
        "type": "internal"
    },
    "poll.FD.RawWrite": {
        "descr": "RawWrite invokes the user-defined function f for a write operation.",
        "name": "poll.FD.RawWrite",
        "params": [],
        "path": "go/internal/poll/index#FD.RawWrite",
        "syntax": "func (fd *FD) RawWrite(f func(uintptr) bool) error",
        "type": "internal"
    },
    "poll.FD.Read": {
        "descr": "Read implements io.Reader.",
        "name": "poll.FD.Read",
        "params": [],
        "path": "go/internal/poll/index#FD.Read",
        "syntax": "func (fd *FD) Read(p []byte) (int, error)",
        "type": "internal"
    },
    "poll.FD.ReadDirent": {
        "descr": "ReadDirent wraps syscall.ReadDirent. We treat this like an ordinary system call rather than a call that tries to fill the buffer.",
        "name": "poll.FD.ReadDirent",
        "params": [],
        "path": "go/internal/poll/index#FD.ReadDirent",
        "syntax": "func (fd *FD) ReadDirent(buf []byte) (int, error)",
        "type": "internal"
    },
    "poll.FD.ReadFrom": {
        "descr": "ReadFrom wraps the recvfrom network call.",
        "name": "poll.FD.ReadFrom",
        "params": [],
        "path": "go/internal/poll/index#FD.ReadFrom",
        "syntax": "func (fd *FD) ReadFrom(p []byte) (int, syscall.Sockaddr, error)",
        "type": "internal"
    },
    "poll.FD.ReadMsg": {
        "descr": "ReadMsg wraps the recvmsg network call.",
        "name": "poll.FD.ReadMsg",
        "params": [],
        "path": "go/internal/poll/index#FD.ReadMsg",
        "syntax": "func (fd *FD) ReadMsg(p []byte, oob []byte) (int, int, int, syscall.Sockaddr, error)",
        "type": "internal"
    },
    "poll.FD.Seek": {
        "descr": "Seek wraps syscall.Seek.",
        "name": "poll.FD.Seek",
        "params": [],
        "path": "go/internal/poll/index#FD.Seek",
        "syntax": "func (fd *FD) Seek(offset int64, whence int) (int64, error)",
        "type": "internal"
    },
    "poll.FD.SetBlocking": {
        "descr": "SetBlocking puts the file into blocking mode.",
        "name": "poll.FD.SetBlocking",
        "params": [],
        "path": "go/internal/poll/index#FD.SetBlocking",
        "syntax": "func (fd *FD) SetBlocking() error",
        "type": "internal"
    },
    "poll.FD.SetDeadline": {
        "descr": "SetDeadline sets the read and write deadlines associated with fd.",
        "name": "poll.FD.SetDeadline",
        "params": [],
        "path": "go/internal/poll/index#FD.SetDeadline",
        "syntax": "func (fd *FD) SetDeadline(t time.Time) error",
        "type": "internal"
    },
    "poll.FD.SetReadDeadline": {
        "descr": "SetReadDeadline sets the read deadline associated with fd.",
        "name": "poll.FD.SetReadDeadline",
        "params": [],
        "path": "go/internal/poll/index#FD.SetReadDeadline",
        "syntax": "func (fd *FD) SetReadDeadline(t time.Time) error",
        "type": "internal"
    },
    "poll.FD.SetWriteDeadline": {
        "descr": "SetWriteDeadline sets the write deadline associated with fd.",
        "name": "poll.FD.SetWriteDeadline",
        "params": [],
        "path": "go/internal/poll/index#FD.SetWriteDeadline",
        "syntax": "func (fd *FD) SetWriteDeadline(t time.Time) error",
        "type": "internal"
    },
    "poll.FD.SetsockoptByte": {
        "descr": "SetsockoptByte wraps the setsockopt network call with a byte argument.",
        "name": "poll.FD.SetsockoptByte",
        "params": [],
        "path": "go/internal/poll/index#FD.SetsockoptByte",
        "syntax": "func (fd *FD) SetsockoptByte(level, name int, arg byte) error",
        "type": "internal"
    },
    "poll.FD.SetsockoptIPMreq": {
        "descr": "SetsockoptIPMreq wraps the setsockopt network call with an IPMreq argument.",
        "name": "poll.FD.SetsockoptIPMreq",
        "params": [],
        "path": "go/internal/poll/index#FD.SetsockoptIPMreq",
        "syntax": "func (fd *FD) SetsockoptIPMreq(level, name int, mreq *syscall.IPMreq) error",
        "type": "internal"
    },
    "poll.FD.SetsockoptIPMreqn": {
        "descr": "SetsockoptIPMreqn wraps the setsockopt network call with an IPMreqn argument.",
        "name": "poll.FD.SetsockoptIPMreqn",
        "params": [],
        "path": "go/internal/poll/index#FD.SetsockoptIPMreqn",
        "syntax": "func (fd *FD) SetsockoptIPMreqn(level, name int, mreq *syscall.IPMreqn) error",
        "type": "internal"
    },
    "poll.FD.SetsockoptIPv6Mreq": {
        "descr": "SetsockoptIPv6Mreq wraps the setsockopt network call with an IPv6Mreq argument.",
        "name": "poll.FD.SetsockoptIPv6Mreq",
        "params": [],
        "path": "go/internal/poll/index#FD.SetsockoptIPv6Mreq",
        "syntax": "func (fd *FD) SetsockoptIPv6Mreq(level, name int, mreq *syscall.IPv6Mreq) error",
        "type": "internal"
    },
    "poll.FD.SetsockoptInet4Addr": {
        "descr": "SetsockoptInet4Addr wraps the setsockopt network call with an IPv4 address.",
        "name": "poll.FD.SetsockoptInet4Addr",
        "params": [],
        "path": "go/internal/poll/index#FD.SetsockoptInet4Addr",
        "syntax": "func (fd *FD) SetsockoptInet4Addr(level, name int, arg [4]byte) error",
        "type": "internal"
    },
    "poll.FD.SetsockoptInt": {
        "descr": "SetsockoptInt wraps the setsockopt network call with an int argument.",
        "name": "poll.FD.SetsockoptInt",
        "params": [],
        "path": "go/internal/poll/index#FD.SetsockoptInt",
        "syntax": "func (fd *FD) SetsockoptInt(level, name, arg int) error",
        "type": "internal"
    },
    "poll.FD.SetsockoptLinger": {
        "descr": "SetsockoptLinger wraps the setsockopt network call with a Linger argument.",
        "name": "poll.FD.SetsockoptLinger",
        "params": [],
        "path": "go/internal/poll/index#FD.SetsockoptLinger",
        "syntax": "func (fd *FD) SetsockoptLinger(level, name int, l *syscall.Linger) error",
        "type": "internal"
    },
    "poll.FD.Shutdown": {
        "descr": "Shutdown wraps the shutdown network call.",
        "name": "poll.FD.Shutdown",
        "params": [],
        "path": "go/internal/poll/index#FD.Shutdown",
        "syntax": "func (fd *FD) Shutdown(how int) error",
        "type": "internal"
    },
    "poll.FD.WaitWrite": {
        "descr": "WaitWrite waits until data can be read from fd.",
        "name": "poll.FD.WaitWrite",
        "params": [],
        "path": "go/internal/poll/index#FD.WaitWrite",
        "syntax": "func (fd *FD) WaitWrite() error",
        "type": "internal"
    },
    "poll.FD.Write": {
        "descr": "Write implements io.Writer.",
        "name": "poll.FD.Write",
        "params": [],
        "path": "go/internal/poll/index#FD.Write",
        "syntax": "func (fd *FD) Write(p []byte) (int, error)",
        "type": "internal"
    },
    "poll.FD.WriteMsg": {
        "descr": "WriteMsg wraps the sendmsg network call.",
        "name": "poll.FD.WriteMsg",
        "params": [],
        "path": "go/internal/poll/index#FD.WriteMsg",
        "syntax": "func (fd *FD) WriteMsg(p []byte, oob []byte, sa syscall.Sockaddr) (int, int, error)",
        "type": "internal"
    },
    "poll.FD.WriteOnce": {
        "descr": "WriteOnce is for testing only. It makes a single write call.",
        "name": "poll.FD.WriteOnce",
        "params": [],
        "path": "go/internal/poll/index#FD.WriteOnce",
        "syntax": "func (fd *FD) WriteOnce(p []byte) (int, error)",
        "type": "internal"
    },
    "poll.FD.WriteTo": {
        "descr": "WriteTo wraps the sendto network call.",
        "name": "poll.FD.WriteTo",
        "params": [],
        "path": "go/internal/poll/index#FD.WriteTo",
        "syntax": "func (fd *FD) WriteTo(p []byte, sa syscall.Sockaddr) (int, error)",
        "type": "internal"
    },
    "poll.FD.Writev": {
        "descr": "Writev wraps the writev system call.",
        "name": "poll.FD.Writev",
        "params": [],
        "path": "go/internal/poll/index#FD.Writev",
        "syntax": "func (fd *FD) Writev(v *[][]byte) (int64, error)",
        "type": "internal"
    },
    "poll.PollDescriptor": {
        "descr": "PollDescriptor returns the descriptor being used by the poller, or ^uintptr(0) if there isn't one. This is only used for testing.",
        "name": "poll.PollDescriptor",
        "params": [],
        "path": "go/internal/poll/index#PollDescriptor",
        "syntax": "func PollDescriptor() uintptr",
        "type": "internal"
    },
    "poll.SendFile": {
        "descr": "SendFile wraps the sendfile system call.",
        "name": "poll.SendFile",
        "params": [],
        "path": "go/internal/poll/index#SendFile",
        "syntax": "func SendFile(dstFD *FD, src int, remain int64) (int64, error)",
        "type": "internal"
    },
    "poll.Splice": {
        "descr": "Splice transfers at most remain bytes of data from src to dst, using the splice system call to minimize copies of data from and to userspace.",
        "name": "poll.Splice",
        "params": [],
        "path": "go/internal/poll/index#Splice",
        "syntax": "func Splice(dst, src *FD, remain int64) (written int64, handled bool, sc string, err error)",
        "type": "internal"
    },
    "poll.TimeoutError": {
        "descr": "TimeoutError is returned for an expired deadline.",
        "name": "poll.TimeoutError",
        "params": [],
        "path": "go/internal/poll/index#TimeoutError",
        "syntax": "type TimeoutError struct{}",
        "type": "internal"
    },
    "poll.TimeoutError.Error": {
        "descr": "Implement the net.Error interface.",
        "name": "poll.TimeoutError.Error",
        "params": [],
        "path": "go/internal/poll/index#TimeoutError.Error",
        "syntax": "func (e *TimeoutError) Error() string",
        "type": "internal"
    },
    "poll.TimeoutError.Temporary": {
        "descr": "",
        "name": "poll.TimeoutError.Temporary",
        "params": [],
        "path": "go/internal/poll/index#TimeoutError.Temporary",
        "syntax": "func (e *TimeoutError) Temporary() bool",
        "type": "internal"
    },
    "poll.TimeoutError.Timeout": {
        "descr": "",
        "name": "poll.TimeoutError.Timeout",
        "params": [],
        "path": "go/internal/poll/index#TimeoutError.Timeout",
        "syntax": "func (e *TimeoutError) Timeout() bool",
        "type": "internal"
    },
    "pprof.Cmdline": {
        "descr": "Cmdline responds with the running program's command line, with arguments separated by NUL bytes. The package initialization registers it as /debug/pprof/cmdline.",
        "name": "pprof.Cmdline",
        "params": [],
        "path": "go/net/http/pprof/index#Cmdline",
        "syntax": "func Cmdline(w http.ResponseWriter, r *http.Request)",
        "type": "net/http"
    },
    "pprof.Do": {
        "descr": "Do calls f with a copy of the parent context with the given labels added to the parent's label map. Each key/value pair in labels is inserted into the label map in the order provided, overriding any previous value for the same key. The augmented label map will be set for the duration of the call to f and restored once f returns.",
        "name": "pprof.Do",
        "params": [],
        "path": "go/runtime/pprof/index#Do",
        "syntax": "func Do(ctx context.Context, labels LabelSet, f func(context.Context))",
        "type": "runtime"
    },
    "pprof.ForLabels": {
        "descr": "ForLabels invokes f with each label set on the context. The function f should return true to continue iteration or false to stop iteration early.",
        "name": "pprof.ForLabels",
        "params": [],
        "path": "go/runtime/pprof/index#ForLabels",
        "syntax": "func ForLabels(ctx context.Context, f func(key, value string) bool)",
        "type": "runtime"
    },
    "pprof.Handler": {
        "descr": "Handler returns an HTTP handler that serves the named profile.",
        "name": "pprof.Handler",
        "params": [],
        "path": "go/net/http/pprof/index#Handler",
        "syntax": "func Handler(name string) http.Handler",
        "type": "net/http"
    },
    "pprof.Index": {
        "descr": "Index responds with the pprof-formatted profile named by the request. For example, \"/debug/pprof/heap\" serves the \"heap\" profile. Index responds to a request for \"/debug/pprof/\" with an HTML page listing the available profiles.",
        "name": "pprof.Index",
        "params": [],
        "path": "go/net/http/pprof/index#Index",
        "syntax": "func Index(w http.ResponseWriter, r *http.Request)",
        "type": "net/http"
    },
    "pprof.Label": {
        "descr": "Label returns the value of the label with the given key on ctx, and a boolean indicating whether that label exists.",
        "name": "pprof.Label",
        "params": [],
        "path": "go/runtime/pprof/index#Label",
        "syntax": "func Label(ctx context.Context, key string) (string, bool)",
        "type": "runtime"
    },
    "pprof.LabelSet": {
        "descr": "LabelSet is a set of labels.",
        "name": "pprof.LabelSet",
        "params": [],
        "path": "go/runtime/pprof/index#LabelSet",
        "syntax": "type LabelSet struct { // contains filtered or unexported fields }",
        "type": "runtime"
    },
    "pprof.Labels": {
        "descr": "Labels takes an even number of strings representing key-value pairs and makes a LabelSet containing them. A label overwrites a prior label with the same key.",
        "name": "pprof.Labels",
        "params": [],
        "path": "go/runtime/pprof/index#Labels",
        "syntax": "func Labels(args ...string) LabelSet",
        "type": "runtime"
    },
    "pprof.Lookup": {
        "descr": "Lookup returns the profile with the given name, or nil if no such profile exists.",
        "name": "pprof.Lookup",
        "params": [],
        "path": "go/runtime/pprof/index#Lookup",
        "syntax": "func Lookup(name string) *Profile",
        "type": "runtime"
    },
    "pprof.NewProfile": {
        "descr": "NewProfile creates a new profile with the given name. If a profile with that name already exists, NewProfile panics. The convention is to use a 'import/path.' prefix to create separate name spaces for each package. For compatibility with various tools that read pprof data, profile names should not contain spaces.",
        "name": "pprof.NewProfile",
        "params": [],
        "path": "go/runtime/pprof/index#NewProfile",
        "syntax": "func NewProfile(name string) *Profile",
        "type": "runtime"
    },
    "pprof.Profile": {
        "descr": "Profile responds with the pprof-formatted cpu profile. Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified. The package initialization registers it as /debug/pprof/profile.",
        "name": "pprof.Profile",
        "params": [],
        "path": "go/net/http/pprof/index#Profile",
        "syntax": "func Profile(w http.ResponseWriter, r *http.Request)",
        "type": "net/http"
    },
    "pprof.Profile.Add": {
        "descr": "Add adds the current execution stack to the profile, associated with value. Add stores value in an internal map, so value must be suitable for use as a map key and will not be garbage collected until the corresponding call to Remove. Add panics if the profile already contains a stack for value.",
        "name": "pprof.Profile.Add",
        "params": [],
        "path": "go/runtime/pprof/index#Profile.Add",
        "syntax": "func (p *Profile) Add(value interface{}, skip int)",
        "type": "runtime"
    },
    "pprof.Profile.Count": {
        "descr": "Count returns the number of execution stacks currently in the profile.",
        "name": "pprof.Profile.Count",
        "params": [],
        "path": "go/runtime/pprof/index#Profile.Count",
        "syntax": "func (p *Profile) Count() int",
        "type": "runtime"
    },
    "pprof.Profile.Name": {
        "descr": "Name returns this profile's name, which can be passed to Lookup to reobtain the profile.",
        "name": "pprof.Profile.Name",
        "params": [],
        "path": "go/runtime/pprof/index#Profile.Name",
        "syntax": "func (p *Profile) Name() string",
        "type": "runtime"
    },
    "pprof.Profile.Remove": {
        "descr": "Remove removes the execution stack associated with value from the profile. It is a no-op if the value is not in the profile.",
        "name": "pprof.Profile.Remove",
        "params": [],
        "path": "go/runtime/pprof/index#Profile.Remove",
        "syntax": "func (p *Profile) Remove(value interface{})",
        "type": "runtime"
    },
    "pprof.Profile.WriteTo": {
        "descr": "WriteTo writes a pprof-formatted snapshot of the profile to w. If a write to w returns an error, WriteTo returns that error. Otherwise, WriteTo returns nil.",
        "name": "pprof.Profile.WriteTo",
        "params": [],
        "path": "go/runtime/pprof/index#Profile.WriteTo",
        "syntax": "func (p *Profile) WriteTo(w io.Writer, debug int) error",
        "type": "runtime"
    },
    "pprof.Profiles": {
        "descr": "Profiles returns a slice of all the known profiles, sorted by name.",
        "name": "pprof.Profiles",
        "params": [],
        "path": "go/runtime/pprof/index#Profiles",
        "syntax": "func Profiles() []*Profile",
        "type": "runtime"
    },
    "pprof.SetGoroutineLabels": {
        "descr": "SetGoroutineLabels sets the current goroutine's labels to match ctx. This is a lower-level API than Do, which should be used instead when possible.",
        "name": "pprof.SetGoroutineLabels",
        "params": [],
        "path": "go/runtime/pprof/index#SetGoroutineLabels",
        "syntax": "func SetGoroutineLabels(ctx context.Context)",
        "type": "runtime"
    },
    "pprof.StartCPUProfile": {
        "descr": "StartCPUProfile enables CPU profiling for the current process. While profiling, the profile will be buffered and written to w. StartCPUProfile returns an error if profiling is already enabled.",
        "name": "pprof.StartCPUProfile",
        "params": [],
        "path": "go/runtime/pprof/index#StartCPUProfile",
        "syntax": "func StartCPUProfile(w io.Writer) error",
        "type": "runtime"
    },
    "pprof.StopCPUProfile": {
        "descr": "StopCPUProfile stops the current CPU profile, if any. StopCPUProfile only returns after all the writes for the profile have completed.",
        "name": "pprof.StopCPUProfile",
        "params": [],
        "path": "go/runtime/pprof/index#StopCPUProfile",
        "syntax": "func StopCPUProfile()",
        "type": "runtime"
    },
    "pprof.Symbol": {
        "descr": "Symbol looks up the program counters listed in the request, responding with a table mapping program counters to function names. The package initialization registers it as /debug/pprof/symbol.",
        "name": "pprof.Symbol",
        "params": [],
        "path": "go/net/http/pprof/index#Symbol",
        "syntax": "func Symbol(w http.ResponseWriter, r *http.Request)",
        "type": "net/http"
    },
    "pprof.Trace": {
        "descr": "Trace responds with the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified. The package initialization registers it as /debug/pprof/trace.",
        "name": "pprof.Trace",
        "params": [],
        "path": "go/net/http/pprof/index#Trace",
        "syntax": "func Trace(w http.ResponseWriter, r *http.Request)",
        "type": "net/http"
    },
    "pprof.WithLabels": {
        "descr": "WithLabels returns a new context.Context with the given labels added. A label overwrites a prior label with the same key.",
        "name": "pprof.WithLabels",
        "params": [],
        "path": "go/runtime/pprof/index#WithLabels",
        "syntax": "func WithLabels(ctx context.Context, labels LabelSet) context.Context",
        "type": "runtime"
    },
    "pprof.WriteHeapProfile": {
        "descr": "WriteHeapProfile is shorthand for Lookup(\"heap\").WriteTo(w, 0). It is preserved for backwards compatibility.",
        "name": "pprof.WriteHeapProfile",
        "params": [],
        "path": "go/runtime/pprof/index#WriteHeapProfile",
        "syntax": "func WriteHeapProfile(w io.Writer) error",
        "type": "runtime"
    },
    "print": {
        "descr": "The print built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Print is useful for bootstrapping and debugging; it is not guaranteed to stay in the language.",
        "name": "builtin.print",
        "params": [],
        "path": "go/builtin/index#print",
        "syntax": "func print(args ...Type)",
        "type": "builtin"
    },
    "printer.CommentedNode": {
        "descr": "A CommentedNode bundles an AST node and corresponding comments. It may be provided as argument to any of the Fprint functions.",
        "name": "printer.CommentedNode",
        "params": [],
        "path": "go/go/printer/index#CommentedNode",
        "syntax": "type CommentedNode struct { Node interface{} // *ast.File, or ast.Expr, ast.Decl, ast.Spec, or ast.Stmt Comments []*ast.CommentGroup }",
        "type": "go"
    },
    "printer.Config": {
        "descr": "A Config node controls the output of Fprint.",
        "name": "printer.Config",
        "params": [],
        "path": "go/go/printer/index#Config",
        "syntax": "type Config struct { Mode Mode // default: 0 Tabwidth int // default: 8 Indent int // default: 0 (all code is indented at least by this much);\n or  added in Go 1.1 });",
        "type": "go"
    },
    "printer.Config.Fprint": {
        "descr": "Fprint \"pretty-prints\" an AST node to output for a given configuration cfg. Position information is interpreted relative to the file set fset. The node type must be *ast.File, *CommentedNode, []ast.Decl, []ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec, or ast.Stmt.",
        "name": "printer.Config.Fprint",
        "params": [],
        "path": "go/go/printer/index#Config.Fprint",
        "syntax": "func (cfg *Config) Fprint(output io.Writer, fset *token.FileSet, node interface{}) error",
        "type": "go"
    },
    "printer.Fprint": {
        "descr": "Fprint \"pretty-prints\" an AST node to output. It calls Config.Fprint with default settings. Note that gofmt uses tabs for indentation but spaces for alignment; use format.Node (package go/format) for output that matches gofmt.",
        "name": "printer.Fprint",
        "params": [],
        "path": "go/go/printer/index#Fprint",
        "syntax": "func Fprint(output io.Writer, fset *token.FileSet, node interface{}) error",
        "type": "go"
    },
    "printer.Mode": {
        "descr": "A Mode value is a set of flags (or 0). They control printing.",
        "name": "printer.Mode",
        "params": [],
        "path": "go/go/printer/index#Mode",
        "syntax": "type Mode uint",
        "type": "go"
    },
    "println": {
        "descr": "The println built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Spaces are always added between arguments and a newline is appended. Println is useful for bootstrapping and debugging; it is not guaranteed to stay in the language.",
        "name": "builtin.println",
        "params": [],
        "path": "go/builtin/index#println",
        "syntax": "func println(args ...Type)",
        "type": "builtin"
    },
    "quick.Check": {
        "descr": "Check looks for an input to f, any function that returns bool, such that f returns false. It calls f repeatedly, with arbitrary values for each argument. If f returns false on a given input, Check returns that input as a *CheckError. For example:",
        "name": "quick.Check",
        "params": [],
        "path": "go/testing/quick/index#Check",
        "syntax": "func Check(f interface{}, config *Config) error",
        "type": "testing"
    },
    "quick.CheckEqual": {
        "descr": "CheckEqual looks for an input on which f and g return different results. It calls f and g repeatedly with arbitrary values for each argument. If f and g return different answers, CheckEqual returns a *CheckEqualError describing the input and the outputs.",
        "name": "quick.CheckEqual",
        "params": [],
        "path": "go/testing/quick/index#CheckEqual",
        "syntax": "func CheckEqual(f, g interface{}, config *Config) error",
        "type": "testing"
    },
    "quick.CheckEqualError": {
        "descr": "A CheckEqualError is the result CheckEqual finding an error.",
        "name": "quick.CheckEqualError",
        "params": [],
        "path": "go/testing/quick/index#CheckEqualError",
        "syntax": "type CheckEqualError struct { CheckError Out1 []interface{} Out2 []interface{} }",
        "type": "testing"
    },
    "quick.CheckEqualError.Error": {
        "descr": "",
        "name": "quick.CheckEqualError.Error",
        "params": [],
        "path": "go/testing/quick/index#CheckEqualError.Error",
        "syntax": "func (s *CheckEqualError) Error() string",
        "type": "testing"
    },
    "quick.CheckError": {
        "descr": "A CheckError is the result of Check finding an error.",
        "name": "quick.CheckError",
        "params": [],
        "path": "go/testing/quick/index#CheckError",
        "syntax": "type CheckError struct { Count int In []interface{} }",
        "type": "testing"
    },
    "quick.CheckError.Error": {
        "descr": "",
        "name": "quick.CheckError.Error",
        "params": [],
        "path": "go/testing/quick/index#CheckError.Error",
        "syntax": "func (s *CheckError) Error() string",
        "type": "testing"
    },
    "quick.Config": {
        "descr": "A Config structure contains options for running a test.",
        "name": "quick.Config",
        "params": [],
        "path": "go/testing/quick/index#Config",
        "syntax": "type Config struct { // MaxCount sets the maximum number of iterations. // If zero, MaxCountScale is used. MaxCount int // MaxCountScale is a non-negative scale factor applied to the // default maximum. // If zero, the default is unchanged. MaxCountScale float64 // Rand specifies a source of random numbers. // If nil, a default pseudo-random source will be used. Rand *rand.Rand // Values specifies a function to generate a slice of // arbitrary reflect.Values that are congruent with the // arguments to the function being tested. // If nil, the top-level Value function is used to generate them. Values func([]reflect.Value, *rand.Rand) }",
        "type": "testing"
    },
    "quick.Generator": {
        "descr": "A Generator can generate random values of its own type.",
        "name": "quick.Generator",
        "params": [],
        "path": "go/testing/quick/index#Generator",
        "syntax": "type Generator interface { // Generate returns a random instance of the type on which it is a // method using the size as a size hint. Generate(rand *rand.Rand, size int) reflect.Value }",
        "type": "testing"
    },
    "quick.SetupError": {
        "descr": "A SetupError is the result of an error in the way that check is being used, independent of the functions being tested.",
        "name": "quick.SetupError",
        "params": [],
        "path": "go/testing/quick/index#SetupError",
        "syntax": "type SetupError string",
        "type": "testing"
    },
    "quick.SetupError.Error": {
        "descr": "",
        "name": "quick.SetupError.Error",
        "params": [],
        "path": "go/testing/quick/index#SetupError.Error",
        "syntax": "func (s SetupError) Error() string",
        "type": "testing"
    },
    "quick.Value": {
        "descr": "Value returns an arbitrary value of the given type. If the type implements the Generator interface, that will be used. Note: To create arbitrary values for structs, all the fields must be exported.",
        "name": "quick.Value",
        "params": [],
        "path": "go/testing/quick/index#Value",
        "syntax": "func Value(t reflect.Type, rand *rand.Rand) (value reflect.Value, ok bool)",
        "type": "testing"
    },
    "quotedprintable.NewReader": {
        "descr": "NewReader returns a quoted-printable reader, decoding from r.",
        "name": "quotedprintable.NewReader",
        "params": [],
        "path": "go/mime/quotedprintable/index#NewReader",
        "syntax": "func NewReader(r io.Reader) *Reader",
        "type": "mime"
    },
    "quotedprintable.NewWriter": {
        "descr": "NewWriter returns a new Writer that writes to w.",
        "name": "quotedprintable.NewWriter",
        "params": [],
        "path": "go/mime/quotedprintable/index#NewWriter",
        "syntax": "func NewWriter(w io.Writer) *Writer",
        "type": "mime"
    },
    "quotedprintable.Reader": {
        "descr": "Reader is a quoted-printable decoder.",
        "name": "quotedprintable.Reader",
        "params": [],
        "path": "go/mime/quotedprintable/index#Reader",
        "syntax": "type Reader struct { // contains filtered or unexported fields }",
        "type": "mime"
    },
    "quotedprintable.Reader.Read": {
        "descr": "Read reads and decodes quoted-printable data from the underlying reader.",
        "name": "quotedprintable.Reader.Read",
        "params": [],
        "path": "go/mime/quotedprintable/index#Reader.Read",
        "syntax": "func (r *Reader) Read(p []byte) (n int, err error)",
        "type": "mime"
    },
    "quotedprintable.Writer": {
        "descr": "A Writer is a quoted-printable writer that implements io.WriteCloser.",
        "name": "quotedprintable.Writer",
        "params": [],
        "path": "go/mime/quotedprintable/index#Writer",
        "syntax": "type Writer struct { // Binary mode treats the writer's input as pure binary and processes end of // line bytes as binary data. Binary bool // contains filtered or unexported fields }",
        "type": "mime"
    },
    "quotedprintable.Writer.Close": {
        "descr": "Close closes the Writer, flushing any unwritten data to the underlying io.Writer, but does not close the underlying io.Writer.",
        "name": "quotedprintable.Writer.Close",
        "params": [],
        "path": "go/mime/quotedprintable/index#Writer.Close",
        "syntax": "func (w *Writer) Close() error",
        "type": "mime"
    },
    "quotedprintable.Writer.Write": {
        "descr": "Write encodes p using quoted-printable encoding and writes it to the underlying io.Writer. It limits line length to 76 characters. The encoded bytes are not necessarily flushed until the Writer is closed.",
        "name": "quotedprintable.Writer.Write",
        "params": [],
        "path": "go/mime/quotedprintable/index#Writer.Write",
        "syntax": "func (w *Writer) Write(p []byte) (n int, err error)",
        "type": "mime"
    },
    "rand.ExpFloat64": {
        "descr": "ExpFloat64 returns an exponentially distributed float64 in the range (0, +math.MaxFloat64] with an exponential distribution whose rate parameter (lambda) is 1 and whose mean is 1/lambda (1) from the default Source. To produce a distribution with a different rate parameter, callers can adjust the output using:",
        "name": "rand.ExpFloat64",
        "params": [],
        "path": "go/math/rand/index#ExpFloat64",
        "syntax": "func ExpFloat64() float64",
        "type": "math/rand"
    },
    "rand.Float32": {
        "descr": "Float32 returns, as a float32, a pseudo-random number in [0.0,1.0) from the default Source.",
        "name": "rand.Float32",
        "params": [],
        "path": "go/math/rand/index#Float32",
        "syntax": "func Float32() float32",
        "type": "math/rand"
    },
    "rand.Float64": {
        "descr": "Float64 returns, as a float64, a pseudo-random number in [0.0,1.0) from the default Source.",
        "name": "rand.Float64",
        "params": [],
        "path": "go/math/rand/index#Float64",
        "syntax": "func Float64() float64",
        "type": "math/rand"
    },
    "rand.Int": {
        "descr": "Int returns a non-negative pseudo-random int from the default Source.",
        "name": "rand.Int",
        "params": [],
        "path": "go/math/rand/index#Int",
        "syntax": "func Int() int",
        "type": "math/rand"
    },
    "rand.Int31": {
        "descr": "Int31 returns a non-negative pseudo-random 31-bit integer as an int32 from the default Source.",
        "name": "rand.Int31",
        "params": [],
        "path": "go/math/rand/index#Int31",
        "syntax": "func Int31() int32",
        "type": "math/rand"
    },
    "rand.Int31n": {
        "descr": "Int31n returns, as an int32, a non-negative pseudo-random number in [0,n) from the default Source. It panics if n <= 0.",
        "name": "rand.Int31n",
        "params": [],
        "path": "go/math/rand/index#Int31n",
        "syntax": "func Int31n(n int32) int32",
        "type": "math/rand"
    },
    "rand.Int63": {
        "descr": "Int63 returns a non-negative pseudo-random 63-bit integer as an int64 from the default Source.",
        "name": "rand.Int63",
        "params": [],
        "path": "go/math/rand/index#Int63",
        "syntax": "func Int63() int64",
        "type": "math/rand"
    },
    "rand.Int63n": {
        "descr": "Int63n returns, as an int64, a non-negative pseudo-random number in [0,n) from the default Source. It panics if n <= 0.",
        "name": "rand.Int63n",
        "params": [],
        "path": "go/math/rand/index#Int63n",
        "syntax": "func Int63n(n int64) int64",
        "type": "math/rand"
    },
    "rand.Intn": {
        "descr": "Intn returns, as an int, a non-negative pseudo-random number in [0,n) from the default Source. It panics if n <= 0.",
        "name": "rand.Intn",
        "params": [],
        "path": "go/math/rand/index#Intn",
        "syntax": "func Intn(n int) int",
        "type": "math/rand"
    },
    "rand.New": {
        "descr": "New returns a new Rand that uses random values from src to generate other random values.",
        "name": "rand.New",
        "params": [],
        "path": "go/math/rand/index#New",
        "syntax": "func New(src Source) *Rand",
        "type": "math/rand"
    },
    "rand.NewSource": {
        "descr": "NewSource returns a new pseudo-random Source seeded with the given value. Unlike the default Source used by top-level functions, this source is not safe for concurrent use by multiple goroutines.",
        "name": "rand.NewSource",
        "params": [],
        "path": "go/math/rand/index#NewSource",
        "syntax": "func NewSource(seed int64) Source",
        "type": "math/rand"
    },
    "rand.NewZipf": {
        "descr": "NewZipf returns a Zipf variate generator. The generator generates values k  [0, imax] such that P(k) is proportional to (v + k) ** (-s). Requirements: s > 1 and v >= 1.",
        "name": "rand.NewZipf",
        "params": [],
        "path": "go/math/rand/index#NewZipf",
        "syntax": "func NewZipf(r *Rand, s float64, v float64, imax uint64) *Zipf",
        "type": "math/rand"
    },
    "rand.NormFloat64": {
        "descr": "NormFloat64 returns a normally distributed float64 in the range [-math.MaxFloat64, +math.MaxFloat64] with standard normal distribution (mean = 0, stddev = 1) from the default Source. To produce a different normal distribution, callers can adjust the output using:",
        "name": "rand.NormFloat64",
        "params": [],
        "path": "go/math/rand/index#NormFloat64",
        "syntax": "func NormFloat64() float64",
        "type": "math/rand"
    },
    "rand.Perm": {
        "descr": "Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n) from the default Source.",
        "name": "rand.Perm",
        "params": [],
        "path": "go/math/rand/index#Perm",
        "syntax": "func Perm(n int) []int",
        "type": "math/rand"
    },
    "rand.Prime": {
        "descr": "Prime returns a number, p, of the given size, such that p is prime with high probability. Prime will return error for any error returned by rand.Read or if bits < 2.",
        "name": "rand.Prime",
        "params": [],
        "path": "go/crypto/rand/index#Prime",
        "syntax": "func Prime(rand io.Reader, bits int) (p *big.Int, err error)",
        "type": "crypto"
    },
    "rand.Rand": {
        "descr": "A Rand is a source of random numbers.",
        "name": "rand.Rand",
        "params": [],
        "path": "go/math/rand/index#Rand",
        "syntax": "type Rand struct { // contains filtered or unexported fields }",
        "type": "math/rand"
    },
    "rand.Rand.ExpFloat64": {
        "descr": "ExpFloat64 returns an exponentially distributed float64 in the range (0, +math.MaxFloat64] with an exponential distribution whose rate parameter (lambda) is 1 and whose mean is 1/lambda (1). To produce a distribution with a different rate parameter, callers can adjust the output using:",
        "name": "rand.Rand.ExpFloat64",
        "params": [],
        "path": "go/math/rand/index#Rand.ExpFloat64",
        "syntax": "func (r *Rand) ExpFloat64() float64",
        "type": "math/rand"
    },
    "rand.Rand.Float32": {
        "descr": "Float32 returns, as a float32, a pseudo-random number in [0.0,1.0).",
        "name": "rand.Rand.Float32",
        "params": [],
        "path": "go/math/rand/index#Rand.Float32",
        "syntax": "func (r *Rand) Float32() float32",
        "type": "math/rand"
    },
    "rand.Rand.Float64": {
        "descr": "Float64 returns, as a float64, a pseudo-random number in [0.0,1.0).",
        "name": "rand.Rand.Float64",
        "params": [],
        "path": "go/math/rand/index#Rand.Float64",
        "syntax": "func (r *Rand) Float64() float64",
        "type": "math/rand"
    },
    "rand.Rand.Int": {
        "descr": "Int returns a non-negative pseudo-random int.",
        "name": "rand.Rand.Int",
        "params": [],
        "path": "go/math/rand/index#Rand.Int",
        "syntax": "func (r *Rand) Int() int",
        "type": "math/rand"
    },
    "rand.Rand.Int31": {
        "descr": "Int31 returns a non-negative pseudo-random 31-bit integer as an int32.",
        "name": "rand.Rand.Int31",
        "params": [],
        "path": "go/math/rand/index#Rand.Int31",
        "syntax": "func (r *Rand) Int31() int32",
        "type": "math/rand"
    },
    "rand.Rand.Int31n": {
        "descr": "Int31n returns, as an int32, a non-negative pseudo-random number in [0,n). It panics if n <= 0.",
        "name": "rand.Rand.Int31n",
        "params": [],
        "path": "go/math/rand/index#Rand.Int31n",
        "syntax": "func (r *Rand) Int31n(n int32) int32",
        "type": "math/rand"
    },
    "rand.Rand.Int63": {
        "descr": "Int63 returns a non-negative pseudo-random 63-bit integer as an int64.",
        "name": "rand.Rand.Int63",
        "params": [],
        "path": "go/math/rand/index#Rand.Int63",
        "syntax": "func (r *Rand) Int63() int64",
        "type": "math/rand"
    },
    "rand.Rand.Int63n": {
        "descr": "Int63n returns, as an int64, a non-negative pseudo-random number in [0,n). It panics if n <= 0.",
        "name": "rand.Rand.Int63n",
        "params": [],
        "path": "go/math/rand/index#Rand.Int63n",
        "syntax": "func (r *Rand) Int63n(n int64) int64",
        "type": "math/rand"
    },
    "rand.Rand.Intn": {
        "descr": "Intn returns, as an int, a non-negative pseudo-random number in [0,n). It panics if n <= 0.",
        "name": "rand.Rand.Intn",
        "params": [],
        "path": "go/math/rand/index#Rand.Intn",
        "syntax": "func (r *Rand) Intn(n int) int",
        "type": "math/rand"
    },
    "rand.Rand.NormFloat64": {
        "descr": "NormFloat64 returns a normally distributed float64 in the range -math.MaxFloat64 through +math.MaxFloat64 inclusive, with standard normal distribution (mean = 0, stddev = 1). To produce a different normal distribution, callers can adjust the output using:",
        "name": "rand.Rand.NormFloat64",
        "params": [],
        "path": "go/math/rand/index#Rand.NormFloat64",
        "syntax": "func (r *Rand) NormFloat64() float64",
        "type": "math/rand"
    },
    "rand.Rand.Perm": {
        "descr": "Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n).",
        "name": "rand.Rand.Perm",
        "params": [],
        "path": "go/math/rand/index#Rand.Perm",
        "syntax": "func (r *Rand) Perm(n int) []int",
        "type": "math/rand"
    },
    "rand.Rand.Read": {
        "descr": "Read generates len(p) random bytes and writes them into p. It always returns len(p) and a nil error. Read should not be called concurrently with any other Rand method.",
        "name": "rand.Rand.Read",
        "params": [],
        "path": "go/math/rand/index#Rand.Read",
        "syntax": "func (r *Rand) Read(p []byte) (n int, err error)",
        "type": "math/rand"
    },
    "rand.Rand.Seed": {
        "descr": "Seed uses the provided seed value to initialize the generator to a deterministic state. Seed should not be called concurrently with any other Rand method.",
        "name": "rand.Rand.Seed",
        "params": [],
        "path": "go/math/rand/index#Rand.Seed",
        "syntax": "func (r *Rand) Seed(seed int64)",
        "type": "math/rand"
    },
    "rand.Rand.Shuffle": {
        "descr": "Shuffle pseudo-randomizes the order of elements. n is the number of elements. Shuffle panics if n < 0. swap swaps the elements with indexes i and j.",
        "name": "rand.Rand.Shuffle",
        "params": [],
        "path": "go/math/rand/index#Rand.Shuffle",
        "syntax": "func (r *Rand) Shuffle(n int, swap func(i, j int))",
        "type": "math/rand"
    },
    "rand.Rand.Uint32": {
        "descr": "Uint32 returns a pseudo-random 32-bit value as a uint32.",
        "name": "rand.Rand.Uint32",
        "params": [],
        "path": "go/math/rand/index#Rand.Uint32",
        "syntax": "func (r *Rand) Uint32() uint32",
        "type": "math/rand"
    },
    "rand.Rand.Uint64": {
        "descr": "Uint64 returns a pseudo-random 64-bit value as a uint64.",
        "name": "rand.Rand.Uint64",
        "params": [],
        "path": "go/math/rand/index#Rand.Uint64",
        "syntax": "func (r *Rand) Uint64() uint64",
        "type": "math/rand"
    },
    "rand.Read": {
        "descr": "Read generates len(p) random bytes from the default Source and writes them into p. It always returns len(p) and a nil error. Read, unlike the Rand.Read method, is safe for concurrent use.",
        "name": "rand.Read",
        "params": [],
        "path": "go/math/rand/index#Read",
        "syntax": "func Read(p []byte) (n int, err error)",
        "type": "math/rand"
    },
    "rand.Seed": {
        "descr": "Seed uses the provided seed value to initialize the default Source to a deterministic state. If Seed is not called, the generator behaves as if seeded by Seed(1). Seed values that have the same remainder when divided by 2^31-1 generate the same pseudo-random sequence. Seed, unlike the Rand.Seed method, is safe for concurrent use.",
        "name": "rand.Seed",
        "params": [],
        "path": "go/math/rand/index#Seed",
        "syntax": "func Seed(seed int64)",
        "type": "math/rand"
    },
    "rand.Shuffle": {
        "descr": "Shuffle pseudo-randomizes the order of elements using the default Source. n is the number of elements. Shuffle panics if n < 0. swap swaps the elements with indexes i and j.",
        "name": "rand.Shuffle",
        "params": [],
        "path": "go/math/rand/index#Shuffle",
        "syntax": "func Shuffle(n int, swap func(i, j int))",
        "type": "math/rand"
    },
    "rand.Source": {
        "descr": "A Source represents a source of uniformly-distributed pseudo-random int64 values in the range [0, 1<<63).",
        "name": "rand.Source",
        "params": [],
        "path": "go/math/rand/index#Source",
        "syntax": "type Source interface { Int63() int64 Seed(seed int64) }",
        "type": "math/rand"
    },
    "rand.Source64": {
        "descr": "A Source64 is a Source that can also generate uniformly-distributed pseudo-random uint64 values in the range [0, 1<<64) directly. If a Rand r's underlying Source s implements Source64, then r.Uint64 returns the result of one call to s.Uint64 instead of making two calls to s.Int63.",
        "name": "rand.Source64",
        "params": [],
        "path": "go/math/rand/index#Source64",
        "syntax": "type Source64 interface { Source Uint64() uint64 }",
        "type": "math/rand"
    },
    "rand.Uint32": {
        "descr": "Uint32 returns a pseudo-random 32-bit value as a uint32 from the default Source.",
        "name": "rand.Uint32",
        "params": [],
        "path": "go/math/rand/index#Uint32",
        "syntax": "func Uint32() uint32",
        "type": "math/rand"
    },
    "rand.Uint64": {
        "descr": "Uint64 returns a pseudo-random 64-bit value as a uint64 from the default Source.",
        "name": "rand.Uint64",
        "params": [],
        "path": "go/math/rand/index#Uint64",
        "syntax": "func Uint64() uint64",
        "type": "math/rand"
    },
    "rand.Zipf": {
        "descr": "A Zipf generates Zipf distributed variates.",
        "name": "rand.Zipf",
        "params": [],
        "path": "go/math/rand/index#Zipf",
        "syntax": "type Zipf struct { // contains filtered or unexported fields }",
        "type": "math/rand"
    },
    "rand.Zipf.Uint64": {
        "descr": "Uint64 returns a value drawn from the Zipf distribution described by the Zipf object.",
        "name": "rand.Zipf.Uint64",
        "params": [],
        "path": "go/math/rand/index#Zipf.Uint64",
        "syntax": "func (z *Zipf) Uint64() uint64",
        "type": "math/rand"
    },
    "rc4.Cipher": {
        "descr": "A Cipher is an instance of RC4 using a particular key.",
        "name": "rc4.Cipher",
        "params": [],
        "path": "go/crypto/rc4/index#Cipher",
        "syntax": "type Cipher struct { // contains filtered or unexported fields }",
        "type": "crypto"
    },
    "rc4.Cipher.Reset": {
        "descr": "Reset zeros the key data so that it will no longer appear in the process's memory.",
        "name": "rc4.Cipher.Reset",
        "params": [],
        "path": "go/crypto/rc4/index#Cipher.Reset",
        "syntax": "func (c *Cipher) Reset()",
        "type": "crypto"
    },
    "rc4.Cipher.XORKeyStream": {
        "descr": "XORKeyStream sets dst to the result of XORing src with the key stream. Dst and src must overlap entirely or not at all.",
        "name": "rc4.Cipher.XORKeyStream",
        "params": [],
        "path": "go/crypto/rc4/index#Cipher.XORKeyStream",
        "syntax": "func (c *Cipher) XORKeyStream(dst, src []byte)",
        "type": "crypto"
    },
    "rc4.KeySizeError": {
        "descr": "",
        "name": "rc4.KeySizeError",
        "params": [],
        "path": "go/crypto/rc4/index#KeySizeError",
        "syntax": "type KeySizeError int",
        "type": "crypto"
    },
    "rc4.KeySizeError.Error": {
        "descr": "",
        "name": "rc4.KeySizeError.Error",
        "params": [],
        "path": "go/crypto/rc4/index#KeySizeError.Error",
        "syntax": "func (k KeySizeError) Error() string",
        "type": "crypto"
    },
    "rc4.NewCipher": {
        "descr": "NewCipher creates and returns a new Cipher. The key argument should be the RC4 key, at least 1 byte and at most 256 bytes.",
        "name": "rc4.NewCipher",
        "params": [],
        "path": "go/crypto/rc4/index#NewCipher",
        "syntax": "func NewCipher(key []byte) (*Cipher, error)",
        "type": "crypto"
    },
    "real": {
        "descr": "The real built-in function returns the real part of the complex number c. The return value will be floating point type corresponding to the type of c.",
        "name": "builtin.real",
        "params": [],
        "path": "go/builtin/index#real",
        "syntax": "func real(c ComplexType) FloatType",
        "type": "builtin"
    },
    "recover": {
        "descr": "The recover built-in function allows a program to manage behavior of a panicking goroutine. Executing a call to recover inside a deferred function (but not any function called by it) stops the panicking sequence by restoring normal execution and retrieves the error value passed to the call of panic. If recover is called outside the deferred function it will not stop a panicking sequence. In this case, or when the goroutine is not panicking, or if the argument supplied to panic was nil, recover returns nil. Thus the return value from recover reports whether the goroutine is panicking.",
        "name": "builtin.recover",
        "params": [],
        "path": "go/builtin/index#recover",
        "syntax": "func recover() interface{}",
        "type": "builtin"
    },
    "reflect.Append": {
        "descr": "Append appends the values x to a slice s and returns the resulting slice. As in Go, each x's value must be assignable to the slice's element type.",
        "name": "reflect.Append",
        "params": [],
        "path": "go/reflect/index#Append",
        "syntax": "func Append(s Value, x ...Value) Value",
        "type": "reflect"
    },
    "reflect.AppendSlice": {
        "descr": "AppendSlice appends a slice t to a slice s and returns the resulting slice. The slices s and t must have the same element type.",
        "name": "reflect.AppendSlice",
        "params": [],
        "path": "go/reflect/index#AppendSlice",
        "syntax": "func AppendSlice(s, t Value) Value",
        "type": "reflect"
    },
    "reflect.ArrayOf": {
        "descr": "ArrayOf returns the array type with the given count and element type. For example, if t represents int, ArrayOf(5, t) represents [5]int.",
        "name": "reflect.ArrayOf",
        "params": [],
        "path": "go/reflect/index#ArrayOf",
        "syntax": "func ArrayOf(count int, elem Type) Type",
        "type": "reflect"
    },
    "reflect.ChanDir": {
        "descr": "ChanDir represents a channel type's direction.",
        "name": "reflect.ChanDir",
        "params": [],
        "path": "go/reflect/index#ChanDir",
        "syntax": "type ChanDir int",
        "type": "reflect"
    },
    "reflect.ChanDir.String": {
        "descr": "",
        "name": "reflect.ChanDir.String",
        "params": [],
        "path": "go/reflect/index#ChanDir.String",
        "syntax": "func (d ChanDir) String() string",
        "type": "reflect"
    },
    "reflect.ChanOf": {
        "descr": "ChanOf returns the channel type with the given direction and element type. For example, if t represents int, ChanOf(RecvDir, t) represents <-chan int.",
        "name": "reflect.ChanOf",
        "params": [],
        "path": "go/reflect/index#ChanOf",
        "syntax": "func ChanOf(dir ChanDir, t Type) Type",
        "type": "reflect"
    },
    "reflect.Copy": {
        "descr": "Copy copies the contents of src into dst until either dst has been filled or src has been exhausted. It returns the number of elements copied. Dst and src each must have kind Slice or Array, and dst and src must have the same element type.",
        "name": "reflect.Copy",
        "params": [],
        "path": "go/reflect/index#Copy",
        "syntax": "func Copy(dst, src Value) int",
        "type": "reflect"
    },
    "reflect.DeepEqual": {
        "descr": "DeepEqual reports whether x and y are deeply equal, defined as follows. Two values of identical type are deeply equal if one of the following cases applies. Values of distinct types are never deeply equal.",
        "name": "reflect.DeepEqual",
        "params": [],
        "path": "go/reflect/index#DeepEqual",
        "syntax": "func DeepEqual(x, y interface{}) bool",
        "type": "reflect"
    },
    "reflect.FuncOf": {
        "descr": "FuncOf returns the function type with the given argument and result types. For example if k represents int and e represents string, FuncOf([]Type{k}, []Type{e}, false) represents func(int) string.",
        "name": "reflect.FuncOf",
        "params": [],
        "path": "go/reflect/index#FuncOf",
        "syntax": "func FuncOf(in, out []Type, variadic bool) Type",
        "type": "reflect"
    },
    "reflect.Indirect": {
        "descr": "Indirect returns the value that v points to. If v is a nil pointer, Indirect returns a zero Value. If v is not a pointer, Indirect returns v.",
        "name": "reflect.Indirect",
        "params": [],
        "path": "go/reflect/index#Indirect",
        "syntax": "func Indirect(v Value) Value",
        "type": "reflect"
    },
    "reflect.Kind": {
        "descr": "A Kind represents the specific kind of type that a Type represents. The zero Kind is not a valid kind.",
        "name": "reflect.Kind",
        "params": [],
        "path": "go/reflect/index#Kind",
        "syntax": "type Kind uint",
        "type": "reflect"
    },
    "reflect.Kind.String": {
        "descr": "",
        "name": "reflect.Kind.String",
        "params": [],
        "path": "go/reflect/index#Kind.String",
        "syntax": "func (k Kind) String() string",
        "type": "reflect"
    },
    "reflect.MakeChan": {
        "descr": "MakeChan creates a new channel with the specified type and buffer size.",
        "name": "reflect.MakeChan",
        "params": [],
        "path": "go/reflect/index#MakeChan",
        "syntax": "func MakeChan(typ Type, buffer int) Value",
        "type": "reflect"
    },
    "reflect.MakeFunc": {
        "descr": "MakeFunc returns a new function of the given Type that wraps the function fn. When called, that new function does the following:",
        "name": "reflect.MakeFunc",
        "params": [],
        "path": "go/reflect/index#MakeFunc",
        "syntax": "func MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value",
        "type": "reflect"
    },
    "reflect.MakeMap": {
        "descr": "MakeMap creates a new map with the specified type.",
        "name": "reflect.MakeMap",
        "params": [],
        "path": "go/reflect/index#MakeMap",
        "syntax": "func MakeMap(typ Type) Value",
        "type": "reflect"
    },
    "reflect.MakeMapWithSize": {
        "descr": "MakeMapWithSize creates a new map with the specified type and initial space for approximately n elements.",
        "name": "reflect.MakeMapWithSize",
        "params": [],
        "path": "go/reflect/index#MakeMapWithSize",
        "syntax": "func MakeMapWithSize(typ Type, n int) Value",
        "type": "reflect"
    },
    "reflect.MakeSlice": {
        "descr": "MakeSlice creates a new zero-initialized slice value for the specified slice type, length, and capacity.",
        "name": "reflect.MakeSlice",
        "params": [],
        "path": "go/reflect/index#MakeSlice",
        "syntax": "func MakeSlice(typ Type, len, cap int) Value",
        "type": "reflect"
    },
    "reflect.MapOf": {
        "descr": "MapOf returns the map type with the given key and element types. For example, if k represents int and e represents string, MapOf(k, e) represents map[int]string.",
        "name": "reflect.MapOf",
        "params": [],
        "path": "go/reflect/index#MapOf",
        "syntax": "func MapOf(key, elem Type) Type",
        "type": "reflect"
    },
    "reflect.Method": {
        "descr": "Method represents a single method.",
        "name": "reflect.Method",
        "params": [],
        "path": "go/reflect/index#Method",
        "syntax": "type Method struct { // Name is the method name. // PkgPath is the package path that qualifies a lower case (unexported) // method name. It is empty for upper case (exported) method names. // The combination of PkgPath and Name uniquely identifies a method // in a method set. // See https://golang.org/ref/spec#Uniqueness_of_identifiers Name string PkgPath string Type Type // method type Func Value // func with receiver as first argument Index int // index for Type.Method }",
        "type": "reflect"
    },
    "reflect.New": {
        "descr": "New returns a Value representing a pointer to a new zero value for the specified type. That is, the returned Value's Type is PtrTo(typ).",
        "name": "reflect.New",
        "params": [],
        "path": "go/reflect/index#New",
        "syntax": "func New(typ Type) Value",
        "type": "reflect"
    },
    "reflect.NewAt": {
        "descr": "NewAt returns a Value representing a pointer to a value of the specified type, using p as that pointer.",
        "name": "reflect.NewAt",
        "params": [],
        "path": "go/reflect/index#NewAt",
        "syntax": "func NewAt(typ Type, p unsafe.Pointer) Value",
        "type": "reflect"
    },
    "reflect.PtrTo": {
        "descr": "PtrTo returns the pointer type with element t. For example, if t represents type Foo, PtrTo(t) represents *Foo.",
        "name": "reflect.PtrTo",
        "params": [],
        "path": "go/reflect/index#PtrTo",
        "syntax": "func PtrTo(t Type) Type",
        "type": "reflect"
    },
    "reflect.Select": {
        "descr": "Select executes a select operation described by the list of cases. Like the Go select statement, it blocks until at least one of the cases can proceed, makes a uniform pseudo-random choice, and then executes that case. It returns the index of the chosen case and, if that case was a receive operation, the value received and a boolean indicating whether the value corresponds to a send on the channel (as opposed to a zero value received because the channel is closed).",
        "name": "reflect.Select",
        "params": [],
        "path": "go/reflect/index#Select",
        "syntax": "func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)",
        "type": "reflect"
    },
    "reflect.SelectCase": {
        "descr": "A SelectCase describes a single case in a select operation. The kind of case depends on Dir, the communication direction.",
        "name": "reflect.SelectCase",
        "params": [],
        "path": "go/reflect/index#SelectCase",
        "syntax": "type SelectCase struct { Dir SelectDir // direction of case Chan Value // channel to use (for send or receive) Send Value // value to send (for send) }",
        "type": "reflect"
    },
    "reflect.SelectDir": {
        "descr": "A SelectDir describes the communication direction of a select case.",
        "name": "reflect.SelectDir",
        "params": [],
        "path": "go/reflect/index#SelectDir",
        "syntax": "type SelectDir int",
        "type": "reflect"
    },
    "reflect.SliceHeader": {
        "descr": "SliceHeader is the runtime representation of a slice. It cannot be used safely or portably and its representation may change in a later release. Moreover, the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data.",
        "name": "reflect.SliceHeader",
        "params": [],
        "path": "go/reflect/index#SliceHeader",
        "syntax": "type SliceHeader struct { Data uintptr Len int Cap int }",
        "type": "reflect"
    },
    "reflect.SliceOf": {
        "descr": "SliceOf returns the slice type with element type t. For example, if t represents int, SliceOf(t) represents []int.",
        "name": "reflect.SliceOf",
        "params": [],
        "path": "go/reflect/index#SliceOf",
        "syntax": "func SliceOf(t Type) Type",
        "type": "reflect"
    },
    "reflect.StringHeader": {
        "descr": "StringHeader is the runtime representation of a string. It cannot be used safely or portably and its representation may change in a later release. Moreover, the Data field is not sufficient to guarantee the data it references will not be garbage collected, so programs must keep a separate, correctly typed pointer to the underlying data.",
        "name": "reflect.StringHeader",
        "params": [],
        "path": "go/reflect/index#StringHeader",
        "syntax": "type StringHeader struct { Data uintptr Len int }",
        "type": "reflect"
    },
    "reflect.StructField": {
        "descr": "A StructField describes a single field in a struct.",
        "name": "reflect.StructField",
        "params": [],
        "path": "go/reflect/index#StructField",
        "syntax": "type StructField struct { // Name is the field name. Name string // PkgPath is the package path that qualifies a lower case (unexported) // field name. It is empty for upper case (exported) field names. // See https://golang.org/ref/spec#Uniqueness_of_identifiers PkgPath string Type Type // field type Tag StructTag // field tag string Offset uintptr // offset within struct, in bytes Index []int // index sequence for Type.FieldByIndex Anonymous bool // is an embedded field }",
        "type": "reflect"
    },
    "reflect.StructOf": {
        "descr": "StructOf returns the struct type containing fields. The Offset and Index fields are ignored and computed as they would be by the compiler.",
        "name": "reflect.StructOf",
        "params": [],
        "path": "go/reflect/index#StructOf",
        "syntax": "func StructOf(fields []StructField) Type",
        "type": "reflect"
    },
    "reflect.StructTag": {
        "descr": "A StructTag is the tag string in a struct field.",
        "name": "reflect.StructTag",
        "params": [],
        "path": "go/reflect/index#StructTag",
        "syntax": "type StructTag string",
        "type": "reflect"
    },
    "reflect.StructTag.Get": {
        "descr": "Get returns the value associated with key in the tag string. If there is no such key in the tag, Get returns the empty string. If the tag does not have the conventional format, the value returned by Get is unspecified. To determine whether a tag is explicitly set to the empty string, use Lookup.",
        "name": "reflect.StructTag.Get",
        "params": [],
        "path": "go/reflect/index#StructTag.Get",
        "syntax": "func (tag StructTag) Get(key string) string",
        "type": "reflect"
    },
    "reflect.StructTag.Lookup": {
        "descr": "Lookup returns the value associated with key in the tag string. If the key is present in the tag the value (which may be empty) is returned. Otherwise the returned value will be the empty string. The ok return value reports whether the value was explicitly set in the tag string. If the tag does not have the conventional format, the value returned by Lookup is unspecified.",
        "name": "reflect.StructTag.Lookup",
        "params": [],
        "path": "go/reflect/index#StructTag.Lookup",
        "syntax": "func (tag StructTag) Lookup(key string) (value string, ok bool)",
        "type": "reflect"
    },
    "reflect.Swapper": {
        "descr": "Swapper returns a function that swaps the elements in the provided slice.",
        "name": "reflect.Swapper",
        "params": [],
        "path": "go/reflect/index#Swapper",
        "syntax": "func Swapper(slice interface{}) func(i, j int)",
        "type": "reflect"
    },
    "reflect.Type": {
        "descr": "Type is the representation of a Go type.",
        "name": "reflect.Type",
        "params": [],
        "path": "go/reflect/index#Type",
        "syntax": "type Type interface { // Align returns the alignment in bytes of a value of // this type when allocated in memory. Align() int // FieldAlign returns the alignment in bytes of a value of // this type when used as a field in a struct. FieldAlign() int // Method returns the i'th method in the type's method set. // It panics if i is not in the range [0, NumMethod()). // // For a non-interface type T or *T, the returned Method's Type and Func // fields describe a function whose first argument is the receiver. // // For an interface type, the returned Method's Type field gives the // method signature, without a receiver, and the Func field is nil. Method(int) Method // MethodByName returns the method with that name in the type's // method set and a boolean indicating if the method was found. // // For a non-interface type T or *T, the returned Method's Type and Func // fields describe a function whose first argument is the receiver. // // For an interface type, the returned Method's Type field gives the // method signature, without a receiver, and the Func field is nil. MethodByName(string) (Method, bool) // NumMethod returns the number of exported methods in the type's method set. NumMethod() int // Name returns the type's name within its package for a defined type. // For other (non-defined) types it returns the empty string. Name() string // PkgPath returns a defined type's package path, that is, the import path // that uniquely identifies the package, such as \"encoding/base64\". // If the type was predeclared (string, error) or not defined (*T, struct{}, // []int, or A where A is an alias for a non-defined type), the package path // will be the empty string. PkgPath() string // Size returns the number of bytes needed to store // a value of the given type; it is analogous to unsafe.Sizeof. Size() uintptr // String returns a string representation of the type. // The string representation may use shortened package names // (e.g., base64 instead of \"encoding/base64\") and is not // guaranteed to be unique among types. To test for type identity, // compare the Types directly. String() string // Kind returns the specific kind of this type. Kind() Kind // Implements reports whether the type implements the interface type u. Implements(u Type) bool // AssignableTo reports whether a value of the type is assignable to type u. AssignableTo(u Type) bool // ConvertibleTo reports whether a value of the type is convertible to type u. ConvertibleTo(u Type) bool // Comparable reports whether values of this type are comparable. Comparable() bool // Bits returns the size of the type in bits. // It panics if the type's Kind is not one of the // sized or unsized Int, Uint, Float, or Complex kinds. Bits() int // ChanDir returns a channel type's direction. // It panics if the type's Kind is not Chan. ChanDir() ChanDir // IsVariadic reports whether a function type's final input parameter // is a \"...\" parameter. If so, t.In(t.NumIn() - 1) returns the parameter's // implicit actual type []T. // // For concreteness, if t represents func(x int, y ... float64), then // // t.NumIn() == 2 // t.In(0) is the reflect.Type for \"int\" // t.In(1) is the reflect.Type for \"[]float64\" // t.IsVariadic() == true // // IsVariadic panics if the type's Kind is not Func. IsVariadic() bool // Elem returns a type's element type. // It panics if the type's Kind is not Array, Chan, Map, Ptr, or Slice. Elem() Type // Field returns a struct type's i'th field. // It panics if the type's Kind is not Struct. // It panics if i is not in the range [0, NumField()). Field(i int) StructField // FieldByIndex returns the nested field corresponding // to the index sequence. It is equivalent to calling Field // successively for each index i. // It panics if the type's Kind is not Struct. FieldByIndex(index []int) StructField // FieldByName returns the struct field with the given name // and a boolean indicating if the field was found. FieldByName(name string) (StructField, bool) // FieldByNameFunc returns the struct field with a name // that satisfies the match function and a boolean indicating if // the field was found. // // FieldByNameFunc considers the fields in the struct itself // and then the fields in any embedded structs, in breadth first order, // stopping at the shallowest nesting depth containing one or more // fields satisfying the match function. If multiple fields at that depth // satisfy the match function, they cancel each other // and FieldByNameFunc returns no match. // This behavior mirrors Go's handling of name lookup in // structs containing embedded fields. FieldByNameFunc(match func(string) bool) (StructField, bool) // In returns the type of a function type's i'th input parameter. // It panics if the type's Kind is not Func. // It panics if i is not in the range [0, NumIn()). In(i int) Type // Key returns a map type's key type. // It panics if the type's Kind is not Map. Key() Type // Len returns an array type's length. // It panics if the type's Kind is not Array. Len() int // NumField returns a struct type's field count. // It panics if the type's Kind is not Struct. NumField() int // NumIn returns a function type's input parameter count. // It panics if the type's Kind is not Func. NumIn() int // NumOut returns a function type's output parameter count. // It panics if the type's Kind is not Func. NumOut() int // Out returns the type of a function type's i'th output parameter. // It panics if the type's Kind is not Func. // It panics if i is not in the range [0, NumOut()). Out(i int) Type // contains filtered or unexported methods }",
        "type": "reflect"
    },
    "reflect.TypeOf": {
        "descr": "TypeOf returns the reflection Type that represents the dynamic type of i. If i is a nil interface value, TypeOf returns nil.",
        "name": "reflect.TypeOf",
        "params": [],
        "path": "go/reflect/index#TypeOf",
        "syntax": "func TypeOf(i interface{}) Type",
        "type": "reflect"
    },
    "reflect.Value": {
        "descr": "Value is the reflection interface to a Go value.",
        "name": "reflect.Value",
        "params": [],
        "path": "go/reflect/index#Value",
        "syntax": "type Value struct { // contains filtered or unexported fields }",
        "type": "reflect"
    },
    "reflect.Value.Addr": {
        "descr": "Addr returns a pointer value representing the address of v. It panics if CanAddr() returns false. Addr is typically used to obtain a pointer to a struct field or slice element in order to call a method that requires a pointer receiver.",
        "name": "reflect.Value.Addr",
        "params": [],
        "path": "go/reflect/index#Value.Addr",
        "syntax": "func (v Value) Addr() Value",
        "type": "reflect"
    },
    "reflect.Value.Bool": {
        "descr": "Bool returns v's underlying value. It panics if v's kind is not Bool.",
        "name": "reflect.Value.Bool",
        "params": [],
        "path": "go/reflect/index#Value.Bool",
        "syntax": "func (v Value) Bool() bool",
        "type": "reflect"
    },
    "reflect.Value.Bytes": {
        "descr": "Bytes returns v's underlying value. It panics if v's underlying value is not a slice of bytes.",
        "name": "reflect.Value.Bytes",
        "params": [],
        "path": "go/reflect/index#Value.Bytes",
        "syntax": "func (v Value) Bytes() []byte",
        "type": "reflect"
    },
    "reflect.Value.Call": {
        "descr": "Call calls the function v with the input arguments in. For example, if len(in) == 3, v.Call(in) represents the Go call v(in[0], in[1], in[2]). Call panics if v's Kind is not Func. It returns the output results as Values. As in Go, each input argument must be assignable to the type of the function's corresponding input parameter. If v is a variadic function, Call creates the variadic slice parameter itself, copying in the corresponding values.",
        "name": "reflect.Value.Call",
        "params": [],
        "path": "go/reflect/index#Value.Call",
        "syntax": "func (v Value) Call(in []Value) []Value",
        "type": "reflect"
    },
    "reflect.Value.CallSlice": {
        "descr": "CallSlice calls the variadic function v with the input arguments in, assigning the slice in[len(in)-1] to v's final variadic argument. For example, if len(in) == 3, v.CallSlice(in) represents the Go call v(in[0], in[1], in[2]...). CallSlice panics if v's Kind is not Func or if v is not variadic. It returns the output results as Values. As in Go, each input argument must be assignable to the type of the function's corresponding input parameter.",
        "name": "reflect.Value.CallSlice",
        "params": [],
        "path": "go/reflect/index#Value.CallSlice",
        "syntax": "func (v Value) CallSlice(in []Value) []Value",
        "type": "reflect"
    },
    "reflect.Value.CanAddr": {
        "descr": "CanAddr reports whether the value's address can be obtained with Addr. Such values are called addressable. A value is addressable if it is an element of a slice, an element of an addressable array, a field of an addressable struct, or the result of dereferencing a pointer. If CanAddr returns false, calling Addr will panic.",
        "name": "reflect.Value.CanAddr",
        "params": [],
        "path": "go/reflect/index#Value.CanAddr",
        "syntax": "func (v Value) CanAddr() bool",
        "type": "reflect"
    },
    "reflect.Value.CanInterface": {
        "descr": "CanInterface reports whether Interface can be used without panicking.",
        "name": "reflect.Value.CanInterface",
        "params": [],
        "path": "go/reflect/index#Value.CanInterface",
        "syntax": "func (v Value) CanInterface() bool",
        "type": "reflect"
    },
    "reflect.Value.CanSet": {
        "descr": "CanSet reports whether the value of v can be changed. A Value can be changed only if it is addressable and was not obtained by the use of unexported struct fields. If CanSet returns false, calling Set or any type-specific setter (e.g., SetBool, SetInt) will panic.",
        "name": "reflect.Value.CanSet",
        "params": [],
        "path": "go/reflect/index#Value.CanSet",
        "syntax": "func (v Value) CanSet() bool",
        "type": "reflect"
    },
    "reflect.Value.Cap": {
        "descr": "Cap returns v's capacity. It panics if v's Kind is not Array, Chan, or Slice.",
        "name": "reflect.Value.Cap",
        "params": [],
        "path": "go/reflect/index#Value.Cap",
        "syntax": "func (v Value) Cap() int",
        "type": "reflect"
    },
    "reflect.Value.Close": {
        "descr": "Close closes the channel v. It panics if v's Kind is not Chan.",
        "name": "reflect.Value.Close",
        "params": [],
        "path": "go/reflect/index#Value.Close",
        "syntax": "func (v Value) Close()",
        "type": "reflect"
    },
    "reflect.Value.Complex": {
        "descr": "Complex returns v's underlying value, as a complex128. It panics if v's Kind is not Complex64 or Complex128",
        "name": "reflect.Value.Complex",
        "params": [],
        "path": "go/reflect/index#Value.Complex",
        "syntax": "func (v Value) Complex() complex128",
        "type": "reflect"
    },
    "reflect.Value.Convert": {
        "descr": "Convert returns the value v converted to type t. If the usual Go conversion rules do not allow conversion of the value v to type t, Convert panics.",
        "name": "reflect.Value.Convert",
        "params": [],
        "path": "go/reflect/index#Value.Convert",
        "syntax": "func (v Value) Convert(t Type) Value",
        "type": "reflect"
    },
    "reflect.Value.Elem": {
        "descr": "Elem returns the value that the interface v contains or that the pointer v points to. It panics if v's Kind is not Interface or Ptr. It returns the zero Value if v is nil.",
        "name": "reflect.Value.Elem",
        "params": [],
        "path": "go/reflect/index#Value.Elem",
        "syntax": "func (v Value) Elem() Value",
        "type": "reflect"
    },
    "reflect.Value.Field": {
        "descr": "Field returns the i'th field of the struct v. It panics if v's Kind is not Struct or i is out of range.",
        "name": "reflect.Value.Field",
        "params": [],
        "path": "go/reflect/index#Value.Field",
        "syntax": "func (v Value) Field(i int) Value",
        "type": "reflect"
    },
    "reflect.Value.FieldByIndex": {
        "descr": "FieldByIndex returns the nested field corresponding to index. It panics if v's Kind is not struct.",
        "name": "reflect.Value.FieldByIndex",
        "params": [],
        "path": "go/reflect/index#Value.FieldByIndex",
        "syntax": "func (v Value) FieldByIndex(index []int) Value",
        "type": "reflect"
    },
    "reflect.Value.FieldByName": {
        "descr": "FieldByName returns the struct field with the given name. It returns the zero Value if no field was found. It panics if v's Kind is not struct.",
        "name": "reflect.Value.FieldByName",
        "params": [],
        "path": "go/reflect/index#Value.FieldByName",
        "syntax": "func (v Value) FieldByName(name string) Value",
        "type": "reflect"
    },
    "reflect.Value.FieldByNameFunc": {
        "descr": "FieldByNameFunc returns the struct field with a name that satisfies the match function. It panics if v's Kind is not struct. It returns the zero Value if no field was found.",
        "name": "reflect.Value.FieldByNameFunc",
        "params": [],
        "path": "go/reflect/index#Value.FieldByNameFunc",
        "syntax": "func (v Value) FieldByNameFunc(match func(string) bool) Value",
        "type": "reflect"
    },
    "reflect.Value.Float": {
        "descr": "Float returns v's underlying value, as a float64. It panics if v's Kind is not Float32 or Float64",
        "name": "reflect.Value.Float",
        "params": [],
        "path": "go/reflect/index#Value.Float",
        "syntax": "func (v Value) Float() float64",
        "type": "reflect"
    },
    "reflect.Value.Index": {
        "descr": "Index returns v's i'th element. It panics if v's Kind is not Array, Slice, or String or i is out of range.",
        "name": "reflect.Value.Index",
        "params": [],
        "path": "go/reflect/index#Value.Index",
        "syntax": "func (v Value) Index(i int) Value",
        "type": "reflect"
    },
    "reflect.Value.Int": {
        "descr": "Int returns v's underlying value, as an int64. It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64.",
        "name": "reflect.Value.Int",
        "params": [],
        "path": "go/reflect/index#Value.Int",
        "syntax": "func (v Value) Int() int64",
        "type": "reflect"
    },
    "reflect.Value.Interface": {
        "descr": "Interface returns v's current value as an interface{}. It is equivalent to:",
        "name": "reflect.Value.Interface",
        "params": [],
        "path": "go/reflect/index#Value.Interface",
        "syntax": "func (v Value) Interface() (i interface{})",
        "type": "reflect"
    },
    "reflect.Value.InterfaceData": {
        "descr": "InterfaceData returns the interface v's value as a uintptr pair. It panics if v's Kind is not Interface.",
        "name": "reflect.Value.InterfaceData",
        "params": [],
        "path": "go/reflect/index#Value.InterfaceData",
        "syntax": "func (v Value) InterfaceData() [2]uintptr",
        "type": "reflect"
    },
    "reflect.Value.IsNil": {
        "descr": "IsNil reports whether its argument v is nil. The argument must be a chan, func, interface, map, pointer, or slice value; if it is not, IsNil panics. Note that IsNil is not always equivalent to a regular comparison with nil in Go. For example, if v was created by calling ValueOf with an uninitialized interface variable i, i==nil will be true but v.IsNil will panic as v will be the zero Value.",
        "name": "reflect.Value.IsNil",
        "params": [],
        "path": "go/reflect/index#Value.IsNil",
        "syntax": "func (v Value) IsNil() bool",
        "type": "reflect"
    },
    "reflect.Value.IsValid": {
        "descr": "IsValid reports whether v represents a value. It returns false if v is the zero Value. If IsValid returns false, all other methods except String panic. Most functions and methods never return an invalid value. If one does, its documentation states the conditions explicitly.",
        "name": "reflect.Value.IsValid",
        "params": [],
        "path": "go/reflect/index#Value.IsValid",
        "syntax": "func (v Value) IsValid() bool",
        "type": "reflect"
    },
    "reflect.Value.Kind": {
        "descr": "Kind returns v's Kind. If v is the zero Value (IsValid returns false), Kind returns Invalid.",
        "name": "reflect.Value.Kind",
        "params": [],
        "path": "go/reflect/index#Value.Kind",
        "syntax": "func (v Value) Kind() Kind",
        "type": "reflect"
    },
    "reflect.Value.Len": {
        "descr": "Len returns v's length. It panics if v's Kind is not Array, Chan, Map, Slice, or String.",
        "name": "reflect.Value.Len",
        "params": [],
        "path": "go/reflect/index#Value.Len",
        "syntax": "func (v Value) Len() int",
        "type": "reflect"
    },
    "reflect.Value.MapIndex": {
        "descr": "MapIndex returns the value associated with key in the map v. It panics if v's Kind is not Map. It returns the zero Value if key is not found in the map or if v represents a nil map. As in Go, the key's value must be assignable to the map's key type.",
        "name": "reflect.Value.MapIndex",
        "params": [],
        "path": "go/reflect/index#Value.MapIndex",
        "syntax": "func (v Value) MapIndex(key Value) Value",
        "type": "reflect"
    },
    "reflect.Value.MapKeys": {
        "descr": "MapKeys returns a slice containing all the keys present in the map, in unspecified order. It panics if v's Kind is not Map. It returns an empty slice if v represents a nil map.",
        "name": "reflect.Value.MapKeys",
        "params": [],
        "path": "go/reflect/index#Value.MapKeys",
        "syntax": "func (v Value) MapKeys() []Value",
        "type": "reflect"
    },
    "reflect.Value.Method": {
        "descr": "Method returns a function value corresponding to v's i'th method. The arguments to a Call on the returned function should not include a receiver; the returned function will always use v as the receiver. Method panics if i is out of range or if v is a nil interface value.",
        "name": "reflect.Value.Method",
        "params": [],
        "path": "go/reflect/index#Value.Method",
        "syntax": "func (v Value) Method(i int) Value",
        "type": "reflect"
    },
    "reflect.Value.MethodByName": {
        "descr": "MethodByName returns a function value corresponding to the method of v with the given name. The arguments to a Call on the returned function should not include a receiver; the returned function will always use v as the receiver. It returns the zero Value if no method was found.",
        "name": "reflect.Value.MethodByName",
        "params": [],
        "path": "go/reflect/index#Value.MethodByName",
        "syntax": "func (v Value) MethodByName(name string) Value",
        "type": "reflect"
    },
    "reflect.Value.NumField": {
        "descr": "NumField returns the number of fields in the struct v. It panics if v's Kind is not Struct.",
        "name": "reflect.Value.NumField",
        "params": [],
        "path": "go/reflect/index#Value.NumField",
        "syntax": "func (v Value) NumField() int",
        "type": "reflect"
    },
    "reflect.Value.NumMethod": {
        "descr": "NumMethod returns the number of exported methods in the value's method set.",
        "name": "reflect.Value.NumMethod",
        "params": [],
        "path": "go/reflect/index#Value.NumMethod",
        "syntax": "func (v Value) NumMethod() int",
        "type": "reflect"
    },
    "reflect.Value.OverflowComplex": {
        "descr": "OverflowComplex reports whether the complex128 x cannot be represented by v's type. It panics if v's Kind is not Complex64 or Complex128.",
        "name": "reflect.Value.OverflowComplex",
        "params": [],
        "path": "go/reflect/index#Value.OverflowComplex",
        "syntax": "func (v Value) OverflowComplex(x complex128) bool",
        "type": "reflect"
    },
    "reflect.Value.OverflowFloat": {
        "descr": "OverflowFloat reports whether the float64 x cannot be represented by v's type. It panics if v's Kind is not Float32 or Float64.",
        "name": "reflect.Value.OverflowFloat",
        "params": [],
        "path": "go/reflect/index#Value.OverflowFloat",
        "syntax": "func (v Value) OverflowFloat(x float64) bool",
        "type": "reflect"
    },
    "reflect.Value.OverflowInt": {
        "descr": "OverflowInt reports whether the int64 x cannot be represented by v's type. It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64.",
        "name": "reflect.Value.OverflowInt",
        "params": [],
        "path": "go/reflect/index#Value.OverflowInt",
        "syntax": "func (v Value) OverflowInt(x int64) bool",
        "type": "reflect"
    },
    "reflect.Value.OverflowUint": {
        "descr": "OverflowUint reports whether the uint64 x cannot be represented by v's type. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.",
        "name": "reflect.Value.OverflowUint",
        "params": [],
        "path": "go/reflect/index#Value.OverflowUint",
        "syntax": "func (v Value) OverflowUint(x uint64) bool",
        "type": "reflect"
    },
    "reflect.Value.Pointer": {
        "descr": "Pointer returns v's value as a uintptr. It returns uintptr instead of unsafe.Pointer so that code using reflect cannot obtain unsafe.Pointers without importing the unsafe package explicitly. It panics if v's Kind is not Chan, Func, Map, Ptr, Slice, or UnsafePointer.",
        "name": "reflect.Value.Pointer",
        "params": [],
        "path": "go/reflect/index#Value.Pointer",
        "syntax": "func (v Value) Pointer() uintptr",
        "type": "reflect"
    },
    "reflect.Value.Recv": {
        "descr": "Recv receives and returns a value from the channel v. It panics if v's Kind is not Chan. The receive blocks until a value is ready. The boolean value ok is true if the value x corresponds to a send on the channel, false if it is a zero value received because the channel is closed.",
        "name": "reflect.Value.Recv",
        "params": [],
        "path": "go/reflect/index#Value.Recv",
        "syntax": "func (v Value) Recv() (x Value, ok bool)",
        "type": "reflect"
    },
    "reflect.Value.Send": {
        "descr": "Send sends x on the channel v. It panics if v's kind is not Chan or if x's type is not the same type as v's element type. As in Go, x's value must be assignable to the channel's element type.",
        "name": "reflect.Value.Send",
        "params": [],
        "path": "go/reflect/index#Value.Send",
        "syntax": "func (v Value) Send(x Value)",
        "type": "reflect"
    },
    "reflect.Value.Set": {
        "descr": "Set assigns x to the value v. It panics if CanSet returns false. As in Go, x's value must be assignable to v's type.",
        "name": "reflect.Value.Set",
        "params": [],
        "path": "go/reflect/index#Value.Set",
        "syntax": "func (v Value) Set(x Value)",
        "type": "reflect"
    },
    "reflect.Value.SetBool": {
        "descr": "SetBool sets v's underlying value. It panics if v's Kind is not Bool or if CanSet() is false.",
        "name": "reflect.Value.SetBool",
        "params": [],
        "path": "go/reflect/index#Value.SetBool",
        "syntax": "func (v Value) SetBool(x bool)",
        "type": "reflect"
    },
    "reflect.Value.SetBytes": {
        "descr": "SetBytes sets v's underlying value. It panics if v's underlying value is not a slice of bytes.",
        "name": "reflect.Value.SetBytes",
        "params": [],
        "path": "go/reflect/index#Value.SetBytes",
        "syntax": "func (v Value) SetBytes(x []byte)",
        "type": "reflect"
    },
    "reflect.Value.SetCap": {
        "descr": "SetCap sets v's capacity to n. It panics if v's Kind is not Slice or if n is smaller than the length or greater than the capacity of the slice.",
        "name": "reflect.Value.SetCap",
        "params": [],
        "path": "go/reflect/index#Value.SetCap",
        "syntax": "func (v Value) SetCap(n int)",
        "type": "reflect"
    },
    "reflect.Value.SetComplex": {
        "descr": "SetComplex sets v's underlying value to x. It panics if v's Kind is not Complex64 or Complex128, or if CanSet() is false.",
        "name": "reflect.Value.SetComplex",
        "params": [],
        "path": "go/reflect/index#Value.SetComplex",
        "syntax": "func (v Value) SetComplex(x complex128)",
        "type": "reflect"
    },
    "reflect.Value.SetFloat": {
        "descr": "SetFloat sets v's underlying value to x. It panics if v's Kind is not Float32 or Float64, or if CanSet() is false.",
        "name": "reflect.Value.SetFloat",
        "params": [],
        "path": "go/reflect/index#Value.SetFloat",
        "syntax": "func (v Value) SetFloat(x float64)",
        "type": "reflect"
    },
    "reflect.Value.SetInt": {
        "descr": "SetInt sets v's underlying value to x. It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64, or if CanSet() is false.",
        "name": "reflect.Value.SetInt",
        "params": [],
        "path": "go/reflect/index#Value.SetInt",
        "syntax": "func (v Value) SetInt(x int64)",
        "type": "reflect"
    },
    "reflect.Value.SetLen": {
        "descr": "SetLen sets v's length to n. It panics if v's Kind is not Slice or if n is negative or greater than the capacity of the slice.",
        "name": "reflect.Value.SetLen",
        "params": [],
        "path": "go/reflect/index#Value.SetLen",
        "syntax": "func (v Value) SetLen(n int)",
        "type": "reflect"
    },
    "reflect.Value.SetMapIndex": {
        "descr": "SetMapIndex sets the value associated with key in the map v to val. It panics if v's Kind is not Map. If val is the zero Value, SetMapIndex deletes the key from the map. Otherwise if v holds a nil map, SetMapIndex will panic. As in Go, key's value must be assignable to the map's key type, and val's value must be assignable to the map's value type.",
        "name": "reflect.Value.SetMapIndex",
        "params": [],
        "path": "go/reflect/index#Value.SetMapIndex",
        "syntax": "func (v Value) SetMapIndex(key, val Value)",
        "type": "reflect"
    },
    "reflect.Value.SetPointer": {
        "descr": "SetPointer sets the unsafe.Pointer value v to x. It panics if v's Kind is not UnsafePointer.",
        "name": "reflect.Value.SetPointer",
        "params": [],
        "path": "go/reflect/index#Value.SetPointer",
        "syntax": "func (v Value) SetPointer(x unsafe.Pointer)",
        "type": "reflect"
    },
    "reflect.Value.SetString": {
        "descr": "SetString sets v's underlying value to x. It panics if v's Kind is not String or if CanSet() is false.",
        "name": "reflect.Value.SetString",
        "params": [],
        "path": "go/reflect/index#Value.SetString",
        "syntax": "func (v Value) SetString(x string)",
        "type": "reflect"
    },
    "reflect.Value.SetUint": {
        "descr": "SetUint sets v's underlying value to x. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64, or if CanSet() is false.",
        "name": "reflect.Value.SetUint",
        "params": [],
        "path": "go/reflect/index#Value.SetUint",
        "syntax": "func (v Value) SetUint(x uint64)",
        "type": "reflect"
    },
    "reflect.Value.Slice": {
        "descr": "Slice returns v[i:j]. It panics if v's Kind is not Array, Slice or String, or if v is an unaddressable array, or if the indexes are out of bounds.",
        "name": "reflect.Value.Slice",
        "params": [],
        "path": "go/reflect/index#Value.Slice",
        "syntax": "func (v Value) Slice(i, j int) Value",
        "type": "reflect"
    },
    "reflect.Value.Slice3": {
        "descr": "Slice3 is the 3-index form of the slice operation: it returns v[i:j:k]. It panics if v's Kind is not Array or Slice, or if v is an unaddressable array, or if the indexes are out of bounds.",
        "name": "reflect.Value.Slice3",
        "params": [],
        "path": "go/reflect/index#Value.Slice3",
        "syntax": "func (v Value) Slice3(i, j, k int) Value",
        "type": "reflect"
    },
    "reflect.Value.String": {
        "descr": "String returns the string v's underlying value, as a string. String is a special case because of Go's String method convention. Unlike the other getters, it does not panic if v's Kind is not String. Instead, it returns a string of the form \"<T value>\" where T is v's type. The fmt package treats Values specially. It does not call their String method implicitly but instead prints the concrete values they hold.",
        "name": "reflect.Value.String",
        "params": [],
        "path": "go/reflect/index#Value.String",
        "syntax": "func (v Value) String() string",
        "type": "reflect"
    },
    "reflect.Value.TryRecv": {
        "descr": "TryRecv attempts to receive a value from the channel v but will not block. It panics if v's Kind is not Chan. If the receive delivers a value, x is the transferred value and ok is true. If the receive cannot finish without blocking, x is the zero Value and ok is false. If the channel is closed, x is the zero value for the channel's element type and ok is false.",
        "name": "reflect.Value.TryRecv",
        "params": [],
        "path": "go/reflect/index#Value.TryRecv",
        "syntax": "func (v Value) TryRecv() (x Value, ok bool)",
        "type": "reflect"
    },
    "reflect.Value.TrySend": {
        "descr": "TrySend attempts to send x on the channel v but will not block. It panics if v's Kind is not Chan. It reports whether the value was sent. As in Go, x's value must be assignable to the channel's element type.",
        "name": "reflect.Value.TrySend",
        "params": [],
        "path": "go/reflect/index#Value.TrySend",
        "syntax": "func (v Value) TrySend(x Value) bool",
        "type": "reflect"
    },
    "reflect.Value.Type": {
        "descr": "Type returns v's type.",
        "name": "reflect.Value.Type",
        "params": [],
        "path": "go/reflect/index#Value.Type",
        "syntax": "func (v Value) Type() Type",
        "type": "reflect"
    },
    "reflect.Value.Uint": {
        "descr": "Uint returns v's underlying value, as a uint64. It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.",
        "name": "reflect.Value.Uint",
        "params": [],
        "path": "go/reflect/index#Value.Uint",
        "syntax": "func (v Value) Uint() uint64",
        "type": "reflect"
    },
    "reflect.Value.UnsafeAddr": {
        "descr": "UnsafeAddr returns a pointer to v's data. It is for advanced clients that also import the \"unsafe\" package. It panics if v is not addressable.",
        "name": "reflect.Value.UnsafeAddr",
        "params": [],
        "path": "go/reflect/index#Value.UnsafeAddr",
        "syntax": "func (v Value) UnsafeAddr() uintptr",
        "type": "reflect"
    },
    "reflect.ValueError": {
        "descr": "A ValueError occurs when a Value method is invoked on a Value that does not support it. Such cases are documented in the description of each method.",
        "name": "reflect.ValueError",
        "params": [],
        "path": "go/reflect/index#ValueError",
        "syntax": "type ValueError struct { Method string Kind Kind }",
        "type": "reflect"
    },
    "reflect.ValueError.Error": {
        "descr": "",
        "name": "reflect.ValueError.Error",
        "params": [],
        "path": "go/reflect/index#ValueError.Error",
        "syntax": "func (e *ValueError) Error() string",
        "type": "reflect"
    },
    "reflect.ValueOf": {
        "descr": "ValueOf returns a new Value initialized to the concrete value stored in the interface i. ValueOf(nil) returns the zero Value.",
        "name": "reflect.ValueOf",
        "params": [],
        "path": "go/reflect/index#ValueOf",
        "syntax": "func ValueOf(i interface{}) Value",
        "type": "reflect"
    },
    "reflect.Zero": {
        "descr": "Zero returns a Value representing the zero value for the specified type. The result is different from the zero value of the Value struct, which represents no value at all. For example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0. The returned value is neither addressable nor settable.",
        "name": "reflect.Zero",
        "params": [],
        "path": "go/reflect/index#Zero",
        "syntax": "func Zero(typ Type) Value",
        "type": "reflect"
    },
    "regexp.Compile": {
        "descr": "Compile parses a regular expression and returns, if successful, a Regexp object that can be used to match against text.",
        "name": "regexp.Compile",
        "params": [],
        "path": "go/regexp/index#Compile",
        "syntax": "func Compile(expr string) (*Regexp, error)",
        "type": "regexp"
    },
    "regexp.CompilePOSIX": {
        "descr": "CompilePOSIX is like Compile but restricts the regular expression to POSIX ERE (egrep) syntax and changes the match semantics to leftmost-longest.",
        "name": "regexp.CompilePOSIX",
        "params": [],
        "path": "go/regexp/index#CompilePOSIX",
        "syntax": "func CompilePOSIX(expr string) (*Regexp, error)",
        "type": "regexp"
    },
    "regexp.Match": {
        "descr": "MatchString reports whether the byte slice b contains any match of the regular expression pattern. More complicated queries need to use Compile and the full Regexp interface.",
        "name": "regexp.Match",
        "params": [],
        "path": "go/regexp/index#Match",
        "syntax": "func Match(pattern string, b []byte) (matched bool, err error)",
        "type": "regexp"
    },
    "regexp.MatchReader": {
        "descr": "MatchReader reports whether the text returned by the RuneReader contains any match of the regular expression pattern. More complicated queries need to use Compile and the full Regexp interface.",
        "name": "regexp.MatchReader",
        "params": [],
        "path": "go/regexp/index#MatchReader",
        "syntax": "func MatchReader(pattern string, r io.RuneReader) (matched bool, err error)",
        "type": "regexp"
    },
    "regexp.MatchString": {
        "descr": "MatchString reports whether the string s contains any match of the regular expression pattern. More complicated queries need to use Compile and the full Regexp interface.",
        "name": "regexp.MatchString",
        "params": [],
        "path": "go/regexp/index#MatchString",
        "syntax": "func MatchString(pattern string, s string) (matched bool, err error)",
        "type": "regexp"
    },
    "regexp.MustCompile": {
        "descr": "MustCompile is like Compile but panics if the expression cannot be parsed. It simplifies safe initialization of global variables holding compiled regular expressions.",
        "name": "regexp.MustCompile",
        "params": [],
        "path": "go/regexp/index#MustCompile",
        "syntax": "func MustCompile(str string) *Regexp",
        "type": "regexp"
    },
    "regexp.MustCompilePOSIX": {
        "descr": "MustCompilePOSIX is like CompilePOSIX but panics if the expression cannot be parsed. It simplifies safe initialization of global variables holding compiled regular expressions.",
        "name": "regexp.MustCompilePOSIX",
        "params": [],
        "path": "go/regexp/index#MustCompilePOSIX",
        "syntax": "func MustCompilePOSIX(str string) *Regexp",
        "type": "regexp"
    },
    "regexp.QuoteMeta": {
        "descr": "QuoteMeta returns a string that escapes all regular expression metacharacters inside the argument text; the returned string is a regular expression matching the literal text.",
        "name": "regexp.QuoteMeta",
        "params": [],
        "path": "go/regexp/index#QuoteMeta",
        "syntax": "func QuoteMeta(s string) string",
        "type": "regexp"
    },
    "regexp.Regexp": {
        "descr": "Regexp is the representation of a compiled regular expression. A Regexp is safe for concurrent use by multiple goroutines, except for configuration methods, such as Longest.",
        "name": "regexp.Regexp",
        "params": [],
        "path": "go/regexp/index#Regexp",
        "syntax": "type Regexp struct { // contains filtered or unexported fields }",
        "type": "regexp"
    },
    "regexp.Regexp.Copy": {
        "descr": "Copy returns a new Regexp object copied from re.",
        "name": "regexp.Regexp.Copy",
        "params": [],
        "path": "go/regexp/index#Regexp.Copy",
        "syntax": "func (re *Regexp) Copy() *Regexp",
        "type": "regexp"
    },
    "regexp.Regexp.Expand": {
        "descr": "Expand appends template to dst and returns the result; during the append, Expand replaces variables in the template with corresponding matches drawn from src. The match slice should have been returned by FindSubmatchIndex.",
        "name": "regexp.Regexp.Expand",
        "params": [],
        "path": "go/regexp/index#Regexp.Expand",
        "syntax": "func (re *Regexp) Expand(dst []byte, template []byte, src []byte, match []int) []byte",
        "type": "regexp"
    },
    "regexp.Regexp.ExpandString": {
        "descr": "ExpandString is like Expand but the template and source are strings. It appends to and returns a byte slice in order to give the calling code control over allocation.",
        "name": "regexp.Regexp.ExpandString",
        "params": [],
        "path": "go/regexp/index#Regexp.ExpandString",
        "syntax": "func (re *Regexp) ExpandString(dst []byte, template string, src string, match []int) []byte",
        "type": "regexp"
    },
    "regexp.Regexp.Find": {
        "descr": "Find returns a slice holding the text of the leftmost match in b of the regular expression. A return value of nil indicates no match.",
        "name": "regexp.Regexp.Find",
        "params": [],
        "path": "go/regexp/index#Regexp.Find",
        "syntax": "func (re *Regexp) Find(b []byte) []byte",
        "type": "regexp"
    },
    "regexp.Regexp.FindAll": {
        "descr": "FindAll is the 'All' version of Find; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindAll",
        "params": [],
        "path": "go/regexp/index#Regexp.FindAll",
        "syntax": "func (re *Regexp) FindAll(b []byte, n int) [][]byte",
        "type": "regexp"
    },
    "regexp.Regexp.FindAllIndex": {
        "descr": "FindAllIndex is the 'All' version of FindIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindAllIndex",
        "params": [],
        "path": "go/regexp/index#Regexp.FindAllIndex",
        "syntax": "func (re *Regexp) FindAllIndex(b []byte, n int) [][]int",
        "type": "regexp"
    },
    "regexp.Regexp.FindAllString": {
        "descr": "FindAllString is the 'All' version of FindString; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindAllString",
        "params": [],
        "path": "go/regexp/index#Regexp.FindAllString",
        "syntax": "func (re *Regexp) FindAllString(s string, n int) []string",
        "type": "regexp"
    },
    "regexp.Regexp.FindAllStringIndex": {
        "descr": "FindAllStringIndex is the 'All' version of FindStringIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindAllStringIndex",
        "params": [],
        "path": "go/regexp/index#Regexp.FindAllStringIndex",
        "syntax": "func (re *Regexp) FindAllStringIndex(s string, n int) [][]int",
        "type": "regexp"
    },
    "regexp.Regexp.FindAllStringSubmatch": {
        "descr": "FindAllStringSubmatch is the 'All' version of FindStringSubmatch; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindAllStringSubmatch",
        "params": [],
        "path": "go/regexp/index#Regexp.FindAllStringSubmatch",
        "syntax": "func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string",
        "type": "regexp"
    },
    "regexp.Regexp.FindAllStringSubmatchIndex": {
        "descr": "FindAllStringSubmatchIndex is the 'All' version of FindStringSubmatchIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindAllStringSubmatchIndex",
        "params": [],
        "path": "go/regexp/index#Regexp.FindAllStringSubmatchIndex",
        "syntax": "func (re *Regexp) FindAllStringSubmatchIndex(s string, n int) [][]int",
        "type": "regexp"
    },
    "regexp.Regexp.FindAllSubmatch": {
        "descr": "FindAllSubmatch is the 'All' version of FindSubmatch; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindAllSubmatch",
        "params": [],
        "path": "go/regexp/index#Regexp.FindAllSubmatch",
        "syntax": "func (re *Regexp) FindAllSubmatch(b []byte, n int) [][][]byte",
        "type": "regexp"
    },
    "regexp.Regexp.FindAllSubmatchIndex": {
        "descr": "FindAllSubmatchIndex is the 'All' version of FindSubmatchIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindAllSubmatchIndex",
        "params": [],
        "path": "go/regexp/index#Regexp.FindAllSubmatchIndex",
        "syntax": "func (re *Regexp) FindAllSubmatchIndex(b []byte, n int) [][]int",
        "type": "regexp"
    },
    "regexp.Regexp.FindIndex": {
        "descr": "FindIndex returns a two-element slice of integers defining the location of the leftmost match in b of the regular expression. The match itself is at b[loc[0]:loc[1]]. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindIndex",
        "params": [],
        "path": "go/regexp/index#Regexp.FindIndex",
        "syntax": "func (re *Regexp) FindIndex(b []byte) (loc []int)",
        "type": "regexp"
    },
    "regexp.Regexp.FindReaderIndex": {
        "descr": "FindReaderIndex returns a two-element slice of integers defining the location of the leftmost match of the regular expression in text read from the RuneReader. The match text was found in the input stream at byte offset loc[0] through loc[1]-1. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindReaderIndex",
        "params": [],
        "path": "go/regexp/index#Regexp.FindReaderIndex",
        "syntax": "func (re *Regexp) FindReaderIndex(r io.RuneReader) (loc []int)",
        "type": "regexp"
    },
    "regexp.Regexp.FindReaderSubmatchIndex": {
        "descr": "FindReaderSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression of text read by the RuneReader, and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindReaderSubmatchIndex",
        "params": [],
        "path": "go/regexp/index#Regexp.FindReaderSubmatchIndex",
        "syntax": "func (re *Regexp) FindReaderSubmatchIndex(r io.RuneReader) []int",
        "type": "regexp"
    },
    "regexp.Regexp.FindString": {
        "descr": "FindString returns a string holding the text of the leftmost match in s of the regular expression. If there is no match, the return value is an empty string, but it will also be empty if the regular expression successfully matches an empty string. Use FindStringIndex or FindStringSubmatch if it is necessary to distinguish these cases.",
        "name": "regexp.Regexp.FindString",
        "params": [],
        "path": "go/regexp/index#Regexp.FindString",
        "syntax": "func (re *Regexp) FindString(s string) string",
        "type": "regexp"
    },
    "regexp.Regexp.FindStringIndex": {
        "descr": "FindStringIndex returns a two-element slice of integers defining the location of the leftmost match in s of the regular expression. The match itself is at s[loc[0]:loc[1]]. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindStringIndex",
        "params": [],
        "path": "go/regexp/index#Regexp.FindStringIndex",
        "syntax": "func (re *Regexp) FindStringIndex(s string) (loc []int)",
        "type": "regexp"
    },
    "regexp.Regexp.FindStringSubmatch": {
        "descr": "FindStringSubmatch returns a slice of strings holding the text of the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the 'Submatch' description in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindStringSubmatch",
        "params": [],
        "path": "go/regexp/index#Regexp.FindStringSubmatch",
        "syntax": "func (re *Regexp) FindStringSubmatch(s string) []string",
        "type": "regexp"
    },
    "regexp.Regexp.FindStringSubmatchIndex": {
        "descr": "FindStringSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindStringSubmatchIndex",
        "params": [],
        "path": "go/regexp/index#Regexp.FindStringSubmatchIndex",
        "syntax": "func (re *Regexp) FindStringSubmatchIndex(s string) []int",
        "type": "regexp"
    },
    "regexp.Regexp.FindSubmatch": {
        "descr": "FindSubmatch returns a slice of slices holding the text of the leftmost match of the regular expression in b and the matches, if any, of its subexpressions, as defined by the 'Submatch' descriptions in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindSubmatch",
        "params": [],
        "path": "go/regexp/index#Regexp.FindSubmatch",
        "syntax": "func (re *Regexp) FindSubmatch(b []byte) [][]byte",
        "type": "regexp"
    },
    "regexp.Regexp.FindSubmatchIndex": {
        "descr": "FindSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression in b and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match.",
        "name": "regexp.Regexp.FindSubmatchIndex",
        "params": [],
        "path": "go/regexp/index#Regexp.FindSubmatchIndex",
        "syntax": "func (re *Regexp) FindSubmatchIndex(b []byte) []int",
        "type": "regexp"
    },
    "regexp.Regexp.LiteralPrefix": {
        "descr": "LiteralPrefix returns a literal string that must begin any match of the regular expression re. It returns the boolean true if the literal string comprises the entire regular expression.",
        "name": "regexp.Regexp.LiteralPrefix",
        "params": [],
        "path": "go/regexp/index#Regexp.LiteralPrefix",
        "syntax": "func (re *Regexp) LiteralPrefix() (prefix string, complete bool)",
        "type": "regexp"
    },
    "regexp.Regexp.Longest": {
        "descr": "Longest makes future searches prefer the leftmost-longest match. That is, when matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses a match that is as long as possible. This method modifies the Regexp and may not be called concurrently with any other methods.",
        "name": "regexp.Regexp.Longest",
        "params": [],
        "path": "go/regexp/index#Regexp.Longest",
        "syntax": "func (re *Regexp) Longest()",
        "type": "regexp"
    },
    "regexp.Regexp.Match": {
        "descr": "Match reports whether the byte slice b contains any match of the regular expression re.",
        "name": "regexp.Regexp.Match",
        "params": [],
        "path": "go/regexp/index#Regexp.Match",
        "syntax": "func (re *Regexp) Match(b []byte) bool",
        "type": "regexp"
    },
    "regexp.Regexp.MatchReader": {
        "descr": "MatchReader reports whether the text returned by the RuneReader contains any match of the regular expression re.",
        "name": "regexp.Regexp.MatchReader",
        "params": [],
        "path": "go/regexp/index#Regexp.MatchReader",
        "syntax": "func (re *Regexp) MatchReader(r io.RuneReader) bool",
        "type": "regexp"
    },
    "regexp.Regexp.MatchString": {
        "descr": "MatchString reports whether the string s contains any match of the regular expression re.",
        "name": "regexp.Regexp.MatchString",
        "params": [],
        "path": "go/regexp/index#Regexp.MatchString",
        "syntax": "func (re *Regexp) MatchString(s string) bool",
        "type": "regexp"
    },
    "regexp.Regexp.NumSubexp": {
        "descr": "NumSubexp returns the number of parenthesized subexpressions in this Regexp.",
        "name": "regexp.Regexp.NumSubexp",
        "params": [],
        "path": "go/regexp/index#Regexp.NumSubexp",
        "syntax": "func (re *Regexp) NumSubexp() int",
        "type": "regexp"
    },
    "regexp.Regexp.ReplaceAll": {
        "descr": "ReplaceAll returns a copy of src, replacing matches of the Regexp with the replacement text repl. Inside repl, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch.",
        "name": "regexp.Regexp.ReplaceAll",
        "params": [],
        "path": "go/regexp/index#Regexp.ReplaceAll",
        "syntax": "func (re *Regexp) ReplaceAll(src, repl []byte) []byte",
        "type": "regexp"
    },
    "regexp.Regexp.ReplaceAllFunc": {
        "descr": "ReplaceAllFunc returns a copy of src in which all matches of the Regexp have been replaced by the return value of function repl applied to the matched byte slice. The replacement returned by repl is substituted directly, without using Expand.",
        "name": "regexp.Regexp.ReplaceAllFunc",
        "params": [],
        "path": "go/regexp/index#Regexp.ReplaceAllFunc",
        "syntax": "func (re *Regexp) ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte",
        "type": "regexp"
    },
    "regexp.Regexp.ReplaceAllLiteral": {
        "descr": "ReplaceAllLiteral returns a copy of src, replacing matches of the Regexp with the replacement bytes repl. The replacement repl is substituted directly, without using Expand.",
        "name": "regexp.Regexp.ReplaceAllLiteral",
        "params": [],
        "path": "go/regexp/index#Regexp.ReplaceAllLiteral",
        "syntax": "func (re *Regexp) ReplaceAllLiteral(src, repl []byte) []byte",
        "type": "regexp"
    },
    "regexp.Regexp.ReplaceAllLiteralString": {
        "descr": "ReplaceAllLiteralString returns a copy of src, replacing matches of the Regexp with the replacement string repl. The replacement repl is substituted directly, without using Expand.",
        "name": "regexp.Regexp.ReplaceAllLiteralString",
        "params": [],
        "path": "go/regexp/index#Regexp.ReplaceAllLiteralString",
        "syntax": "func (re *Regexp) ReplaceAllLiteralString(src, repl string) string",
        "type": "regexp"
    },
    "regexp.Regexp.ReplaceAllString": {
        "descr": "ReplaceAllString returns a copy of src, replacing matches of the Regexp with the replacement string repl. Inside repl, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch.",
        "name": "regexp.Regexp.ReplaceAllString",
        "params": [],
        "path": "go/regexp/index#Regexp.ReplaceAllString",
        "syntax": "func (re *Regexp) ReplaceAllString(src, repl string) string",
        "type": "regexp"
    },
    "regexp.Regexp.ReplaceAllStringFunc": {
        "descr": "ReplaceAllStringFunc returns a copy of src in which all matches of the Regexp have been replaced by the return value of function repl applied to the matched substring. The replacement returned by repl is substituted directly, without using Expand.",
        "name": "regexp.Regexp.ReplaceAllStringFunc",
        "params": [],
        "path": "go/regexp/index#Regexp.ReplaceAllStringFunc",
        "syntax": "func (re *Regexp) ReplaceAllStringFunc(src string, repl func(string) string) string",
        "type": "regexp"
    },
    "regexp.Regexp.Split": {
        "descr": "Split slices s into substrings separated by the expression and returns a slice of the substrings between those expression matches.",
        "name": "regexp.Regexp.Split",
        "params": [],
        "path": "go/regexp/index#Regexp.Split",
        "syntax": "func (re *Regexp) Split(s string, n int) []string",
        "type": "regexp"
    },
    "regexp.Regexp.String": {
        "descr": "String returns the source text used to compile the regular expression.",
        "name": "regexp.Regexp.String",
        "params": [],
        "path": "go/regexp/index#Regexp.String",
        "syntax": "func (re *Regexp) String() string",
        "type": "regexp"
    },
    "regexp.Regexp.SubexpNames": {
        "descr": "SubexpNames returns the names of the parenthesized subexpressions in this Regexp. The name for the first sub-expression is names[1], so that if m is a match slice, the name for m[i] is SubexpNames()[i]. Since the Regexp as a whole cannot be named, names[0] is always the empty string. The slice should not be modified.",
        "name": "regexp.Regexp.SubexpNames",
        "params": [],
        "path": "go/regexp/index#Regexp.SubexpNames",
        "syntax": "func (re *Regexp) SubexpNames() []string",
        "type": "regexp"
    },
    "ring.New": {
        "descr": "New creates a ring of n elements.",
        "name": "ring.New",
        "params": [],
        "path": "go/container/ring/index#New",
        "syntax": "func New(n int) *Ring",
        "type": "container"
    },
    "ring.Ring": {
        "descr": "A Ring is an element of a circular list, or ring. Rings do not have a beginning or end; a pointer to any ring element serves as reference to the entire ring. Empty rings are represented as nil Ring pointers. The zero value for a Ring is a one-element ring with a nil Value.",
        "name": "ring.Ring",
        "params": [],
        "path": "go/container/ring/index#Ring",
        "syntax": "type Ring struct { Value interface{} // for use by client; untouched by this library // contains filtered or unexported fields }",
        "type": "container"
    },
    "ring.Ring.Do": {
        "descr": "Do calls function f on each element of the ring, in forward order. The behavior of Do is undefined if f changes *r.",
        "name": "ring.Ring.Do",
        "params": [],
        "path": "go/container/ring/index#Ring.Do",
        "syntax": "func (r *Ring) Do(f func(interface{}))",
        "type": "container"
    },
    "ring.Ring.Len": {
        "descr": "Len computes the number of elements in ring r. It executes in time proportional to the number of elements.",
        "name": "ring.Ring.Len",
        "params": [],
        "path": "go/container/ring/index#Ring.Len",
        "syntax": "func (r *Ring) Len() int",
        "type": "container"
    },
    "ring.Ring.Link": {
        "descr": "Link connects ring r with ring s such that r.Next() becomes s and returns the original value for r.Next(). r must not be empty.",
        "name": "ring.Ring.Link",
        "params": [],
        "path": "go/container/ring/index#Ring.Link",
        "syntax": "func (r *Ring) Link(s *Ring) *Ring",
        "type": "container"
    },
    "ring.Ring.Move": {
        "descr": "Move moves n % r.Len() elements backward (n < 0) or forward (n >= 0) in the ring and returns that ring element. r must not be empty.",
        "name": "ring.Ring.Move",
        "params": [],
        "path": "go/container/ring/index#Ring.Move",
        "syntax": "func (r *Ring) Move(n int) *Ring",
        "type": "container"
    },
    "ring.Ring.Next": {
        "descr": "Next returns the next ring element. r must not be empty.",
        "name": "ring.Ring.Next",
        "params": [],
        "path": "go/container/ring/index#Ring.Next",
        "syntax": "func (r *Ring) Next() *Ring",
        "type": "container"
    },
    "ring.Ring.Prev": {
        "descr": "Prev returns the previous ring element. r must not be empty.",
        "name": "ring.Ring.Prev",
        "params": [],
        "path": "go/container/ring/index#Ring.Prev",
        "syntax": "func (r *Ring) Prev() *Ring",
        "type": "container"
    },
    "ring.Ring.Unlink": {
        "descr": "Unlink removes n % r.Len() elements from the ring r, starting at r.Next(). If n % r.Len() == 0, r remains unchanged. The result is the removed subring. r must not be empty.",
        "name": "ring.Ring.Unlink",
        "params": [],
        "path": "go/container/ring/index#Ring.Unlink",
        "syntax": "func (r *Ring) Unlink(n int) *Ring",
        "type": "container"
    },
    "rpc.Accept": {
        "descr": "Accept accepts connections on the listener and serves requests to DefaultServer for each incoming connection. Accept blocks; the caller typically invokes it in a go statement.",
        "name": "rpc.Accept",
        "params": [],
        "path": "go/net/rpc/index#Accept",
        "syntax": "func Accept(lis net.Listener)",
        "type": "net/rpc"
    },
    "rpc.Call": {
        "descr": "Call represents an active RPC.",
        "name": "rpc.Call",
        "params": [],
        "path": "go/net/rpc/index#Call",
        "syntax": "type Call struct { ServiceMethod string // The name of the service and method to call. Args interface{} // The argument to the function (*struct). Reply interface{} // The reply from the function (*struct). Error error // After completion, the error status. Done chan *Call // Strobes when call is complete. }",
        "type": "net/rpc"
    },
    "rpc.Client": {
        "descr": "Client represents an RPC Client. There may be multiple outstanding Calls associated with a single Client, and a Client may be used by multiple goroutines simultaneously.",
        "name": "rpc.Client",
        "params": [],
        "path": "go/net/rpc/index#Client",
        "syntax": "type Client struct { // contains filtered or unexported fields }",
        "type": "net/rpc"
    },
    "rpc.Client.Call": {
        "descr": "Call invokes the named function, waits for it to complete, and returns its error status.",
        "name": "rpc.Client.Call",
        "params": [],
        "path": "go/net/rpc/index#Client.Call",
        "syntax": "func (client *Client) Call(serviceMethod string, args interface{}, reply interface{}) error",
        "type": "net/rpc"
    },
    "rpc.Client.Close": {
        "descr": "Close calls the underlying codec's Close method. If the connection is already shutting down, ErrShutdown is returned.",
        "name": "rpc.Client.Close",
        "params": [],
        "path": "go/net/rpc/index#Client.Close",
        "syntax": "func (client *Client) Close() error",
        "type": "net/rpc"
    },
    "rpc.Client.Go": {
        "descr": "Go invokes the function asynchronously. It returns the Call structure representing the invocation. The done channel will signal when the call is complete by returning the same Call object. If done is nil, Go will allocate a new channel. If non-nil, done must be buffered or Go will deliberately crash.",
        "name": "rpc.Client.Go",
        "params": [],
        "path": "go/net/rpc/index#Client.Go",
        "syntax": "func (client *Client) Go(serviceMethod string, args interface{}, reply interface{}, done chan *Call) *Call",
        "type": "net/rpc"
    },
    "rpc.ClientCodec": {
        "descr": "A ClientCodec implements writing of RPC requests and reading of RPC responses for the client side of an RPC session. The client calls WriteRequest to write a request to the connection and calls ReadResponseHeader and ReadResponseBody in pairs to read responses. The client calls Close when finished with the connection. ReadResponseBody may be called with a nil argument to force the body of the response to be read and then discarded. See NewClient's comment for information about concurrent access.",
        "name": "rpc.ClientCodec",
        "params": [],
        "path": "go/net/rpc/index#ClientCodec",
        "syntax": "type ClientCodec interface { WriteRequest(*Request, interface{}) error ReadResponseHeader(*Response) error ReadResponseBody(interface{}) error Close() error }",
        "type": "net/rpc"
    },
    "rpc.Dial": {
        "descr": "Dial connects to an RPC server at the specified network address.",
        "name": "rpc.Dial",
        "params": [],
        "path": "go/net/rpc/index#Dial",
        "syntax": "func Dial(network, address string) (*Client, error)",
        "type": "net/rpc"
    },
    "rpc.DialHTTP": {
        "descr": "DialHTTP connects to an HTTP RPC server at the specified network address listening on the default HTTP RPC path.",
        "name": "rpc.DialHTTP",
        "params": [],
        "path": "go/net/rpc/index#DialHTTP",
        "syntax": "func DialHTTP(network, address string) (*Client, error)",
        "type": "net/rpc"
    },
    "rpc.DialHTTPPath": {
        "descr": "DialHTTPPath connects to an HTTP RPC server at the specified network address and path.",
        "name": "rpc.DialHTTPPath",
        "params": [],
        "path": "go/net/rpc/index#DialHTTPPath",
        "syntax": "func DialHTTPPath(network, address, path string) (*Client, error)",
        "type": "net/rpc"
    },
    "rpc.HandleHTTP": {
        "descr": "HandleHTTP registers an HTTP handler for RPC messages to DefaultServer on DefaultRPCPath and a debugging handler on DefaultDebugPath. It is still necessary to invoke http.Serve(), typically in a go statement.",
        "name": "rpc.HandleHTTP",
        "params": [],
        "path": "go/net/rpc/index#HandleHTTP",
        "syntax": "func HandleHTTP()",
        "type": "net/rpc"
    },
    "rpc.NewClient": {
        "descr": "NewClient returns a new Client to handle requests to the set of services at the other end of the connection. It adds a buffer to the write side of the connection so the header and payload are sent as a unit.",
        "name": "rpc.NewClient",
        "params": [],
        "path": "go/net/rpc/index#NewClient",
        "syntax": "func NewClient(conn io.ReadWriteCloser) *Client",
        "type": "net/rpc"
    },
    "rpc.NewClientWithCodec": {
        "descr": "NewClientWithCodec is like NewClient but uses the specified codec to encode requests and decode responses.",
        "name": "rpc.NewClientWithCodec",
        "params": [],
        "path": "go/net/rpc/index#NewClientWithCodec",
        "syntax": "func NewClientWithCodec(codec ClientCodec) *Client",
        "type": "net/rpc"
    },
    "rpc.NewServer": {
        "descr": "NewServer returns a new Server.",
        "name": "rpc.NewServer",
        "params": [],
        "path": "go/net/rpc/index#NewServer",
        "syntax": "func NewServer() *Server",
        "type": "net/rpc"
    },
    "rpc.Register": {
        "descr": "Register publishes the receiver's methods in the DefaultServer.",
        "name": "rpc.Register",
        "params": [],
        "path": "go/net/rpc/index#Register",
        "syntax": "func Register(rcvr interface{}) error",
        "type": "net/rpc"
    },
    "rpc.RegisterName": {
        "descr": "RegisterName is like Register but uses the provided name for the type instead of the receiver's concrete type.",
        "name": "rpc.RegisterName",
        "params": [],
        "path": "go/net/rpc/index#RegisterName",
        "syntax": "func RegisterName(name string, rcvr interface{}) error",
        "type": "net/rpc"
    },
    "rpc.Request": {
        "descr": "Request is a header written before every RPC call. It is used internally but documented here as an aid to debugging, such as when analyzing network traffic.",
        "name": "rpc.Request",
        "params": [],
        "path": "go/net/rpc/index#Request",
        "syntax": "type Request struct { ServiceMethod string // format: \"Service.Method\" Seq uint64 // sequence number chosen by client // contains filtered or unexported fields }",
        "type": "net/rpc"
    },
    "rpc.Response": {
        "descr": "Response is a header written before every RPC return. It is used internally but documented here as an aid to debugging, such as when analyzing network traffic.",
        "name": "rpc.Response",
        "params": [],
        "path": "go/net/rpc/index#Response",
        "syntax": "type Response struct { ServiceMethod string // echoes that of the Request Seq uint64 // echoes that of the request Error string // error, if any. // contains filtered or unexported fields }",
        "type": "net/rpc"
    },
    "rpc.ServeCodec": {
        "descr": "ServeCodec is like ServeConn but uses the specified codec to decode requests and encode responses.",
        "name": "rpc.ServeCodec",
        "params": [],
        "path": "go/net/rpc/index#ServeCodec",
        "syntax": "func ServeCodec(codec ServerCodec)",
        "type": "net/rpc"
    },
    "rpc.ServeConn": {
        "descr": "ServeConn runs the DefaultServer on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement. ServeConn uses the gob wire format (see package gob) on the connection. To use an alternate codec, use ServeCodec. See NewClient's comment for information about concurrent access.",
        "name": "rpc.ServeConn",
        "params": [],
        "path": "go/net/rpc/index#ServeConn",
        "syntax": "func ServeConn(conn io.ReadWriteCloser)",
        "type": "net/rpc"
    },
    "rpc.ServeRequest": {
        "descr": "ServeRequest is like ServeCodec but synchronously serves a single request. It does not close the codec upon completion.",
        "name": "rpc.ServeRequest",
        "params": [],
        "path": "go/net/rpc/index#ServeRequest",
        "syntax": "func ServeRequest(codec ServerCodec) error",
        "type": "net/rpc"
    },
    "rpc.Server": {
        "descr": "Server represents an RPC Server.",
        "name": "rpc.Server",
        "params": [],
        "path": "go/net/rpc/index#Server",
        "syntax": "type Server struct { // contains filtered or unexported fields }",
        "type": "net/rpc"
    },
    "rpc.Server.Accept": {
        "descr": "Accept accepts connections on the listener and serves requests for each incoming connection. Accept blocks until the listener returns a non-nil error. The caller typically invokes Accept in a go statement.",
        "name": "rpc.Server.Accept",
        "params": [],
        "path": "go/net/rpc/index#Server.Accept",
        "syntax": "func (server *Server) Accept(lis net.Listener)",
        "type": "net/rpc"
    },
    "rpc.Server.HandleHTTP": {
        "descr": "HandleHTTP registers an HTTP handler for RPC messages on rpcPath, and a debugging handler on debugPath. It is still necessary to invoke http.Serve(), typically in a go statement.",
        "name": "rpc.Server.HandleHTTP",
        "params": [],
        "path": "go/net/rpc/index#Server.HandleHTTP",
        "syntax": "func (server *Server) HandleHTTP(rpcPath, debugPath string)",
        "type": "net/rpc"
    },
    "rpc.Server.Register": {
        "descr": "Register publishes in the server the set of methods of the receiver value that satisfy the following conditions:",
        "name": "rpc.Server.Register",
        "params": [],
        "path": "go/net/rpc/index#Server.Register",
        "syntax": "func (server *Server) Register(rcvr interface{}) error",
        "type": "net/rpc"
    },
    "rpc.Server.RegisterName": {
        "descr": "RegisterName is like Register but uses the provided name for the type instead of the receiver's concrete type.",
        "name": "rpc.Server.RegisterName",
        "params": [],
        "path": "go/net/rpc/index#Server.RegisterName",
        "syntax": "func (server *Server) RegisterName(name string, rcvr interface{}) error",
        "type": "net/rpc"
    },
    "rpc.Server.ServeCodec": {
        "descr": "ServeCodec is like ServeConn but uses the specified codec to decode requests and encode responses.",
        "name": "rpc.Server.ServeCodec",
        "params": [],
        "path": "go/net/rpc/index#Server.ServeCodec",
        "syntax": "func (server *Server) ServeCodec(codec ServerCodec)",
        "type": "net/rpc"
    },
    "rpc.Server.ServeConn": {
        "descr": "ServeConn runs the server on a single connection. ServeConn blocks, serving the connection until the client hangs up. The caller typically invokes ServeConn in a go statement. ServeConn uses the gob wire format (see package gob) on the connection. To use an alternate codec, use ServeCodec. See NewClient's comment for information about concurrent access.",
        "name": "rpc.Server.ServeConn",
        "params": [],
        "path": "go/net/rpc/index#Server.ServeConn",
        "syntax": "func (server *Server) ServeConn(conn io.ReadWriteCloser)",
        "type": "net/rpc"
    },
    "rpc.Server.ServeHTTP": {
        "descr": "ServeHTTP implements an http.Handler that answers RPC requests.",
        "name": "rpc.Server.ServeHTTP",
        "params": [],
        "path": "go/net/rpc/index#Server.ServeHTTP",
        "syntax": "func (server *Server) ServeHTTP(w http.ResponseWriter, req *http.Request)",
        "type": "net/rpc"
    },
    "rpc.Server.ServeRequest": {
        "descr": "ServeRequest is like ServeCodec but synchronously serves a single request. It does not close the codec upon completion.",
        "name": "rpc.Server.ServeRequest",
        "params": [],
        "path": "go/net/rpc/index#Server.ServeRequest",
        "syntax": "func (server *Server) ServeRequest(codec ServerCodec) error",
        "type": "net/rpc"
    },
    "rpc.ServerCodec": {
        "descr": "A ServerCodec implements reading of RPC requests and writing of RPC responses for the server side of an RPC session. The server calls ReadRequestHeader and ReadRequestBody in pairs to read requests from the connection, and it calls WriteResponse to write a response back. The server calls Close when finished with the connection. ReadRequestBody may be called with a nil argument to force the body of the request to be read and discarded. See NewClient's comment for information about concurrent access.",
        "name": "rpc.ServerCodec",
        "params": [],
        "path": "go/net/rpc/index#ServerCodec",
        "syntax": "type ServerCodec interface { ReadRequestHeader(*Request) error ReadRequestBody(interface{}) error WriteResponse(*Response, interface{}) error // Close can be called multiple times and must be idempotent. Close() error }",
        "type": "net/rpc"
    },
    "rpc.ServerError": {
        "descr": "ServerError represents an error that has been returned from the remote side of the RPC connection.",
        "name": "rpc.ServerError",
        "params": [],
        "path": "go/net/rpc/index#ServerError",
        "syntax": "type ServerError string",
        "type": "net/rpc"
    },
    "rpc.ServerError.Error": {
        "descr": "",
        "name": "rpc.ServerError.Error",
        "params": [],
        "path": "go/net/rpc/index#ServerError.Error",
        "syntax": "func (e ServerError) Error() string",
        "type": "net/rpc"
    },
    "rsa.CRTValue": {
        "descr": "CRTValue contains the precomputed Chinese remainder theorem values.",
        "name": "rsa.CRTValue",
        "params": [],
        "path": "go/crypto/rsa/index#CRTValue",
        "syntax": "type CRTValue struct { Exp *big.Int // D mod (prime-1). Coeff *big.Int // RCoeff  1 mod Prime. R *big.Int // product of primes prior to this (inc p and q). }",
        "type": "crypto"
    },
    "rsa.DecryptOAEP": {
        "descr": "OAEP is parameterised by a hash function that is used as a random oracle. Encryption and decryption of a given message must use the same hash function and sha256.New() is a reasonable choice.",
        "name": "rsa.DecryptOAEP",
        "params": [],
        "path": "go/crypto/rsa/index#DecryptOAEP",
        "syntax": "func DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext []byte, label []byte) ([]byte, error)",
        "type": "crypto"
    },
    "rsa.DecryptPKCS1v15": {
        "descr": "DecryptPKCS1v15 decrypts a plaintext using RSA and the padding scheme from PKCS#1 v1.5. If rand != nil, it uses RSA blinding to avoid timing side-channel attacks.",
        "name": "rsa.DecryptPKCS1v15",
        "params": [],
        "path": "go/crypto/rsa/index#DecryptPKCS1v15",
        "syntax": "func DecryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) ([]byte, error)",
        "type": "crypto"
    },
    "rsa.DecryptPKCS1v15SessionKey": {
        "descr": "DecryptPKCS1v15SessionKey decrypts a session key using RSA and the padding scheme from PKCS#1 v1.5. If rand != nil, it uses RSA blinding to avoid timing side-channel attacks. It returns an error if the ciphertext is the wrong length or if the ciphertext is greater than the public modulus. Otherwise, no error is returned. If the padding is valid, the resulting plaintext message is copied into key. Otherwise, key is unchanged. These alternatives occur in constant time. It is intended that the user of this function generate a random session key beforehand and continue the protocol with the resulting value. This will remove any possibility that an attacker can learn any information about the plaintext. See Chosen Ciphertext Attacks Against Protocols Based on the RSA Encryption Standard PKCS #1, Daniel Bleichenbacher, Advances in Cryptology (Crypto '98).",
        "name": "rsa.DecryptPKCS1v15SessionKey",
        "params": [],
        "path": "go/crypto/rsa/index#DecryptPKCS1v15SessionKey",
        "syntax": "func DecryptPKCS1v15SessionKey(rand io.Reader, priv *PrivateKey, ciphertext []byte, key []byte) error",
        "type": "crypto"
    },
    "rsa.EncryptOAEP": {
        "descr": "EncryptOAEP encrypts the given message with RSA-OAEP.",
        "name": "rsa.EncryptOAEP",
        "params": [],
        "path": "go/crypto/rsa/index#EncryptOAEP",
        "syntax": "func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) ([]byte, error)",
        "type": "crypto"
    },
    "rsa.EncryptPKCS1v15": {
        "descr": "EncryptPKCS1v15 encrypts the given message with RSA and the padding scheme from PKCS#1 v1.5. The message must be no longer than the length of the public modulus minus 11 bytes.",
        "name": "rsa.EncryptPKCS1v15",
        "params": [],
        "path": "go/crypto/rsa/index#EncryptPKCS1v15",
        "syntax": "func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) ([]byte, error)",
        "type": "crypto"
    },
    "rsa.GenerateKey": {
        "descr": "GenerateKey generates an RSA keypair of the given bit size using the random source random (for example, crypto/rand.Reader).",
        "name": "rsa.GenerateKey",
        "params": [],
        "path": "go/crypto/rsa/index#GenerateKey",
        "syntax": "func GenerateKey(random io.Reader, bits int) (*PrivateKey, error)",
        "type": "crypto"
    },
    "rsa.GenerateMultiPrimeKey": {
        "descr": "GenerateMultiPrimeKey generates a multi-prime RSA keypair of the given bit size and the given random source, as suggested in [1]. Although the public keys are compatible (actually, indistinguishable) from the 2-prime case, the private keys are not. Thus it may not be possible to export multi-prime private keys in certain formats or to subsequently import them into other code.",
        "name": "rsa.GenerateMultiPrimeKey",
        "params": [],
        "path": "go/crypto/rsa/index#GenerateMultiPrimeKey",
        "syntax": "func GenerateMultiPrimeKey(random io.Reader, nprimes int, bits int) (*PrivateKey, error)",
        "type": "crypto"
    },
    "rsa.OAEPOptions": {
        "descr": "OAEPOptions is an interface for passing options to OAEP decryption using the crypto.Decrypter interface.",
        "name": "rsa.OAEPOptions",
        "params": [],
        "path": "go/crypto/rsa/index#OAEPOptions",
        "syntax": "type OAEPOptions struct { // Hash is the hash function that will be used when generating the mask. Hash crypto.Hash // Label is an arbitrary byte string that must be equal to the value // used when encrypting. Label []byte }",
        "type": "crypto"
    },
    "rsa.PKCS1v15DecryptOptions": {
        "descr": "PKCS1v15DecrypterOpts is for passing options to PKCS#1 v1.5 decryption using the crypto.Decrypter interface.",
        "name": "rsa.PKCS1v15DecryptOptions",
        "params": [],
        "path": "go/crypto/rsa/index#PKCS1v15DecryptOptions",
        "syntax": "type PKCS1v15DecryptOptions struct { // SessionKeyLen is the length of the session key that is being // decrypted. If not zero, then a padding error during decryption will // cause a random plaintext of this length to be returned rather than // an error. These alternatives happen in constant time. SessionKeyLen int }",
        "type": "crypto"
    },
    "rsa.PSSOptions": {
        "descr": "PSSOptions contains options for creating and verifying PSS signatures.",
        "name": "rsa.PSSOptions",
        "params": [],
        "path": "go/crypto/rsa/index#PSSOptions",
        "syntax": "type PSSOptions struct { // SaltLength controls the length of the salt used in the PSS // signature. It can either be a number of bytes, or one of the special // PSSSaltLength constants. SaltLength int // Hash, if not zero, overrides the hash function passed to SignPSS. // This is the only way to specify the hash function when using the // crypto.Signer interface. Hash crypto.Hash // Go 1.4 }",
        "type": "crypto"
    },
    "rsa.PSSOptions.HashFunc": {
        "descr": "HashFunc returns pssOpts.Hash so that PSSOptions implements crypto.SignerOpts.",
        "name": "rsa.PSSOptions.HashFunc",
        "params": [],
        "path": "go/crypto/rsa/index#PSSOptions.HashFunc",
        "syntax": "func (pssOpts *PSSOptions) HashFunc() crypto.Hash",
        "type": "crypto"
    },
    "rsa.PrecomputedValues": {
        "descr": "",
        "name": "rsa.PrecomputedValues",
        "params": [],
        "path": "go/crypto/rsa/index#PrecomputedValues",
        "syntax": "type PrecomputedValues struct { Dp, Dq *big.Int // D mod (P-1) (or mod Q-1) Qinv *big.Int // Q^-1 mod P // CRTValues is used for the 3rd and subsequent primes. Due to a // historical accident, the CRT for the first two primes is handled // differently in PKCS#1 and interoperability is sufficiently // important that we mirror this. CRTValues []CRTValue }",
        "type": "crypto"
    },
    "rsa.PrivateKey": {
        "descr": "A PrivateKey represents an RSA key",
        "name": "rsa.PrivateKey",
        "params": [],
        "path": "go/crypto/rsa/index#PrivateKey",
        "syntax": "type PrivateKey struct { PublicKey // public part. D *big.Int // private exponent Primes []*big.Int // prime factors of N, has >= 2 elements. // Precomputed contains precomputed values that speed up private // operations, if available. Precomputed PrecomputedValues }",
        "type": "crypto"
    },
    "rsa.PrivateKey.Decrypt": {
        "descr": "Decrypt decrypts ciphertext with priv. If opts is nil or of type *PKCS1v15DecryptOptions then PKCS#1 v1.5 decryption is performed. Otherwise opts must have type *OAEPOptions and OAEP decryption is done.",
        "name": "rsa.PrivateKey.Decrypt",
        "params": [],
        "path": "go/crypto/rsa/index#PrivateKey.Decrypt",
        "syntax": "func (priv *PrivateKey) Decrypt(rand io.Reader, ciphertext []byte, opts crypto.DecrypterOpts) (plaintext []byte, err error)",
        "type": "crypto"
    },
    "rsa.PrivateKey.Precompute": {
        "descr": "Precompute performs some calculations that speed up private key operations in the future.",
        "name": "rsa.PrivateKey.Precompute",
        "params": [],
        "path": "go/crypto/rsa/index#PrivateKey.Precompute",
        "syntax": "func (priv *PrivateKey) Precompute()",
        "type": "crypto"
    },
    "rsa.PrivateKey.Public": {
        "descr": "Public returns the public key corresponding to priv.",
        "name": "rsa.PrivateKey.Public",
        "params": [],
        "path": "go/crypto/rsa/index#PrivateKey.Public",
        "syntax": "func (priv *PrivateKey) Public() crypto.PublicKey",
        "type": "crypto"
    },
    "rsa.PrivateKey.Sign": {
        "descr": "Sign signs digest with priv, reading randomness from rand. If opts is a *PSSOptions then the PSS algorithm will be used, otherwise PKCS#1 v1.5 will be used.",
        "name": "rsa.PrivateKey.Sign",
        "params": [],
        "path": "go/crypto/rsa/index#PrivateKey.Sign",
        "syntax": "func (priv *PrivateKey) Sign(rand io.Reader, digest []byte, opts crypto.SignerOpts) ([]byte, error)",
        "type": "crypto"
    },
    "rsa.PrivateKey.Validate": {
        "descr": "Validate performs basic sanity checks on the key. It returns nil if the key is valid, or else an error describing a problem.",
        "name": "rsa.PrivateKey.Validate",
        "params": [],
        "path": "go/crypto/rsa/index#PrivateKey.Validate",
        "syntax": "func (priv *PrivateKey) Validate() error",
        "type": "crypto"
    },
    "rsa.PublicKey": {
        "descr": "A PublicKey represents the public part of an RSA key.",
        "name": "rsa.PublicKey",
        "params": [],
        "path": "go/crypto/rsa/index#PublicKey",
        "syntax": "type PublicKey struct { N *big.Int // modulus E int // public exponent }",
        "type": "crypto"
    },
    "rsa.PublicKey.Size": {
        "descr": "Size returns the modulus size in bytes. Raw signatures and ciphertexts for or by this public key will have the same size.",
        "name": "rsa.PublicKey.Size",
        "params": [],
        "path": "go/crypto/rsa/index#PublicKey.Size",
        "syntax": "func (pub *PublicKey) Size() int",
        "type": "crypto"
    },
    "rsa.SignPKCS1v15": {
        "descr": "SignPKCS1v15 calculates the signature of hashed using RSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5. Note that hashed must be the result of hashing the input message using the given hash function. If hash is zero, hashed is signed directly. This isn't advisable except for interoperability.",
        "name": "rsa.SignPKCS1v15",
        "params": [],
        "path": "go/crypto/rsa/index#SignPKCS1v15",
        "syntax": "func SignPKCS1v15(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte) ([]byte, error)",
        "type": "crypto"
    },
    "rsa.SignPSS": {
        "descr": "SignPSS calculates the signature of hashed using RSASSA-PSS [1]. Note that hashed must be the result of hashing the input message using the given hash function. The opts argument may be nil, in which case sensible defaults are used.",
        "name": "rsa.SignPSS",
        "params": [],
        "path": "go/crypto/rsa/index#SignPSS",
        "syntax": "func SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte, opts *PSSOptions) ([]byte, error)",
        "type": "crypto"
    },
    "rsa.VerifyPKCS1v15": {
        "descr": "VerifyPKCS1v15 verifies an RSA PKCS#1 v1.5 signature. hashed is the result of hashing the input message using the given hash function and sig is the signature. A valid signature is indicated by returning a nil error. If hash is zero then hashed is used directly. This isn't advisable except for interoperability.",
        "name": "rsa.VerifyPKCS1v15",
        "params": [],
        "path": "go/crypto/rsa/index#VerifyPKCS1v15",
        "syntax": "func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte) error",
        "type": "crypto"
    },
    "rsa.VerifyPSS": {
        "descr": "VerifyPSS verifies a PSS signature. hashed is the result of hashing the input message using the given hash function and sig is the signature. A valid signature is indicated by returning a nil error. The opts argument may be nil, in which case sensible defaults are used.",
        "name": "rsa.VerifyPSS",
        "params": [],
        "path": "go/crypto/rsa/index#VerifyPSS",
        "syntax": "func VerifyPSS(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte, opts *PSSOptions) error",
        "type": "crypto"
    },
    "rune": {
        "descr": "rune is an alias for int32 and is equivalent to int32 in all ways. It is used, by convention, to distinguish character values from integer values.",
        "name": "builtin.rune",
        "params": [],
        "path": "go/builtin/index#rune",
        "syntax": "type rune = int32",
        "type": "builtin"
    },
    "runtime": {
        "descr": "MemProfileRate controls the fraction of memory allocations that are recorded and reported in the memory profile. The profiler aims to sample an average of one allocation per MemProfileRate bytes allocated.",
        "name": "runtime",
        "params": [],
        "path": "go/runtime/index#pkg-variables",
        "syntax": "var MemProfileRate int = 512 * 1024",
        "type": "runtime"
    },
    "runtime.BlockProfile": {
        "descr": "BlockProfile returns n, the number of records in the current blocking profile. If len(p) >= n, BlockProfile copies the profile into p and returns n, true. If len(p) < n, BlockProfile does not change p and returns n, false.",
        "name": "runtime.BlockProfile",
        "params": [],
        "path": "go/runtime/index#BlockProfile",
        "syntax": "func BlockProfile(p []BlockProfileRecord) (n int, ok bool)",
        "type": "runtime"
    },
    "runtime.BlockProfileRecord": {
        "descr": "BlockProfileRecord describes blocking events originated at a particular call sequence (stack trace).",
        "name": "runtime.BlockProfileRecord",
        "params": [],
        "path": "go/runtime/index#BlockProfileRecord",
        "syntax": "type BlockProfileRecord struct { Count int64 Cycles int64 StackRecord }",
        "type": "runtime"
    },
    "runtime.Breakpoint": {
        "descr": "Breakpoint executes a breakpoint trap.",
        "name": "runtime.Breakpoint",
        "params": [],
        "path": "go/runtime/index#Breakpoint",
        "syntax": "func Breakpoint()",
        "type": "runtime"
    },
    "runtime.CPUProfile": {
        "descr": "CPUProfile panics. It formerly provided raw access to chunks of a pprof-format profile generated by the runtime. The details of generating that format have changed, so this functionality has been removed.",
        "name": "runtime.CPUProfile",
        "params": [],
        "path": "go/runtime/index#CPUProfile",
        "syntax": "func CPUProfile() []byte",
        "type": "runtime"
    },
    "runtime.Caller": {
        "descr": "Caller reports file and line number information about function invocations on the calling goroutine's stack. The argument skip is the number of stack frames to ascend, with 0 identifying the caller of Caller. (For historical reasons the meaning of skip differs between Caller and Callers.) The return values report the program counter, file name, and line number within the file of the corresponding call. The boolean ok is false if it was not possible to recover the information.",
        "name": "runtime.Caller",
        "params": [],
        "path": "go/runtime/index#Caller",
        "syntax": "func Caller(skip int) (pc uintptr, file string, line int, ok bool)",
        "type": "runtime"
    },
    "runtime.Callers": {
        "descr": "Callers fills the slice pc with the return program counters of function invocations on the calling goroutine's stack. The argument skip is the number of stack frames to skip before recording in pc, with 0 identifying the frame for Callers itself and 1 identifying the caller of Callers. It returns the number of entries written to pc.",
        "name": "runtime.Callers",
        "params": [],
        "path": "go/runtime/index#Callers",
        "syntax": "func Callers(skip int, pc []uintptr) int",
        "type": "runtime"
    },
    "runtime.CallersFrames": {
        "descr": "CallersFrames takes a slice of PC values returned by Callers and prepares to return function/file/line information. Do not change the slice until you are done with the Frames.",
        "name": "runtime.CallersFrames",
        "params": [],
        "path": "go/runtime/index#CallersFrames",
        "syntax": "func CallersFrames(callers []uintptr) *Frames",
        "type": "runtime"
    },
    "runtime.Error": {
        "descr": "The Error interface identifies a run time error.",
        "name": "runtime.Error",
        "params": [],
        "path": "go/runtime/index#Error",
        "syntax": "type Error interface { error // RuntimeError is a no-op function but // serves to distinguish types that are run time // errors from ordinary errors: a type is a // run time error if it has a RuntimeError method. RuntimeError() }",
        "type": "runtime"
    },
    "runtime.Frame": {
        "descr": "Frame is the information returned by Frames for each call frame.",
        "name": "runtime.Frame",
        "params": [],
        "path": "go/runtime/index#Frame",
        "syntax": "type Frame struct { // PC is the program counter for the location in this frame. // For a frame that calls another frame, this will be the // program counter of a call instruction. Because of inlining, // multiple frames may have the same PC value, but different // symbolic information. PC uintptr // Func is the Func value of this call frame. This may be nil // for non-Go code or fully inlined functions. Func *Func // Function is the package path-qualified function name of // this call frame. If non-empty, this string uniquely // identifies a single function in the program. // This may be the empty string if not known. // If Func is not nil then Function == Func.Name(). Function string // File and Line are the file name and line number of the // location in this frame. For non-leaf frames, this will be // the location of a call. These may be the empty string and // zero, respectively, if not known. File string Line int // Entry point program counter for the function; may be zero // if not known. If Func is not nil then Entry == // Func.Entry(). Entry uintptr }",
        "type": "runtime"
    },
    "runtime.Frames": {
        "descr": "Frames may be used to get function/file/line information for a slice of PC values returned by Callers.",
        "name": "runtime.Frames",
        "params": [],
        "path": "go/runtime/index#Frames",
        "syntax": "type Frames struct { // contains filtered or unexported fields }",
        "type": "runtime"
    },
    "runtime.Frames.Next": {
        "descr": "Next returns frame information for the next caller. If more is false, there are no more callers (the Frame value is valid).",
        "name": "runtime.Frames.Next",
        "params": [],
        "path": "go/runtime/index#Frames.Next",
        "syntax": "func (ci *Frames) Next() (frame Frame, more bool)",
        "type": "runtime"
    },
    "runtime.Func": {
        "descr": "A Func represents a Go function in the running binary.",
        "name": "runtime.Func",
        "params": [],
        "path": "go/runtime/index#Func",
        "syntax": "type Func struct { // contains filtered or unexported fields }",
        "type": "runtime"
    },
    "runtime.Func.Entry": {
        "descr": "Entry returns the entry address of the function.",
        "name": "runtime.Func.Entry",
        "params": [],
        "path": "go/runtime/index#Func.Entry",
        "syntax": "func (f *Func) Entry() uintptr",
        "type": "runtime"
    },
    "runtime.Func.FileLine": {
        "descr": "FileLine returns the file name and line number of the source code corresponding to the program counter pc. The result will not be accurate if pc is not a program counter within f.",
        "name": "runtime.Func.FileLine",
        "params": [],
        "path": "go/runtime/index#Func.FileLine",
        "syntax": "func (f *Func) FileLine(pc uintptr) (file string, line int)",
        "type": "runtime"
    },
    "runtime.Func.Name": {
        "descr": "Name returns the name of the function.",
        "name": "runtime.Func.Name",
        "params": [],
        "path": "go/runtime/index#Func.Name",
        "syntax": "func (f *Func) Name() string",
        "type": "runtime"
    },
    "runtime.FuncForPC": {
        "descr": "FuncForPC returns a *Func describing the function that contains the given program counter address, or else nil.",
        "name": "runtime.FuncForPC",
        "params": [],
        "path": "go/runtime/index#FuncForPC",
        "syntax": "func FuncForPC(pc uintptr) *Func",
        "type": "runtime"
    },
    "runtime.GC": {
        "descr": "GC runs a garbage collection and blocks the caller until the garbage collection is complete. It may also block the entire program.",
        "name": "runtime.GC",
        "params": [],
        "path": "go/runtime/index#GC",
        "syntax": "func GC()",
        "type": "runtime"
    },
    "runtime.GOMAXPROCS": {
        "descr": "GOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously and returns the previous setting. If n < 1, it does not change the current setting. The number of logical CPUs on the local machine can be queried with NumCPU. This call will go away when the scheduler improves.",
        "name": "runtime.GOMAXPROCS",
        "params": [],
        "path": "go/runtime/index#GOMAXPROCS",
        "syntax": "func GOMAXPROCS(n int) int",
        "type": "runtime"
    },
    "runtime.GOROOT": {
        "descr": "GOROOT returns the root of the Go tree. It uses the GOROOT environment variable, if set at process start, or else the root used during the Go build.",
        "name": "runtime.GOROOT",
        "params": [],
        "path": "go/runtime/index#GOROOT",
        "syntax": "func GOROOT() string",
        "type": "runtime"
    },
    "runtime.Goexit": {
        "descr": "Goexit terminates the goroutine that calls it. No other goroutine is affected. Goexit runs all deferred calls before terminating the goroutine. Because Goexit is not a panic, any recover calls in those deferred functions will return nil.",
        "name": "runtime.Goexit",
        "params": [],
        "path": "go/runtime/index#Goexit",
        "syntax": "func Goexit()",
        "type": "runtime"
    },
    "runtime.GoroutineProfile": {
        "descr": "GoroutineProfile returns n, the number of records in the active goroutine stack profile. If len(p) >= n, GoroutineProfile copies the profile into p and returns n, true. If len(p) < n, GoroutineProfile does not change p and returns n, false.",
        "name": "runtime.GoroutineProfile",
        "params": [],
        "path": "go/runtime/index#GoroutineProfile",
        "syntax": "func GoroutineProfile(p []StackRecord) (n int, ok bool)",
        "type": "runtime"
    },
    "runtime.Gosched": {
        "descr": "Gosched yields the processor, allowing other goroutines to run. It does not suspend the current goroutine, so execution resumes automatically.",
        "name": "runtime.Gosched",
        "params": [],
        "path": "go/runtime/index#Gosched",
        "syntax": "func Gosched()",
        "type": "runtime"
    },
    "runtime.KeepAlive": {
        "descr": "KeepAlive marks its argument as currently reachable. This ensures that the object is not freed, and its finalizer is not run, before the point in the program where KeepAlive is called.",
        "name": "runtime.KeepAlive",
        "params": [],
        "path": "go/runtime/index#KeepAlive",
        "syntax": "func KeepAlive(x interface{})",
        "type": "runtime"
    },
    "runtime.LockOSThread": {
        "descr": "LockOSThread wires the calling goroutine to its current operating system thread. The calling goroutine will always execute in that thread, and no other goroutine will execute in it, until the calling goroutine has made as many calls to UnlockOSThread as to LockOSThread. If the calling goroutine exits without unlocking the thread, the thread will be terminated.",
        "name": "runtime.LockOSThread",
        "params": [],
        "path": "go/runtime/index#LockOSThread",
        "syntax": "func LockOSThread()",
        "type": "runtime"
    },
    "runtime.MemProfile": {
        "descr": "MemProfile returns a profile of memory allocated and freed per allocation site.",
        "name": "runtime.MemProfile",
        "params": [],
        "path": "go/runtime/index#MemProfile",
        "syntax": "func MemProfile(p []MemProfileRecord, inuseZero bool) (n int, ok bool)",
        "type": "runtime"
    },
    "runtime.MemProfileRecord": {
        "descr": "A MemProfileRecord describes the live objects allocated by a particular call sequence (stack trace).",
        "name": "runtime.MemProfileRecord",
        "params": [],
        "path": "go/runtime/index#MemProfileRecord",
        "syntax": "type MemProfileRecord struct { AllocBytes, FreeBytes int64 // number of bytes allocated, freed AllocObjects, FreeObjects int64 // number of objects allocated, freed Stack0 [32]uintptr // stack trace for this record; ends at first 0 entry }",
        "type": "runtime"
    },
    "runtime.MemProfileRecord.InUseBytes": {
        "descr": "InUseBytes returns the number of bytes in use (AllocBytes - FreeBytes).",
        "name": "runtime.MemProfileRecord.InUseBytes",
        "params": [],
        "path": "go/runtime/index#MemProfileRecord.InUseBytes",
        "syntax": "func (r *MemProfileRecord) InUseBytes() int64",
        "type": "runtime"
    },
    "runtime.MemProfileRecord.InUseObjects": {
        "descr": "InUseObjects returns the number of objects in use (AllocObjects - FreeObjects).",
        "name": "runtime.MemProfileRecord.InUseObjects",
        "params": [],
        "path": "go/runtime/index#MemProfileRecord.InUseObjects",
        "syntax": "func (r *MemProfileRecord) InUseObjects() int64",
        "type": "runtime"
    },
    "runtime.MemProfileRecord.Stack": {
        "descr": "Stack returns the stack trace associated with the record, a prefix of r.Stack0.",
        "name": "runtime.MemProfileRecord.Stack",
        "params": [],
        "path": "go/runtime/index#MemProfileRecord.Stack",
        "syntax": "func (r *MemProfileRecord) Stack() []uintptr",
        "type": "runtime"
    },
    "runtime.MemStats": {
        "descr": "A MemStats records statistics about the memory allocator.",
        "name": "runtime.MemStats",
        "params": [],
        "path": "go/runtime/index#MemStats",
        "syntax": "type MemStats struct { // Alloc is bytes of allocated heap objects. // // This is the same as HeapAlloc (see below). Alloc uint64 // TotalAlloc is cumulative bytes allocated for heap objects. // // TotalAlloc increases as heap objects are allocated, but // unlike Alloc and HeapAlloc, it does not decrease when // objects are freed. TotalAlloc uint64 // Sys is the total bytes of memory obtained from the OS. // // Sys is the sum of the XSys fields below. Sys measures the // virtual address space reserved by the Go runtime for the // heap, stacks, and other internal data structures. It's // likely that not all of the virtual address space is backed // by physical memory at any given moment, though in general // it all was at some point. Sys uint64 // Lookups is the number of pointer lookups performed by the // runtime. // // This is primarily useful for debugging runtime internals. Lookups uint64 // Mallocs is the cumulative count of heap objects allocated. // The number of live objects is Mallocs - Frees. Mallocs uint64 // Frees is the cumulative count of heap objects freed. Frees uint64 // HeapAlloc is bytes of allocated heap objects. // // \"Allocated\" heap objects include all reachable objects, as // well as unreachable objects that the garbage collector has // not yet freed. Specifically, HeapAlloc increases as heap // objects are allocated and decreases as the heap is swept // and unreachable objects are freed. Sweeping occurs // incrementally between GC cycles, so these two processes // occur simultaneously, and as a result HeapAlloc tends to // change smoothly (in contrast with the sawtooth that is // typical of stop-the-world garbage collectors). HeapAlloc uint64 // HeapSys is bytes of heap memory obtained from the OS. // // HeapSys measures the amount of virtual address space // reserved for the heap. This includes virtual address space // that has been reserved but not yet used, which consumes no // physical memory, but tends to be small, as well as virtual // address space for which the physical memory has been // returned to the OS after it became unused (see HeapReleased // for a measure of the latter). // // HeapSys estimates the largest size the heap has had. HeapSys uint64 // HeapIdle is bytes in idle (unused) spans. // // Idle spans have no objects in them. These spans could be // (and may already have been) returned to the OS, or they can // be reused for heap allocations, or they can be reused as // stack memory. // // HeapIdle minus HeapReleased estimates the amount of memory // that could be returned to the OS, but is being retained by // the runtime so it can grow the heap without requesting more // memory from the OS. If this difference is significantly // larger than the heap size, it indicates there was a recent // transient spike in live heap size. HeapIdle uint64 // HeapInuse is bytes in in-use spans. // // In-use spans have at least one object in them. These spans // can only be used for other objects of roughly the same // size. // // HeapInuse minus HeapAlloc estimates the amount of memory // that has been dedicated to particular size classes, but is // not currently being used. This is an upper bound on // fragmentation, but in general this memory can be reused // efficiently. HeapInuse uint64 // HeapReleased is bytes of physical memory returned to the OS. // // This counts heap memory from idle spans that was returned // to the OS and has not yet been reacquired for the heap. HeapReleased uint64 // HeapObjects is the number of allocated heap objects. // // Like HeapAlloc, this increases as objects are allocated and // decreases as the heap is swept and unreachable objects are // freed. HeapObjects uint64 // StackInuse is bytes in stack spans. // // In-use stack spans have at least one stack in them. These // spans can only be used for other stacks of the same size. // // There is no StackIdle because unused stack spans are // returned to the heap (and hence counted toward HeapIdle). StackInuse uint64 // StackSys is bytes of stack memory obtained from the OS. // // StackSys is StackInuse, plus any memory obtained directly // from the OS for OS thread stacks (which should be minimal). StackSys uint64 // MSpanInuse is bytes of allocated mspan structures. MSpanInuse uint64 // MSpanSys is bytes of memory obtained from the OS for mspan // structures. MSpanSys uint64 // MCacheInuse is bytes of allocated mcache structures. MCacheInuse uint64 // MCacheSys is bytes of memory obtained from the OS for // mcache structures. MCacheSys uint64 // BuckHashSys is bytes of memory in profiling bucket hash tables. BuckHashSys uint64 // GCSys is bytes of memory in garbage collection metadata. GCSys uint64 // Go 1.2 // OtherSys is bytes of memory in miscellaneous off-heap // runtime allocations. OtherSys uint64 // Go 1.2 // NextGC is the target heap size of the next GC cycle. // // The garbage collector's goal is to keep HeapAlloc  NextGC. // At the end of each GC cycle, the target for the next cycle // is computed based on the amount of reachable data and the // value of GOGC. NextGC uint64 // LastGC is the time the last garbage collection finished, as // nanoseconds since 1970 (the UNIX epoch). LastGC uint64 // PauseTotalNs is the cumulative nanoseconds in GC // stop-the-world pauses since the program started. // // During a stop-the-world pause, all goroutines are paused // and only the garbage collector can run. PauseTotalNs uint64 // PauseNs is a circular buffer of recent GC stop-the-world // pause times in nanoseconds. // // The most recent pause is at PauseNs[(NumGC+255)%256]. In // general, PauseNs[N%256] records the time paused in the most // recent N%256th GC cycle. There may be multiple pauses per // GC cycle; this is the sum of all pauses during a cycle. PauseNs [256]uint64 // PauseEnd is a circular buffer of recent GC pause end times, // as nanoseconds since 1970 (the UNIX epoch). // // This buffer is filled the same way as PauseNs. There may be // multiple pauses per GC cycle; this records the end of the // last pause in a cycle. PauseEnd [256]uint64 // Go 1.4 // NumGC is the number of completed GC cycles. NumGC uint32 // NumForcedGC is the number of GC cycles that were forced by // the application calling the GC function. NumForcedGC uint32 // Go 1.8 // GCCPUFraction is the fraction of this program's available // CPU time used by the GC since the program started. // // GCCPUFraction is expressed as a number between 0 and 1, // where 0 means GC has consumed none of this program's CPU. A // program's available CPU time is defined as the integral of // GOMAXPROCS since the program started. That is, if // GOMAXPROCS is 2 and a program has been running for 10 // seconds, its \"available CPU\" is 20 seconds. GCCPUFraction // does not include CPU time used for write barrier activity. // // This is the same as the fraction of CPU reported by // GODEBUG=gctrace=1. GCCPUFraction float64 // Go 1.5 // EnableGC indicates that GC is enabled. It is always true, // even if GOGC=off. EnableGC bool // DebugGC is currently unused. DebugGC bool // BySize reports per-size class allocation statistics. // // BySize[N] gives statistics for allocations of size S where // BySize[N-1].Size < S  BySize[N].Size. // // This does not report allocations larger than BySize[60].Size. BySize [61]struct { // Size is the maximum byte size of an object in this // size class. Size uint32 // Mallocs is the cumulative count of heap objects // allocated in this size class. The cumulative bytes // of allocation is Size*Mallocs. The number of live // objects in this size class is Mallocs - Frees. Mallocs uint64 // Frees is the cumulative count of heap objects freed // in this size class. Frees uint64 } }",
        "type": "runtime"
    },
    "runtime.MutexProfile": {
        "descr": "MutexProfile returns n, the number of records in the current mutex profile. If len(p) >= n, MutexProfile copies the profile into p and returns n, true. Otherwise, MutexProfile does not change p, and returns n, false.",
        "name": "runtime.MutexProfile",
        "params": [],
        "path": "go/runtime/index#MutexProfile",
        "syntax": "func MutexProfile(p []BlockProfileRecord) (n int, ok bool)",
        "type": "runtime"
    },
    "runtime.NumCPU": {
        "descr": "NumCPU returns the number of logical CPUs usable by the current process.",
        "name": "runtime.NumCPU",
        "params": [],
        "path": "go/runtime/index#NumCPU",
        "syntax": "func NumCPU() int",
        "type": "runtime"
    },
    "runtime.NumCgoCall": {
        "descr": "NumCgoCall returns the number of cgo calls made by the current process.",
        "name": "runtime.NumCgoCall",
        "params": [],
        "path": "go/runtime/index#NumCgoCall",
        "syntax": "func NumCgoCall() int64",
        "type": "runtime"
    },
    "runtime.NumGoroutine": {
        "descr": "NumGoroutine returns the number of goroutines that currently exist.",
        "name": "runtime.NumGoroutine",
        "params": [],
        "path": "go/runtime/index#NumGoroutine",
        "syntax": "func NumGoroutine() int",
        "type": "runtime"
    },
    "runtime.ReadMemStats": {
        "descr": "ReadMemStats populates m with memory allocator statistics.",
        "name": "runtime.ReadMemStats",
        "params": [],
        "path": "go/runtime/index#ReadMemStats",
        "syntax": "func ReadMemStats(m *MemStats)",
        "type": "runtime"
    },
    "runtime.ReadTrace": {
        "descr": "ReadTrace returns the next chunk of binary tracing data, blocking until data is available. If tracing is turned off and all the data accumulated while it was on has been returned, ReadTrace returns nil. The caller must copy the returned data before calling ReadTrace again. ReadTrace must be called from one goroutine at a time.",
        "name": "runtime.ReadTrace",
        "params": [],
        "path": "go/runtime/index#ReadTrace",
        "syntax": "func ReadTrace() []byte",
        "type": "runtime"
    },
    "runtime.SetBlockProfileRate": {
        "descr": "SetBlockProfileRate controls the fraction of goroutine blocking events that are reported in the blocking profile. The profiler aims to sample an average of one blocking event per rate nanoseconds spent blocked.",
        "name": "runtime.SetBlockProfileRate",
        "params": [],
        "path": "go/runtime/index#SetBlockProfileRate",
        "syntax": "func SetBlockProfileRate(rate int)",
        "type": "runtime"
    },
    "runtime.SetCPUProfileRate": {
        "descr": "SetCPUProfileRate sets the CPU profiling rate to hz samples per second. If hz <= 0, SetCPUProfileRate turns off profiling. If the profiler is on, the rate cannot be changed without first turning it off.",
        "name": "runtime.SetCPUProfileRate",
        "params": [],
        "path": "go/runtime/index#SetCPUProfileRate",
        "syntax": "func SetCPUProfileRate(hz int)",
        "type": "runtime"
    },
    "runtime.SetCgoTraceback": {
        "descr": "SetCgoTraceback records three C functions to use to gather traceback information from C code and to convert that traceback information into symbolic information. These are used when printing stack traces for a program that uses cgo.",
        "name": "runtime.SetCgoTraceback",
        "params": [],
        "path": "go/runtime/index#SetCgoTraceback",
        "syntax": "func SetCgoTraceback(version int, traceback, context, symbolizer unsafe.Pointer)",
        "type": "runtime"
    },
    "runtime.SetFinalizer": {
        "descr": "SetFinalizer sets the finalizer associated with obj to the provided finalizer function. When the garbage collector finds an unreachable block with an associated finalizer, it clears the association and runs finalizer(obj) in a separate goroutine. This makes obj reachable again, but now without an associated finalizer. Assuming that SetFinalizer is not called again, the next time the garbage collector sees that obj is unreachable, it will free obj.",
        "name": "runtime.SetFinalizer",
        "params": [],
        "path": "go/runtime/index#SetFinalizer",
        "syntax": "func SetFinalizer(obj interface{}, finalizer interface{})",
        "type": "runtime"
    },
    "runtime.SetMutexProfileFraction": {
        "descr": "SetMutexProfileFraction controls the fraction of mutex contention events that are reported in the mutex profile. On average 1/rate events are reported. The previous rate is returned.",
        "name": "runtime.SetMutexProfileFraction",
        "params": [],
        "path": "go/runtime/index#SetMutexProfileFraction",
        "syntax": "func SetMutexProfileFraction(rate int) int",
        "type": "runtime"
    },
    "runtime.Stack": {
        "descr": "Stack formats a stack trace of the calling goroutine into buf and returns the number of bytes written to buf. If all is true, Stack formats stack traces of all other goroutines into buf after the trace for the current goroutine.",
        "name": "runtime.Stack",
        "params": [],
        "path": "go/runtime/index#Stack",
        "syntax": "func Stack(buf []byte, all bool) int",
        "type": "runtime"
    },
    "runtime.StackRecord": {
        "descr": "A StackRecord describes a single execution stack.",
        "name": "runtime.StackRecord",
        "params": [],
        "path": "go/runtime/index#StackRecord",
        "syntax": "type StackRecord struct { Stack0 [32]uintptr // stack trace for this record; ends at first 0 entry }",
        "type": "runtime"
    },
    "runtime.StackRecord.Stack": {
        "descr": "Stack returns the stack trace associated with the record, a prefix of r.Stack0.",
        "name": "runtime.StackRecord.Stack",
        "params": [],
        "path": "go/runtime/index#StackRecord.Stack",
        "syntax": "func (r *StackRecord) Stack() []uintptr",
        "type": "runtime"
    },
    "runtime.StartTrace": {
        "descr": "StartTrace enables tracing for the current process. While tracing, the data will be buffered and available via ReadTrace. StartTrace returns an error if tracing is already enabled. Most clients should use the runtime/trace package or the testing package's -test.trace flag instead of calling StartTrace directly.",
        "name": "runtime.StartTrace",
        "params": [],
        "path": "go/runtime/index#StartTrace",
        "syntax": "func StartTrace() error",
        "type": "runtime"
    },
    "runtime.StopTrace": {
        "descr": "StopTrace stops tracing, if it was previously enabled. StopTrace only returns after all the reads for the trace have completed.",
        "name": "runtime.StopTrace",
        "params": [],
        "path": "go/runtime/index#StopTrace",
        "syntax": "func StopTrace()",
        "type": "runtime"
    },
    "runtime.ThreadCreateProfile": {
        "descr": "ThreadCreateProfile returns n, the number of records in the thread creation profile. If len(p) >= n, ThreadCreateProfile copies the profile into p and returns n, true. If len(p) < n, ThreadCreateProfile does not change p and returns n, false.",
        "name": "runtime.ThreadCreateProfile",
        "params": [],
        "path": "go/runtime/index#ThreadCreateProfile",
        "syntax": "func ThreadCreateProfile(p []StackRecord) (n int, ok bool)",
        "type": "runtime"
    },
    "runtime.TypeAssertionError": {
        "descr": "A TypeAssertionError explains a failed type assertion.",
        "name": "runtime.TypeAssertionError",
        "params": [],
        "path": "go/runtime/index#TypeAssertionError",
        "syntax": "type TypeAssertionError struct { // contains filtered or unexported fields }",
        "type": "runtime"
    },
    "runtime.TypeAssertionError.Error": {
        "descr": "",
        "name": "runtime.TypeAssertionError.Error",
        "params": [],
        "path": "go/runtime/index#TypeAssertionError.Error",
        "syntax": "func (e *TypeAssertionError) Error() string",
        "type": "runtime"
    },
    "runtime.TypeAssertionError.RuntimeError": {
        "descr": "",
        "name": "runtime.TypeAssertionError.RuntimeError",
        "params": [],
        "path": "go/runtime/index#TypeAssertionError.RuntimeError",
        "syntax": "func (*TypeAssertionError) RuntimeError()",
        "type": "runtime"
    },
    "runtime.UnlockOSThread": {
        "descr": "UnlockOSThread undoes an earlier call to LockOSThread. If this drops the number of active LockOSThread calls on the calling goroutine to zero, it unwires the calling goroutine from its fixed operating system thread. If there are no active LockOSThread calls, this is a no-op.",
        "name": "runtime.UnlockOSThread",
        "params": [],
        "path": "go/runtime/index#UnlockOSThread",
        "syntax": "func UnlockOSThread()",
        "type": "runtime"
    },
    "runtime.Version": {
        "descr": "Version returns the Go tree's version string. It is either the commit hash and date at the time of the build or, when possible, a release tag like \"go1.3\".",
        "name": "runtime.Version",
        "params": [],
        "path": "go/runtime/index#Version",
        "syntax": "func Version() string",
        "type": "runtime"
    },
    "scanner.Error": {
        "descr": "In an ErrorList, an error is represented by an *Error. The position Pos, if valid, points to the beginning of the offending token, and the error condition is described by Msg.",
        "name": "scanner.Error",
        "params": [],
        "path": "go/go/scanner/index#Error",
        "syntax": "type Error struct { Pos token.Position Msg string }",
        "type": "go"
    },
    "scanner.Error.Error": {
        "descr": "Error implements the error interface.",
        "name": "scanner.Error.Error",
        "params": [],
        "path": "go/go/scanner/index#Error.Error",
        "syntax": "func (e Error) Error() string",
        "type": "go"
    },
    "scanner.ErrorHandler": {
        "descr": "An ErrorHandler may be provided to Scanner.Init. If a syntax error is encountered and a handler was installed, the handler is called with a position and an error message. The position points to the beginning of the offending token.",
        "name": "scanner.ErrorHandler",
        "params": [],
        "path": "go/go/scanner/index#ErrorHandler",
        "syntax": "type ErrorHandler func(pos token.Position, msg string)",
        "type": "go"
    },
    "scanner.ErrorList": {
        "descr": "ErrorList is a list of *Errors. The zero value for an ErrorList is an empty ErrorList ready to use.",
        "name": "scanner.ErrorList",
        "params": [],
        "path": "go/go/scanner/index#ErrorList",
        "syntax": "type ErrorList []*Error",
        "type": "go"
    },
    "scanner.ErrorList.Add": {
        "descr": "Add adds an Error with given position and error message to an ErrorList.",
        "name": "scanner.ErrorList.Add",
        "params": [],
        "path": "go/go/scanner/index#ErrorList.Add",
        "syntax": "func (p *ErrorList) Add(pos token.Position, msg string)",
        "type": "go"
    },
    "scanner.ErrorList.Err": {
        "descr": "Err returns an error equivalent to this error list. If the list is empty, Err returns nil.",
        "name": "scanner.ErrorList.Err",
        "params": [],
        "path": "go/go/scanner/index#ErrorList.Err",
        "syntax": "func (p ErrorList) Err() error",
        "type": "go"
    },
    "scanner.ErrorList.Error": {
        "descr": "An ErrorList implements the error interface.",
        "name": "scanner.ErrorList.Error",
        "params": [],
        "path": "go/go/scanner/index#ErrorList.Error",
        "syntax": "func (p ErrorList) Error() string",
        "type": "go"
    },
    "scanner.ErrorList.Len": {
        "descr": "ErrorList implements the sort Interface.",
        "name": "scanner.ErrorList.Len",
        "params": [],
        "path": "go/go/scanner/index#ErrorList.Len",
        "syntax": "func (p ErrorList) Len() int",
        "type": "go"
    },
    "scanner.ErrorList.Less": {
        "descr": "",
        "name": "scanner.ErrorList.Less",
        "params": [],
        "path": "go/go/scanner/index#ErrorList.Less",
        "syntax": "func (p ErrorList) Less(i, j int) bool",
        "type": "go"
    },
    "scanner.ErrorList.RemoveMultiples": {
        "descr": "RemoveMultiples sorts an ErrorList and removes all but the first error per line.",
        "name": "scanner.ErrorList.RemoveMultiples",
        "params": [],
        "path": "go/go/scanner/index#ErrorList.RemoveMultiples",
        "syntax": "func (p *ErrorList) RemoveMultiples()",
        "type": "go"
    },
    "scanner.ErrorList.Reset": {
        "descr": "Reset resets an ErrorList to no errors.",
        "name": "scanner.ErrorList.Reset",
        "params": [],
        "path": "go/go/scanner/index#ErrorList.Reset",
        "syntax": "func (p *ErrorList) Reset()",
        "type": "go"
    },
    "scanner.ErrorList.Sort": {
        "descr": "Sort sorts an ErrorList. *Error entries are sorted by position, other errors are sorted by error message, and before any *Error entry.",
        "name": "scanner.ErrorList.Sort",
        "params": [],
        "path": "go/go/scanner/index#ErrorList.Sort",
        "syntax": "func (p ErrorList) Sort()",
        "type": "go"
    },
    "scanner.ErrorList.Swap": {
        "descr": "",
        "name": "scanner.ErrorList.Swap",
        "params": [],
        "path": "go/go/scanner/index#ErrorList.Swap",
        "syntax": "func (p ErrorList) Swap(i, j int)",
        "type": "go"
    },
    "scanner.Mode": {
        "descr": "A mode value is a set of flags (or 0). They control scanner behavior.",
        "name": "scanner.Mode",
        "params": [],
        "path": "go/go/scanner/index#Mode",
        "syntax": "type Mode uint",
        "type": "go"
    },
    "scanner.Position": {
        "descr": "A source position is represented by a Position value. A position is valid if Line > 0.",
        "name": "scanner.Position",
        "params": [],
        "path": "go/text/scanner/index#Position",
        "syntax": "type Position struct { Filename string // filename, if any Offset int // byte offset, starting at 0 Line int // line number, starting at 1 Column int // column number, starting at 1 (character count per line) }",
        "type": "text"
    },
    "scanner.Position.IsValid": {
        "descr": "IsValid reports whether the position is valid.",
        "name": "scanner.Position.IsValid",
        "params": [],
        "path": "go/text/scanner/index#Position.IsValid",
        "syntax": "func (pos *Position) IsValid() bool",
        "type": "text"
    },
    "scanner.Position.String": {
        "descr": "",
        "name": "scanner.Position.String",
        "params": [],
        "path": "go/text/scanner/index#Position.String",
        "syntax": "func (pos Position) String() string",
        "type": "text"
    },
    "scanner.PrintError": {
        "descr": "PrintError is a utility function that prints a list of errors to w, one error per line, if the err parameter is an ErrorList. Otherwise it prints the err string.",
        "name": "scanner.PrintError",
        "params": [],
        "path": "go/go/scanner/index#PrintError",
        "syntax": "func PrintError(w io.Writer, err error)",
        "type": "go"
    },
    "scanner.Scanner": {
        "descr": "A Scanner implements reading of Unicode characters and tokens from an io.Reader.",
        "name": "scanner.Scanner",
        "params": [],
        "path": "go/text/scanner/index#Scanner",
        "syntax": "type Scanner struct { // Error is called for each error encountered. If no Error // function is set, the error is reported to os.Stderr. Error func(s *Scanner, msg string) // ErrorCount is incremented by one for each error encountered. ErrorCount int // The Mode field controls which tokens are recognized. For instance, // to recognize Ints, set the ScanInts bit in Mode. The field may be // changed at any time. Mode uint // The Whitespace field controls which characters are recognized // as white space. To recognize a character ch <= ' ' as white space, // set the ch'th bit in Whitespace (the Scanner's behavior is undefined // for values ch > ' '). The field may be changed at any time. Whitespace uint64 // IsIdentRune is a predicate controlling the characters accepted // as the ith rune in an identifier. The set of valid characters // must not intersect with the set of white space characters. // If no IsIdentRune function is set, regular Go identifiers are // accepted instead. The field may be changed at any time. IsIdentRune func(ch rune, i int) bool // Go 1.4 // Start position of most recently scanned token; set by Scan. // Calling Init or Next invalidates the position (Line == 0). // The Filename field is always left untouched by the Scanner. // If an error is reported (via Error) and Position is invalid, // the scanner is not inside a token. Call Pos to obtain an error // position in that case, or to obtain the position immediately // after the most recently scanned token. Position // contains filtered or unexported fields }",
        "type": "text"
    },
    "scanner.Scanner.Init": {
        "descr": "Init prepares the scanner s to tokenize the text src by setting the scanner at the beginning of src. The scanner uses the file set file for position information and it adds line information for each line. It is ok to re-use the same file when re-scanning the same file as line information which is already present is ignored. Init causes a panic if the file size does not match the src size.",
        "name": "scanner.Scanner.Init",
        "params": [],
        "path": "go/go/scanner/index#Scanner.Init",
        "syntax": "func (s *Scanner) Init(file *token.File, src []byte, err ErrorHandler, mode Mode)",
        "type": "go"
    },
    "scanner.Scanner.Next": {
        "descr": "Next reads and returns the next Unicode character. It returns EOF at the end of the source. It reports a read error by calling s.Error, if not nil; otherwise it prints an error message to os.Stderr. Next does not update the Scanner's Position field; use Pos() to get the current position.",
        "name": "scanner.Scanner.Next",
        "params": [],
        "path": "go/text/scanner/index#Scanner.Next",
        "syntax": "func (s *Scanner) Next() rune",
        "type": "text"
    },
    "scanner.Scanner.Peek": {
        "descr": "Peek returns the next Unicode character in the source without advancing the scanner. It returns EOF if the scanner's position is at the last character of the source.",
        "name": "scanner.Scanner.Peek",
        "params": [],
        "path": "go/text/scanner/index#Scanner.Peek",
        "syntax": "func (s *Scanner) Peek() rune",
        "type": "text"
    },
    "scanner.Scanner.Pos": {
        "descr": "Pos returns the position of the character immediately after the character or token returned by the last call to Next or Scan. Use the Scanner's Position field for the start position of the most recently scanned token.",
        "name": "scanner.Scanner.Pos",
        "params": [],
        "path": "go/text/scanner/index#Scanner.Pos",
        "syntax": "func (s *Scanner) Pos() (pos Position)",
        "type": "text"
    },
    "scanner.Scanner.Scan": {
        "descr": "Scan reads the next token or Unicode character from source and returns it. It only recognizes tokens t for which the respective Mode bit (1<<-t) is set. It returns EOF at the end of the source. It reports scanner errors (read and token errors) by calling s.Error, if not nil; otherwise it prints an error message to os.Stderr.",
        "name": "scanner.Scanner.Scan",
        "params": [],
        "path": "go/text/scanner/index#Scanner.Scan",
        "syntax": "func (s *Scanner) Scan() rune",
        "type": "text"
    },
    "scanner.Scanner.TokenText": {
        "descr": "TokenText returns the string corresponding to the most recently scanned token. Valid after calling Scan().",
        "name": "scanner.Scanner.TokenText",
        "params": [],
        "path": "go/text/scanner/index#Scanner.TokenText",
        "syntax": "func (s *Scanner) TokenText() string",
        "type": "text"
    },
    "scanner.TokenString": {
        "descr": "TokenString returns a printable string for a token or Unicode character.",
        "name": "scanner.TokenString",
        "params": [],
        "path": "go/text/scanner/index#TokenString",
        "syntax": "func TokenString(tok rune) string",
        "type": "text"
    },
    "sha1.New": {
        "descr": "New returns a new hash.Hash computing the SHA1 checksum. The Hash also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.",
        "name": "sha1.New",
        "params": [],
        "path": "go/crypto/sha1/index#New",
        "syntax": "func New() hash.Hash",
        "type": "crypto"
    },
    "sha1.Sum": {
        "descr": "Sum returns the SHA-1 checksum of the data.",
        "name": "sha1.Sum",
        "params": [],
        "path": "go/crypto/sha1/index#Sum",
        "syntax": "func Sum(data []byte) [Size]byte",
        "type": "crypto"
    },
    "sha256.New": {
        "descr": "New returns a new hash.Hash computing the SHA256 checksum. The Hash also implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal and unmarshal the internal state of the hash.",
        "name": "sha256.New",
        "params": [],
        "path": "go/crypto/sha256/index#New",
        "syntax": "func New() hash.Hash",
        "type": "crypto"
    },
    "sha256.New224": {
        "descr": "New224 returns a new hash.Hash computing the SHA224 checksum.",
        "name": "sha256.New224",
        "params": [],
        "path": "go/crypto/sha256/index#New224",
        "syntax": "func New224() hash.Hash",
        "type": "crypto"
    },
    "sha256.Sum224": {
        "descr": "Sum224 returns the SHA224 checksum of the data.",
        "name": "sha256.Sum224",
        "params": [],
        "path": "go/crypto/sha256/index#Sum224",
        "syntax": "func Sum224(data []byte) (sum224 [Size224]byte)",
        "type": "crypto"
    },
    "sha256.Sum256": {
        "descr": "Sum256 returns the SHA256 checksum of the data.",
        "name": "sha256.Sum256",
        "params": [],
        "path": "go/crypto/sha256/index#Sum256",
        "syntax": "func Sum256(data []byte) [Size]byte",
        "type": "crypto"
    },
    "sha512.New": {
        "descr": "New returns a new hash.Hash computing the SHA-512 checksum.",
        "name": "sha512.New",
        "params": [],
        "path": "go/crypto/sha512/index#New",
        "syntax": "func New() hash.Hash",
        "type": "crypto"
    },
    "sha512.New384": {
        "descr": "New384 returns a new hash.Hash computing the SHA-384 checksum.",
        "name": "sha512.New384",
        "params": [],
        "path": "go/crypto/sha512/index#New384",
        "syntax": "func New384() hash.Hash",
        "type": "crypto"
    },
    "sha512.New512_224": {
        "descr": "New512_224 returns a new hash.Hash computing the SHA-512/224 checksum.",
        "name": "sha512.New512_224",
        "params": [],
        "path": "go/crypto/sha512/index#New512_224",
        "syntax": "func New512_224() hash.Hash",
        "type": "crypto"
    },
    "sha512.New512_256": {
        "descr": "New512_256 returns a new hash.Hash computing the SHA-512/256 checksum.",
        "name": "sha512.New512_256",
        "params": [],
        "path": "go/crypto/sha512/index#New512_256",
        "syntax": "func New512_256() hash.Hash",
        "type": "crypto"
    },
    "sha512.Sum384": {
        "descr": "Sum384 returns the SHA384 checksum of the data.",
        "name": "sha512.Sum384",
        "params": [],
        "path": "go/crypto/sha512/index#Sum384",
        "syntax": "func Sum384(data []byte) (sum384 [Size384]byte)",
        "type": "crypto"
    },
    "sha512.Sum512": {
        "descr": "Sum512 returns the SHA512 checksum of the data.",
        "name": "sha512.Sum512",
        "params": [],
        "path": "go/crypto/sha512/index#Sum512",
        "syntax": "func Sum512(data []byte) [Size]byte",
        "type": "crypto"
    },
    "sha512.Sum512_224": {
        "descr": "Sum512_224 returns the Sum512/224 checksum of the data.",
        "name": "sha512.Sum512_224",
        "params": [],
        "path": "go/crypto/sha512/index#Sum512_224",
        "syntax": "func Sum512_224(data []byte) (sum224 [Size224]byte)",
        "type": "crypto"
    },
    "sha512.Sum512_256": {
        "descr": "Sum512_256 returns the Sum512/256 checksum of the data.",
        "name": "sha512.Sum512_256",
        "params": [],
        "path": "go/crypto/sha512/index#Sum512_256",
        "syntax": "func Sum512_256(data []byte) (sum256 [Size256]byte)",
        "type": "crypto"
    },
    "signal.Ignore": {
        "descr": "Ignore causes the provided signals to be ignored. If they are received by the program, nothing will happen. Ignore undoes the effect of any prior calls to Notify for the provided signals. If no signals are provided, all incoming signals will be ignored.",
        "name": "signal.Ignore",
        "params": [],
        "path": "go/os/signal/index#Ignore",
        "syntax": "func Ignore(sig ...os.Signal)",
        "type": "os"
    },
    "signal.Ignored": {
        "descr": "Ignored reports whether sig is currently ignored.",
        "name": "signal.Ignored",
        "params": [],
        "path": "go/os/signal/index#Ignored",
        "syntax": "func Ignored(sig os.Signal) bool",
        "type": "os"
    },
    "signal.Notify": {
        "descr": "Notify causes package signal to relay incoming signals to c. If no signals are provided, all incoming signals will be relayed to c. Otherwise, just the provided signals will.",
        "name": "signal.Notify",
        "params": [],
        "path": "go/os/signal/index#Notify",
        "syntax": "func Notify(c chan<- os.Signal, sig ...os.Signal)",
        "type": "os"
    },
    "signal.Reset": {
        "descr": "Reset undoes the effect of any prior calls to Notify for the provided signals. If no signals are provided, all signal handlers will be reset.",
        "name": "signal.Reset",
        "params": [],
        "path": "go/os/signal/index#Reset",
        "syntax": "func Reset(sig ...os.Signal)",
        "type": "os"
    },
    "signal.Stop": {
        "descr": "Stop causes package signal to stop relaying incoming signals to c. It undoes the effect of all prior calls to Notify using c. When Stop returns, it is guaranteed that c will receive no more signals.",
        "name": "signal.Stop",
        "params": [],
        "path": "go/os/signal/index#Stop",
        "syntax": "func Stop(c chan<- os.Signal)",
        "type": "os"
    },
    "smtp.Auth": {
        "descr": "Auth is implemented by an SMTP authentication mechanism.",
        "name": "smtp.Auth",
        "params": [],
        "path": "go/net/smtp/index#Auth",
        "syntax": "type Auth interface { // Start begins an authentication with a server. // It returns the name of the authentication protocol // and optionally data to include in the initial AUTH message // sent to the server. It can return proto == \"\" to indicate // that the authentication should be skipped. // If it returns a non-nil error, the SMTP client aborts // the authentication attempt and closes the connection. Start(server *ServerInfo) (proto string, toServer []byte, err error) // Next continues the authentication. The server has just sent // the fromServer data. If more is true, the server expects a // response, which Next should return as toServer; otherwise // Next should return toServer == nil. // If Next returns a non-nil error, the SMTP client aborts // the authentication attempt and closes the connection. Next(fromServer []byte, more bool) (toServer []byte, err error) }",
        "type": "net/smtp"
    },
    "smtp.CRAMMD5Auth": {
        "descr": "CRAMMD5Auth returns an Auth that implements the CRAM-MD5 authentication mechanism as defined in RFC 2195. The returned Auth uses the given username and secret to authenticate to the server using the challenge-response mechanism.",
        "name": "smtp.CRAMMD5Auth",
        "params": [],
        "path": "go/net/smtp/index#CRAMMD5Auth",
        "syntax": "func CRAMMD5Auth(username, secret string) Auth",
        "type": "net/smtp"
    },
    "smtp.Client": {
        "descr": "A Client represents a client connection to an SMTP server.",
        "name": "smtp.Client",
        "params": [],
        "path": "go/net/smtp/index#Client",
        "syntax": "type Client struct { // Text is the textproto.Conn used by the Client. It is exported to allow for // clients to add extensions. Text *textproto.Conn // contains filtered or unexported fields }",
        "type": "net/smtp"
    },
    "smtp.Client.Auth": {
        "descr": "Auth authenticates a client using the provided authentication mechanism. A failed authentication closes the connection. Only servers that advertise the AUTH extension support this function.",
        "name": "smtp.Client.Auth",
        "params": [],
        "path": "go/net/smtp/index#Client.Auth",
        "syntax": "func (c *Client) Auth(a Auth) error",
        "type": "net/smtp"
    },
    "smtp.Client.Close": {
        "descr": "Close closes the connection.",
        "name": "smtp.Client.Close",
        "params": [],
        "path": "go/net/smtp/index#Client.Close",
        "syntax": "func (c *Client) Close() error",
        "type": "net/smtp"
    },
    "smtp.Client.Data": {
        "descr": "Data issues a DATA command to the server and returns a writer that can be used to write the mail headers and body. The caller should close the writer before calling any more methods on c. A call to Data must be preceded by one or more calls to Rcpt.",
        "name": "smtp.Client.Data",
        "params": [],
        "path": "go/net/smtp/index#Client.Data",
        "syntax": "func (c *Client) Data() (io.WriteCloser, error)",
        "type": "net/smtp"
    },
    "smtp.Client.Extension": {
        "descr": "Extension reports whether an extension is support by the server. The extension name is case-insensitive. If the extension is supported, Extension also returns a string that contains any parameters the server specifies for the extension.",
        "name": "smtp.Client.Extension",
        "params": [],
        "path": "go/net/smtp/index#Client.Extension",
        "syntax": "func (c *Client) Extension(ext string) (bool, string)",
        "type": "net/smtp"
    },
    "smtp.Client.Hello": {
        "descr": "Hello sends a HELO or EHLO to the server as the given host name. Calling this method is only necessary if the client needs control over the host name used. The client will introduce itself as \"localhost\" automatically otherwise. If Hello is called, it must be called before any of the other methods.",
        "name": "smtp.Client.Hello",
        "params": [],
        "path": "go/net/smtp/index#Client.Hello",
        "syntax": "func (c *Client) Hello(localName string) error",
        "type": "net/smtp"
    },
    "smtp.Client.Mail": {
        "descr": "Mail issues a MAIL command to the server using the provided email address. If the server supports the 8BITMIME extension, Mail adds the BODY=8BITMIME parameter. This initiates a mail transaction and is followed by one or more Rcpt calls.",
        "name": "smtp.Client.Mail",
        "params": [],
        "path": "go/net/smtp/index#Client.Mail",
        "syntax": "func (c *Client) Mail(from string) error",
        "type": "net/smtp"
    },
    "smtp.Client.Noop": {
        "descr": "Noop sends the NOOP command to the server. It does nothing but check that the connection to the server is okay.",
        "name": "smtp.Client.Noop",
        "params": [],
        "path": "go/net/smtp/index#Client.Noop",
        "syntax": "func (c *Client) Noop() error",
        "type": "net/smtp"
    },
    "smtp.Client.Quit": {
        "descr": "Quit sends the QUIT command and closes the connection to the server.",
        "name": "smtp.Client.Quit",
        "params": [],
        "path": "go/net/smtp/index#Client.Quit",
        "syntax": "func (c *Client) Quit() error",
        "type": "net/smtp"
    },
    "smtp.Client.Rcpt": {
        "descr": "Rcpt issues a RCPT command to the server using the provided email address. A call to Rcpt must be preceded by a call to Mail and may be followed by a Data call or another Rcpt call.",
        "name": "smtp.Client.Rcpt",
        "params": [],
        "path": "go/net/smtp/index#Client.Rcpt",
        "syntax": "func (c *Client) Rcpt(to string) error",
        "type": "net/smtp"
    },
    "smtp.Client.Reset": {
        "descr": "Reset sends the RSET command to the server, aborting the current mail transaction.",
        "name": "smtp.Client.Reset",
        "params": [],
        "path": "go/net/smtp/index#Client.Reset",
        "syntax": "func (c *Client) Reset() error",
        "type": "net/smtp"
    },
    "smtp.Client.StartTLS": {
        "descr": "StartTLS sends the STARTTLS command and encrypts all further communication. Only servers that advertise the STARTTLS extension support this function.",
        "name": "smtp.Client.StartTLS",
        "params": [],
        "path": "go/net/smtp/index#Client.StartTLS",
        "syntax": "func (c *Client) StartTLS(config *tls.Config) error",
        "type": "net/smtp"
    },
    "smtp.Client.TLSConnectionState": {
        "descr": "TLSConnectionState returns the client's TLS connection state. The return values are their zero values if StartTLS did not succeed.",
        "name": "smtp.Client.TLSConnectionState",
        "params": [],
        "path": "go/net/smtp/index#Client.TLSConnectionState",
        "syntax": "func (c *Client) TLSConnectionState() (state tls.ConnectionState, ok bool)",
        "type": "net/smtp"
    },
    "smtp.Client.Verify": {
        "descr": "Verify checks the validity of an email address on the server. If Verify returns nil, the address is valid. A non-nil return does not necessarily indicate an invalid address. Many servers will not verify addresses for security reasons.",
        "name": "smtp.Client.Verify",
        "params": [],
        "path": "go/net/smtp/index#Client.Verify",
        "syntax": "func (c *Client) Verify(addr string) error",
        "type": "net/smtp"
    },
    "smtp.Dial": {
        "descr": "Dial returns a new Client connected to an SMTP server at addr. The addr must include a port, as in \"mail.example.com:smtp\".",
        "name": "smtp.Dial",
        "params": [],
        "path": "go/net/smtp/index#Dial",
        "syntax": "func Dial(addr string) (*Client, error)",
        "type": "net/smtp"
    },
    "smtp.NewClient": {
        "descr": "NewClient returns a new Client using an existing connection and host as a server name to be used when authenticating.",
        "name": "smtp.NewClient",
        "params": [],
        "path": "go/net/smtp/index#NewClient",
        "syntax": "func NewClient(conn net.Conn, host string) (*Client, error)",
        "type": "net/smtp"
    },
    "smtp.PlainAuth": {
        "descr": "PlainAuth returns an Auth that implements the PLAIN authentication mechanism as defined in RFC 4616. The returned Auth uses the given username and password to authenticate to host and act as identity. Usually identity should be the empty string, to act as username.",
        "name": "smtp.PlainAuth",
        "params": [],
        "path": "go/net/smtp/index#PlainAuth",
        "syntax": "func PlainAuth(identity, username, password, host string) Auth",
        "type": "net/smtp"
    },
    "smtp.SendMail": {
        "descr": "SendMail connects to the server at addr, switches to TLS if possible, authenticates with the optional mechanism a if possible, and then sends an email from address from, to addresses to, with message msg. The addr must include a port, as in \"mail.example.com:smtp\".",
        "name": "smtp.SendMail",
        "params": [],
        "path": "go/net/smtp/index#SendMail",
        "syntax": "func SendMail(addr string, a Auth, from string, to []string, msg []byte) error",
        "type": "net/smtp"
    },
    "smtp.ServerInfo": {
        "descr": "ServerInfo records information about an SMTP server.",
        "name": "smtp.ServerInfo",
        "params": [],
        "path": "go/net/smtp/index#ServerInfo",
        "syntax": "type ServerInfo struct { Name string // SMTP server name TLS bool // using TLS, with valid certificate for Name Auth []string // advertised authentication mechanisms }",
        "type": "net/smtp"
    },
    "sort.Float64Slice": {
        "descr": "Float64Slice attaches the methods of Interface to []float64, sorting in increasing order (not-a-number values are treated as less than other values).",
        "name": "sort.Float64Slice",
        "params": [],
        "path": "go/sort/index#Float64Slice",
        "syntax": "type Float64Slice []float64",
        "type": "sort"
    },
    "sort.Float64Slice.Len": {
        "descr": "",
        "name": "sort.Float64Slice.Len",
        "params": [],
        "path": "go/sort/index#Float64Slice.Len",
        "syntax": "func (p Float64Slice) Len() int",
        "type": "sort"
    },
    "sort.Float64Slice.Less": {
        "descr": "",
        "name": "sort.Float64Slice.Less",
        "params": [],
        "path": "go/sort/index#Float64Slice.Less",
        "syntax": "func (p Float64Slice) Less(i, j int) bool",
        "type": "sort"
    },
    "sort.Float64Slice.Search": {
        "descr": "Search returns the result of applying SearchFloat64s to the receiver and x.",
        "name": "sort.Float64Slice.Search",
        "params": [],
        "path": "go/sort/index#Float64Slice.Search",
        "syntax": "func (p Float64Slice) Search(x float64) int",
        "type": "sort"
    },
    "sort.Float64Slice.Sort": {
        "descr": "Sort is a convenience method.",
        "name": "sort.Float64Slice.Sort",
        "params": [],
        "path": "go/sort/index#Float64Slice.Sort",
        "syntax": "func (p Float64Slice) Sort()",
        "type": "sort"
    },
    "sort.Float64Slice.Swap": {
        "descr": "",
        "name": "sort.Float64Slice.Swap",
        "params": [],
        "path": "go/sort/index#Float64Slice.Swap",
        "syntax": "func (p Float64Slice) Swap(i, j int)",
        "type": "sort"
    },
    "sort.Float64s": {
        "descr": "Float64s sorts a slice of float64s in increasing order (not-a-number values are treated as less than other values).",
        "name": "sort.Float64s",
        "params": [],
        "path": "go/sort/index#Float64s",
        "syntax": "func Float64s(a []float64)",
        "type": "sort"
    },
    "sort.Float64sAreSorted": {
        "descr": "Float64sAreSorted tests whether a slice of float64s is sorted in increasing order (not-a-number values are treated as less than other values).",
        "name": "sort.Float64sAreSorted",
        "params": [],
        "path": "go/sort/index#Float64sAreSorted",
        "syntax": "func Float64sAreSorted(a []float64) bool",
        "type": "sort"
    },
    "sort.IntSlice": {
        "descr": "IntSlice attaches the methods of Interface to []int, sorting in increasing order.",
        "name": "sort.IntSlice",
        "params": [],
        "path": "go/sort/index#IntSlice",
        "syntax": "type IntSlice []int",
        "type": "sort"
    },
    "sort.IntSlice.Len": {
        "descr": "",
        "name": "sort.IntSlice.Len",
        "params": [],
        "path": "go/sort/index#IntSlice.Len",
        "syntax": "func (p IntSlice) Len() int",
        "type": "sort"
    },
    "sort.IntSlice.Less": {
        "descr": "",
        "name": "sort.IntSlice.Less",
        "params": [],
        "path": "go/sort/index#IntSlice.Less",
        "syntax": "func (p IntSlice) Less(i, j int) bool",
        "type": "sort"
    },
    "sort.IntSlice.Search": {
        "descr": "Search returns the result of applying SearchInts to the receiver and x.",
        "name": "sort.IntSlice.Search",
        "params": [],
        "path": "go/sort/index#IntSlice.Search",
        "syntax": "func (p IntSlice) Search(x int) int",
        "type": "sort"
    },
    "sort.IntSlice.Sort": {
        "descr": "Sort is a convenience method.",
        "name": "sort.IntSlice.Sort",
        "params": [],
        "path": "go/sort/index#IntSlice.Sort",
        "syntax": "func (p IntSlice) Sort()",
        "type": "sort"
    },
    "sort.IntSlice.Swap": {
        "descr": "",
        "name": "sort.IntSlice.Swap",
        "params": [],
        "path": "go/sort/index#IntSlice.Swap",
        "syntax": "func (p IntSlice) Swap(i, j int)",
        "type": "sort"
    },
    "sort.Interface": {
        "descr": "A type, typically a collection, that satisfies sort.Interface can be sorted by the routines in this package. The methods require that the elements of the collection be enumerated by an integer index.",
        "name": "sort.Interface",
        "params": [],
        "path": "go/sort/index#Interface",
        "syntax": "type Interface interface { // Len is the number of elements in the collection. Len() int // Less reports whether the element with // index i should sort before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }",
        "type": "sort"
    },
    "sort.Ints": {
        "descr": "Ints sorts a slice of ints in increasing order.",
        "name": "sort.Ints",
        "params": [],
        "path": "go/sort/index#Ints",
        "syntax": "func Ints(a []int)",
        "type": "sort"
    },
    "sort.IntsAreSorted": {
        "descr": "IntsAreSorted tests whether a slice of ints is sorted in increasing order.",
        "name": "sort.IntsAreSorted",
        "params": [],
        "path": "go/sort/index#IntsAreSorted",
        "syntax": "func IntsAreSorted(a []int) bool",
        "type": "sort"
    },
    "sort.IsSorted": {
        "descr": "IsSorted reports whether data is sorted.",
        "name": "sort.IsSorted",
        "params": [],
        "path": "go/sort/index#IsSorted",
        "syntax": "func IsSorted(data Interface) bool",
        "type": "sort"
    },
    "sort.Reverse": {
        "descr": "Reverse returns the reverse order for data.",
        "name": "sort.Reverse",
        "params": [],
        "path": "go/sort/index#Reverse",
        "syntax": "func Reverse(data Interface) Interface",
        "type": "sort"
    },
    "sort.Search": {
        "descr": "Search uses binary search to find and return the smallest index i in [0, n) at which f(i) is true, assuming that on the range [0, n), f(i) == true implies f(i+1) == true. That is, Search requires that f is false for some (possibly empty) prefix of the input range [0, n) and then true for the (possibly empty) remainder; Search returns the first true index. If there is no such index, Search returns n. (Note that the \"not found\" return value is not -1 as in, for instance, strings.Index.) Search calls f(i) only for i in the range [0, n).",
        "name": "sort.Search",
        "params": [],
        "path": "go/sort/index#Search",
        "syntax": "func Search(n int, f func(int) bool) int",
        "type": "sort"
    },
    "sort.SearchFloat64s": {
        "descr": "SearchFloat64s searches for x in a sorted slice of float64s and returns the index as specified by Search. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order.",
        "name": "sort.SearchFloat64s",
        "params": [],
        "path": "go/sort/index#SearchFloat64s",
        "syntax": "func SearchFloat64s(a []float64, x float64) int",
        "type": "sort"
    },
    "sort.SearchInts": {
        "descr": "SearchInts searches for x in a sorted slice of ints and returns the index as specified by Search. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order.",
        "name": "sort.SearchInts",
        "params": [],
        "path": "go/sort/index#SearchInts",
        "syntax": "func SearchInts(a []int, x int) int",
        "type": "sort"
    },
    "sort.SearchStrings": {
        "descr": "SearchStrings searches for x in a sorted slice of strings and returns the index as specified by Search. The return value is the index to insert x if x is not present (it could be len(a)). The slice must be sorted in ascending order.",
        "name": "sort.SearchStrings",
        "params": [],
        "path": "go/sort/index#SearchStrings",
        "syntax": "func SearchStrings(a []string, x string) int",
        "type": "sort"
    },
    "sort.Slice": {
        "descr": "Slice sorts the provided slice given the provided less function.",
        "name": "sort.Slice",
        "params": [],
        "path": "go/sort/index#Slice",
        "syntax": "func Slice(slice interface{}, less func(i, j int) bool)",
        "type": "sort"
    },
    "sort.SliceIsSorted": {
        "descr": "SliceIsSorted tests whether a slice is sorted.",
        "name": "sort.SliceIsSorted",
        "params": [],
        "path": "go/sort/index#SliceIsSorted",
        "syntax": "func SliceIsSorted(slice interface{}, less func(i, j int) bool) bool",
        "type": "sort"
    },
    "sort.SliceStable": {
        "descr": "SliceStable sorts the provided slice given the provided less function while keeping the original order of equal elements.",
        "name": "sort.SliceStable",
        "params": [],
        "path": "go/sort/index#SliceStable",
        "syntax": "func SliceStable(slice interface{}, less func(i, j int) bool)",
        "type": "sort"
    },
    "sort.Sort": {
        "descr": "Sort sorts data. It makes one call to data.Len to determine n, and O(n*log(n)) calls to data.Less and data.Swap. The sort is not guaranteed to be stable.",
        "name": "sort.Sort",
        "params": [],
        "path": "go/sort/index#Sort",
        "syntax": "func Sort(data Interface)",
        "type": "sort"
    },
    "sort.Stable": {
        "descr": "Stable sorts data while keeping the original order of equal elements.",
        "name": "sort.Stable",
        "params": [],
        "path": "go/sort/index#Stable",
        "syntax": "func Stable(data Interface)",
        "type": "sort"
    },
    "sort.StringSlice": {
        "descr": "StringSlice attaches the methods of Interface to []string, sorting in increasing order.",
        "name": "sort.StringSlice",
        "params": [],
        "path": "go/sort/index#StringSlice",
        "syntax": "type StringSlice []string",
        "type": "sort"
    },
    "sort.StringSlice.Len": {
        "descr": "",
        "name": "sort.StringSlice.Len",
        "params": [],
        "path": "go/sort/index#StringSlice.Len",
        "syntax": "func (p StringSlice) Len() int",
        "type": "sort"
    },
    "sort.StringSlice.Less": {
        "descr": "",
        "name": "sort.StringSlice.Less",
        "params": [],
        "path": "go/sort/index#StringSlice.Less",
        "syntax": "func (p StringSlice) Less(i, j int) bool",
        "type": "sort"
    },
    "sort.StringSlice.Search": {
        "descr": "Search returns the result of applying SearchStrings to the receiver and x.",
        "name": "sort.StringSlice.Search",
        "params": [],
        "path": "go/sort/index#StringSlice.Search",
        "syntax": "func (p StringSlice) Search(x string) int",
        "type": "sort"
    },
    "sort.StringSlice.Sort": {
        "descr": "Sort is a convenience method.",
        "name": "sort.StringSlice.Sort",
        "params": [],
        "path": "go/sort/index#StringSlice.Sort",
        "syntax": "func (p StringSlice) Sort()",
        "type": "sort"
    },
    "sort.StringSlice.Swap": {
        "descr": "",
        "name": "sort.StringSlice.Swap",
        "params": [],
        "path": "go/sort/index#StringSlice.Swap",
        "syntax": "func (p StringSlice) Swap(i, j int)",
        "type": "sort"
    },
    "sort.Strings": {
        "descr": "Strings sorts a slice of strings in increasing order.",
        "name": "sort.Strings",
        "params": [],
        "path": "go/sort/index#Strings",
        "syntax": "func Strings(a []string)",
        "type": "sort"
    },
    "sort.StringsAreSorted": {
        "descr": "StringsAreSorted tests whether a slice of strings is sorted in increasing order.",
        "name": "sort.StringsAreSorted",
        "params": [],
        "path": "go/sort/index#StringsAreSorted",
        "syntax": "func StringsAreSorted(a []string) bool",
        "type": "sort"
    },
    "sql.ColumnType": {
        "descr": "ColumnType contains the name and type of a column.",
        "name": "sql.ColumnType",
        "params": [],
        "path": "go/database/sql/index#ColumnType",
        "syntax": "type ColumnType struct { // contains filtered or unexported fields }",
        "type": "database"
    },
    "sql.ColumnType.DatabaseTypeName": {
        "descr": "DatabaseTypeName returns the database system name of the column type. If an empty string is returned the driver type name is not supported. Consult your driver documentation for a list of driver data types. Length specifiers are not included. Common type include \"VARCHAR\", \"TEXT\", \"NVARCHAR\", \"DECIMAL\", \"BOOL\", \"INT\", \"BIGINT\".",
        "name": "sql.ColumnType.DatabaseTypeName",
        "params": [],
        "path": "go/database/sql/index#ColumnType.DatabaseTypeName",
        "syntax": "func (ci *ColumnType) DatabaseTypeName() string",
        "type": "database"
    },
    "sql.ColumnType.DecimalSize": {
        "descr": "DecimalSize returns the scale and precision of a decimal type. If not applicable or if not supported ok is false.",
        "name": "sql.ColumnType.DecimalSize",
        "params": [],
        "path": "go/database/sql/index#ColumnType.DecimalSize",
        "syntax": "func (ci *ColumnType) DecimalSize() (precision, scale int64, ok bool)",
        "type": "database"
    },
    "sql.ColumnType.Length": {
        "descr": "Length returns the column type length for variable length column types such as text and binary field types. If the type length is unbounded the value will be math.MaxInt64 (any database limits will still apply). If the column type is not variable length, such as an int, or if not supported by the driver ok is false.",
        "name": "sql.ColumnType.Length",
        "params": [],
        "path": "go/database/sql/index#ColumnType.Length",
        "syntax": "func (ci *ColumnType) Length() (length int64, ok bool)",
        "type": "database"
    },
    "sql.ColumnType.Name": {
        "descr": "Name returns the name or alias of the column.",
        "name": "sql.ColumnType.Name",
        "params": [],
        "path": "go/database/sql/index#ColumnType.Name",
        "syntax": "func (ci *ColumnType) Name() string",
        "type": "database"
    },
    "sql.ColumnType.Nullable": {
        "descr": "Nullable returns whether the column may be null. If a driver does not support this property ok will be false.",
        "name": "sql.ColumnType.Nullable",
        "params": [],
        "path": "go/database/sql/index#ColumnType.Nullable",
        "syntax": "func (ci *ColumnType) Nullable() (nullable, ok bool)",
        "type": "database"
    },
    "sql.ColumnType.ScanType": {
        "descr": "ScanType returns a Go type suitable for scanning into using Rows.Scan. If a driver does not support this property ScanType will return the type of an empty interface.",
        "name": "sql.ColumnType.ScanType",
        "params": [],
        "path": "go/database/sql/index#ColumnType.ScanType",
        "syntax": "func (ci *ColumnType) ScanType() reflect.Type",
        "type": "database"
    },
    "sql.Conn": {
        "descr": "Conn represents a single database connection rather than a pool of database connections. Prefer running queries from DB unless there is a specific need for a continuous single database connection.",
        "name": "sql.Conn",
        "params": [],
        "path": "go/database/sql/index#Conn",
        "syntax": "type Conn struct { // contains filtered or unexported fields }",
        "type": "database"
    },
    "sql.Conn.BeginTx": {
        "descr": "BeginTx starts a transaction.",
        "name": "sql.Conn.BeginTx",
        "params": [],
        "path": "go/database/sql/index#Conn.BeginTx",
        "syntax": "func (c *Conn) BeginTx(ctx context.Context, opts *TxOptions) (*Tx, error)",
        "type": "database"
    },
    "sql.Conn.Close": {
        "descr": "Close returns the connection to the connection pool. All operations after a Close will return with ErrConnDone. Close is safe to call concurrently with other operations and will block until all other operations finish. It may be useful to first cancel any used context and then call close directly after.",
        "name": "sql.Conn.Close",
        "params": [],
        "path": "go/database/sql/index#Conn.Close",
        "syntax": "func (c *Conn) Close() error",
        "type": "database"
    },
    "sql.Conn.ExecContext": {
        "descr": "ExecContext executes a query without returning any rows. The args are for any placeholder parameters in the query.",
        "name": "sql.Conn.ExecContext",
        "params": [],
        "path": "go/database/sql/index#Conn.ExecContext",
        "syntax": "func (c *Conn) ExecContext(ctx context.Context, query string, args ...interface{}) (Result, error)",
        "type": "database"
    },
    "sql.Conn.PingContext": {
        "descr": "PingContext verifies the connection to the database is still alive.",
        "name": "sql.Conn.PingContext",
        "params": [],
        "path": "go/database/sql/index#Conn.PingContext",
        "syntax": "func (c *Conn) PingContext(ctx context.Context) error",
        "type": "database"
    },
    "sql.Conn.PrepareContext": {
        "descr": "PrepareContext creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement. The caller must call the statement's Close method when the statement is no longer needed.",
        "name": "sql.Conn.PrepareContext",
        "params": [],
        "path": "go/database/sql/index#Conn.PrepareContext",
        "syntax": "func (c *Conn) PrepareContext(ctx context.Context, query string) (*Stmt, error)",
        "type": "database"
    },
    "sql.Conn.QueryContext": {
        "descr": "QueryContext executes a query that returns rows, typically a SELECT. The args are for any placeholder parameters in the query.",
        "name": "sql.Conn.QueryContext",
        "params": [],
        "path": "go/database/sql/index#Conn.QueryContext",
        "syntax": "func (c *Conn) QueryContext(ctx context.Context, query string, args ...interface{}) (*Rows, error)",
        "type": "database"
    },
    "sql.Conn.QueryRowContext": {
        "descr": "QueryRowContext executes a query that is expected to return at most one row. QueryRowContext always returns a non-nil value. Errors are deferred until Row's Scan method is called. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.",
        "name": "sql.Conn.QueryRowContext",
        "params": [],
        "path": "go/database/sql/index#Conn.QueryRowContext",
        "syntax": "func (c *Conn) QueryRowContext(ctx context.Context, query string, args ...interface{}) *Row",
        "type": "database"
    },
    "sql.DB": {
        "descr": "DB is a database handle representing a pool of zero or more underlying connections. It's safe for concurrent use by multiple goroutines.",
        "name": "sql.DB",
        "params": [],
        "path": "go/database/sql/index#DB",
        "syntax": "type DB struct { // contains filtered or unexported fields }",
        "type": "database"
    },
    "sql.DB.Begin": {
        "descr": "Begin starts a transaction. The default isolation level is dependent on the driver.",
        "name": "sql.DB.Begin",
        "params": [],
        "path": "go/database/sql/index#DB.Begin",
        "syntax": "func (db *DB) Begin() (*Tx, error)",
        "type": "database"
    },
    "sql.DB.BeginTx": {
        "descr": "BeginTx starts a transaction.",
        "name": "sql.DB.BeginTx",
        "params": [],
        "path": "go/database/sql/index#DB.BeginTx",
        "syntax": "func (db *DB) BeginTx(ctx context.Context, opts *TxOptions) (*Tx, error)",
        "type": "database"
    },
    "sql.DB.Close": {
        "descr": "Close closes the database and prevents new queries from starting. Close then waits for all queries that have started processing on the server to finish.",
        "name": "sql.DB.Close",
        "params": [],
        "path": "go/database/sql/index#DB.Close",
        "syntax": "func (db *DB) Close() error",
        "type": "database"
    },
    "sql.DB.Conn": {
        "descr": "Conn returns a single connection by either opening a new connection or returning an existing connection from the connection pool. Conn will block until either a connection is returned or ctx is canceled. Queries run on the same Conn will be run in the same database session.",
        "name": "sql.DB.Conn",
        "params": [],
        "path": "go/database/sql/index#DB.Conn",
        "syntax": "func (db *DB) Conn(ctx context.Context) (*Conn, error)",
        "type": "database"
    },
    "sql.DB.Driver": {
        "descr": "Driver returns the database's underlying driver.",
        "name": "sql.DB.Driver",
        "params": [],
        "path": "go/database/sql/index#DB.Driver",
        "syntax": "func (db *DB) Driver() driver.Driver",
        "type": "database"
    },
    "sql.DB.Exec": {
        "descr": "Exec executes a query without returning any rows. The args are for any placeholder parameters in the query.",
        "name": "sql.DB.Exec",
        "params": [],
        "path": "go/database/sql/index#DB.Exec",
        "syntax": "func (db *DB) Exec(query string, args ...interface{}) (Result, error)",
        "type": "database"
    },
    "sql.DB.ExecContext": {
        "descr": "ExecContext executes a query without returning any rows. The args are for any placeholder parameters in the query.",
        "name": "sql.DB.ExecContext",
        "params": [],
        "path": "go/database/sql/index#DB.ExecContext",
        "syntax": "func (db *DB) ExecContext(ctx context.Context, query string, args ...interface{}) (Result, error)",
        "type": "database"
    },
    "sql.DB.Ping": {
        "descr": "Ping verifies a connection to the database is still alive, establishing a connection if necessary.",
        "name": "sql.DB.Ping",
        "params": [],
        "path": "go/database/sql/index#DB.Ping",
        "syntax": "func (db *DB) Ping() error",
        "type": "database"
    },
    "sql.DB.PingContext": {
        "descr": "PingContext verifies a connection to the database is still alive, establishing a connection if necessary.",
        "name": "sql.DB.PingContext",
        "params": [],
        "path": "go/database/sql/index#DB.PingContext",
        "syntax": "func (db *DB) PingContext(ctx context.Context) error",
        "type": "database"
    },
    "sql.DB.Prepare": {
        "descr": "Prepare creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement. The caller must call the statement's Close method when the statement is no longer needed.",
        "name": "sql.DB.Prepare",
        "params": [],
        "path": "go/database/sql/index#DB.Prepare",
        "syntax": "func (db *DB) Prepare(query string) (*Stmt, error)",
        "type": "database"
    },
    "sql.DB.PrepareContext": {
        "descr": "PrepareContext creates a prepared statement for later queries or executions. Multiple queries or executions may be run concurrently from the returned statement. The caller must call the statement's Close method when the statement is no longer needed.",
        "name": "sql.DB.PrepareContext",
        "params": [],
        "path": "go/database/sql/index#DB.PrepareContext",
        "syntax": "func (db *DB) PrepareContext(ctx context.Context, query string) (*Stmt, error)",
        "type": "database"
    },
    "sql.DB.Query": {
        "descr": "Query executes a query that returns rows, typically a SELECT. The args are for any placeholder parameters in the query.",
        "name": "sql.DB.Query",
        "params": [],
        "path": "go/database/sql/index#DB.Query",
        "syntax": "func (db *DB) Query(query string, args ...interface{}) (*Rows, error)",
        "type": "database"
    },
    "sql.DB.QueryContext": {
        "descr": "QueryContext executes a query that returns rows, typically a SELECT. The args are for any placeholder parameters in the query.",
        "name": "sql.DB.QueryContext",
        "params": [],
        "path": "go/database/sql/index#DB.QueryContext",
        "syntax": "func (db *DB) QueryContext(ctx context.Context, query string, args ...interface{}) (*Rows, error)",
        "type": "database"
    },
    "sql.DB.QueryRow": {
        "descr": "QueryRow executes a query that is expected to return at most one row. QueryRow always returns a non-nil value. Errors are deferred until Row's Scan method is called. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.",
        "name": "sql.DB.QueryRow",
        "params": [],
        "path": "go/database/sql/index#DB.QueryRow",
        "syntax": "func (db *DB) QueryRow(query string, args ...interface{}) *Row",
        "type": "database"
    },
    "sql.DB.QueryRowContext": {
        "descr": "QueryRowContext executes a query that is expected to return at most one row. QueryRowContext always returns a non-nil value. Errors are deferred until Row's Scan method is called. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.",
        "name": "sql.DB.QueryRowContext",
        "params": [],
        "path": "go/database/sql/index#DB.QueryRowContext",
        "syntax": "func (db *DB) QueryRowContext(ctx context.Context, query string, args ...interface{}) *Row",
        "type": "database"
    },
    "sql.DB.SetConnMaxLifetime": {
        "descr": "SetConnMaxLifetime sets the maximum amount of time a connection may be reused.",
        "name": "sql.DB.SetConnMaxLifetime",
        "params": [],
        "path": "go/database/sql/index#DB.SetConnMaxLifetime",
        "syntax": "func (db *DB) SetConnMaxLifetime(d time.Duration)",
        "type": "database"
    },
    "sql.DB.SetMaxIdleConns": {
        "descr": "SetMaxIdleConns sets the maximum number of connections in the idle connection pool.",
        "name": "sql.DB.SetMaxIdleConns",
        "params": [],
        "path": "go/database/sql/index#DB.SetMaxIdleConns",
        "syntax": "func (db *DB) SetMaxIdleConns(n int)",
        "type": "database"
    },
    "sql.DB.SetMaxOpenConns": {
        "descr": "SetMaxOpenConns sets the maximum number of open connections to the database.",
        "name": "sql.DB.SetMaxOpenConns",
        "params": [],
        "path": "go/database/sql/index#DB.SetMaxOpenConns",
        "syntax": "func (db *DB) SetMaxOpenConns(n int)",
        "type": "database"
    },
    "sql.DB.Stats": {
        "descr": "Stats returns database statistics.",
        "name": "sql.DB.Stats",
        "params": [],
        "path": "go/database/sql/index#DB.Stats",
        "syntax": "func (db *DB) Stats() DBStats",
        "type": "database"
    },
    "sql.DBStats": {
        "descr": "DBStats contains database statistics.",
        "name": "sql.DBStats",
        "params": [],
        "path": "go/database/sql/index#DBStats",
        "syntax": "type DBStats struct { MaxOpenConnections int // Maximum number of open connections to the database; added in Go 1.11 // Pool Status OpenConnections int // The number of established connections both in use and idle. InUse int // The number of connections currently in use; added in Go 1.11 Idle int // The number of idle connections; added in Go 1.11 // Counters WaitCount int64 // The total number of connections waited for; added in Go 1.11 WaitDuration time.Duration // The total time blocked waiting for a new connection; added in Go 1.11 MaxIdleClosed int64 // The total number of connections closed due to SetMaxIdleConns; added in Go 1.11 MaxLifetimeClosed int64 // The total number of connections closed due to SetConnMaxLifetime; added in Go 1.11 }",
        "type": "database"
    },
    "sql.Drivers": {
        "descr": "Drivers returns a sorted list of the names of the registered drivers.",
        "name": "sql.Drivers",
        "params": [],
        "path": "go/database/sql/index#Drivers",
        "syntax": "func Drivers() []string",
        "type": "database"
    },
    "sql.IsolationLevel": {
        "descr": "IsolationLevel is the transaction isolation level used in TxOptions.",
        "name": "sql.IsolationLevel",
        "params": [],
        "path": "go/database/sql/index#IsolationLevel",
        "syntax": "type IsolationLevel int",
        "type": "database"
    },
    "sql.IsolationLevel.String": {
        "descr": "",
        "name": "sql.IsolationLevel.String",
        "params": [],
        "path": "go/database/sql/index#IsolationLevel.String",
        "syntax": "func (i IsolationLevel) String() string",
        "type": "database"
    },
    "sql.Named": {
        "descr": "Named provides a more concise way to create NamedArg values.",
        "name": "sql.Named",
        "params": [],
        "path": "go/database/sql/index#Named",
        "syntax": "func Named(name string, value interface{}) NamedArg",
        "type": "database"
    },
    "sql.NamedArg": {
        "descr": "A NamedArg is a named argument. NamedArg values may be used as arguments to Query or Exec and bind to the corresponding named parameter in the SQL statement.",
        "name": "sql.NamedArg",
        "params": [],
        "path": "go/database/sql/index#NamedArg",
        "syntax": "type NamedArg struct { // Name is the name of the parameter placeholder. // // If empty, the ordinal position in the argument list will be // used. // // Name must omit any symbol prefix. Name string // Value is the value of the parameter. // It may be assigned the same value types as the query // arguments. Value interface{} // contains filtered or unexported fields }",
        "type": "database"
    },
    "sql.NullBool": {
        "descr": "NullBool represents a bool that may be null. NullBool implements the Scanner interface so it can be used as a scan destination, similar to NullString.",
        "name": "sql.NullBool",
        "params": [],
        "path": "go/database/sql/index#NullBool",
        "syntax": "type NullBool struct { Bool bool Valid bool // Valid is true if Bool is not NULL }",
        "type": "database"
    },
    "sql.NullBool.Scan": {
        "descr": "Scan implements the Scanner interface.",
        "name": "sql.NullBool.Scan",
        "params": [],
        "path": "go/database/sql/index#NullBool.Scan",
        "syntax": "func (n *NullBool) Scan(value interface{}) error",
        "type": "database"
    },
    "sql.NullBool.Value": {
        "descr": "Value implements the driver Valuer interface.",
        "name": "sql.NullBool.Value",
        "params": [],
        "path": "go/database/sql/index#NullBool.Value",
        "syntax": "func (n NullBool) Value() (driver.Value, error)",
        "type": "database"
    },
    "sql.NullFloat64": {
        "descr": "NullFloat64 represents a float64 that may be null. NullFloat64 implements the Scanner interface so it can be used as a scan destination, similar to NullString.",
        "name": "sql.NullFloat64",
        "params": [],
        "path": "go/database/sql/index#NullFloat64",
        "syntax": "type NullFloat64 struct { Float64 float64 Valid bool // Valid is true if Float64 is not NULL }",
        "type": "database"
    },
    "sql.NullFloat64.Scan": {
        "descr": "Scan implements the Scanner interface.",
        "name": "sql.NullFloat64.Scan",
        "params": [],
        "path": "go/database/sql/index#NullFloat64.Scan",
        "syntax": "func (n *NullFloat64) Scan(value interface{}) error",
        "type": "database"
    },
    "sql.NullFloat64.Value": {
        "descr": "Value implements the driver Valuer interface.",
        "name": "sql.NullFloat64.Value",
        "params": [],
        "path": "go/database/sql/index#NullFloat64.Value",
        "syntax": "func (n NullFloat64) Value() (driver.Value, error)",
        "type": "database"
    },
    "sql.NullInt64": {
        "descr": "NullInt64 represents an int64 that may be null. NullInt64 implements the Scanner interface so it can be used as a scan destination, similar to NullString.",
        "name": "sql.NullInt64",
        "params": [],
        "path": "go/database/sql/index#NullInt64",
        "syntax": "type NullInt64 struct { Int64 int64 Valid bool // Valid is true if Int64 is not NULL }",
        "type": "database"
    },
    "sql.NullInt64.Scan": {
        "descr": "Scan implements the Scanner interface.",
        "name": "sql.NullInt64.Scan",
        "params": [],
        "path": "go/database/sql/index#NullInt64.Scan",
        "syntax": "func (n *NullInt64) Scan(value interface{}) error",
        "type": "database"
    },
    "sql.NullInt64.Value": {
        "descr": "Value implements the driver Valuer interface.",
        "name": "sql.NullInt64.Value",
        "params": [],
        "path": "go/database/sql/index#NullInt64.Value",
        "syntax": "func (n NullInt64) Value() (driver.Value, error)",
        "type": "database"
    },
    "sql.NullString": {
        "descr": "NullString represents a string that may be null. NullString implements the Scanner interface so it can be used as a scan destination:",
        "name": "sql.NullString",
        "params": [],
        "path": "go/database/sql/index#NullString",
        "syntax": "var s NullString err := db.QueryRow(\"SELECT name FROM foo WHERE id=?\", id).Scan(&s) ... if s.Valid { // use s.String } else { // NULL value }",
        "type": "database"
    },
    "sql.NullString.Scan": {
        "descr": "Scan implements the Scanner interface.",
        "name": "sql.NullString.Scan",
        "params": [],
        "path": "go/database/sql/index#NullString.Scan",
        "syntax": "func (ns *NullString) Scan(value interface{}) error",
        "type": "database"
    },
    "sql.NullString.Value": {
        "descr": "Value implements the driver Valuer interface.",
        "name": "sql.NullString.Value",
        "params": [],
        "path": "go/database/sql/index#NullString.Value",
        "syntax": "func (ns NullString) Value() (driver.Value, error)",
        "type": "database"
    },
    "sql.Open": {
        "descr": "Open opens a database specified by its database driver name and a driver-specific data source name, usually consisting of at least a database name and connection information.",
        "name": "sql.Open",
        "params": [],
        "path": "go/database/sql/index#Open",
        "syntax": "func Open(driverName, dataSourceName string) (*DB, error)",
        "type": "database"
    },
    "sql.OpenDB": {
        "descr": "OpenDB opens a database using a Connector, allowing drivers to bypass a string based data source name.",
        "name": "sql.OpenDB",
        "params": [],
        "path": "go/database/sql/index#OpenDB",
        "syntax": "func OpenDB(c driver.Connector) *DB",
        "type": "database"
    },
    "sql.Out": {
        "descr": "Out may be used to retrieve OUTPUT value parameters from stored procedures.",
        "name": "sql.Out",
        "params": [],
        "path": "go/database/sql/index#Out",
        "syntax": "var outArg string _, err := db.ExecContext(ctx, \"ProcName\", sql.Named(\"Arg1\", sql.Out{Dest: &outArg}))",
        "type": "database"
    },
    "sql.RawBytes": {
        "descr": "RawBytes is a byte slice that holds a reference to memory owned by the database itself. After a Scan into a RawBytes, the slice is only valid until the next call to Next, Scan, or Close.",
        "name": "sql.RawBytes",
        "params": [],
        "path": "go/database/sql/index#RawBytes",
        "syntax": "type RawBytes []byte",
        "type": "database"
    },
    "sql.Register": {
        "descr": "Register makes a database driver available by the provided name. If Register is called twice with the same name or if driver is nil, it panics.",
        "name": "sql.Register",
        "params": [],
        "path": "go/database/sql/index#Register",
        "syntax": "func Register(name string, driver driver.Driver)",
        "type": "database"
    },
    "sql.Result": {
        "descr": "A Result summarizes an executed SQL command.",
        "name": "sql.Result",
        "params": [],
        "path": "go/database/sql/index#Result",
        "syntax": "type Result interface { // LastInsertId returns the integer generated by the database // in response to a command. Typically this will be from an // \"auto increment\" column when inserting a new row. Not all // databases support this feature, and the syntax of such // statements varies. LastInsertId() (int64, error) // RowsAffected returns the number of rows affected by an // update, insert, or delete. Not every database or database // driver may support this. RowsAffected() (int64, error) }",
        "type": "database"
    },
    "sql.Row": {
        "descr": "Row is the result of calling QueryRow to select a single row.",
        "name": "sql.Row",
        "params": [],
        "path": "go/database/sql/index#Row",
        "syntax": "type Row struct { // contains filtered or unexported fields }",
        "type": "database"
    },
    "sql.Row.Scan": {
        "descr": "Scan copies the columns from the matched row into the values pointed at by dest. See the documentation on Rows.Scan for details. If more than one row matches the query, Scan uses the first row and discards the rest. If no row matches the query, Scan returns ErrNoRows.",
        "name": "sql.Row.Scan",
        "params": [],
        "path": "go/database/sql/index#Row.Scan",
        "syntax": "func (r *Row) Scan(dest ...interface{}) error",
        "type": "database"
    },
    "sql.Rows": {
        "descr": "Rows is the result of a query. Its cursor starts before the first row of the result set. Use Next to advance from row to row.",
        "name": "sql.Rows",
        "params": [],
        "path": "go/database/sql/index#Rows",
        "syntax": "type Rows struct { // contains filtered or unexported fields }",
        "type": "database"
    },
    "sql.Rows.Close": {
        "descr": "Close closes the Rows, preventing further enumeration. If Next is called and returns false and there are no further result sets, the Rows are closed automatically and it will suffice to check the result of Err. Close is idempotent and does not affect the result of Err.",
        "name": "sql.Rows.Close",
        "params": [],
        "path": "go/database/sql/index#Rows.Close",
        "syntax": "func (rs *Rows) Close() error",
        "type": "database"
    },
    "sql.Rows.ColumnTypes": {
        "descr": "ColumnTypes returns column information such as column type, length, and nullable. Some information may not be available from some drivers.",
        "name": "sql.Rows.ColumnTypes",
        "params": [],
        "path": "go/database/sql/index#Rows.ColumnTypes",
        "syntax": "func (rs *Rows) ColumnTypes() ([]*ColumnType, error)",
        "type": "database"
    },
    "sql.Rows.Columns": {
        "descr": "Columns returns the column names. Columns returns an error if the rows are closed, or if the rows are from QueryRow and there was a deferred error.",
        "name": "sql.Rows.Columns",
        "params": [],
        "path": "go/database/sql/index#Rows.Columns",
        "syntax": "func (rs *Rows) Columns() ([]string, error)",
        "type": "database"
    },
    "sql.Rows.Err": {
        "descr": "Err returns the error, if any, that was encountered during iteration. Err may be called after an explicit or implicit Close.",
        "name": "sql.Rows.Err",
        "params": [],
        "path": "go/database/sql/index#Rows.Err",
        "syntax": "func (rs *Rows) Err() error",
        "type": "database"
    },
    "sql.Rows.Next": {
        "descr": "Next prepares the next result row for reading with the Scan method. It returns true on success, or false if there is no next result row or an error happened while preparing it. Err should be consulted to distinguish between the two cases.",
        "name": "sql.Rows.Next",
        "params": [],
        "path": "go/database/sql/index#Rows.Next",
        "syntax": "func (rs *Rows) Next() bool",
        "type": "database"
    },
    "sql.Rows.NextResultSet": {
        "descr": "NextResultSet prepares the next result set for reading. It returns true if there is further result sets, or false if there is no further result set or if there is an error advancing to it. The Err method should be consulted to distinguish between the two cases.",
        "name": "sql.Rows.NextResultSet",
        "params": [],
        "path": "go/database/sql/index#Rows.NextResultSet",
        "syntax": "func (rs *Rows) NextResultSet() bool",
        "type": "database"
    },
    "sql.Rows.Scan": {
        "descr": "Scan copies the columns in the current row into the values pointed at by dest. The number of values in dest must be the same as the number of columns in Rows.",
        "name": "sql.Rows.Scan",
        "params": [],
        "path": "go/database/sql/index#Rows.Scan",
        "syntax": "func (rs *Rows) Scan(dest ...interface{}) error",
        "type": "database"
    },
    "sql.Scanner": {
        "descr": "Scanner is an interface used by Scan.",
        "name": "sql.Scanner",
        "params": [],
        "path": "go/database/sql/index#Scanner",
        "syntax": "type Scanner interface { // Scan assigns a value from a database driver. // // The src value will be of one of the following types: // // int64 // float64 // bool // []byte // string // time.Time // nil - for NULL values // // An error should be returned if the value cannot be stored // without loss of information. // // Reference types such as []byte are only valid until the next call to Scan // and should not be retained. Their underlying memory is owned by the driver. // If retention is necessary, copy their values before the next call to Scan. Scan(src interface{}) error }",
        "type": "database"
    },
    "sql.Stmt": {
        "descr": "Stmt is a prepared statement. A Stmt is safe for concurrent use by multiple goroutines.",
        "name": "sql.Stmt",
        "params": [],
        "path": "go/database/sql/index#Stmt",
        "syntax": "type Stmt struct { // contains filtered or unexported fields }",
        "type": "database"
    },
    "sql.Stmt.Close": {
        "descr": "Close closes the statement.",
        "name": "sql.Stmt.Close",
        "params": [],
        "path": "go/database/sql/index#Stmt.Close",
        "syntax": "func (s *Stmt) Close() error",
        "type": "database"
    },
    "sql.Stmt.Exec": {
        "descr": "Exec executes a prepared statement with the given arguments and returns a Result summarizing the effect of the statement.",
        "name": "sql.Stmt.Exec",
        "params": [],
        "path": "go/database/sql/index#Stmt.Exec",
        "syntax": "func (s *Stmt) Exec(args ...interface{}) (Result, error)",
        "type": "database"
    },
    "sql.Stmt.ExecContext": {
        "descr": "ExecContext executes a prepared statement with the given arguments and returns a Result summarizing the effect of the statement.",
        "name": "sql.Stmt.ExecContext",
        "params": [],
        "path": "go/database/sql/index#Stmt.ExecContext",
        "syntax": "func (s *Stmt) ExecContext(ctx context.Context, args ...interface{}) (Result, error)",
        "type": "database"
    },
    "sql.Stmt.Query": {
        "descr": "Query executes a prepared query statement with the given arguments and returns the query results as a *Rows.",
        "name": "sql.Stmt.Query",
        "params": [],
        "path": "go/database/sql/index#Stmt.Query",
        "syntax": "func (s *Stmt) Query(args ...interface{}) (*Rows, error)",
        "type": "database"
    },
    "sql.Stmt.QueryContext": {
        "descr": "QueryContext executes a prepared query statement with the given arguments and returns the query results as a *Rows.",
        "name": "sql.Stmt.QueryContext",
        "params": [],
        "path": "go/database/sql/index#Stmt.QueryContext",
        "syntax": "func (s *Stmt) QueryContext(ctx context.Context, args ...interface{}) (*Rows, error)",
        "type": "database"
    },
    "sql.Stmt.QueryRow": {
        "descr": "QueryRow executes a prepared query statement with the given arguments. If an error occurs during the execution of the statement, that error will be returned by a call to Scan on the returned *Row, which is always non-nil. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.",
        "name": "sql.Stmt.QueryRow",
        "params": [],
        "path": "go/database/sql/index#Stmt.QueryRow",
        "syntax": "func (s *Stmt) QueryRow(args ...interface{}) *Row",
        "type": "database"
    },
    "sql.Stmt.QueryRowContext": {
        "descr": "QueryRowContext executes a prepared query statement with the given arguments. If an error occurs during the execution of the statement, that error will be returned by a call to Scan on the returned *Row, which is always non-nil. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.",
        "name": "sql.Stmt.QueryRowContext",
        "params": [],
        "path": "go/database/sql/index#Stmt.QueryRowContext",
        "syntax": "func (s *Stmt) QueryRowContext(ctx context.Context, args ...interface{}) *Row",
        "type": "database"
    },
    "sql.Tx": {
        "descr": "Tx is an in-progress database transaction.",
        "name": "sql.Tx",
        "params": [],
        "path": "go/database/sql/index#Tx",
        "syntax": "type Tx struct { // contains filtered or unexported fields }",
        "type": "database"
    },
    "sql.Tx.Commit": {
        "descr": "Commit commits the transaction.",
        "name": "sql.Tx.Commit",
        "params": [],
        "path": "go/database/sql/index#Tx.Commit",
        "syntax": "func (tx *Tx) Commit() error",
        "type": "database"
    },
    "sql.Tx.Exec": {
        "descr": "Exec executes a query that doesn't return rows. For example: an INSERT and UPDATE.",
        "name": "sql.Tx.Exec",
        "params": [],
        "path": "go/database/sql/index#Tx.Exec",
        "syntax": "func (tx *Tx) Exec(query string, args ...interface{}) (Result, error)",
        "type": "database"
    },
    "sql.Tx.ExecContext": {
        "descr": "ExecContext executes a query that doesn't return rows. For example: an INSERT and UPDATE.",
        "name": "sql.Tx.ExecContext",
        "params": [],
        "path": "go/database/sql/index#Tx.ExecContext",
        "syntax": "func (tx *Tx) ExecContext(ctx context.Context, query string, args ...interface{}) (Result, error)",
        "type": "database"
    },
    "sql.Tx.Prepare": {
        "descr": "Prepare creates a prepared statement for use within a transaction.",
        "name": "sql.Tx.Prepare",
        "params": [],
        "path": "go/database/sql/index#Tx.Prepare",
        "syntax": "func (tx *Tx) Prepare(query string) (*Stmt, error)",
        "type": "database"
    },
    "sql.Tx.PrepareContext": {
        "descr": "PrepareContext creates a prepared statement for use within a transaction.",
        "name": "sql.Tx.PrepareContext",
        "params": [],
        "path": "go/database/sql/index#Tx.PrepareContext",
        "syntax": "func (tx *Tx) PrepareContext(ctx context.Context, query string) (*Stmt, error)",
        "type": "database"
    },
    "sql.Tx.Query": {
        "descr": "Query executes a query that returns rows, typically a SELECT.",
        "name": "sql.Tx.Query",
        "params": [],
        "path": "go/database/sql/index#Tx.Query",
        "syntax": "func (tx *Tx) Query(query string, args ...interface{}) (*Rows, error)",
        "type": "database"
    },
    "sql.Tx.QueryContext": {
        "descr": "QueryContext executes a query that returns rows, typically a SELECT.",
        "name": "sql.Tx.QueryContext",
        "params": [],
        "path": "go/database/sql/index#Tx.QueryContext",
        "syntax": "func (tx *Tx) QueryContext(ctx context.Context, query string, args ...interface{}) (*Rows, error)",
        "type": "database"
    },
    "sql.Tx.QueryRow": {
        "descr": "QueryRow executes a query that is expected to return at most one row. QueryRow always returns a non-nil value. Errors are deferred until Row's Scan method is called. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.",
        "name": "sql.Tx.QueryRow",
        "params": [],
        "path": "go/database/sql/index#Tx.QueryRow",
        "syntax": "func (tx *Tx) QueryRow(query string, args ...interface{}) *Row",
        "type": "database"
    },
    "sql.Tx.QueryRowContext": {
        "descr": "QueryRowContext executes a query that is expected to return at most one row. QueryRowContext always returns a non-nil value. Errors are deferred until Row's Scan method is called. If the query selects no rows, the *Row's Scan will return ErrNoRows. Otherwise, the *Row's Scan scans the first selected row and discards the rest.",
        "name": "sql.Tx.QueryRowContext",
        "params": [],
        "path": "go/database/sql/index#Tx.QueryRowContext",
        "syntax": "func (tx *Tx) QueryRowContext(ctx context.Context, query string, args ...interface{}) *Row",
        "type": "database"
    },
    "sql.Tx.Rollback": {
        "descr": "Rollback aborts the transaction.",
        "name": "sql.Tx.Rollback",
        "params": [],
        "path": "go/database/sql/index#Tx.Rollback",
        "syntax": "func (tx *Tx) Rollback() error",
        "type": "database"
    },
    "sql.Tx.Stmt": {
        "descr": "Stmt returns a transaction-specific prepared statement from an existing statement.",
        "name": "sql.Tx.Stmt",
        "params": [],
        "path": "go/database/sql/index#Tx.Stmt",
        "syntax": "func (tx *Tx) Stmt(stmt *Stmt) *Stmt",
        "type": "database"
    },
    "sql.Tx.StmtContext": {
        "descr": "StmtContext returns a transaction-specific prepared statement from an existing statement.",
        "name": "sql.Tx.StmtContext",
        "params": [],
        "path": "go/database/sql/index#Tx.StmtContext",
        "syntax": "func (tx *Tx) StmtContext(ctx context.Context, stmt *Stmt) *Stmt",
        "type": "database"
    },
    "sql.TxOptions": {
        "descr": "TxOptions holds the transaction options to be used in DB.BeginTx.",
        "name": "sql.TxOptions",
        "params": [],
        "path": "go/database/sql/index#TxOptions",
        "syntax": "type TxOptions struct { // Isolation is the transaction isolation level. // If zero, the driver or database's default level is used. Isolation IsolationLevel ReadOnly bool }",
        "type": "database"
    },
    "strconv": {
        "descr": "ErrRange indicates that a value is out of range for the target type.",
        "name": "strconv",
        "params": [],
        "path": "go/strconv/index#pkg-variables",
        "syntax": "var ErrRange = errors.New(\"value out of range\")",
        "type": "strconv"
    },
    "strconv.AppendBool": {
        "descr": "AppendBool appends \"true\" or \"false\", according to the value of b, to dst and returns the extended buffer.",
        "name": "strconv.AppendBool",
        "params": [],
        "path": "go/strconv/index#AppendBool",
        "syntax": "func AppendBool(dst []byte, b bool) []byte",
        "type": "strconv"
    },
    "strconv.AppendFloat": {
        "descr": "AppendFloat appends the string form of the floating-point number f, as generated by FormatFloat, to dst and returns the extended buffer.",
        "name": "strconv.AppendFloat",
        "params": [],
        "path": "go/strconv/index#AppendFloat",
        "syntax": "func AppendFloat(dst []byte, f float64, fmt byte, prec, bitSize int) []byte",
        "type": "strconv"
    },
    "strconv.AppendInt": {
        "descr": "AppendInt appends the string form of the integer i, as generated by FormatInt, to dst and returns the extended buffer.",
        "name": "strconv.AppendInt",
        "params": [],
        "path": "go/strconv/index#AppendInt",
        "syntax": "func AppendInt(dst []byte, i int64, base int) []byte",
        "type": "strconv"
    },
    "strconv.AppendQuote": {
        "descr": "AppendQuote appends a double-quoted Go string literal representing s, as generated by Quote, to dst and returns the extended buffer.",
        "name": "strconv.AppendQuote",
        "params": [],
        "path": "go/strconv/index#AppendQuote",
        "syntax": "func AppendQuote(dst []byte, s string) []byte",
        "type": "strconv"
    },
    "strconv.AppendQuoteRune": {
        "descr": "AppendQuoteRune appends a single-quoted Go character literal representing the rune, as generated by QuoteRune, to dst and returns the extended buffer.",
        "name": "strconv.AppendQuoteRune",
        "params": [],
        "path": "go/strconv/index#AppendQuoteRune",
        "syntax": "func AppendQuoteRune(dst []byte, r rune) []byte",
        "type": "strconv"
    },
    "strconv.AppendQuoteRuneToASCII": {
        "descr": "AppendQuoteRuneToASCII appends a single-quoted Go character literal representing the rune, as generated by QuoteRuneToASCII, to dst and returns the extended buffer.",
        "name": "strconv.AppendQuoteRuneToASCII",
        "params": [],
        "path": "go/strconv/index#AppendQuoteRuneToASCII",
        "syntax": "func AppendQuoteRuneToASCII(dst []byte, r rune) []byte",
        "type": "strconv"
    },
    "strconv.AppendQuoteRuneToGraphic": {
        "descr": "AppendQuoteRuneToGraphic appends a single-quoted Go character literal representing the rune, as generated by QuoteRuneToGraphic, to dst and returns the extended buffer.",
        "name": "strconv.AppendQuoteRuneToGraphic",
        "params": [],
        "path": "go/strconv/index#AppendQuoteRuneToGraphic",
        "syntax": "func AppendQuoteRuneToGraphic(dst []byte, r rune) []byte",
        "type": "strconv"
    },
    "strconv.AppendQuoteToASCII": {
        "descr": "AppendQuoteToASCII appends a double-quoted Go string literal representing s, as generated by QuoteToASCII, to dst and returns the extended buffer.",
        "name": "strconv.AppendQuoteToASCII",
        "params": [],
        "path": "go/strconv/index#AppendQuoteToASCII",
        "syntax": "func AppendQuoteToASCII(dst []byte, s string) []byte",
        "type": "strconv"
    },
    "strconv.AppendQuoteToGraphic": {
        "descr": "AppendQuoteToGraphic appends a double-quoted Go string literal representing s, as generated by QuoteToGraphic, to dst and returns the extended buffer.",
        "name": "strconv.AppendQuoteToGraphic",
        "params": [],
        "path": "go/strconv/index#AppendQuoteToGraphic",
        "syntax": "func AppendQuoteToGraphic(dst []byte, s string) []byte",
        "type": "strconv"
    },
    "strconv.AppendUint": {
        "descr": "AppendUint appends the string form of the unsigned integer i, as generated by FormatUint, to dst and returns the extended buffer.",
        "name": "strconv.AppendUint",
        "params": [],
        "path": "go/strconv/index#AppendUint",
        "syntax": "func AppendUint(dst []byte, i uint64, base int) []byte",
        "type": "strconv"
    },
    "strconv.Atoi": {
        "descr": "Atoi returns the result of ParseInt(s, 10, 0) converted to type int.",
        "name": "strconv.Atoi",
        "params": [],
        "path": "go/strconv/index#Atoi",
        "syntax": "func Atoi(s string) (int, error)",
        "type": "strconv"
    },
    "strconv.CanBackquote": {
        "descr": "CanBackquote reports whether the string s can be represented unchanged as a single-line backquoted string without control characters other than tab.",
        "name": "strconv.CanBackquote",
        "params": [],
        "path": "go/strconv/index#CanBackquote",
        "syntax": "func CanBackquote(s string) bool",
        "type": "strconv"
    },
    "strconv.FormatBool": {
        "descr": "FormatBool returns \"true\" or \"false\" according to the value of b.",
        "name": "strconv.FormatBool",
        "params": [],
        "path": "go/strconv/index#FormatBool",
        "syntax": "func FormatBool(b bool) string",
        "type": "strconv"
    },
    "strconv.FormatFloat": {
        "descr": "FormatFloat converts the floating-point number f to a string, according to the format fmt and precision prec. It rounds the result assuming that the original was obtained from a floating-point value of bitSize bits (32 for float32, 64 for float64).",
        "name": "strconv.FormatFloat",
        "params": [],
        "path": "go/strconv/index#FormatFloat",
        "syntax": "func FormatFloat(f float64, fmt byte, prec, bitSize int) string",
        "type": "strconv"
    },
    "strconv.FormatInt": {
        "descr": "FormatInt returns the string representation of i in the given base, for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z' for digit values >= 10.",
        "name": "strconv.FormatInt",
        "params": [],
        "path": "go/strconv/index#FormatInt",
        "syntax": "func FormatInt(i int64, base int) string",
        "type": "strconv"
    },
    "strconv.FormatUint": {
        "descr": "FormatUint returns the string representation of i in the given base, for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z' for digit values >= 10.",
        "name": "strconv.FormatUint",
        "params": [],
        "path": "go/strconv/index#FormatUint",
        "syntax": "func FormatUint(i uint64, base int) string",
        "type": "strconv"
    },
    "strconv.IsGraphic": {
        "descr": "IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such characters include letters, marks, numbers, punctuation, symbols, and spaces, from categories L, M, N, P, S, and Zs.",
        "name": "strconv.IsGraphic",
        "params": [],
        "path": "go/strconv/index#IsGraphic",
        "syntax": "func IsGraphic(r rune) bool",
        "type": "strconv"
    },
    "strconv.IsPrint": {
        "descr": "IsPrint reports whether the rune is defined as printable by Go, with the same definition as unicode.IsPrint: letters, numbers, punctuation, symbols and ASCII space.",
        "name": "strconv.IsPrint",
        "params": [],
        "path": "go/strconv/index#IsPrint",
        "syntax": "func IsPrint(r rune) bool",
        "type": "strconv"
    },
    "strconv.Itoa": {
        "descr": "Itoa is shorthand for FormatInt(int64(i), 10).",
        "name": "strconv.Itoa",
        "params": [],
        "path": "go/strconv/index#Itoa",
        "syntax": "func Itoa(i int) string",
        "type": "strconv"
    },
    "strconv.NumError": {
        "descr": "A NumError records a failed conversion.",
        "name": "strconv.NumError",
        "params": [],
        "path": "go/strconv/index#NumError",
        "syntax": "type NumError struct { Func string // the failing function (ParseBool, ParseInt, ParseUint, ParseFloat) Num string // the input Err error // the reason the conversion failed (e.g. ErrRange, ErrSyntax, etc.) }",
        "type": "strconv"
    },
    "strconv.NumError.Error": {
        "descr": "",
        "name": "strconv.NumError.Error",
        "params": [],
        "path": "go/strconv/index#NumError.Error",
        "syntax": "func (e *NumError) Error() string",
        "type": "strconv"
    },
    "strconv.ParseBool": {
        "descr": "ParseBool returns the boolean value represented by the string. It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False. Any other value returns an error.",
        "name": "strconv.ParseBool",
        "params": [],
        "path": "go/strconv/index#ParseBool",
        "syntax": "func ParseBool(str string) (bool, error)",
        "type": "strconv"
    },
    "strconv.ParseFloat": {
        "descr": "ParseFloat converts the string s to a floating-point number with the precision specified by bitSize: 32 for float32, or 64 for float64. When bitSize=32, the result still has type float64, but it will be convertible to float32 without changing its value.",
        "name": "strconv.ParseFloat",
        "params": [],
        "path": "go/strconv/index#ParseFloat",
        "syntax": "func ParseFloat(s string, bitSize int) (float64, error)",
        "type": "strconv"
    },
    "strconv.ParseInt": {
        "descr": "ParseInt interprets a string s in the given base (0, 2 to 36) and bit size (0 to 64) and returns the corresponding value i.",
        "name": "strconv.ParseInt",
        "params": [],
        "path": "go/strconv/index#ParseInt",
        "syntax": "func ParseInt(s string, base int, bitSize int) (i int64, err error)",
        "type": "strconv"
    },
    "strconv.ParseUint": {
        "descr": "ParseUint is like ParseInt but for unsigned numbers.",
        "name": "strconv.ParseUint",
        "params": [],
        "path": "go/strconv/index#ParseUint",
        "syntax": "func ParseUint(s string, base int, bitSize int) (uint64, error)",
        "type": "strconv"
    },
    "strconv.Quote": {
        "descr": "Quote returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for control characters and non-printable characters as defined by IsPrint.",
        "name": "strconv.Quote",
        "params": [],
        "path": "go/strconv/index#Quote",
        "syntax": "func Quote(s string) string",
        "type": "strconv"
    },
    "strconv.QuoteRune": {
        "descr": "QuoteRune returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for control characters and non-printable characters as defined by IsPrint.",
        "name": "strconv.QuoteRune",
        "params": [],
        "path": "go/strconv/index#QuoteRune",
        "syntax": "func QuoteRune(r rune) string",
        "type": "strconv"
    },
    "strconv.QuoteRuneToASCII": {
        "descr": "QuoteRuneToASCII returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for non-ASCII characters and non-printable characters as defined by IsPrint.",
        "name": "strconv.QuoteRuneToASCII",
        "params": [],
        "path": "go/strconv/index#QuoteRuneToASCII",
        "syntax": "func QuoteRuneToASCII(r rune) string",
        "type": "strconv"
    },
    "strconv.QuoteRuneToGraphic": {
        "descr": "QuoteRuneToGraphic returns a single-quoted Go character literal representing the rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for non-ASCII characters and non-printable characters as defined by IsGraphic.",
        "name": "strconv.QuoteRuneToGraphic",
        "params": [],
        "path": "go/strconv/index#QuoteRuneToGraphic",
        "syntax": "func QuoteRuneToGraphic(r rune) string",
        "type": "strconv"
    },
    "strconv.QuoteToASCII": {
        "descr": "QuoteToASCII returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for non-ASCII characters and non-printable characters as defined by IsPrint.",
        "name": "strconv.QuoteToASCII",
        "params": [],
        "path": "go/strconv/index#QuoteToASCII",
        "syntax": "func QuoteToASCII(s string) string",
        "type": "strconv"
    },
    "strconv.QuoteToGraphic": {
        "descr": "QuoteToGraphic returns a double-quoted Go string literal representing s. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for non-ASCII characters and non-printable characters as defined by IsGraphic.",
        "name": "strconv.QuoteToGraphic",
        "params": [],
        "path": "go/strconv/index#QuoteToGraphic",
        "syntax": "func QuoteToGraphic(s string) string",
        "type": "strconv"
    },
    "strconv.Unquote": {
        "descr": "Unquote interprets s as a single-quoted, double-quoted, or backquoted Go string literal, returning the string value that s quotes. (If s is single-quoted, it would be a Go character literal; Unquote returns the corresponding one-character string.)",
        "name": "strconv.Unquote",
        "params": [],
        "path": "go/strconv/index#Unquote",
        "syntax": "func Unquote(s string) (string, error)",
        "type": "strconv"
    },
    "strconv.UnquoteChar": {
        "descr": "UnquoteChar decodes the first character or byte in the escaped string or character literal represented by the string s. It returns four values:",
        "name": "strconv.UnquoteChar",
        "params": [],
        "path": "go/strconv/index#UnquoteChar",
        "syntax": "func UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string, err error)",
        "type": "strconv"
    },
    "string": {
        "descr": "",
        "name": "syscall.string",
        "params": [],
        "path": "go/syscall/index#Mount",
        "syntax": "func Mount(source string, target string, fstype string, flags uintptr, data string) (err error)",
        "type": "syscall"
    },
    "strings.Builder": {
        "descr": "A Builder is used to efficiently build a string using Write methods. It minimizes memory copying. The zero value is ready to use. Do not copy a non-zero Builder.",
        "name": "strings.Builder",
        "params": [],
        "path": "go/strings/index#Builder",
        "syntax": "type Builder struct { // contains filtered or unexported fields }",
        "type": "strings"
    },
    "strings.Builder.Grow": {
        "descr": "Grow grows b's capacity, if necessary, to guarantee space for another n bytes. After Grow(n), at least n bytes can be written to b without another allocation. If n is negative, Grow panics.",
        "name": "strings.Builder.Grow",
        "params": [],
        "path": "go/strings/index#Builder.Grow",
        "syntax": "func (b *Builder) Grow(n int)",
        "type": "strings"
    },
    "strings.Builder.Len": {
        "descr": "Len returns the number of accumulated bytes; b.Len() == len(b.String()).",
        "name": "strings.Builder.Len",
        "params": [],
        "path": "go/strings/index#Builder.Len",
        "syntax": "func (b *Builder) Len() int",
        "type": "strings"
    },
    "strings.Builder.Reset": {
        "descr": "Reset resets the Builder to be empty.",
        "name": "strings.Builder.Reset",
        "params": [],
        "path": "go/strings/index#Builder.Reset",
        "syntax": "func (b *Builder) Reset()",
        "type": "strings"
    },
    "strings.Builder.String": {
        "descr": "String returns the accumulated string.",
        "name": "strings.Builder.String",
        "params": [],
        "path": "go/strings/index#Builder.String",
        "syntax": "func (b *Builder) String() string",
        "type": "strings"
    },
    "strings.Builder.Write": {
        "descr": "Write appends the contents of p to b's buffer. Write always returns len(p), nil.",
        "name": "strings.Builder.Write",
        "params": [],
        "path": "go/strings/index#Builder.Write",
        "syntax": "func (b *Builder) Write(p []byte) (int, error)",
        "type": "strings"
    },
    "strings.Builder.WriteByte": {
        "descr": "WriteByte appends the byte c to b's buffer. The returned error is always nil.",
        "name": "strings.Builder.WriteByte",
        "params": [],
        "path": "go/strings/index#Builder.WriteByte",
        "syntax": "func (b *Builder) WriteByte(c byte) error",
        "type": "strings"
    },
    "strings.Builder.WriteRune": {
        "descr": "WriteRune appends the UTF-8 encoding of Unicode code point r to b's buffer. It returns the length of r and a nil error.",
        "name": "strings.Builder.WriteRune",
        "params": [],
        "path": "go/strings/index#Builder.WriteRune",
        "syntax": "func (b *Builder) WriteRune(r rune) (int, error)",
        "type": "strings"
    },
    "strings.Builder.WriteString": {
        "descr": "WriteString appends the contents of s to b's buffer. It returns the length of s and a nil error.",
        "name": "strings.Builder.WriteString",
        "params": [],
        "path": "go/strings/index#Builder.WriteString",
        "syntax": "func (b *Builder) WriteString(s string) (int, error)",
        "type": "strings"
    },
    "strings.Compare": {
        "descr": "Compare returns an integer comparing two strings lexicographically. The result will be 0 if a==b, -1 if a < b, and +1 if a > b.",
        "name": "strings.Compare",
        "params": [],
        "path": "go/strings/index#Compare",
        "syntax": "func Compare(a, b string) int",
        "type": "strings"
    },
    "strings.Contains": {
        "descr": "Contains reports whether substr is within s.",
        "name": "strings.Contains",
        "params": [],
        "path": "go/strings/index#Contains",
        "syntax": "func Contains(s, substr string) bool",
        "type": "strings"
    },
    "strings.ContainsAny": {
        "descr": "ContainsAny reports whether any Unicode code points in chars are within s.",
        "name": "strings.ContainsAny",
        "params": [],
        "path": "go/strings/index#ContainsAny",
        "syntax": "func ContainsAny(s, chars string) bool",
        "type": "strings"
    },
    "strings.ContainsRune": {
        "descr": "ContainsRune reports whether the Unicode code point r is within s.",
        "name": "strings.ContainsRune",
        "params": [],
        "path": "go/strings/index#ContainsRune",
        "syntax": "func ContainsRune(s string, r rune) bool",
        "type": "strings"
    },
    "strings.Count": {
        "descr": "Count counts the number of non-overlapping instances of substr in s. If substr is an empty string, Count returns 1 + the number of Unicode code points in s.",
        "name": "strings.Count",
        "params": [],
        "path": "go/strings/index#Count",
        "syntax": "func Count(s, substr string) int",
        "type": "strings"
    },
    "strings.EqualFold": {
        "descr": "EqualFold reports whether s and t, interpreted as UTF-8 strings, are equal under Unicode case-folding.",
        "name": "strings.EqualFold",
        "params": [],
        "path": "go/strings/index#EqualFold",
        "syntax": "func EqualFold(s, t string) bool",
        "type": "strings"
    },
    "strings.Fields": {
        "descr": "Fields splits the string s around each instance of one or more consecutive white space characters, as defined by unicode.IsSpace, returning a slice of substrings of s or an empty slice if s contains only white space.",
        "name": "strings.Fields",
        "params": [],
        "path": "go/strings/index#Fields",
        "syntax": "func Fields(s string) []string",
        "type": "strings"
    },
    "strings.FieldsFunc": {
        "descr": "FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c) and returns an array of slices of s. If all code points in s satisfy f(c) or the string is empty, an empty slice is returned. FieldsFunc makes no guarantees about the order in which it calls f(c). If f does not return consistent results for a given c, FieldsFunc may crash.",
        "name": "strings.FieldsFunc",
        "params": [],
        "path": "go/strings/index#FieldsFunc",
        "syntax": "func FieldsFunc(s string, f func(rune) bool) []string",
        "type": "strings"
    },
    "strings.HasPrefix": {
        "descr": "HasPrefix tests whether the string s begins with prefix.",
        "name": "strings.HasPrefix",
        "params": [],
        "path": "go/strings/index#HasPrefix",
        "syntax": "func HasPrefix(s, prefix string) bool",
        "type": "strings"
    },
    "strings.HasSuffix": {
        "descr": "HasSuffix tests whether the string s ends with suffix.",
        "name": "strings.HasSuffix",
        "params": [],
        "path": "go/strings/index#HasSuffix",
        "syntax": "func HasSuffix(s, suffix string) bool",
        "type": "strings"
    },
    "strings.Index": {
        "descr": "Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.",
        "name": "strings.Index",
        "params": [],
        "path": "go/strings/index#Index",
        "syntax": "func Index(s, substr string) int",
        "type": "strings"
    },
    "strings.IndexAny": {
        "descr": "IndexAny returns the index of the first instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s.",
        "name": "strings.IndexAny",
        "params": [],
        "path": "go/strings/index#IndexAny",
        "syntax": "func IndexAny(s, chars string) int",
        "type": "strings"
    },
    "strings.IndexByte": {
        "descr": "IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.",
        "name": "strings.IndexByte",
        "params": [],
        "path": "go/strings/index#IndexByte",
        "syntax": "func IndexByte(s string, c byte) int",
        "type": "strings"
    },
    "strings.IndexFunc": {
        "descr": "IndexFunc returns the index into s of the first Unicode code point satisfying f(c), or -1 if none do.",
        "name": "strings.IndexFunc",
        "params": [],
        "path": "go/strings/index#IndexFunc",
        "syntax": "func IndexFunc(s string, f func(rune) bool) int",
        "type": "strings"
    },
    "strings.IndexRune": {
        "descr": "IndexRune returns the index of the first instance of the Unicode code point r, or -1 if rune is not present in s. If r is utf8.RuneError, it returns the first instance of any invalid UTF-8 byte sequence.",
        "name": "strings.IndexRune",
        "params": [],
        "path": "go/strings/index#IndexRune",
        "syntax": "func IndexRune(s string, r rune) int",
        "type": "strings"
    },
    "strings.Join": {
        "descr": "Join concatenates the elements of a to create a single string. The separator string sep is placed between elements in the resulting string.",
        "name": "strings.Join",
        "params": [],
        "path": "go/strings/index#Join",
        "syntax": "func Join(a []string, sep string) string",
        "type": "strings"
    },
    "strings.LastIndex": {
        "descr": "LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.",
        "name": "strings.LastIndex",
        "params": [],
        "path": "go/strings/index#LastIndex",
        "syntax": "func LastIndex(s, substr string) int",
        "type": "strings"
    },
    "strings.LastIndexAny": {
        "descr": "LastIndexAny returns the index of the last instance of any Unicode code point from chars in s, or -1 if no Unicode code point from chars is present in s.",
        "name": "strings.LastIndexAny",
        "params": [],
        "path": "go/strings/index#LastIndexAny",
        "syntax": "func LastIndexAny(s, chars string) int",
        "type": "strings"
    },
    "strings.LastIndexByte": {
        "descr": "LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.",
        "name": "strings.LastIndexByte",
        "params": [],
        "path": "go/strings/index#LastIndexByte",
        "syntax": "func LastIndexByte(s string, c byte) int",
        "type": "strings"
    },
    "strings.LastIndexFunc": {
        "descr": "LastIndexFunc returns the index into s of the last Unicode code point satisfying f(c), or -1 if none do.",
        "name": "strings.LastIndexFunc",
        "params": [],
        "path": "go/strings/index#LastIndexFunc",
        "syntax": "func LastIndexFunc(s string, f func(rune) bool) int",
        "type": "strings"
    },
    "strings.Map": {
        "descr": "Map returns a copy of the string s with all its characters modified according to the mapping function. If mapping returns a negative value, the character is dropped from the string with no replacement.",
        "name": "strings.Map",
        "params": [],
        "path": "go/strings/index#Map",
        "syntax": "func Map(mapping func(rune) rune, s string) string",
        "type": "strings"
    },
    "strings.NewReader": {
        "descr": "NewReader returns a new Reader reading from s. It is similar to bytes.NewBufferString but more efficient and read-only.",
        "name": "strings.NewReader",
        "params": [],
        "path": "go/strings/index#NewReader",
        "syntax": "func NewReader(s string) *Reader",
        "type": "strings"
    },
    "strings.NewReplacer": {
        "descr": "NewReplacer returns a new Replacer from a list of old, new string pairs. Replacements are performed in the order they appear in the target string, without overlapping matches.",
        "name": "strings.NewReplacer",
        "params": [],
        "path": "go/strings/index#NewReplacer",
        "syntax": "func NewReplacer(oldnew ...string) *Replacer",
        "type": "strings"
    },
    "strings.Reader": {
        "descr": "A Reader implements the io.Reader, io.ReaderAt, io.Seeker, io.WriterTo, io.ByteScanner, and io.RuneScanner interfaces by reading from a string.",
        "name": "strings.Reader",
        "params": [],
        "path": "go/strings/index#Reader",
        "syntax": "type Reader struct { // contains filtered or unexported fields }",
        "type": "strings"
    },
    "strings.Reader.Len": {
        "descr": "Len returns the number of bytes of the unread portion of the string.",
        "name": "strings.Reader.Len",
        "params": [],
        "path": "go/strings/index#Reader.Len",
        "syntax": "func (r *Reader) Len() int",
        "type": "strings"
    },
    "strings.Reader.Read": {
        "descr": "",
        "name": "strings.Reader.Read",
        "params": [],
        "path": "go/strings/index#Reader.Read",
        "syntax": "func (r *Reader) Read(b []byte) (n int, err error)",
        "type": "strings"
    },
    "strings.Reader.ReadAt": {
        "descr": "",
        "name": "strings.Reader.ReadAt",
        "params": [],
        "path": "go/strings/index#Reader.ReadAt",
        "syntax": "func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)",
        "type": "strings"
    },
    "strings.Reader.ReadByte": {
        "descr": "",
        "name": "strings.Reader.ReadByte",
        "params": [],
        "path": "go/strings/index#Reader.ReadByte",
        "syntax": "func (r *Reader) ReadByte() (byte, error)",
        "type": "strings"
    },
    "strings.Reader.ReadRune": {
        "descr": "",
        "name": "strings.Reader.ReadRune",
        "params": [],
        "path": "go/strings/index#Reader.ReadRune",
        "syntax": "func (r *Reader) ReadRune() (ch rune, size int, err error)",
        "type": "strings"
    },
    "strings.Reader.Reset": {
        "descr": "Reset resets the Reader to be reading from s.",
        "name": "strings.Reader.Reset",
        "params": [],
        "path": "go/strings/index#Reader.Reset",
        "syntax": "func (r *Reader) Reset(s string)",
        "type": "strings"
    },
    "strings.Reader.Seek": {
        "descr": "Seek implements the io.Seeker interface.",
        "name": "strings.Reader.Seek",
        "params": [],
        "path": "go/strings/index#Reader.Seek",
        "syntax": "func (r *Reader) Seek(offset int64, whence int) (int64, error)",
        "type": "strings"
    },
    "strings.Reader.Size": {
        "descr": "Size returns the original length of the underlying string. Size is the number of bytes available for reading via ReadAt. The returned value is always the same and is not affected by calls to any other method.",
        "name": "strings.Reader.Size",
        "params": [],
        "path": "go/strings/index#Reader.Size",
        "syntax": "func (r *Reader) Size() int64",
        "type": "strings"
    },
    "strings.Reader.UnreadByte": {
        "descr": "",
        "name": "strings.Reader.UnreadByte",
        "params": [],
        "path": "go/strings/index#Reader.UnreadByte",
        "syntax": "func (r *Reader) UnreadByte() error",
        "type": "strings"
    },
    "strings.Reader.UnreadRune": {
        "descr": "",
        "name": "strings.Reader.UnreadRune",
        "params": [],
        "path": "go/strings/index#Reader.UnreadRune",
        "syntax": "func (r *Reader) UnreadRune() error",
        "type": "strings"
    },
    "strings.Reader.WriteTo": {
        "descr": "WriteTo implements the io.WriterTo interface.",
        "name": "strings.Reader.WriteTo",
        "params": [],
        "path": "go/strings/index#Reader.WriteTo",
        "syntax": "func (r *Reader) WriteTo(w io.Writer) (n int64, err error)",
        "type": "strings"
    },
    "strings.Repeat": {
        "descr": "Repeat returns a new string consisting of count copies of the string s.",
        "name": "strings.Repeat",
        "params": [],
        "path": "go/strings/index#Repeat",
        "syntax": "func Repeat(s string, count int) string",
        "type": "strings"
    },
    "strings.Replace": {
        "descr": "Replace returns a copy of the string s with the first n non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the string and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune string. If n < 0, there is no limit on the number of replacements.",
        "name": "strings.Replace",
        "params": [],
        "path": "go/strings/index#Replace",
        "syntax": "func Replace(s, old, new string, n int) string",
        "type": "strings"
    },
    "strings.Replacer": {
        "descr": "Replacer replaces a list of strings with replacements. It is safe for concurrent use by multiple goroutines.",
        "name": "strings.Replacer",
        "params": [],
        "path": "go/strings/index#Replacer",
        "syntax": "type Replacer struct { // contains filtered or unexported fields }",
        "type": "strings"
    },
    "strings.Replacer.Replace": {
        "descr": "Replace returns a copy of s with all replacements performed.",
        "name": "strings.Replacer.Replace",
        "params": [],
        "path": "go/strings/index#Replacer.Replace",
        "syntax": "func (r *Replacer) Replace(s string) string",
        "type": "strings"
    },
    "strings.Replacer.WriteString": {
        "descr": "WriteString writes s to w with all replacements performed.",
        "name": "strings.Replacer.WriteString",
        "params": [],
        "path": "go/strings/index#Replacer.WriteString",
        "syntax": "func (r *Replacer) WriteString(w io.Writer, s string) (n int, err error)",
        "type": "strings"
    },
    "strings.Split": {
        "descr": "Split slices s into all substrings separated by sep and returns a slice of the substrings between those separators.",
        "name": "strings.Split",
        "params": [],
        "path": "go/strings/index#Split",
        "syntax": "func Split(s, sep string) []string",
        "type": "strings"
    },
    "strings.SplitAfter": {
        "descr": "SplitAfter slices s into all substrings after each instance of sep and returns a slice of those substrings.",
        "name": "strings.SplitAfter",
        "params": [],
        "path": "go/strings/index#SplitAfter",
        "syntax": "func SplitAfter(s, sep string) []string",
        "type": "strings"
    },
    "strings.SplitAfterN": {
        "descr": "SplitAfterN slices s into substrings after each instance of sep and returns a slice of those substrings.",
        "name": "strings.SplitAfterN",
        "params": [],
        "path": "go/strings/index#SplitAfterN",
        "syntax": "func SplitAfterN(s, sep string, n int) []string",
        "type": "strings"
    },
    "strings.SplitN": {
        "descr": "SplitN slices s into substrings separated by sep and returns a slice of the substrings between those separators.",
        "name": "strings.SplitN",
        "params": [],
        "path": "go/strings/index#SplitN",
        "syntax": "func SplitN(s, sep string, n int) []string",
        "type": "strings"
    },
    "strings.Title": {
        "descr": "Title returns a copy of the string s with all Unicode letters that begin words mapped to their title case.",
        "name": "strings.Title",
        "params": [],
        "path": "go/strings/index#Title",
        "syntax": "func Title(s string) string",
        "type": "strings"
    },
    "strings.ToLower": {
        "descr": "ToLower returns a copy of the string s with all Unicode letters mapped to their lower case.",
        "name": "strings.ToLower",
        "params": [],
        "path": "go/strings/index#ToLower",
        "syntax": "func ToLower(s string) string",
        "type": "strings"
    },
    "strings.ToLowerSpecial": {
        "descr": "ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their lower case, giving priority to the special casing rules.",
        "name": "strings.ToLowerSpecial",
        "params": [],
        "path": "go/strings/index#ToLowerSpecial",
        "syntax": "func ToLowerSpecial(c unicode.SpecialCase, s string) string",
        "type": "strings"
    },
    "strings.ToTitle": {
        "descr": "ToTitle returns a copy of the string s with all Unicode letters mapped to their title case.",
        "name": "strings.ToTitle",
        "params": [],
        "path": "go/strings/index#ToTitle",
        "syntax": "func ToTitle(s string) string",
        "type": "strings"
    },
    "strings.ToTitleSpecial": {
        "descr": "ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their title case, giving priority to the special casing rules.",
        "name": "strings.ToTitleSpecial",
        "params": [],
        "path": "go/strings/index#ToTitleSpecial",
        "syntax": "func ToTitleSpecial(c unicode.SpecialCase, s string) string",
        "type": "strings"
    },
    "strings.ToUpper": {
        "descr": "ToUpper returns a copy of the string s with all Unicode letters mapped to their upper case.",
        "name": "strings.ToUpper",
        "params": [],
        "path": "go/strings/index#ToUpper",
        "syntax": "func ToUpper(s string) string",
        "type": "strings"
    },
    "strings.ToUpperSpecial": {
        "descr": "ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their upper case, giving priority to the special casing rules.",
        "name": "strings.ToUpperSpecial",
        "params": [],
        "path": "go/strings/index#ToUpperSpecial",
        "syntax": "func ToUpperSpecial(c unicode.SpecialCase, s string) string",
        "type": "strings"
    },
    "strings.Trim": {
        "descr": "Trim returns a slice of the string s with all leading and trailing Unicode code points contained in cutset removed.",
        "name": "strings.Trim",
        "params": [],
        "path": "go/strings/index#Trim",
        "syntax": "func Trim(s string, cutset string) string",
        "type": "strings"
    },
    "strings.TrimFunc": {
        "descr": "TrimFunc returns a slice of the string s with all leading and trailing Unicode code points c satisfying f(c) removed.",
        "name": "strings.TrimFunc",
        "params": [],
        "path": "go/strings/index#TrimFunc",
        "syntax": "func TrimFunc(s string, f func(rune) bool) string",
        "type": "strings"
    },
    "strings.TrimLeft": {
        "descr": "TrimLeft returns a slice of the string s with all leading Unicode code points contained in cutset removed.",
        "name": "strings.TrimLeft",
        "params": [],
        "path": "go/strings/index#TrimLeft",
        "syntax": "func TrimLeft(s string, cutset string) string",
        "type": "strings"
    },
    "strings.TrimLeftFunc": {
        "descr": "TrimLeftFunc returns a slice of the string s with all leading Unicode code points c satisfying f(c) removed.",
        "name": "strings.TrimLeftFunc",
        "params": [],
        "path": "go/strings/index#TrimLeftFunc",
        "syntax": "func TrimLeftFunc(s string, f func(rune) bool) string",
        "type": "strings"
    },
    "strings.TrimPrefix": {
        "descr": "TrimPrefix returns s without the provided leading prefix string. If s doesn't start with prefix, s is returned unchanged.",
        "name": "strings.TrimPrefix",
        "params": [],
        "path": "go/strings/index#TrimPrefix",
        "syntax": "func TrimPrefix(s, prefix string) string",
        "type": "strings"
    },
    "strings.TrimRight": {
        "descr": "TrimRight returns a slice of the string s, with all trailing Unicode code points contained in cutset removed.",
        "name": "strings.TrimRight",
        "params": [],
        "path": "go/strings/index#TrimRight",
        "syntax": "func TrimRight(s string, cutset string) string",
        "type": "strings"
    },
    "strings.TrimRightFunc": {
        "descr": "TrimRightFunc returns a slice of the string s with all trailing Unicode code points c satisfying f(c) removed.",
        "name": "strings.TrimRightFunc",
        "params": [],
        "path": "go/strings/index#TrimRightFunc",
        "syntax": "func TrimRightFunc(s string, f func(rune) bool) string",
        "type": "strings"
    },
    "strings.TrimSpace": {
        "descr": "TrimSpace returns a slice of the string s, with all leading and trailing white space removed, as defined by Unicode.",
        "name": "strings.TrimSpace",
        "params": [],
        "path": "go/strings/index#TrimSpace",
        "syntax": "func TrimSpace(s string) string",
        "type": "strings"
    },
    "strings.TrimSuffix": {
        "descr": "TrimSuffix returns s without the provided trailing suffix string. If s doesn't end with suffix, s is returned unchanged.",
        "name": "strings.TrimSuffix",
        "params": [],
        "path": "go/strings/index#TrimSuffix",
        "syntax": "func TrimSuffix(s, suffix string) string",
        "type": "strings"
    },
    "subtle.ConstantTimeByteEq": {
        "descr": "ConstantTimeByteEq returns 1 if x == y and 0 otherwise.",
        "name": "subtle.ConstantTimeByteEq",
        "params": [],
        "path": "go/crypto/subtle/index#ConstantTimeByteEq",
        "syntax": "func ConstantTimeByteEq(x, y uint8) int",
        "type": "crypto"
    },
    "subtle.ConstantTimeCompare": {
        "descr": "ConstantTimeCompare returns 1 if and only if the two slices, x and y, have equal contents. The time taken is a function of the length of the slices and is independent of the contents.",
        "name": "subtle.ConstantTimeCompare",
        "params": [],
        "path": "go/crypto/subtle/index#ConstantTimeCompare",
        "syntax": "func ConstantTimeCompare(x, y []byte) int",
        "type": "crypto"
    },
    "subtle.ConstantTimeCopy": {
        "descr": "ConstantTimeCopy copies the contents of y into x (a slice of equal length) if v == 1. If v == 0, x is left unchanged. Its behavior is undefined if v takes any other value.",
        "name": "subtle.ConstantTimeCopy",
        "params": [],
        "path": "go/crypto/subtle/index#ConstantTimeCopy",
        "syntax": "func ConstantTimeCopy(v int, x, y []byte)",
        "type": "crypto"
    },
    "subtle.ConstantTimeEq": {
        "descr": "ConstantTimeEq returns 1 if x == y and 0 otherwise.",
        "name": "subtle.ConstantTimeEq",
        "params": [],
        "path": "go/crypto/subtle/index#ConstantTimeEq",
        "syntax": "func ConstantTimeEq(x, y int32) int",
        "type": "crypto"
    },
    "subtle.ConstantTimeLessOrEq": {
        "descr": "ConstantTimeLessOrEq returns 1 if x <= y and 0 otherwise. Its behavior is undefined if x or y are negative or > 2**31 - 1.",
        "name": "subtle.ConstantTimeLessOrEq",
        "params": [],
        "path": "go/crypto/subtle/index#ConstantTimeLessOrEq",
        "syntax": "func ConstantTimeLessOrEq(x, y int) int",
        "type": "crypto"
    },
    "subtle.ConstantTimeSelect": {
        "descr": "ConstantTimeSelect returns x if v is 1 and y if v is 0. Its behavior is undefined if v takes any other value.",
        "name": "subtle.ConstantTimeSelect",
        "params": [],
        "path": "go/crypto/subtle/index#ConstantTimeSelect",
        "syntax": "func ConstantTimeSelect(v, x, y int) int",
        "type": "crypto"
    },
    "suffixarray.Index": {
        "descr": "Index implements a suffix array for fast substring search.",
        "name": "suffixarray.Index",
        "params": [],
        "path": "go/index/suffixarray/index#Index",
        "syntax": "type Index struct { // contains filtered or unexported fields }",
        "type": "index"
    },
    "suffixarray.Index.Bytes": {
        "descr": "Bytes returns the data over which the index was created. It must not be modified.",
        "name": "suffixarray.Index.Bytes",
        "params": [],
        "path": "go/index/suffixarray/index#Index.Bytes",
        "syntax": "func (x *Index) Bytes() []byte",
        "type": "index"
    },
    "suffixarray.Index.FindAllIndex": {
        "descr": "FindAllIndex returns a sorted list of non-overlapping matches of the regular expression r, where a match is a pair of indices specifying the matched slice of x.Bytes(). If n < 0, all matches are returned in successive order. Otherwise, at most n matches are returned and they may not be successive. The result is nil if there are no matches, or if n == 0.",
        "name": "suffixarray.Index.FindAllIndex",
        "params": [],
        "path": "go/index/suffixarray/index#Index.FindAllIndex",
        "syntax": "func (x *Index) FindAllIndex(r *regexp.Regexp, n int) (result [][]int)",
        "type": "index"
    },
    "suffixarray.Index.Lookup": {
        "descr": "Lookup returns an unsorted list of at most n indices where the byte string s occurs in the indexed data. If n < 0, all occurrences are returned. The result is nil if s is empty, s is not found, or n == 0. Lookup time is O(log(N)*len(s) + len(result)) where N is the size of the indexed data.",
        "name": "suffixarray.Index.Lookup",
        "params": [],
        "path": "go/index/suffixarray/index#Index.Lookup",
        "syntax": "func (x *Index) Lookup(s []byte, n int) (result []int)",
        "type": "index"
    },
    "suffixarray.Index.Read": {
        "descr": "Read reads the index from r into x; x must not be nil.",
        "name": "suffixarray.Index.Read",
        "params": [],
        "path": "go/index/suffixarray/index#Index.Read",
        "syntax": "func (x *Index) Read(r io.Reader) error",
        "type": "index"
    },
    "suffixarray.Index.Write": {
        "descr": "Write writes the index x to w.",
        "name": "suffixarray.Index.Write",
        "params": [],
        "path": "go/index/suffixarray/index#Index.Write",
        "syntax": "func (x *Index) Write(w io.Writer) error",
        "type": "index"
    },
    "suffixarray.New": {
        "descr": "New creates a new Index for data. Index creation time is O(N*log(N)) for N = len(data).",
        "name": "suffixarray.New",
        "params": [],
        "path": "go/index/suffixarray/index#New",
        "syntax": "func New(data []byte) *Index",
        "type": "index"
    },
    "sync.Cond": {
        "descr": "Cond implements a condition variable, a rendezvous point for goroutines waiting for or announcing the occurrence of an event.",
        "name": "sync.Cond",
        "params": [],
        "path": "go/sync/index#Cond",
        "syntax": "type Cond struct { // L is held while observing or changing the condition L Locker // contains filtered or unexported fields }",
        "type": "sync"
    },
    "sync.Cond.Broadcast": {
        "descr": "Broadcast wakes all goroutines waiting on c.",
        "name": "sync.Cond.Broadcast",
        "params": [],
        "path": "go/sync/index#Cond.Broadcast",
        "syntax": "func (c *Cond) Broadcast()",
        "type": "sync"
    },
    "sync.Cond.Signal": {
        "descr": "Signal wakes one goroutine waiting on c, if there is any.",
        "name": "sync.Cond.Signal",
        "params": [],
        "path": "go/sync/index#Cond.Signal",
        "syntax": "func (c *Cond) Signal()",
        "type": "sync"
    },
    "sync.Cond.Wait": {
        "descr": "Wait atomically unlocks c.L and suspends execution of the calling goroutine. After later resuming execution, Wait locks c.L before returning. Unlike in other systems, Wait cannot return unless awoken by Broadcast or Signal.",
        "name": "sync.Cond.Wait",
        "params": [],
        "path": "go/sync/index#Cond.Wait",
        "syntax": "func (c *Cond) Wait()",
        "type": "sync"
    },
    "sync.Locker": {
        "descr": "A Locker represents an object that can be locked and unlocked.",
        "name": "sync.Locker",
        "params": [],
        "path": "go/sync/index#Locker",
        "syntax": "type Locker interface { Lock() Unlock() }",
        "type": "sync"
    },
    "sync.Map": {
        "descr": "Map is like a Go map[interface{}]interface{} but is safe for concurrent use by multiple goroutines without additional locking or coordination. Loads, stores, and deletes run in amortized constant time.",
        "name": "sync.Map",
        "params": [],
        "path": "go/sync/index#Map",
        "syntax": "type Map struct { // contains filtered or unexported fields }",
        "type": "sync"
    },
    "sync.Map.Delete": {
        "descr": "Delete deletes the value for a key.",
        "name": "sync.Map.Delete",
        "params": [],
        "path": "go/sync/index#Map.Delete",
        "syntax": "func (m *Map) Delete(key interface{})",
        "type": "sync"
    },
    "sync.Map.Load": {
        "descr": "Load returns the value stored in the map for a key, or nil if no value is present. The ok result indicates whether value was found in the map.",
        "name": "sync.Map.Load",
        "params": [],
        "path": "go/sync/index#Map.Load",
        "syntax": "func (m *Map) Load(key interface{}) (value interface{}, ok bool)",
        "type": "sync"
    },
    "sync.Map.LoadOrStore": {
        "descr": "LoadOrStore returns the existing value for the key if present. Otherwise, it stores and returns the given value. The loaded result is true if the value was loaded, false if stored.",
        "name": "sync.Map.LoadOrStore",
        "params": [],
        "path": "go/sync/index#Map.LoadOrStore",
        "syntax": "func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)",
        "type": "sync"
    },
    "sync.Map.Range": {
        "descr": "Range calls f sequentially for each key and value present in the map. If f returns false, range stops the iteration.",
        "name": "sync.Map.Range",
        "params": [],
        "path": "go/sync/index#Map.Range",
        "syntax": "func (m *Map) Range(f func(key, value interface{}) bool)",
        "type": "sync"
    },
    "sync.Map.Store": {
        "descr": "Store sets the value for a key.",
        "name": "sync.Map.Store",
        "params": [],
        "path": "go/sync/index#Map.Store",
        "syntax": "func (m *Map) Store(key, value interface{})",
        "type": "sync"
    },
    "sync.Mutex": {
        "descr": "A Mutex is a mutual exclusion lock. The zero value for a Mutex is an unlocked mutex.",
        "name": "sync.Mutex",
        "params": [],
        "path": "go/sync/index#Mutex",
        "syntax": "type Mutex struct { // contains filtered or unexported fields }",
        "type": "sync"
    },
    "sync.Mutex.Lock": {
        "descr": "Lock locks m. If the lock is already in use, the calling goroutine blocks until the mutex is available.",
        "name": "sync.Mutex.Lock",
        "params": [],
        "path": "go/sync/index#Mutex.Lock",
        "syntax": "func (m *Mutex) Lock()",
        "type": "sync"
    },
    "sync.Mutex.Unlock": {
        "descr": "Unlock unlocks m. It is a run-time error if m is not locked on entry to Unlock.",
        "name": "sync.Mutex.Unlock",
        "params": [],
        "path": "go/sync/index#Mutex.Unlock",
        "syntax": "func (m *Mutex) Unlock()",
        "type": "sync"
    },
    "sync.NewCond": {
        "descr": "NewCond returns a new Cond with Locker l.",
        "name": "sync.NewCond",
        "params": [],
        "path": "go/sync/index#NewCond",
        "syntax": "func NewCond(l Locker) *Cond",
        "type": "sync"
    },
    "sync.Once": {
        "descr": "Once is an object that will perform exactly one action.",
        "name": "sync.Once",
        "params": [],
        "path": "go/sync/index#Once",
        "syntax": "type Once struct { // contains filtered or unexported fields }",
        "type": "sync"
    },
    "sync.Once.Do": {
        "descr": "Do calls the function f if and only if Do is being called for the first time for this instance of Once. In other words, given",
        "name": "sync.Once.Do",
        "params": [],
        "path": "go/sync/index#Once.Do",
        "syntax": "func (o *Once) Do(f func())",
        "type": "sync"
    },
    "sync.Pool": {
        "descr": "A Pool is a set of temporary objects that may be individually saved and retrieved.",
        "name": "sync.Pool",
        "params": [],
        "path": "go/sync/index#Pool",
        "syntax": "type Pool struct { // New optionally specifies a function to generate // a value when Get would otherwise return nil. // It may not be changed concurrently with calls to Get. New func() interface{} // contains filtered or unexported fields }",
        "type": "sync"
    },
    "sync.Pool.Get": {
        "descr": "Get selects an arbitrary item from the Pool, removes it from the Pool, and returns it to the caller. Get may choose to ignore the pool and treat it as empty. Callers should not assume any relation between values passed to Put and the values returned by Get.",
        "name": "sync.Pool.Get",
        "params": [],
        "path": "go/sync/index#Pool.Get",
        "syntax": "func (p *Pool) Get() interface{}",
        "type": "sync"
    },
    "sync.Pool.Put": {
        "descr": "Put adds x to the pool.",
        "name": "sync.Pool.Put",
        "params": [],
        "path": "go/sync/index#Pool.Put",
        "syntax": "func (p *Pool) Put(x interface{})",
        "type": "sync"
    },
    "sync.RWMutex": {
        "descr": "A RWMutex is a reader/writer mutual exclusion lock. The lock can be held by an arbitrary number of readers or a single writer. The zero value for a RWMutex is an unlocked mutex.",
        "name": "sync.RWMutex",
        "params": [],
        "path": "go/sync/index#RWMutex",
        "syntax": "type RWMutex struct { // contains filtered or unexported fields }",
        "type": "sync"
    },
    "sync.RWMutex.Lock": {
        "descr": "Lock locks rw for writing. If the lock is already locked for reading or writing, Lock blocks until the lock is available.",
        "name": "sync.RWMutex.Lock",
        "params": [],
        "path": "go/sync/index#RWMutex.Lock",
        "syntax": "func (rw *RWMutex) Lock()",
        "type": "sync"
    },
    "sync.RWMutex.RLock": {
        "descr": "RLock locks rw for reading.",
        "name": "sync.RWMutex.RLock",
        "params": [],
        "path": "go/sync/index#RWMutex.RLock",
        "syntax": "func (rw *RWMutex) RLock()",
        "type": "sync"
    },
    "sync.RWMutex.RLocker": {
        "descr": "RLocker returns a Locker interface that implements the Lock and Unlock methods by calling rw.RLock and rw.RUnlock.",
        "name": "sync.RWMutex.RLocker",
        "params": [],
        "path": "go/sync/index#RWMutex.RLocker",
        "syntax": "func (rw *RWMutex) RLocker() Locker",
        "type": "sync"
    },
    "sync.RWMutex.RUnlock": {
        "descr": "RUnlock undoes a single RLock call; it does not affect other simultaneous readers. It is a run-time error if rw is not locked for reading on entry to RUnlock.",
        "name": "sync.RWMutex.RUnlock",
        "params": [],
        "path": "go/sync/index#RWMutex.RUnlock",
        "syntax": "func (rw *RWMutex) RUnlock()",
        "type": "sync"
    },
    "sync.RWMutex.Unlock": {
        "descr": "Unlock unlocks rw for writing. It is a run-time error if rw is not locked for writing on entry to Unlock.",
        "name": "sync.RWMutex.Unlock",
        "params": [],
        "path": "go/sync/index#RWMutex.Unlock",
        "syntax": "func (rw *RWMutex) Unlock()",
        "type": "sync"
    },
    "sync.WaitGroup": {
        "descr": "A WaitGroup waits for a collection of goroutines to finish. The main goroutine calls Add to set the number of goroutines to wait for. Then each of the goroutines runs and calls Done when finished. At the same time, Wait can be used to block until all goroutines have finished.",
        "name": "sync.WaitGroup",
        "params": [],
        "path": "go/sync/index#WaitGroup",
        "syntax": "type WaitGroup struct { // contains filtered or unexported fields }",
        "type": "sync"
    },
    "sync.WaitGroup.Add": {
        "descr": "Add adds delta, which may be negative, to the WaitGroup counter. If the counter becomes zero, all goroutines blocked on Wait are released. If the counter goes negative, Add panics.",
        "name": "sync.WaitGroup.Add",
        "params": [],
        "path": "go/sync/index#WaitGroup.Add",
        "syntax": "func (wg *WaitGroup) Add(delta int)",
        "type": "sync"
    },
    "sync.WaitGroup.Done": {
        "descr": "Done decrements the WaitGroup counter by one.",
        "name": "sync.WaitGroup.Done",
        "params": [],
        "path": "go/sync/index#WaitGroup.Done",
        "syntax": "func (wg *WaitGroup) Done()",
        "type": "sync"
    },
    "sync.WaitGroup.Wait": {
        "descr": "Wait blocks until the WaitGroup counter is zero.",
        "name": "sync.WaitGroup.Wait",
        "params": [],
        "path": "go/sync/index#WaitGroup.Wait",
        "syntax": "func (wg *WaitGroup) Wait()",
        "type": "sync"
    },
    "syntax.Compile": {
        "descr": "Compile compiles the regexp into a program to be executed. The regexp should have been simplified already (returned from re.Simplify).",
        "name": "syntax.Compile",
        "params": [],
        "path": "go/regexp/syntax/index#Compile",
        "syntax": "func Compile(re *Regexp) (*Prog, error)",
        "type": "regexp"
    },
    "syntax.EmptyOp": {
        "descr": "An EmptyOp specifies a kind or mixture of zero-width assertions.",
        "name": "syntax.EmptyOp",
        "params": [],
        "path": "go/regexp/syntax/index#EmptyOp",
        "syntax": "type EmptyOp uint8",
        "type": "regexp"
    },
    "syntax.EmptyOpContext": {
        "descr": "EmptyOpContext returns the zero-width assertions satisfied at the position between the runes r1 and r2. Passing r1 == -1 indicates that the position is at the beginning of the text. Passing r2 == -1 indicates that the position is at the end of the text.",
        "name": "syntax.EmptyOpContext",
        "params": [],
        "path": "go/regexp/syntax/index#EmptyOpContext",
        "syntax": "func EmptyOpContext(r1, r2 rune) EmptyOp",
        "type": "regexp"
    },
    "syntax.Error": {
        "descr": "An Error describes a failure to parse a regular expression and gives the offending expression.",
        "name": "syntax.Error",
        "params": [],
        "path": "go/regexp/syntax/index#Error",
        "syntax": "type Error struct { Code ErrorCode Expr string }",
        "type": "regexp"
    },
    "syntax.Error.Error": {
        "descr": "",
        "name": "syntax.Error.Error",
        "params": [],
        "path": "go/regexp/syntax/index#Error.Error",
        "syntax": "func (e *Error) Error() string",
        "type": "regexp"
    },
    "syntax.ErrorCode": {
        "descr": "An ErrorCode describes a failure to parse a regular expression.",
        "name": "syntax.ErrorCode",
        "params": [],
        "path": "go/regexp/syntax/index#ErrorCode",
        "syntax": "type ErrorCode string",
        "type": "regexp"
    },
    "syntax.ErrorCode.String": {
        "descr": "",
        "name": "syntax.ErrorCode.String",
        "params": [],
        "path": "go/regexp/syntax/index#ErrorCode.String",
        "syntax": "func (e ErrorCode) String() string",
        "type": "regexp"
    },
    "syntax.Flags": {
        "descr": "Flags control the behavior of the parser and record information about regexp context.",
        "name": "syntax.Flags",
        "params": [],
        "path": "go/regexp/syntax/index#Flags",
        "syntax": "type Flags uint16",
        "type": "regexp"
    },
    "syntax.Inst": {
        "descr": "An Inst is a single instruction in a regular expression program.",
        "name": "syntax.Inst",
        "params": [],
        "path": "go/regexp/syntax/index#Inst",
        "syntax": "type Inst struct { Op InstOp Out uint32 // all but InstMatch, InstFail Arg uint32 // InstAlt, InstAltMatch, InstCapture, InstEmptyWidth Rune []rune }",
        "type": "regexp"
    },
    "syntax.Inst.MatchEmptyWidth": {
        "descr": "MatchEmptyWidth reports whether the instruction matches an empty string between the runes before and after. It should only be called when i.Op == InstEmptyWidth.",
        "name": "syntax.Inst.MatchEmptyWidth",
        "params": [],
        "path": "go/regexp/syntax/index#Inst.MatchEmptyWidth",
        "syntax": "func (i *Inst) MatchEmptyWidth(before rune, after rune) bool",
        "type": "regexp"
    },
    "syntax.Inst.MatchRune": {
        "descr": "MatchRune reports whether the instruction matches (and consumes) r. It should only be called when i.Op == InstRune.",
        "name": "syntax.Inst.MatchRune",
        "params": [],
        "path": "go/regexp/syntax/index#Inst.MatchRune",
        "syntax": "func (i *Inst) MatchRune(r rune) bool",
        "type": "regexp"
    },
    "syntax.Inst.MatchRunePos": {
        "descr": "MatchRunePos checks whether the instruction matches (and consumes) r. If so, MatchRunePos returns the index of the matching rune pair (or, when len(i.Rune) == 1, rune singleton). If not, MatchRunePos returns -1. MatchRunePos should only be called when i.Op == InstRune.",
        "name": "syntax.Inst.MatchRunePos",
        "params": [],
        "path": "go/regexp/syntax/index#Inst.MatchRunePos",
        "syntax": "func (i *Inst) MatchRunePos(r rune) int",
        "type": "regexp"
    },
    "syntax.Inst.String": {
        "descr": "",
        "name": "syntax.Inst.String",
        "params": [],
        "path": "go/regexp/syntax/index#Inst.String",
        "syntax": "func (i *Inst) String() string",
        "type": "regexp"
    },
    "syntax.InstOp": {
        "descr": "An InstOp is an instruction opcode.",
        "name": "syntax.InstOp",
        "params": [],
        "path": "go/regexp/syntax/index#InstOp",
        "syntax": "type InstOp uint8",
        "type": "regexp"
    },
    "syntax.InstOp.String": {
        "descr": "",
        "name": "syntax.InstOp.String",
        "params": [],
        "path": "go/regexp/syntax/index#InstOp.String",
        "syntax": "func (i InstOp) String() string",
        "type": "regexp"
    },
    "syntax.IsWordChar": {
        "descr": "IsWordChar reports whether r is consider a word character during the evaluation of the \\b and \\B zero-width assertions. These assertions are ASCII-only: the word characters are [A-Za-z0-9_].",
        "name": "syntax.IsWordChar",
        "params": [],
        "path": "go/regexp/syntax/index#IsWordChar",
        "syntax": "func IsWordChar(r rune) bool",
        "type": "regexp"
    },
    "syntax.Op": {
        "descr": "An Op is a single regular expression operator.",
        "name": "syntax.Op",
        "params": [],
        "path": "go/regexp/syntax/index#Op",
        "syntax": "type Op uint8",
        "type": "regexp"
    },
    "syntax.Op.String": {
        "descr": "",
        "name": "syntax.Op.String",
        "params": [],
        "path": "go/regexp/syntax/index#Op.String",
        "syntax": "func (i Op) String() string",
        "type": "regexp"
    },
    "syntax.Parse": {
        "descr": "Parse parses a regular expression string s, controlled by the specified Flags, and returns a regular expression parse tree. The syntax is described in the top-level comment.",
        "name": "syntax.Parse",
        "params": [],
        "path": "go/regexp/syntax/index#Parse",
        "syntax": "func Parse(s string, flags Flags) (*Regexp, error)",
        "type": "regexp"
    },
    "syntax.Prog": {
        "descr": "A Prog is a compiled regular expression program.",
        "name": "syntax.Prog",
        "params": [],
        "path": "go/regexp/syntax/index#Prog",
        "syntax": "type Prog struct { Inst []Inst Start int // index of start instruction NumCap int // number of InstCapture insts in re }",
        "type": "regexp"
    },
    "syntax.Prog.Prefix": {
        "descr": "Prefix returns a literal string that all matches for the regexp must start with. Complete is true if the prefix is the entire match.",
        "name": "syntax.Prog.Prefix",
        "params": [],
        "path": "go/regexp/syntax/index#Prog.Prefix",
        "syntax": "func (p *Prog) Prefix() (prefix string, complete bool)",
        "type": "regexp"
    },
    "syntax.Prog.StartCond": {
        "descr": "StartCond returns the leading empty-width conditions that must be true in any match. It returns ^EmptyOp(0) if no matches are possible.",
        "name": "syntax.Prog.StartCond",
        "params": [],
        "path": "go/regexp/syntax/index#Prog.StartCond",
        "syntax": "func (p *Prog) StartCond() EmptyOp",
        "type": "regexp"
    },
    "syntax.Prog.String": {
        "descr": "",
        "name": "syntax.Prog.String",
        "params": [],
        "path": "go/regexp/syntax/index#Prog.String",
        "syntax": "func (p *Prog) String() string",
        "type": "regexp"
    },
    "syntax.Regexp": {
        "descr": "A Regexp is a node in a regular expression syntax tree.",
        "name": "syntax.Regexp",
        "params": [],
        "path": "go/regexp/syntax/index#Regexp",
        "syntax": "type Regexp struct { Op Op // operator Flags Flags Sub []*Regexp // subexpressions, if any Sub0 [1]*Regexp // storage for short Sub Rune []rune // matched runes, for OpLiteral, OpCharClass Rune0 [2]rune // storage for short Rune Min, Max int // min, max for OpRepeat Cap int // capturing index, for OpCapture Name string // capturing name, for OpCapture }",
        "type": "regexp"
    },
    "syntax.Regexp.CapNames": {
        "descr": "CapNames walks the regexp to find the names of capturing groups.",
        "name": "syntax.Regexp.CapNames",
        "params": [],
        "path": "go/regexp/syntax/index#Regexp.CapNames",
        "syntax": "func (re *Regexp) CapNames() []string",
        "type": "regexp"
    },
    "syntax.Regexp.Equal": {
        "descr": "Equal returns true if x and y have identical structure.",
        "name": "syntax.Regexp.Equal",
        "params": [],
        "path": "go/regexp/syntax/index#Regexp.Equal",
        "syntax": "func (x *Regexp) Equal(y *Regexp) bool",
        "type": "regexp"
    },
    "syntax.Regexp.MaxCap": {
        "descr": "MaxCap walks the regexp to find the maximum capture index.",
        "name": "syntax.Regexp.MaxCap",
        "params": [],
        "path": "go/regexp/syntax/index#Regexp.MaxCap",
        "syntax": "func (re *Regexp) MaxCap() int",
        "type": "regexp"
    },
    "syntax.Regexp.Simplify": {
        "descr": "Simplify returns a regexp equivalent to re but without counted repetitions and with various other simplifications, such as rewriting /(?:a+)+/ to /a+/. The resulting regexp will execute correctly but its string representation will not produce the same parse tree, because capturing parentheses may have been duplicated or removed. For example, the simplified form for /(x){1,2}/ is /(x)(x)?/ but both parentheses capture as $1. The returned regexp may share structure with or be the original.",
        "name": "syntax.Regexp.Simplify",
        "params": [],
        "path": "go/regexp/syntax/index#Regexp.Simplify",
        "syntax": "func (re *Regexp) Simplify() *Regexp",
        "type": "regexp"
    },
    "syntax.Regexp.String": {
        "descr": "",
        "name": "syntax.Regexp.String",
        "params": [],
        "path": "go/regexp/syntax/index#Regexp.String",
        "syntax": "func (re *Regexp) String() string",
        "type": "regexp"
    },
    "sys.ArchFamilyType": {
        "descr": "",
        "name": "sys.ArchFamilyType",
        "params": [],
        "path": "go/runtime/internal/sys/index#ArchFamilyType",
        "syntax": "type ArchFamilyType int",
        "type": "runtime"
    },
    "sys.Bswap32": {
        "descr": "Bswap32 returns its input with byte order reversed 0x01020304 -> 0x04030201",
        "name": "sys.Bswap32",
        "params": [],
        "path": "go/runtime/internal/sys/index#Bswap32",
        "syntax": "func Bswap32(x uint32) uint32",
        "type": "runtime"
    },
    "sys.Bswap64": {
        "descr": "Bswap64 returns its input with byte order reversed 0x0102030405060708 -> 0x0807060504030201",
        "name": "sys.Bswap64",
        "params": [],
        "path": "go/runtime/internal/sys/index#Bswap64",
        "syntax": "func Bswap64(x uint64) uint64",
        "type": "runtime"
    },
    "sys.Ctz32": {
        "descr": "Ctz32 counts trailing (low-order) zeroes, and if all are zero, then 32.",
        "name": "sys.Ctz32",
        "params": [],
        "path": "go/runtime/internal/sys/index#Ctz32",
        "syntax": "func Ctz32(x uint32) int",
        "type": "runtime"
    },
    "sys.Ctz64": {
        "descr": "Ctz64 counts trailing (low-order) zeroes, and if all are zero, then 64.",
        "name": "sys.Ctz64",
        "params": [],
        "path": "go/runtime/internal/sys/index#Ctz64",
        "syntax": "func Ctz64(x uint64) int",
        "type": "runtime"
    },
    "sys.Ctz8": {
        "descr": "Ctz8 returns the number of trailing zero bits in x; the result is 8 for x == 0.",
        "name": "sys.Ctz8",
        "params": [],
        "path": "go/runtime/internal/sys/index#Ctz8",
        "syntax": "func Ctz8(x uint8) int",
        "type": "runtime"
    },
    "sys.Uintreg": {
        "descr": "",
        "name": "sys.Uintreg",
        "params": [],
        "path": "go/runtime/internal/sys/index#Uintreg",
        "syntax": "type Uintreg uint64",
        "type": "runtime"
    },
    "syscall": {
        "descr": "For testing: clients can set this flag to force creation of IPv6 sockets to return EAFNOSUPPORT.",
        "name": "syscall",
        "params": [],
        "path": "go/syscall/index#pkg-variables",
        "syntax": "var ( Stdin = 0 Stdout = 1 Stderr = 2 )",
        "type": "syscall"
    },
    "syscall.Accept": {
        "descr": "",
        "name": "syscall.Accept",
        "params": [],
        "path": "go/syscall/index#Accept",
        "syntax": "func Accept(fd int) (nfd int, sa Sockaddr, err error)",
        "type": "syscall"
    },
    "syscall.Accept4": {
        "descr": "",
        "name": "syscall.Accept4",
        "params": [],
        "path": "go/syscall/index#Accept4",
        "syntax": "func Accept4(fd int, flags int) (nfd int, sa Sockaddr, err error)",
        "type": "syscall"
    },
    "syscall.Access": {
        "descr": "",
        "name": "syscall.Access",
        "params": [],
        "path": "go/syscall/index#Access",
        "syntax": "func Access(path string, mode uint32) (err error)",
        "type": "syscall"
    },
    "syscall.Acct": {
        "descr": "",
        "name": "syscall.Acct",
        "params": [],
        "path": "go/syscall/index#Acct",
        "syntax": "func Acct(path string) (err error)",
        "type": "syscall"
    },
    "syscall.Adjtimex": {
        "descr": "",
        "name": "syscall.Adjtimex",
        "params": [],
        "path": "go/syscall/index#Adjtimex",
        "syntax": "func Adjtimex(buf *Timex) (state int, err error)",
        "type": "syscall"
    },
    "syscall.AttachLsf": {
        "descr": "Deprecated: Use golang.org/x/net/bpf instead.",
        "name": "syscall.AttachLsf",
        "params": [],
        "path": "go/syscall/index#AttachLsf",
        "syntax": "func AttachLsf(fd int, i []SockFilter) error",
        "type": "syscall"
    },
    "syscall.Bind": {
        "descr": "",
        "name": "syscall.Bind",
        "params": [],
        "path": "go/syscall/index#Bind",
        "syntax": "func Bind(fd int, sa Sockaddr) (err error)",
        "type": "syscall"
    },
    "syscall.BindToDevice": {
        "descr": "BindToDevice binds the socket associated with fd to device.",
        "name": "syscall.BindToDevice",
        "params": [],
        "path": "go/syscall/index#BindToDevice",
        "syntax": "func BindToDevice(fd int, device string) (err error)",
        "type": "syscall"
    },
    "syscall.BytePtrFromString": {
        "descr": "BytePtrFromString returns a pointer to a NUL-terminated array of bytes containing the text of s. If s contains a NUL byte at any location, it returns (nil, EINVAL).",
        "name": "syscall.BytePtrFromString",
        "params": [],
        "path": "go/syscall/index#BytePtrFromString",
        "syntax": "func BytePtrFromString(s string) (*byte, error)",
        "type": "syscall"
    },
    "syscall.ByteSliceFromString": {
        "descr": "ByteSliceFromString returns a NUL-terminated slice of bytes containing the text of s. If s contains a NUL byte at any location, it returns (nil, EINVAL).",
        "name": "syscall.ByteSliceFromString",
        "params": [],
        "path": "go/syscall/index#ByteSliceFromString",
        "syntax": "func ByteSliceFromString(s string) ([]byte, error)",
        "type": "syscall"
    },
    "syscall.Chdir": {
        "descr": "",
        "name": "syscall.Chdir",
        "params": [],
        "path": "go/syscall/index#Chdir",
        "syntax": "func Chdir(path string) (err error)",
        "type": "syscall"
    },
    "syscall.Chmod": {
        "descr": "",
        "name": "syscall.Chmod",
        "params": [],
        "path": "go/syscall/index#Chmod",
        "syntax": "func Chmod(path string, mode uint32) (err error)",
        "type": "syscall"
    },
    "syscall.Chown": {
        "descr": "",
        "name": "syscall.Chown",
        "params": [],
        "path": "go/syscall/index#Chown",
        "syntax": "func Chown(path string, uid int, gid int) (err error)",
        "type": "syscall"
    },
    "syscall.Chroot": {
        "descr": "",
        "name": "syscall.Chroot",
        "params": [],
        "path": "go/syscall/index#Chroot",
        "syntax": "func Chroot(path string) (err error)",
        "type": "syscall"
    },
    "syscall.Clearenv": {
        "descr": "",
        "name": "syscall.Clearenv",
        "params": [],
        "path": "go/syscall/index#Clearenv",
        "syntax": "func Clearenv()",
        "type": "syscall"
    },
    "syscall.Close": {
        "descr": "",
        "name": "syscall.Close",
        "params": [],
        "path": "go/syscall/index#Close",
        "syntax": "func Close(fd int) (err error)",
        "type": "syscall"
    },
    "syscall.CloseOnExec": {
        "descr": "",
        "name": "syscall.CloseOnExec",
        "params": [],
        "path": "go/syscall/index#CloseOnExec",
        "syntax": "func CloseOnExec(fd int)",
        "type": "syscall"
    },
    "syscall.CmsgLen": {
        "descr": "CmsgLen returns the value to store in the Len field of the Cmsghdr structure, taking into account any necessary alignment.",
        "name": "syscall.CmsgLen",
        "params": [],
        "path": "go/syscall/index#CmsgLen",
        "syntax": "func CmsgLen(datalen int) int",
        "type": "syscall"
    },
    "syscall.CmsgSpace": {
        "descr": "CmsgSpace returns the number of bytes an ancillary element with payload of the passed data length occupies.",
        "name": "syscall.CmsgSpace",
        "params": [],
        "path": "go/syscall/index#CmsgSpace",
        "syntax": "func CmsgSpace(datalen int) int",
        "type": "syscall"
    },
    "syscall.Cmsghdr": {
        "descr": "",
        "name": "syscall.Cmsghdr",
        "params": [],
        "path": "go/syscall/index#Cmsghdr",
        "syntax": "type Cmsghdr struct { Len uint64 Level int32 Type int32 }",
        "type": "syscall"
    },
    "syscall.Cmsghdr.SetLen": {
        "descr": "",
        "name": "syscall.Cmsghdr.SetLen",
        "params": [],
        "path": "go/syscall/index#Cmsghdr.SetLen",
        "syntax": "func (cmsg *Cmsghdr) SetLen(length int)",
        "type": "syscall"
    },
    "syscall.Conn": {
        "descr": "Conn is implemented by some types in the net package to provide access to the underlying file descriptor or handle.",
        "name": "syscall.Conn",
        "params": [],
        "path": "go/syscall/index#Conn",
        "syntax": "type Conn interface { // SyscallConn returns a raw network connection. SyscallConn() (RawConn, error) }",
        "type": "syscall"
    },
    "syscall.Connect": {
        "descr": "",
        "name": "syscall.Connect",
        "params": [],
        "path": "go/syscall/index#Connect",
        "syntax": "func Connect(fd int, sa Sockaddr) (err error)",
        "type": "syscall"
    },
    "syscall.Creat": {
        "descr": "",
        "name": "syscall.Creat",
        "params": [],
        "path": "go/syscall/index#Creat",
        "syntax": "func Creat(path string, mode uint32) (fd int, err error)",
        "type": "syscall"
    },
    "syscall.Credential": {
        "descr": "Credential holds user and group identities to be assumed by a child process started by StartProcess.",
        "name": "syscall.Credential",
        "params": [],
        "path": "go/syscall/index#Credential",
        "syntax": "type Credential struct { Uid uint32 // User ID. Gid uint32 // Group ID. Groups []uint32 // Supplementary group IDs. NoSetGroups bool // If true, don't set supplementary groups }",
        "type": "syscall"
    },
    "syscall.DetachLsf": {
        "descr": "Deprecated: Use golang.org/x/net/bpf instead.",
        "name": "syscall.DetachLsf",
        "params": [],
        "path": "go/syscall/index#DetachLsf",
        "syntax": "func DetachLsf(fd int) error",
        "type": "syscall"
    },
    "syscall.Dirent": {
        "descr": "",
        "name": "syscall.Dirent",
        "params": [],
        "path": "go/syscall/index#Dirent",
        "syntax": "type Dirent struct { Ino uint64 Off int64 Reclen uint16 Type uint8 Name [256]int8 Pad_cgo_0 [5]byte }",
        "type": "syscall"
    },
    "syscall.Dup": {
        "descr": "",
        "name": "syscall.Dup",
        "params": [],
        "path": "go/syscall/index#Dup",
        "syntax": "func Dup(oldfd int) (fd int, err error)",
        "type": "syscall"
    },
    "syscall.Dup2": {
        "descr": "",
        "name": "syscall.Dup2",
        "params": [],
        "path": "go/syscall/index#Dup2",
        "syntax": "func Dup2(oldfd int, newfd int) (err error)",
        "type": "syscall"
    },
    "syscall.Dup3": {
        "descr": "",
        "name": "syscall.Dup3",
        "params": [],
        "path": "go/syscall/index#Dup3",
        "syntax": "func Dup3(oldfd int, newfd int, flags int) (err error)",
        "type": "syscall"
    },
    "syscall.Environ": {
        "descr": "",
        "name": "syscall.Environ",
        "params": [],
        "path": "go/syscall/index#Environ",
        "syntax": "func Environ() []string",
        "type": "syscall"
    },
    "syscall.EpollCreate": {
        "descr": "",
        "name": "syscall.EpollCreate",
        "params": [],
        "path": "go/syscall/index#EpollCreate",
        "syntax": "func EpollCreate(size int) (fd int, err error)",
        "type": "syscall"
    },
    "syscall.EpollCreate1": {
        "descr": "",
        "name": "syscall.EpollCreate1",
        "params": [],
        "path": "go/syscall/index#EpollCreate1",
        "syntax": "func EpollCreate1(flag int) (fd int, err error)",
        "type": "syscall"
    },
    "syscall.EpollCtl": {
        "descr": "",
        "name": "syscall.EpollCtl",
        "params": [],
        "path": "go/syscall/index#EpollCtl",
        "syntax": "func EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error)",
        "type": "syscall"
    },
    "syscall.EpollEvent": {
        "descr": "",
        "name": "syscall.EpollEvent",
        "params": [],
        "path": "go/syscall/index#EpollEvent",
        "syntax": "type EpollEvent struct { Events uint32 Fd int32 Pad int32 }",
        "type": "syscall"
    },
    "syscall.EpollWait": {
        "descr": "",
        "name": "syscall.EpollWait",
        "params": [],
        "path": "go/syscall/index#EpollWait",
        "syntax": "func EpollWait(epfd int, events []EpollEvent, msec int) (n int, err error)",
        "type": "syscall"
    },
    "syscall.Errno": {
        "descr": "An Errno is an unsigned number describing an error condition. It implements the error interface. The zero Errno is by convention a non-error, so code to convert from Errno to error should use:",
        "name": "syscall.Errno",
        "params": [],
        "path": "go/syscall/index#Errno",
        "syntax": "err = nil if errno != 0 { err = errno }",
        "type": "syscall"
    },
    "syscall.Errno.Error": {
        "descr": "",
        "name": "syscall.Errno.Error",
        "params": [],
        "path": "go/syscall/index#Errno.Error",
        "syntax": "func (e Errno) Error() string",
        "type": "syscall"
    },
    "syscall.Errno.Temporary": {
        "descr": "",
        "name": "syscall.Errno.Temporary",
        "params": [],
        "path": "go/syscall/index#Errno.Temporary",
        "syntax": "func (e Errno) Temporary() bool",
        "type": "syscall"
    },
    "syscall.Errno.Timeout": {
        "descr": "",
        "name": "syscall.Errno.Timeout",
        "params": [],
        "path": "go/syscall/index#Errno.Timeout",
        "syntax": "func (e Errno) Timeout() bool",
        "type": "syscall"
    },
    "syscall.Exec": {
        "descr": "Exec invokes the execve(2) system call.",
        "name": "syscall.Exec",
        "params": [],
        "path": "go/syscall/index#Exec",
        "syntax": "func Exec(argv0 string, argv []string, envv []string) (err error)",
        "type": "syscall"
    },
    "syscall.Exit": {
        "descr": "",
        "name": "syscall.Exit",
        "params": [],
        "path": "go/syscall/index#Exit",
        "syntax": "func Exit(code int)",
        "type": "syscall"
    },
    "syscall.Faccessat": {
        "descr": "",
        "name": "syscall.Faccessat",
        "params": [],
        "path": "go/syscall/index#Faccessat",
        "syntax": "func Faccessat(dirfd int, path string, mode uint32, flags int) (err error)",
        "type": "syscall"
    },
    "syscall.Fallocate": {
        "descr": "",
        "name": "syscall.Fallocate",
        "params": [],
        "path": "go/syscall/index#Fallocate",
        "syntax": "func Fallocate(fd int, mode uint32, off int64, len int64) (err error)",
        "type": "syscall"
    },
    "syscall.Fchdir": {
        "descr": "",
        "name": "syscall.Fchdir",
        "params": [],
        "path": "go/syscall/index#Fchdir",
        "syntax": "func Fchdir(fd int) (err error)",
        "type": "syscall"
    },
    "syscall.Fchmod": {
        "descr": "",
        "name": "syscall.Fchmod",
        "params": [],
        "path": "go/syscall/index#Fchmod",
        "syntax": "func Fchmod(fd int, mode uint32) (err error)",
        "type": "syscall"
    },
    "syscall.Fchmodat": {
        "descr": "",
        "name": "syscall.Fchmodat",
        "params": [],
        "path": "go/syscall/index#Fchmodat",
        "syntax": "func Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)",
        "type": "syscall"
    },
    "syscall.Fchown": {
        "descr": "",
        "name": "syscall.Fchown",
        "params": [],
        "path": "go/syscall/index#Fchown",
        "syntax": "func Fchown(fd int, uid int, gid int) (err error)",
        "type": "syscall"
    },
    "syscall.Fchownat": {
        "descr": "",
        "name": "syscall.Fchownat",
        "params": [],
        "path": "go/syscall/index#Fchownat",
        "syntax": "func Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)",
        "type": "syscall"
    },
    "syscall.FcntlFlock": {
        "descr": "FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command.",
        "name": "syscall.FcntlFlock",
        "params": [],
        "path": "go/syscall/index#FcntlFlock",
        "syntax": "func FcntlFlock(fd uintptr, cmd int, lk *Flock_t) error",
        "type": "syscall"
    },
    "syscall.FdSet": {
        "descr": "",
        "name": "syscall.FdSet",
        "params": [],
        "path": "go/syscall/index#FdSet",
        "syntax": "type FdSet struct { Bits [16]int64 }",
        "type": "syscall"
    },
    "syscall.Fdatasync": {
        "descr": "",
        "name": "syscall.Fdatasync",
        "params": [],
        "path": "go/syscall/index#Fdatasync",
        "syntax": "func Fdatasync(fd int) (err error)",
        "type": "syscall"
    },
    "syscall.Flock": {
        "descr": "",
        "name": "syscall.Flock",
        "params": [],
        "path": "go/syscall/index#Flock",
        "syntax": "func Flock(fd int, how int) (err error)",
        "type": "syscall"
    },
    "syscall.Flock_t": {
        "descr": "",
        "name": "syscall.Flock_t",
        "params": [],
        "path": "go/syscall/index#Flock_t",
        "syntax": "type Flock_t struct { Type int16 Whence int16 Pad_cgo_0 [4]byte Start int64 Len int64 Pid int32 Pad_cgo_1 [4]byte }",
        "type": "syscall"
    },
    "syscall.ForkExec": {
        "descr": "Combination of fork and exec, careful to be thread safe.",
        "name": "syscall.ForkExec",
        "params": [],
        "path": "go/syscall/index#ForkExec",
        "syntax": "func ForkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err error)",
        "type": "syscall"
    },
    "syscall.Fsid": {
        "descr": "",
        "name": "syscall.Fsid",
        "params": [],
        "path": "go/syscall/index#Fsid",
        "syntax": "type Fsid struct { X__val [2]int32 }",
        "type": "syscall"
    },
    "syscall.Fstat": {
        "descr": "",
        "name": "syscall.Fstat",
        "params": [],
        "path": "go/syscall/index#Fstat",
        "syntax": "func Fstat(fd int, stat *Stat_t) (err error)",
        "type": "syscall"
    },
    "syscall.Fstatfs": {
        "descr": "",
        "name": "syscall.Fstatfs",
        "params": [],
        "path": "go/syscall/index#Fstatfs",
        "syntax": "func Fstatfs(fd int, buf *Statfs_t) (err error)",
        "type": "syscall"
    },
    "syscall.Fsync": {
        "descr": "",
        "name": "syscall.Fsync",
        "params": [],
        "path": "go/syscall/index#Fsync",
        "syntax": "func Fsync(fd int) (err error)",
        "type": "syscall"
    },
    "syscall.Ftruncate": {
        "descr": "",
        "name": "syscall.Ftruncate",
        "params": [],
        "path": "go/syscall/index#Ftruncate",
        "syntax": "func Ftruncate(fd int, length int64) (err error)",
        "type": "syscall"
    },
    "syscall.Futimes": {
        "descr": "",
        "name": "syscall.Futimes",
        "params": [],
        "path": "go/syscall/index#Futimes",
        "syntax": "func Futimes(fd int, tv []Timeval) (err error)",
        "type": "syscall"
    },
    "syscall.Futimesat": {
        "descr": "",
        "name": "syscall.Futimesat",
        "params": [],
        "path": "go/syscall/index#Futimesat",
        "syntax": "func Futimesat(dirfd int, path string, tv []Timeval) (err error)",
        "type": "syscall"
    },
    "syscall.Getcwd": {
        "descr": "",
        "name": "syscall.Getcwd",
        "params": [],
        "path": "go/syscall/index#Getcwd",
        "syntax": "func Getcwd(buf []byte) (n int, err error)",
        "type": "syscall"
    },
    "syscall.Getdents": {
        "descr": "",
        "name": "syscall.Getdents",
        "params": [],
        "path": "go/syscall/index#Getdents",
        "syntax": "func Getdents(fd int, buf []byte) (n int, err error)",
        "type": "syscall"
    },
    "syscall.Getegid": {
        "descr": "",
        "name": "syscall.Getegid",
        "params": [],
        "path": "go/syscall/index#Getegid",
        "syntax": "func Getegid() (egid int)",
        "type": "syscall"
    },
    "syscall.Getenv": {
        "descr": "",
        "name": "syscall.Getenv",
        "params": [],
        "path": "go/syscall/index#Getenv",
        "syntax": "func Getenv(key string) (value string, found bool)",
        "type": "syscall"
    },
    "syscall.Geteuid": {
        "descr": "",
        "name": "syscall.Geteuid",
        "params": [],
        "path": "go/syscall/index#Geteuid",
        "syntax": "func Geteuid() (euid int)",
        "type": "syscall"
    },
    "syscall.Getgid": {
        "descr": "",
        "name": "syscall.Getgid",
        "params": [],
        "path": "go/syscall/index#Getgid",
        "syntax": "func Getgid() (gid int)",
        "type": "syscall"
    },
    "syscall.Getgroups": {
        "descr": "",
        "name": "syscall.Getgroups",
        "params": [],
        "path": "go/syscall/index#Getgroups",
        "syntax": "func Getgroups() (gids []int, err error)",
        "type": "syscall"
    },
    "syscall.Getpagesize": {
        "descr": "",
        "name": "syscall.Getpagesize",
        "params": [],
        "path": "go/syscall/index#Getpagesize",
        "syntax": "func Getpagesize() int",
        "type": "syscall"
    },
    "syscall.Getpeername": {
        "descr": "",
        "name": "syscall.Getpeername",
        "params": [],
        "path": "go/syscall/index#Getpeername",
        "syntax": "func Getpeername(fd int) (sa Sockaddr, err error)",
        "type": "syscall"
    },
    "syscall.Getpgid": {
        "descr": "",
        "name": "syscall.Getpgid",
        "params": [],
        "path": "go/syscall/index#Getpgid",
        "syntax": "func Getpgid(pid int) (pgid int, err error)",
        "type": "syscall"
    },
    "syscall.Getpgrp": {
        "descr": "",
        "name": "syscall.Getpgrp",
        "params": [],
        "path": "go/syscall/index#Getpgrp",
        "syntax": "func Getpgrp() (pid int)",
        "type": "syscall"
    },
    "syscall.Getpid": {
        "descr": "",
        "name": "syscall.Getpid",
        "params": [],
        "path": "go/syscall/index#Getpid",
        "syntax": "func Getpid() (pid int)",
        "type": "syscall"
    },
    "syscall.Getppid": {
        "descr": "",
        "name": "syscall.Getppid",
        "params": [],
        "path": "go/syscall/index#Getppid",
        "syntax": "func Getppid() (ppid int)",
        "type": "syscall"
    },
    "syscall.Getpriority": {
        "descr": "",
        "name": "syscall.Getpriority",
        "params": [],
        "path": "go/syscall/index#Getpriority",
        "syntax": "func Getpriority(which int, who int) (prio int, err error)",
        "type": "syscall"
    },
    "syscall.Getrlimit": {
        "descr": "",
        "name": "syscall.Getrlimit",
        "params": [],
        "path": "go/syscall/index#Getrlimit",
        "syntax": "func Getrlimit(resource int, rlim *Rlimit) (err error)",
        "type": "syscall"
    },
    "syscall.Getrusage": {
        "descr": "",
        "name": "syscall.Getrusage",
        "params": [],
        "path": "go/syscall/index#Getrusage",
        "syntax": "func Getrusage(who int, rusage *Rusage) (err error)",
        "type": "syscall"
    },
    "syscall.Getsockname": {
        "descr": "",
        "name": "syscall.Getsockname",
        "params": [],
        "path": "go/syscall/index#Getsockname",
        "syntax": "func Getsockname(fd int) (sa Sockaddr, err error)",
        "type": "syscall"
    },
    "syscall.GetsockoptICMPv6Filter": {
        "descr": "",
        "name": "syscall.GetsockoptICMPv6Filter",
        "params": [],
        "path": "go/syscall/index#GetsockoptICMPv6Filter",
        "syntax": "func GetsockoptICMPv6Filter(fd, level, opt int) (*ICMPv6Filter, error)",
        "type": "syscall"
    },
    "syscall.GetsockoptIPMreq": {
        "descr": "",
        "name": "syscall.GetsockoptIPMreq",
        "params": [],
        "path": "go/syscall/index#GetsockoptIPMreq",
        "syntax": "func GetsockoptIPMreq(fd, level, opt int) (*IPMreq, error)",
        "type": "syscall"
    },
    "syscall.GetsockoptIPMreqn": {
        "descr": "",
        "name": "syscall.GetsockoptIPMreqn",
        "params": [],
        "path": "go/syscall/index#GetsockoptIPMreqn",
        "syntax": "func GetsockoptIPMreqn(fd, level, opt int) (*IPMreqn, error)",
        "type": "syscall"
    },
    "syscall.GetsockoptIPv6MTUInfo": {
        "descr": "",
        "name": "syscall.GetsockoptIPv6MTUInfo",
        "params": [],
        "path": "go/syscall/index#GetsockoptIPv6MTUInfo",
        "syntax": "func GetsockoptIPv6MTUInfo(fd, level, opt int) (*IPv6MTUInfo, error)",
        "type": "syscall"
    },
    "syscall.GetsockoptIPv6Mreq": {
        "descr": "",
        "name": "syscall.GetsockoptIPv6Mreq",
        "params": [],
        "path": "go/syscall/index#GetsockoptIPv6Mreq",
        "syntax": "func GetsockoptIPv6Mreq(fd, level, opt int) (*IPv6Mreq, error)",
        "type": "syscall"
    },
    "syscall.GetsockoptInet4Addr": {
        "descr": "",
        "name": "syscall.GetsockoptInet4Addr",
        "params": [],
        "path": "go/syscall/index#GetsockoptInet4Addr",
        "syntax": "func GetsockoptInet4Addr(fd, level, opt int) (value [4]byte, err error)",
        "type": "syscall"
    },
    "syscall.GetsockoptInt": {
        "descr": "",
        "name": "syscall.GetsockoptInt",
        "params": [],
        "path": "go/syscall/index#GetsockoptInt",
        "syntax": "func GetsockoptInt(fd, level, opt int) (value int, err error)",
        "type": "syscall"
    },
    "syscall.GetsockoptUcred": {
        "descr": "",
        "name": "syscall.GetsockoptUcred",
        "params": [],
        "path": "go/syscall/index#GetsockoptUcred",
        "syntax": "func GetsockoptUcred(fd, level, opt int) (*Ucred, error)",
        "type": "syscall"
    },
    "syscall.Gettid": {
        "descr": "",
        "name": "syscall.Gettid",
        "params": [],
        "path": "go/syscall/index#Gettid",
        "syntax": "func Gettid() (tid int)",
        "type": "syscall"
    },
    "syscall.Gettimeofday": {
        "descr": "",
        "name": "syscall.Gettimeofday",
        "params": [],
        "path": "go/syscall/index#Gettimeofday",
        "syntax": "func Gettimeofday(tv *Timeval) (err error)",
        "type": "syscall"
    },
    "syscall.Getuid": {
        "descr": "",
        "name": "syscall.Getuid",
        "params": [],
        "path": "go/syscall/index#Getuid",
        "syntax": "func Getuid() (uid int)",
        "type": "syscall"
    },
    "syscall.Getwd": {
        "descr": "",
        "name": "syscall.Getwd",
        "params": [],
        "path": "go/syscall/index#Getwd",
        "syntax": "func Getwd() (wd string, err error)",
        "type": "syscall"
    },
    "syscall.Getxattr": {
        "descr": "",
        "name": "syscall.Getxattr",
        "params": [],
        "path": "go/syscall/index#Getxattr",
        "syntax": "func Getxattr(path string, attr string, dest []byte) (sz int, err error)",
        "type": "syscall"
    },
    "syscall.ICMPv6Filter": {
        "descr": "",
        "name": "syscall.ICMPv6Filter",
        "params": [],
        "path": "go/syscall/index#ICMPv6Filter",
        "syntax": "type ICMPv6Filter struct { Data [8]uint32 }",
        "type": "syscall"
    },
    "syscall.IPMreq": {
        "descr": "",
        "name": "syscall.IPMreq",
        "params": [],
        "path": "go/syscall/index#IPMreq",
        "syntax": "type IPMreq struct { Multiaddr [4]byte /* in_addr */ Interface [4]byte /* in_addr */ }",
        "type": "syscall"
    },
    "syscall.IPMreqn": {
        "descr": "",
        "name": "syscall.IPMreqn",
        "params": [],
        "path": "go/syscall/index#IPMreqn",
        "syntax": "type IPMreqn struct { Multiaddr [4]byte /* in_addr */ Address [4]byte /* in_addr */ Ifindex int32 }",
        "type": "syscall"
    },
    "syscall.IPv6MTUInfo": {
        "descr": "",
        "name": "syscall.IPv6MTUInfo",
        "params": [],
        "path": "go/syscall/index#IPv6MTUInfo",
        "syntax": "type IPv6MTUInfo struct { Addr RawSockaddrInet6 Mtu uint32 }",
        "type": "syscall"
    },
    "syscall.IPv6Mreq": {
        "descr": "",
        "name": "syscall.IPv6Mreq",
        "params": [],
        "path": "go/syscall/index#IPv6Mreq",
        "syntax": "type IPv6Mreq struct { Multiaddr [16]byte /* in6_addr */ Interface uint32 }",
        "type": "syscall"
    },
    "syscall.IfAddrmsg": {
        "descr": "",
        "name": "syscall.IfAddrmsg",
        "params": [],
        "path": "go/syscall/index#IfAddrmsg",
        "syntax": "type IfAddrmsg struct { Family uint8 Prefixlen uint8 Flags uint8 Scope uint8 Index uint32 }",
        "type": "syscall"
    },
    "syscall.IfInfomsg": {
        "descr": "",
        "name": "syscall.IfInfomsg",
        "params": [],
        "path": "go/syscall/index#IfInfomsg",
        "syntax": "type IfInfomsg struct { Family uint8 X__ifi_pad uint8 Type uint16 Index int32 Flags uint32 Change uint32 }",
        "type": "syscall"
    },
    "syscall.Inet4Pktinfo": {
        "descr": "",
        "name": "syscall.Inet4Pktinfo",
        "params": [],
        "path": "go/syscall/index#Inet4Pktinfo",
        "syntax": "type Inet4Pktinfo struct { Ifindex int32 Spec_dst [4]byte /* in_addr */ Addr [4]byte /* in_addr */ }",
        "type": "syscall"
    },
    "syscall.Inet6Pktinfo": {
        "descr": "",
        "name": "syscall.Inet6Pktinfo",
        "params": [],
        "path": "go/syscall/index#Inet6Pktinfo",
        "syntax": "type Inet6Pktinfo struct { Addr [16]byte /* in6_addr */ Ifindex uint32 }",
        "type": "syscall"
    },
    "syscall.InotifyAddWatch": {
        "descr": "",
        "name": "syscall.InotifyAddWatch",
        "params": [],
        "path": "go/syscall/index#InotifyAddWatch",
        "syntax": "func InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error)",
        "type": "syscall"
    },
    "syscall.InotifyEvent": {
        "descr": "",
        "name": "syscall.InotifyEvent",
        "params": [],
        "path": "go/syscall/index#InotifyEvent",
        "syntax": "type InotifyEvent struct { Wd int32 Mask uint32 Cookie uint32 Len uint32 Name [0]uint8 }",
        "type": "syscall"
    },
    "syscall.InotifyInit": {
        "descr": "",
        "name": "syscall.InotifyInit",
        "params": [],
        "path": "go/syscall/index#InotifyInit",
        "syntax": "func InotifyInit() (fd int, err error)",
        "type": "syscall"
    },
    "syscall.InotifyInit1": {
        "descr": "",
        "name": "syscall.InotifyInit1",
        "params": [],
        "path": "go/syscall/index#InotifyInit1",
        "syntax": "func InotifyInit1(flags int) (fd int, err error)",
        "type": "syscall"
    },
    "syscall.InotifyRmWatch": {
        "descr": "",
        "name": "syscall.InotifyRmWatch",
        "params": [],
        "path": "go/syscall/index#InotifyRmWatch",
        "syntax": "func InotifyRmWatch(fd int, watchdesc uint32) (success int, err error)",
        "type": "syscall"
    },
    "syscall.Ioperm": {
        "descr": "",
        "name": "syscall.Ioperm",
        "params": [],
        "path": "go/syscall/index#Ioperm",
        "syntax": "func Ioperm(from int, num int, on int) (err error)",
        "type": "syscall"
    },
    "syscall.Iopl": {
        "descr": "",
        "name": "syscall.Iopl",
        "params": [],
        "path": "go/syscall/index#Iopl",
        "syntax": "func Iopl(level int) (err error)",
        "type": "syscall"
    },
    "syscall.Iovec": {
        "descr": "",
        "name": "syscall.Iovec",
        "params": [],
        "path": "go/syscall/index#Iovec",
        "syntax": "type Iovec struct { Base *byte Len uint64 }",
        "type": "syscall"
    },
    "syscall.Iovec.SetLen": {
        "descr": "",
        "name": "syscall.Iovec.SetLen",
        "params": [],
        "path": "go/syscall/index#Iovec.SetLen",
        "syntax": "func (iov *Iovec) SetLen(length int)",
        "type": "syscall"
    },
    "syscall.Kill": {
        "descr": "",
        "name": "syscall.Kill",
        "params": [],
        "path": "go/syscall/index#Kill",
        "syntax": "func Kill(pid int, sig Signal) (err error)",
        "type": "syscall"
    },
    "syscall.Klogctl": {
        "descr": "",
        "name": "syscall.Klogctl",
        "params": [],
        "path": "go/syscall/index#Klogctl",
        "syntax": "func Klogctl(typ int, buf []byte) (n int, err error)",
        "type": "syscall"
    },
    "syscall.Lchown": {
        "descr": "",
        "name": "syscall.Lchown",
        "params": [],
        "path": "go/syscall/index#Lchown",
        "syntax": "func Lchown(path string, uid int, gid int) (err error)",
        "type": "syscall"
    },
    "syscall.Linger": {
        "descr": "",
        "name": "syscall.Linger",
        "params": [],
        "path": "go/syscall/index#Linger",
        "syntax": "type Linger struct { Onoff int32 Linger int32 }",
        "type": "syscall"
    },
    "syscall.Link": {
        "descr": "",
        "name": "syscall.Link",
        "params": [],
        "path": "go/syscall/index#Link",
        "syntax": "func Link(oldpath string, newpath string) (err error)",
        "type": "syscall"
    },
    "syscall.Listen": {
        "descr": "",
        "name": "syscall.Listen",
        "params": [],
        "path": "go/syscall/index#Listen",
        "syntax": "func Listen(s int, n int) (err error)",
        "type": "syscall"
    },
    "syscall.Listxattr": {
        "descr": "",
        "name": "syscall.Listxattr",
        "params": [],
        "path": "go/syscall/index#Listxattr",
        "syntax": "func Listxattr(path string, dest []byte) (sz int, err error)",
        "type": "syscall"
    },
    "syscall.LsfJump": {
        "descr": "Deprecated: Use golang.org/x/net/bpf instead.",
        "name": "syscall.LsfJump",
        "params": [],
        "path": "go/syscall/index#LsfJump",
        "syntax": "func LsfJump(code, k, jt, jf int) *SockFilter",
        "type": "syscall"
    },
    "syscall.LsfSocket": {
        "descr": "Deprecated: Use golang.org/x/net/bpf instead.",
        "name": "syscall.LsfSocket",
        "params": [],
        "path": "go/syscall/index#LsfSocket",
        "syntax": "func LsfSocket(ifindex, proto int) (int, error)",
        "type": "syscall"
    },
    "syscall.LsfStmt": {
        "descr": "Deprecated: Use golang.org/x/net/bpf instead.",
        "name": "syscall.LsfStmt",
        "params": [],
        "path": "go/syscall/index#LsfStmt",
        "syntax": "func LsfStmt(code, k int) *SockFilter",
        "type": "syscall"
    },
    "syscall.Lstat": {
        "descr": "",
        "name": "syscall.Lstat",
        "params": [],
        "path": "go/syscall/index#Lstat",
        "syntax": "func Lstat(path string, stat *Stat_t) (err error)",
        "type": "syscall"
    },
    "syscall.Madvise": {
        "descr": "",
        "name": "syscall.Madvise",
        "params": [],
        "path": "go/syscall/index#Madvise",
        "syntax": "func Madvise(b []byte, advice int) (err error)",
        "type": "syscall"
    },
    "syscall.Mkdir": {
        "descr": "",
        "name": "syscall.Mkdir",
        "params": [],
        "path": "go/syscall/index#Mkdir",
        "syntax": "func Mkdir(path string, mode uint32) (err error)",
        "type": "syscall"
    },
    "syscall.Mkdirat": {
        "descr": "",
        "name": "syscall.Mkdirat",
        "params": [],
        "path": "go/syscall/index#Mkdirat",
        "syntax": "func Mkdirat(dirfd int, path string, mode uint32) (err error)",
        "type": "syscall"
    },
    "syscall.Mkfifo": {
        "descr": "",
        "name": "syscall.Mkfifo",
        "params": [],
        "path": "go/syscall/index#Mkfifo",
        "syntax": "func Mkfifo(path string, mode uint32) (err error)",
        "type": "syscall"
    },
    "syscall.Mknod": {
        "descr": "",
        "name": "syscall.Mknod",
        "params": [],
        "path": "go/syscall/index#Mknod",
        "syntax": "func Mknod(path string, mode uint32, dev int) (err error)",
        "type": "syscall"
    },
    "syscall.Mknodat": {
        "descr": "",
        "name": "syscall.Mknodat",
        "params": [],
        "path": "go/syscall/index#Mknodat",
        "syntax": "func Mknodat(dirfd int, path string, mode uint32, dev int) (err error)",
        "type": "syscall"
    },
    "syscall.Mlock": {
        "descr": "",
        "name": "syscall.Mlock",
        "params": [],
        "path": "go/syscall/index#Mlock",
        "syntax": "func Mlock(b []byte) (err error)",
        "type": "syscall"
    },
    "syscall.Mlockall": {
        "descr": "",
        "name": "syscall.Mlockall",
        "params": [],
        "path": "go/syscall/index#Mlockall",
        "syntax": "func Mlockall(flags int) (err error)",
        "type": "syscall"
    },
    "syscall.Mmap": {
        "descr": "",
        "name": "syscall.Mmap",
        "params": [],
        "path": "go/syscall/index#Mmap",
        "syntax": "func Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, err error)",
        "type": "syscall"
    },
    "syscall.Mprotect": {
        "descr": "",
        "name": "syscall.Mprotect",
        "params": [],
        "path": "go/syscall/index#Mprotect",
        "syntax": "func Mprotect(b []byte, prot int) (err error)",
        "type": "syscall"
    },
    "syscall.Msghdr": {
        "descr": "",
        "name": "syscall.Msghdr",
        "params": [],
        "path": "go/syscall/index#Msghdr",
        "syntax": "type Msghdr struct { Name *byte Namelen uint32 Pad_cgo_0 [4]byte Iov *Iovec Iovlen uint64 Control *byte Controllen uint64 Flags int32 Pad_cgo_1 [4]byte }",
        "type": "syscall"
    },
    "syscall.Msghdr.SetControllen": {
        "descr": "",
        "name": "syscall.Msghdr.SetControllen",
        "params": [],
        "path": "go/syscall/index#Msghdr.SetControllen",
        "syntax": "func (msghdr *Msghdr) SetControllen(length int)",
        "type": "syscall"
    },
    "syscall.Munlock": {
        "descr": "",
        "name": "syscall.Munlock",
        "params": [],
        "path": "go/syscall/index#Munlock",
        "syntax": "func Munlock(b []byte) (err error)",
        "type": "syscall"
    },
    "syscall.Munlockall": {
        "descr": "",
        "name": "syscall.Munlockall",
        "params": [],
        "path": "go/syscall/index#Munlockall",
        "syntax": "func Munlockall() (err error)",
        "type": "syscall"
    },
    "syscall.Munmap": {
        "descr": "",
        "name": "syscall.Munmap",
        "params": [],
        "path": "go/syscall/index#Munmap",
        "syntax": "func Munmap(b []byte) (err error)",
        "type": "syscall"
    },
    "syscall.Nanosleep": {
        "descr": "",
        "name": "syscall.Nanosleep",
        "params": [],
        "path": "go/syscall/index#Nanosleep",
        "syntax": "func Nanosleep(time *Timespec, leftover *Timespec) (err error)",
        "type": "syscall"
    },
    "syscall.NetlinkMessage": {
        "descr": "NetlinkMessage represents a netlink message.",
        "name": "syscall.NetlinkMessage",
        "params": [],
        "path": "go/syscall/index#NetlinkMessage",
        "syntax": "type NetlinkMessage struct { Header NlMsghdr Data []byte }",
        "type": "syscall"
    },
    "syscall.NetlinkRIB": {
        "descr": "NetlinkRIB returns routing information base, as known as RIB, which consists of network facility information, states and parameters.",
        "name": "syscall.NetlinkRIB",
        "params": [],
        "path": "go/syscall/index#NetlinkRIB",
        "syntax": "func NetlinkRIB(proto, family int) ([]byte, error)",
        "type": "syscall"
    },
    "syscall.NetlinkRouteAttr": {
        "descr": "NetlinkRouteAttr represents a netlink route attribute.",
        "name": "syscall.NetlinkRouteAttr",
        "params": [],
        "path": "go/syscall/index#NetlinkRouteAttr",
        "syntax": "type NetlinkRouteAttr struct { Attr RtAttr Value []byte }",
        "type": "syscall"
    },
    "syscall.NetlinkRouteRequest": {
        "descr": "NetlinkRouteRequest represents a request message to receive routing and link states from the kernel.",
        "name": "syscall.NetlinkRouteRequest",
        "params": [],
        "path": "go/syscall/index#NetlinkRouteRequest",
        "syntax": "type NetlinkRouteRequest struct { Header NlMsghdr Data RtGenmsg }",
        "type": "syscall"
    },
    "syscall.NlAttr": {
        "descr": "",
        "name": "syscall.NlAttr",
        "params": [],
        "path": "go/syscall/index#NlAttr",
        "syntax": "type NlAttr struct { Len uint16 Type uint16 }",
        "type": "syscall"
    },
    "syscall.NlMsgerr": {
        "descr": "",
        "name": "syscall.NlMsgerr",
        "params": [],
        "path": "go/syscall/index#NlMsgerr",
        "syntax": "type NlMsgerr struct { Error int32 Msg NlMsghdr }",
        "type": "syscall"
    },
    "syscall.NlMsghdr": {
        "descr": "",
        "name": "syscall.NlMsghdr",
        "params": [],
        "path": "go/syscall/index#NlMsghdr",
        "syntax": "type NlMsghdr struct { Len uint32 Type uint16 Flags uint16 Seq uint32 Pid uint32 }",
        "type": "syscall"
    },
    "syscall.NsecToTimespec": {
        "descr": "NsecToTimespec takes a number of nanoseconds since the Unix epoch and returns the corresponding Timespec value.",
        "name": "syscall.NsecToTimespec",
        "params": [],
        "path": "go/syscall/index#NsecToTimespec",
        "syntax": "func NsecToTimespec(nsec int64) Timespec",
        "type": "syscall"
    },
    "syscall.NsecToTimeval": {
        "descr": "NsecToTimeval takes a number of nanoseconds since the Unix epoch and returns the corresponding Timeval value.",
        "name": "syscall.NsecToTimeval",
        "params": [],
        "path": "go/syscall/index#NsecToTimeval",
        "syntax": "func NsecToTimeval(nsec int64) Timeval",
        "type": "syscall"
    },
    "syscall.Open": {
        "descr": "",
        "name": "syscall.Open",
        "params": [],
        "path": "go/syscall/index#Open",
        "syntax": "func Open(path string, mode int, perm uint32) (fd int, err error)",
        "type": "syscall"
    },
    "syscall.Openat": {
        "descr": "",
        "name": "syscall.Openat",
        "params": [],
        "path": "go/syscall/index#Openat",
        "syntax": "func Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error)",
        "type": "syscall"
    },
    "syscall.ParseDirent": {
        "descr": "ParseDirent parses up to max directory entries in buf, appending the names to names. It returns the number of bytes consumed from buf, the number of entries added to names, and the new names slice.",
        "name": "syscall.ParseDirent",
        "params": [],
        "path": "go/syscall/index#ParseDirent",
        "syntax": "func ParseDirent(buf []byte, max int, names []string) (consumed int, count int, newnames []string)",
        "type": "syscall"
    },
    "syscall.ParseNetlinkMessage": {
        "descr": "ParseNetlinkMessage parses b as an array of netlink messages and returns the slice containing the NetlinkMessage structures.",
        "name": "syscall.ParseNetlinkMessage",
        "params": [],
        "path": "go/syscall/index#ParseNetlinkMessage",
        "syntax": "func ParseNetlinkMessage(b []byte) ([]NetlinkMessage, error)",
        "type": "syscall"
    },
    "syscall.ParseNetlinkRouteAttr": {
        "descr": "ParseNetlinkRouteAttr parses m's payload as an array of netlink route attributes and returns the slice containing the NetlinkRouteAttr structures.",
        "name": "syscall.ParseNetlinkRouteAttr",
        "params": [],
        "path": "go/syscall/index#ParseNetlinkRouteAttr",
        "syntax": "func ParseNetlinkRouteAttr(m *NetlinkMessage) ([]NetlinkRouteAttr, error)",
        "type": "syscall"
    },
    "syscall.ParseSocketControlMessage": {
        "descr": "ParseSocketControlMessage parses b as an array of socket control messages.",
        "name": "syscall.ParseSocketControlMessage",
        "params": [],
        "path": "go/syscall/index#ParseSocketControlMessage",
        "syntax": "func ParseSocketControlMessage(b []byte) ([]SocketControlMessage, error)",
        "type": "syscall"
    },
    "syscall.ParseUnixCredentials": {
        "descr": "ParseUnixCredentials decodes a socket control message that contains credentials in a Ucred structure. To receive such a message, the SO_PASSCRED option must be enabled on the socket.",
        "name": "syscall.ParseUnixCredentials",
        "params": [],
        "path": "go/syscall/index#ParseUnixCredentials",
        "syntax": "func ParseUnixCredentials(m *SocketControlMessage) (*Ucred, error)",
        "type": "syscall"
    },
    "syscall.ParseUnixRights": {
        "descr": "ParseUnixRights decodes a socket control message that contains an integer array of open file descriptors from another process.",
        "name": "syscall.ParseUnixRights",
        "params": [],
        "path": "go/syscall/index#ParseUnixRights",
        "syntax": "func ParseUnixRights(m *SocketControlMessage) ([]int, error)",
        "type": "syscall"
    },
    "syscall.Pause": {
        "descr": "",
        "name": "syscall.Pause",
        "params": [],
        "path": "go/syscall/index#Pause",
        "syntax": "func Pause() (err error)",
        "type": "syscall"
    },
    "syscall.Pipe": {
        "descr": "",
        "name": "syscall.Pipe",
        "params": [],
        "path": "go/syscall/index#Pipe",
        "syntax": "func Pipe(p []int) (err error)",
        "type": "syscall"
    },
    "syscall.Pipe2": {
        "descr": "",
        "name": "syscall.Pipe2",
        "params": [],
        "path": "go/syscall/index#Pipe2",
        "syntax": "func Pipe2(p []int, flags int) (err error)",
        "type": "syscall"
    },
    "syscall.PivotRoot": {
        "descr": "",
        "name": "syscall.PivotRoot",
        "params": [],
        "path": "go/syscall/index#PivotRoot",
        "syntax": "func PivotRoot(newroot string, putold string) (err error)",
        "type": "syscall"
    },
    "syscall.Pread": {
        "descr": "",
        "name": "syscall.Pread",
        "params": [],
        "path": "go/syscall/index#Pread",
        "syntax": "func Pread(fd int, p []byte, offset int64) (n int, err error)",
        "type": "syscall"
    },
    "syscall.ProcAttr": {
        "descr": "ProcAttr holds attributes that will be applied to a new process started by StartProcess.",
        "name": "syscall.ProcAttr",
        "params": [],
        "path": "go/syscall/index#ProcAttr",
        "syntax": "type ProcAttr struct { Dir string // Current working directory. Env []string // Environment. Files []uintptr // File descriptors. Sys *SysProcAttr }",
        "type": "syscall"
    },
    "syscall.PtraceAttach": {
        "descr": "",
        "name": "syscall.PtraceAttach",
        "params": [],
        "path": "go/syscall/index#PtraceAttach",
        "syntax": "func PtraceAttach(pid int) (err error)",
        "type": "syscall"
    },
    "syscall.PtraceCont": {
        "descr": "",
        "name": "syscall.PtraceCont",
        "params": [],
        "path": "go/syscall/index#PtraceCont",
        "syntax": "func PtraceCont(pid int, signal int) (err error)",
        "type": "syscall"
    },
    "syscall.PtraceDetach": {
        "descr": "",
        "name": "syscall.PtraceDetach",
        "params": [],
        "path": "go/syscall/index#PtraceDetach",
        "syntax": "func PtraceDetach(pid int) (err error)",
        "type": "syscall"
    },
    "syscall.PtraceGetEventMsg": {
        "descr": "",
        "name": "syscall.PtraceGetEventMsg",
        "params": [],
        "path": "go/syscall/index#PtraceGetEventMsg",
        "syntax": "func PtraceGetEventMsg(pid int) (msg uint, err error)",
        "type": "syscall"
    },
    "syscall.PtraceGetRegs": {
        "descr": "",
        "name": "syscall.PtraceGetRegs",
        "params": [],
        "path": "go/syscall/index#PtraceGetRegs",
        "syntax": "func PtraceGetRegs(pid int, regsout *PtraceRegs) (err error)",
        "type": "syscall"
    },
    "syscall.PtracePeekData": {
        "descr": "",
        "name": "syscall.PtracePeekData",
        "params": [],
        "path": "go/syscall/index#PtracePeekData",
        "syntax": "func PtracePeekData(pid int, addr uintptr, out []byte) (count int, err error)",
        "type": "syscall"
    },
    "syscall.PtracePeekText": {
        "descr": "",
        "name": "syscall.PtracePeekText",
        "params": [],
        "path": "go/syscall/index#PtracePeekText",
        "syntax": "func PtracePeekText(pid int, addr uintptr, out []byte) (count int, err error)",
        "type": "syscall"
    },
    "syscall.PtracePokeData": {
        "descr": "",
        "name": "syscall.PtracePokeData",
        "params": [],
        "path": "go/syscall/index#PtracePokeData",
        "syntax": "func PtracePokeData(pid int, addr uintptr, data []byte) (count int, err error)",
        "type": "syscall"
    },
    "syscall.PtracePokeText": {
        "descr": "",
        "name": "syscall.PtracePokeText",
        "params": [],
        "path": "go/syscall/index#PtracePokeText",
        "syntax": "func PtracePokeText(pid int, addr uintptr, data []byte) (count int, err error)",
        "type": "syscall"
    },
    "syscall.PtraceRegs": {
        "descr": "",
        "name": "syscall.PtraceRegs",
        "params": [],
        "path": "go/syscall/index#PtraceRegs",
        "syntax": "type PtraceRegs struct { R15 uint64 R14 uint64 R13 uint64 R12 uint64 Rbp uint64 Rbx uint64 R11 uint64 R10 uint64 R9 uint64 R8 uint64 Rax uint64 Rcx uint64 Rdx uint64 Rsi uint64 Rdi uint64 Orig_rax uint64 Rip uint64 Cs uint64 Eflags uint64 Rsp uint64 Ss uint64 Fs_base uint64 Gs_base uint64 Ds uint64 Es uint64 Fs uint64 Gs uint64 }",
        "type": "syscall"
    },
    "syscall.PtraceRegs.PC": {
        "descr": "",
        "name": "syscall.PtraceRegs.PC",
        "params": [],
        "path": "go/syscall/index#PtraceRegs.PC",
        "syntax": "func (r *PtraceRegs) PC() uint64",
        "type": "syscall"
    },
    "syscall.PtraceRegs.SetPC": {
        "descr": "",
        "name": "syscall.PtraceRegs.SetPC",
        "params": [],
        "path": "go/syscall/index#PtraceRegs.SetPC",
        "syntax": "func (r *PtraceRegs) SetPC(pc uint64)",
        "type": "syscall"
    },
    "syscall.PtraceSetOptions": {
        "descr": "",
        "name": "syscall.PtraceSetOptions",
        "params": [],
        "path": "go/syscall/index#PtraceSetOptions",
        "syntax": "func PtraceSetOptions(pid int, options int) (err error)",
        "type": "syscall"
    },
    "syscall.PtraceSetRegs": {
        "descr": "",
        "name": "syscall.PtraceSetRegs",
        "params": [],
        "path": "go/syscall/index#PtraceSetRegs",
        "syntax": "func PtraceSetRegs(pid int, regs *PtraceRegs) (err error)",
        "type": "syscall"
    },
    "syscall.PtraceSingleStep": {
        "descr": "",
        "name": "syscall.PtraceSingleStep",
        "params": [],
        "path": "go/syscall/index#PtraceSingleStep",
        "syntax": "func PtraceSingleStep(pid int) (err error)",
        "type": "syscall"
    },
    "syscall.PtraceSyscall": {
        "descr": "",
        "name": "syscall.PtraceSyscall",
        "params": [],
        "path": "go/syscall/index#PtraceSyscall",
        "syntax": "func PtraceSyscall(pid int, signal int) (err error)",
        "type": "syscall"
    },
    "syscall.Pwrite": {
        "descr": "",
        "name": "syscall.Pwrite",
        "params": [],
        "path": "go/syscall/index#Pwrite",
        "syntax": "func Pwrite(fd int, p []byte, offset int64) (n int, err error)",
        "type": "syscall"
    },
    "syscall.RawConn": {
        "descr": "A RawConn is a raw network connection.",
        "name": "syscall.RawConn",
        "params": [],
        "path": "go/syscall/index#RawConn",
        "syntax": "type RawConn interface { // Control invokes f on the underlying connection's file // descriptor or handle. // The file descriptor fd is guaranteed to remain valid while // f executes but not after f returns. Control(f func(fd uintptr)) error // Read invokes f on the underlying connection's file // descriptor or handle; f is expected to try to read from the // file descriptor. // If f returns true, Read returns. Otherwise Read blocks // waiting for the connection to be ready for reading and // tries again repeatedly. // The file descriptor is guaranteed to remain valid while f // executes but not after f returns. Read(f func(fd uintptr) (done bool)) error // Write is like Read but for writing. Write(f func(fd uintptr) (done bool)) error }",
        "type": "syscall"
    },
    "syscall.RawSockaddr": {
        "descr": "",
        "name": "syscall.RawSockaddr",
        "params": [],
        "path": "go/syscall/index#RawSockaddr",
        "syntax": "type RawSockaddr struct { Family uint16 Data [14]int8 }",
        "type": "syscall"
    },
    "syscall.RawSockaddrAny": {
        "descr": "",
        "name": "syscall.RawSockaddrAny",
        "params": [],
        "path": "go/syscall/index#RawSockaddrAny",
        "syntax": "type RawSockaddrAny struct { Addr RawSockaddr Pad [96]int8 }",
        "type": "syscall"
    },
    "syscall.RawSockaddrInet4": {
        "descr": "",
        "name": "syscall.RawSockaddrInet4",
        "params": [],
        "path": "go/syscall/index#RawSockaddrInet4",
        "syntax": "type RawSockaddrInet4 struct { Family uint16 Port uint16 Addr [4]byte /* in_addr */ Zero [8]uint8 }",
        "type": "syscall"
    },
    "syscall.RawSockaddrInet6": {
        "descr": "",
        "name": "syscall.RawSockaddrInet6",
        "params": [],
        "path": "go/syscall/index#RawSockaddrInet6",
        "syntax": "type RawSockaddrInet6 struct { Family uint16 Port uint16 Flowinfo uint32 Addr [16]byte /* in6_addr */ Scope_id uint32 }",
        "type": "syscall"
    },
    "syscall.RawSockaddrLinklayer": {
        "descr": "",
        "name": "syscall.RawSockaddrLinklayer",
        "params": [],
        "path": "go/syscall/index#RawSockaddrLinklayer",
        "syntax": "type RawSockaddrLinklayer struct { Family uint16 Protocol uint16 Ifindex int32 Hatype uint16 Pkttype uint8 Halen uint8 Addr [8]uint8 }",
        "type": "syscall"
    },
    "syscall.RawSockaddrNetlink": {
        "descr": "",
        "name": "syscall.RawSockaddrNetlink",
        "params": [],
        "path": "go/syscall/index#RawSockaddrNetlink",
        "syntax": "type RawSockaddrNetlink struct { Family uint16 Pad uint16 Pid uint32 Groups uint32 }",
        "type": "syscall"
    },
    "syscall.RawSockaddrUnix": {
        "descr": "",
        "name": "syscall.RawSockaddrUnix",
        "params": [],
        "path": "go/syscall/index#RawSockaddrUnix",
        "syntax": "type RawSockaddrUnix struct { Family uint16 Path [108]int8 }",
        "type": "syscall"
    },
    "syscall.RawSyscall": {
        "descr": "",
        "name": "syscall.RawSyscall",
        "params": [],
        "path": "go/syscall/index#RawSyscall",
        "syntax": "func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)",
        "type": "syscall"
    },
    "syscall.RawSyscall6": {
        "descr": "",
        "name": "syscall.RawSyscall6",
        "params": [],
        "path": "go/syscall/index#RawSyscall6",
        "syntax": "func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)",
        "type": "syscall"
    },
    "syscall.Read": {
        "descr": "",
        "name": "syscall.Read",
        "params": [],
        "path": "go/syscall/index#Read",
        "syntax": "func Read(fd int, p []byte) (n int, err error)",
        "type": "syscall"
    },
    "syscall.ReadDirent": {
        "descr": "",
        "name": "syscall.ReadDirent",
        "params": [],
        "path": "go/syscall/index#ReadDirent",
        "syntax": "func ReadDirent(fd int, buf []byte) (n int, err error)",
        "type": "syscall"
    },
    "syscall.Readlink": {
        "descr": "",
        "name": "syscall.Readlink",
        "params": [],
        "path": "go/syscall/index#Readlink",
        "syntax": "func Readlink(path string, buf []byte) (n int, err error)",
        "type": "syscall"
    },
    "syscall.Reboot": {
        "descr": "",
        "name": "syscall.Reboot",
        "params": [],
        "path": "go/syscall/index#Reboot",
        "syntax": "func Reboot(cmd int) (err error)",
        "type": "syscall"
    },
    "syscall.Recvfrom": {
        "descr": "",
        "name": "syscall.Recvfrom",
        "params": [],
        "path": "go/syscall/index#Recvfrom",
        "syntax": "func Recvfrom(fd int, p []byte, flags int) (n int, from Sockaddr, err error)",
        "type": "syscall"
    },
    "syscall.Recvmsg": {
        "descr": "",
        "name": "syscall.Recvmsg",
        "params": [],
        "path": "go/syscall/index#Recvmsg",
        "syntax": "func Recvmsg(fd int, p, oob []byte, flags int) (n, oobn int, recvflags int, from Sockaddr, err error)",
        "type": "syscall"
    },
    "syscall.Removexattr": {
        "descr": "",
        "name": "syscall.Removexattr",
        "params": [],
        "path": "go/syscall/index#Removexattr",
        "syntax": "func Removexattr(path string, attr string) (err error)",
        "type": "syscall"
    },
    "syscall.Rename": {
        "descr": "",
        "name": "syscall.Rename",
        "params": [],
        "path": "go/syscall/index#Rename",
        "syntax": "func Rename(oldpath string, newpath string) (err error)",
        "type": "syscall"
    },
    "syscall.Renameat": {
        "descr": "",
        "name": "syscall.Renameat",
        "params": [],
        "path": "go/syscall/index#Renameat",
        "syntax": "func Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)",
        "type": "syscall"
    },
    "syscall.Rlimit": {
        "descr": "",
        "name": "syscall.Rlimit",
        "params": [],
        "path": "go/syscall/index#Rlimit",
        "syntax": "type Rlimit struct { Cur uint64 Max uint64 }",
        "type": "syscall"
    },
    "syscall.Rmdir": {
        "descr": "",
        "name": "syscall.Rmdir",
        "params": [],
        "path": "go/syscall/index#Rmdir",
        "syntax": "func Rmdir(path string) error",
        "type": "syscall"
    },
    "syscall.RtAttr": {
        "descr": "",
        "name": "syscall.RtAttr",
        "params": [],
        "path": "go/syscall/index#RtAttr",
        "syntax": "type RtAttr struct { Len uint16 Type uint16 }",
        "type": "syscall"
    },
    "syscall.RtGenmsg": {
        "descr": "",
        "name": "syscall.RtGenmsg",
        "params": [],
        "path": "go/syscall/index#RtGenmsg",
        "syntax": "type RtGenmsg struct { Family uint8 }",
        "type": "syscall"
    },
    "syscall.RtMsg": {
        "descr": "",
        "name": "syscall.RtMsg",
        "params": [],
        "path": "go/syscall/index#RtMsg",
        "syntax": "type RtMsg struct { Family uint8 Dst_len uint8 Src_len uint8 Tos uint8 Table uint8 Protocol uint8 Scope uint8 Type uint8 Flags uint32 }",
        "type": "syscall"
    },
    "syscall.RtNexthop": {
        "descr": "",
        "name": "syscall.RtNexthop",
        "params": [],
        "path": "go/syscall/index#RtNexthop",
        "syntax": "type RtNexthop struct { Len uint16 Flags uint8 Hops uint8 Ifindex int32 }",
        "type": "syscall"
    },
    "syscall.Rusage": {
        "descr": "",
        "name": "syscall.Rusage",
        "params": [],
        "path": "go/syscall/index#Rusage",
        "syntax": "type Rusage struct { Utime Timeval Stime Timeval Maxrss int64 Ixrss int64 Idrss int64 Isrss int64 Minflt int64 Majflt int64 Nswap int64 Inblock int64 Oublock int64 Msgsnd int64 Msgrcv int64 Nsignals int64 Nvcsw int64 Nivcsw int64 }",
        "type": "syscall"
    },
    "syscall.Seek": {
        "descr": "",
        "name": "syscall.Seek",
        "params": [],
        "path": "go/syscall/index#Seek",
        "syntax": "func Seek(fd int, offset int64, whence int) (off int64, err error)",
        "type": "syscall"
    },
    "syscall.Select": {
        "descr": "",
        "name": "syscall.Select",
        "params": [],
        "path": "go/syscall/index#Select",
        "syntax": "func Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error)",
        "type": "syscall"
    },
    "syscall.Sendfile": {
        "descr": "",
        "name": "syscall.Sendfile",
        "params": [],
        "path": "go/syscall/index#Sendfile",
        "syntax": "func Sendfile(outfd int, infd int, offset *int64, count int) (written int, err error)",
        "type": "syscall"
    },
    "syscall.Sendmsg": {
        "descr": "",
        "name": "syscall.Sendmsg",
        "params": [],
        "path": "go/syscall/index#Sendmsg",
        "syntax": "func Sendmsg(fd int, p, oob []byte, to Sockaddr, flags int) (err error)",
        "type": "syscall"
    },
    "syscall.SendmsgN": {
        "descr": "",
        "name": "syscall.SendmsgN",
        "params": [],
        "path": "go/syscall/index#SendmsgN",
        "syntax": "func SendmsgN(fd int, p, oob []byte, to Sockaddr, flags int) (n int, err error)",
        "type": "syscall"
    },
    "syscall.Sendto": {
        "descr": "",
        "name": "syscall.Sendto",
        "params": [],
        "path": "go/syscall/index#Sendto",
        "syntax": "func Sendto(fd int, p []byte, flags int, to Sockaddr) (err error)",
        "type": "syscall"
    },
    "syscall.SetLsfPromisc": {
        "descr": "Deprecated: Use golang.org/x/net/bpf instead.",
        "name": "syscall.SetLsfPromisc",
        "params": [],
        "path": "go/syscall/index#SetLsfPromisc",
        "syntax": "func SetLsfPromisc(name string, m bool) error",
        "type": "syscall"
    },
    "syscall.SetNonblock": {
        "descr": "",
        "name": "syscall.SetNonblock",
        "params": [],
        "path": "go/syscall/index#SetNonblock",
        "syntax": "func SetNonblock(fd int, nonblocking bool) (err error)",
        "type": "syscall"
    },
    "syscall.Setdomainname": {
        "descr": "",
        "name": "syscall.Setdomainname",
        "params": [],
        "path": "go/syscall/index#Setdomainname",
        "syntax": "func Setdomainname(p []byte) (err error)",
        "type": "syscall"
    },
    "syscall.Setenv": {
        "descr": "",
        "name": "syscall.Setenv",
        "params": [],
        "path": "go/syscall/index#Setenv",
        "syntax": "func Setenv(key, value string) error",
        "type": "syscall"
    },
    "syscall.Setfsgid": {
        "descr": "",
        "name": "syscall.Setfsgid",
        "params": [],
        "path": "go/syscall/index#Setfsgid",
        "syntax": "func Setfsgid(gid int) (err error)",
        "type": "syscall"
    },
    "syscall.Setfsuid": {
        "descr": "",
        "name": "syscall.Setfsuid",
        "params": [],
        "path": "go/syscall/index#Setfsuid",
        "syntax": "func Setfsuid(uid int) (err error)",
        "type": "syscall"
    },
    "syscall.Setgid": {
        "descr": "",
        "name": "syscall.Setgid",
        "params": [],
        "path": "go/syscall/index#Setgid",
        "syntax": "func Setgid(gid int) (err error)",
        "type": "syscall"
    },
    "syscall.Setgroups": {
        "descr": "",
        "name": "syscall.Setgroups",
        "params": [],
        "path": "go/syscall/index#Setgroups",
        "syntax": "func Setgroups(gids []int) (err error)",
        "type": "syscall"
    },
    "syscall.Sethostname": {
        "descr": "",
        "name": "syscall.Sethostname",
        "params": [],
        "path": "go/syscall/index#Sethostname",
        "syntax": "func Sethostname(p []byte) (err error)",
        "type": "syscall"
    },
    "syscall.Setpgid": {
        "descr": "",
        "name": "syscall.Setpgid",
        "params": [],
        "path": "go/syscall/index#Setpgid",
        "syntax": "func Setpgid(pid int, pgid int) (err error)",
        "type": "syscall"
    },
    "syscall.Setpriority": {
        "descr": "",
        "name": "syscall.Setpriority",
        "params": [],
        "path": "go/syscall/index#Setpriority",
        "syntax": "func Setpriority(which int, who int, prio int) (err error)",
        "type": "syscall"
    },
    "syscall.Setregid": {
        "descr": "",
        "name": "syscall.Setregid",
        "params": [],
        "path": "go/syscall/index#Setregid",
        "syntax": "func Setregid(rgid int, egid int) (err error)",
        "type": "syscall"
    },
    "syscall.Setresgid": {
        "descr": "",
        "name": "syscall.Setresgid",
        "params": [],
        "path": "go/syscall/index#Setresgid",
        "syntax": "func Setresgid(rgid int, egid int, sgid int) (err error)",
        "type": "syscall"
    },
    "syscall.Setresuid": {
        "descr": "",
        "name": "syscall.Setresuid",
        "params": [],
        "path": "go/syscall/index#Setresuid",
        "syntax": "func Setresuid(ruid int, euid int, suid int) (err error)",
        "type": "syscall"
    },
    "syscall.Setreuid": {
        "descr": "",
        "name": "syscall.Setreuid",
        "params": [],
        "path": "go/syscall/index#Setreuid",
        "syntax": "func Setreuid(ruid int, euid int) (err error)",
        "type": "syscall"
    },
    "syscall.Setrlimit": {
        "descr": "",
        "name": "syscall.Setrlimit",
        "params": [],
        "path": "go/syscall/index#Setrlimit",
        "syntax": "func Setrlimit(resource int, rlim *Rlimit) (err error)",
        "type": "syscall"
    },
    "syscall.Setsid": {
        "descr": "",
        "name": "syscall.Setsid",
        "params": [],
        "path": "go/syscall/index#Setsid",
        "syntax": "func Setsid() (pid int, err error)",
        "type": "syscall"
    },
    "syscall.SetsockoptByte": {
        "descr": "",
        "name": "syscall.SetsockoptByte",
        "params": [],
        "path": "go/syscall/index#SetsockoptByte",
        "syntax": "func SetsockoptByte(fd, level, opt int, value byte) (err error)",
        "type": "syscall"
    },
    "syscall.SetsockoptICMPv6Filter": {
        "descr": "",
        "name": "syscall.SetsockoptICMPv6Filter",
        "params": [],
        "path": "go/syscall/index#SetsockoptICMPv6Filter",
        "syntax": "func SetsockoptICMPv6Filter(fd, level, opt int, filter *ICMPv6Filter) error",
        "type": "syscall"
    },
    "syscall.SetsockoptIPMreq": {
        "descr": "",
        "name": "syscall.SetsockoptIPMreq",
        "params": [],
        "path": "go/syscall/index#SetsockoptIPMreq",
        "syntax": "func SetsockoptIPMreq(fd, level, opt int, mreq *IPMreq) (err error)",
        "type": "syscall"
    },
    "syscall.SetsockoptIPMreqn": {
        "descr": "",
        "name": "syscall.SetsockoptIPMreqn",
        "params": [],
        "path": "go/syscall/index#SetsockoptIPMreqn",
        "syntax": "func SetsockoptIPMreqn(fd, level, opt int, mreq *IPMreqn) (err error)",
        "type": "syscall"
    },
    "syscall.SetsockoptIPv6Mreq": {
        "descr": "",
        "name": "syscall.SetsockoptIPv6Mreq",
        "params": [],
        "path": "go/syscall/index#SetsockoptIPv6Mreq",
        "syntax": "func SetsockoptIPv6Mreq(fd, level, opt int, mreq *IPv6Mreq) (err error)",
        "type": "syscall"
    },
    "syscall.SetsockoptInet4Addr": {
        "descr": "",
        "name": "syscall.SetsockoptInet4Addr",
        "params": [],
        "path": "go/syscall/index#SetsockoptInet4Addr",
        "syntax": "func SetsockoptInet4Addr(fd, level, opt int, value [4]byte) (err error)",
        "type": "syscall"
    },
    "syscall.SetsockoptInt": {
        "descr": "",
        "name": "syscall.SetsockoptInt",
        "params": [],
        "path": "go/syscall/index#SetsockoptInt",
        "syntax": "func SetsockoptInt(fd, level, opt int, value int) (err error)",
        "type": "syscall"
    },
    "syscall.SetsockoptLinger": {
        "descr": "",
        "name": "syscall.SetsockoptLinger",
        "params": [],
        "path": "go/syscall/index#SetsockoptLinger",
        "syntax": "func SetsockoptLinger(fd, level, opt int, l *Linger) (err error)",
        "type": "syscall"
    },
    "syscall.SetsockoptString": {
        "descr": "",
        "name": "syscall.SetsockoptString",
        "params": [],
        "path": "go/syscall/index#SetsockoptString",
        "syntax": "func SetsockoptString(fd, level, opt int, s string) (err error)",
        "type": "syscall"
    },
    "syscall.SetsockoptTimeval": {
        "descr": "",
        "name": "syscall.SetsockoptTimeval",
        "params": [],
        "path": "go/syscall/index#SetsockoptTimeval",
        "syntax": "func SetsockoptTimeval(fd, level, opt int, tv *Timeval) (err error)",
        "type": "syscall"
    },
    "syscall.Settimeofday": {
        "descr": "",
        "name": "syscall.Settimeofday",
        "params": [],
        "path": "go/syscall/index#Settimeofday",
        "syntax": "func Settimeofday(tv *Timeval) (err error)",
        "type": "syscall"
    },
    "syscall.Setuid": {
        "descr": "",
        "name": "syscall.Setuid",
        "params": [],
        "path": "go/syscall/index#Setuid",
        "syntax": "func Setuid(uid int) (err error)",
        "type": "syscall"
    },
    "syscall.Setxattr": {
        "descr": "",
        "name": "syscall.Setxattr",
        "params": [],
        "path": "go/syscall/index#Setxattr",
        "syntax": "func Setxattr(path string, attr string, data []byte, flags int) (err error)",
        "type": "syscall"
    },
    "syscall.Shutdown": {
        "descr": "",
        "name": "syscall.Shutdown",
        "params": [],
        "path": "go/syscall/index#Shutdown",
        "syntax": "func Shutdown(fd int, how int) (err error)",
        "type": "syscall"
    },
    "syscall.Signal": {
        "descr": "A Signal is a number describing a process signal. It implements the os.Signal interface.",
        "name": "syscall.Signal",
        "params": [],
        "path": "go/syscall/index#Signal",
        "syntax": "type Signal int",
        "type": "syscall"
    },
    "syscall.Signal.Signal": {
        "descr": "",
        "name": "syscall.Signal.Signal",
        "params": [],
        "path": "go/syscall/index#Signal.Signal",
        "syntax": "func (s Signal) Signal()",
        "type": "syscall"
    },
    "syscall.Signal.String": {
        "descr": "",
        "name": "syscall.Signal.String",
        "params": [],
        "path": "go/syscall/index#Signal.String",
        "syntax": "func (s Signal) String() string",
        "type": "syscall"
    },
    "syscall.SlicePtrFromStrings": {
        "descr": "SlicePtrFromStrings converts a slice of strings to a slice of pointers to NUL-terminated byte arrays. If any string contains a NUL byte, it returns (nil, EINVAL).",
        "name": "syscall.SlicePtrFromStrings",
        "params": [],
        "path": "go/syscall/index#SlicePtrFromStrings",
        "syntax": "func SlicePtrFromStrings(ss []string) ([]*byte, error)",
        "type": "syscall"
    },
    "syscall.SockFilter": {
        "descr": "",
        "name": "syscall.SockFilter",
        "params": [],
        "path": "go/syscall/index#SockFilter",
        "syntax": "type SockFilter struct { Code uint16 Jt uint8 Jf uint8 K uint32 }",
        "type": "syscall"
    },
    "syscall.SockFprog": {
        "descr": "",
        "name": "syscall.SockFprog",
        "params": [],
        "path": "go/syscall/index#SockFprog",
        "syntax": "type SockFprog struct { Len uint16 Pad_cgo_0 [6]byte Filter *SockFilter }",
        "type": "syscall"
    },
    "syscall.Sockaddr": {
        "descr": "",
        "name": "syscall.Sockaddr",
        "params": [],
        "path": "go/syscall/index#Sockaddr",
        "syntax": "type Sockaddr interface { // contains filtered or unexported methods }",
        "type": "syscall"
    },
    "syscall.SockaddrInet4": {
        "descr": "",
        "name": "syscall.SockaddrInet4",
        "params": [],
        "path": "go/syscall/index#SockaddrInet4",
        "syntax": "type SockaddrInet4 struct { Port int Addr [4]byte // contains filtered or unexported fields }",
        "type": "syscall"
    },
    "syscall.SockaddrInet6": {
        "descr": "",
        "name": "syscall.SockaddrInet6",
        "params": [],
        "path": "go/syscall/index#SockaddrInet6",
        "syntax": "type SockaddrInet6 struct { Port int ZoneId uint32 Addr [16]byte // contains filtered or unexported fields }",
        "type": "syscall"
    },
    "syscall.SockaddrLinklayer": {
        "descr": "",
        "name": "syscall.SockaddrLinklayer",
        "params": [],
        "path": "go/syscall/index#SockaddrLinklayer",
        "syntax": "type SockaddrLinklayer struct { Protocol uint16 Ifindex int Hatype uint16 Pkttype uint8 Halen uint8 Addr [8]byte // contains filtered or unexported fields }",
        "type": "syscall"
    },
    "syscall.SockaddrNetlink": {
        "descr": "",
        "name": "syscall.SockaddrNetlink",
        "params": [],
        "path": "go/syscall/index#SockaddrNetlink",
        "syntax": "type SockaddrNetlink struct { Family uint16 Pad uint16 Pid uint32 Groups uint32 // contains filtered or unexported fields }",
        "type": "syscall"
    },
    "syscall.SockaddrUnix": {
        "descr": "",
        "name": "syscall.SockaddrUnix",
        "params": [],
        "path": "go/syscall/index#SockaddrUnix",
        "syntax": "type SockaddrUnix struct { Name string // contains filtered or unexported fields }",
        "type": "syscall"
    },
    "syscall.Socket": {
        "descr": "",
        "name": "syscall.Socket",
        "params": [],
        "path": "go/syscall/index#Socket",
        "syntax": "func Socket(domain, typ, proto int) (fd int, err error)",
        "type": "syscall"
    },
    "syscall.SocketControlMessage": {
        "descr": "SocketControlMessage represents a socket control message.",
        "name": "syscall.SocketControlMessage",
        "params": [],
        "path": "go/syscall/index#SocketControlMessage",
        "syntax": "type SocketControlMessage struct { Header Cmsghdr Data []byte }",
        "type": "syscall"
    },
    "syscall.Socketpair": {
        "descr": "",
        "name": "syscall.Socketpair",
        "params": [],
        "path": "go/syscall/index#Socketpair",
        "syntax": "func Socketpair(domain, typ, proto int) (fd [2]int, err error)",
        "type": "syscall"
    },
    "syscall.Splice": {
        "descr": "",
        "name": "syscall.Splice",
        "params": [],
        "path": "go/syscall/index#Splice",
        "syntax": "func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error)",
        "type": "syscall"
    },
    "syscall.StartProcess": {
        "descr": "StartProcess wraps ForkExec for package os.",
        "name": "syscall.StartProcess",
        "params": [],
        "path": "go/syscall/index#StartProcess",
        "syntax": "func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid int, handle uintptr, err error)",
        "type": "syscall"
    },
    "syscall.Stat": {
        "descr": "",
        "name": "syscall.Stat",
        "params": [],
        "path": "go/syscall/index#Stat",
        "syntax": "func Stat(path string, stat *Stat_t) (err error)",
        "type": "syscall"
    },
    "syscall.Stat_t": {
        "descr": "",
        "name": "syscall.Stat_t",
        "params": [],
        "path": "go/syscall/index#Stat_t",
        "syntax": "type Stat_t struct { Dev uint64 Ino uint64 Nlink uint64 Mode uint32 Uid uint32 Gid uint32 X__pad0 int32 Rdev uint64 Size int64 Blksize int64 Blocks int64 Atim Timespec Mtim Timespec Ctim Timespec X__unused [3]int64 }",
        "type": "syscall"
    },
    "syscall.Statfs": {
        "descr": "",
        "name": "syscall.Statfs",
        "params": [],
        "path": "go/syscall/index#Statfs",
        "syntax": "func Statfs(path string, buf *Statfs_t) (err error)",
        "type": "syscall"
    },
    "syscall.Statfs_t": {
        "descr": "",
        "name": "syscall.Statfs_t",
        "params": [],
        "path": "go/syscall/index#Statfs_t",
        "syntax": "type Statfs_t struct { Type int64 Bsize int64 Blocks uint64 Bfree uint64 Bavail uint64 Files uint64 Ffree uint64 Fsid Fsid Namelen int64 Frsize int64 Flags int64 Spare [4]int64 }",
        "type": "syscall"
    },
    "syscall.StringBytePtr": {
        "descr": "StringBytePtr returns a pointer to a NUL-terminated array of bytes. If s contains a NUL byte this function panics instead of returning an error.",
        "name": "syscall.StringBytePtr",
        "params": [],
        "path": "go/syscall/index#StringBytePtr",
        "syntax": "func StringBytePtr(s string) *byte",
        "type": "syscall"
    },
    "syscall.StringByteSlice": {
        "descr": "StringByteSlice converts a string to a NUL-terminated []byte, If s contains a NUL byte this function panics instead of returning an error.",
        "name": "syscall.StringByteSlice",
        "params": [],
        "path": "go/syscall/index#StringByteSlice",
        "syntax": "func StringByteSlice(s string) []byte",
        "type": "syscall"
    },
    "syscall.StringSlicePtr": {
        "descr": "StringSlicePtr converts a slice of strings to a slice of pointers to NUL-terminated byte arrays. If any string contains a NUL byte this function panics instead of returning an error.",
        "name": "syscall.StringSlicePtr",
        "params": [],
        "path": "go/syscall/index#StringSlicePtr",
        "syntax": "func StringSlicePtr(ss []string) []*byte",
        "type": "syscall"
    },
    "syscall.Symlink": {
        "descr": "",
        "name": "syscall.Symlink",
        "params": [],
        "path": "go/syscall/index#Symlink",
        "syntax": "func Symlink(oldpath string, newpath string) (err error)",
        "type": "syscall"
    },
    "syscall.Sync": {
        "descr": "",
        "name": "syscall.Sync",
        "params": [],
        "path": "go/syscall/index#Sync",
        "syntax": "func Sync()",
        "type": "syscall"
    },
    "syscall.SyncFileRange": {
        "descr": "",
        "name": "syscall.SyncFileRange",
        "params": [],
        "path": "go/syscall/index#SyncFileRange",
        "syntax": "func SyncFileRange(fd int, off int64, n int64, flags int) (err error)",
        "type": "syscall"
    },
    "syscall.SysProcAttr": {
        "descr": "",
        "name": "syscall.SysProcAttr",
        "params": [],
        "path": "go/syscall/index#SysProcAttr",
        "syntax": "type SysProcAttr struct { Chroot string // Chroot. Credential *Credential // Credential. Ptrace bool // Enable tracing. Setsid bool // Create session. Setpgid bool // Set process group ID to Pgid, or, if Pgid == 0, to new pid. Setctty bool // Set controlling terminal to fd Ctty (only meaningful if Setsid is set) Noctty bool // Detach fd 0 from controlling terminal Ctty int // Controlling TTY fd Foreground bool // Place child's process group in foreground. (Implies Setpgid. Uses Ctty as fd of controlling TTY) Pgid int // Child's process group ID if Setpgid. Pdeathsig Signal // Signal that the process will get when its parent dies (Linux only) Cloneflags uintptr // Flags for clone calls (Linux only) Unshareflags uintptr // Flags for unshare calls (Linux only) UidMappings []SysProcIDMap // User ID mappings for user namespaces. GidMappings []SysProcIDMap // Group ID mappings for user namespaces. // GidMappingsEnableSetgroups enabling setgroups syscall. // If false, then setgroups syscall will be disabled for the child process. // This parameter is no-op if GidMappings == nil. Otherwise for unprivileged // users this should be set to false for mappings work. GidMappingsEnableSetgroups bool AmbientCaps []uintptr // Ambient capabilities (Linux only) }",
        "type": "syscall"
    },
    "syscall.SysProcIDMap": {
        "descr": "SysProcIDMap holds Container ID to Host ID mappings used for User Namespaces in Linux. See user_namespaces(7).",
        "name": "syscall.SysProcIDMap",
        "params": [],
        "path": "go/syscall/index#SysProcIDMap",
        "syntax": "type SysProcIDMap struct { ContainerID int // Container ID. HostID int // Host ID. Size int // Size. }",
        "type": "syscall"
    },
    "syscall.Syscall": {
        "descr": "",
        "name": "syscall.Syscall",
        "params": [],
        "path": "go/syscall/index#Syscall",
        "syntax": "func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)",
        "type": "syscall"
    },
    "syscall.Syscall6": {
        "descr": "",
        "name": "syscall.Syscall6",
        "params": [],
        "path": "go/syscall/index#Syscall6",
        "syntax": "func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)",
        "type": "syscall"
    },
    "syscall.Sysinfo": {
        "descr": "",
        "name": "syscall.Sysinfo",
        "params": [],
        "path": "go/syscall/index#Sysinfo",
        "syntax": "func Sysinfo(info *Sysinfo_t) (err error)",
        "type": "syscall"
    },
    "syscall.Sysinfo_t": {
        "descr": "",
        "name": "syscall.Sysinfo_t",
        "params": [],
        "path": "go/syscall/index#Sysinfo_t",
        "syntax": "type Sysinfo_t struct { Uptime int64 Loads [3]uint64 Totalram uint64 Freeram uint64 Sharedram uint64 Bufferram uint64 Totalswap uint64 Freeswap uint64 Procs uint16 Pad uint16 Pad_cgo_0 [4]byte Totalhigh uint64 Freehigh uint64 Unit uint32 X_f [0]byte Pad_cgo_1 [4]byte }",
        "type": "syscall"
    },
    "syscall.TCPInfo": {
        "descr": "",
        "name": "syscall.TCPInfo",
        "params": [],
        "path": "go/syscall/index#TCPInfo",
        "syntax": "type TCPInfo struct { State uint8 Ca_state uint8 Retransmits uint8 Probes uint8 Backoff uint8 Options uint8 Pad_cgo_0 [2]byte Rto uint32 Ato uint32 Snd_mss uint32 Rcv_mss uint32 Unacked uint32 Sacked uint32 Lost uint32 Retrans uint32 Fackets uint32 Last_data_sent uint32 Last_ack_sent uint32 Last_data_recv uint32 Last_ack_recv uint32 Pmtu uint32 Rcv_ssthresh uint32 Rtt uint32 Rttvar uint32 Snd_ssthresh uint32 Snd_cwnd uint32 Advmss uint32 Reordering uint32 Rcv_rtt uint32 Rcv_space uint32 Total_retrans uint32 }",
        "type": "syscall"
    },
    "syscall.Tee": {
        "descr": "",
        "name": "syscall.Tee",
        "params": [],
        "path": "go/syscall/index#Tee",
        "syntax": "func Tee(rfd int, wfd int, len int, flags int) (n int64, err error)",
        "type": "syscall"
    },
    "syscall.Termios": {
        "descr": "",
        "name": "syscall.Termios",
        "params": [],
        "path": "go/syscall/index#Termios",
        "syntax": "type Termios struct { Iflag uint32 Oflag uint32 Cflag uint32 Lflag uint32 Line uint8 Cc [32]uint8 Pad_cgo_0 [3]byte Ispeed uint32 Ospeed uint32 }",
        "type": "syscall"
    },
    "syscall.Tgkill": {
        "descr": "",
        "name": "syscall.Tgkill",
        "params": [],
        "path": "go/syscall/index#Tgkill",
        "syntax": "func Tgkill(tgid int, tid int, sig Signal) (err error)",
        "type": "syscall"
    },
    "syscall.Time": {
        "descr": "",
        "name": "syscall.Time",
        "params": [],
        "path": "go/syscall/index#Time",
        "syntax": "func Time(t *Time_t) (tt Time_t, err error)",
        "type": "syscall"
    },
    "syscall.Time_t": {
        "descr": "",
        "name": "syscall.Time_t",
        "params": [],
        "path": "go/syscall/index#Time_t",
        "syntax": "type Time_t int64",
        "type": "syscall"
    },
    "syscall.Times": {
        "descr": "",
        "name": "syscall.Times",
        "params": [],
        "path": "go/syscall/index#Times",
        "syntax": "func Times(tms *Tms) (ticks uintptr, err error)",
        "type": "syscall"
    },
    "syscall.Timespec": {
        "descr": "",
        "name": "syscall.Timespec",
        "params": [],
        "path": "go/syscall/index#Timespec",
        "syntax": "type Timespec struct { Sec int64 Nsec int64 }",
        "type": "syscall"
    },
    "syscall.Timespec.Nano": {
        "descr": "Nano returns ts as the number of nanoseconds elapsed since the Unix epoch.",
        "name": "syscall.Timespec.Nano",
        "params": [],
        "path": "go/syscall/index#Timespec.Nano",
        "syntax": "func (ts *Timespec) Nano() int64",
        "type": "syscall"
    },
    "syscall.Timespec.Unix": {
        "descr": "Unix returns ts as the number of seconds and nanoseconds elapsed since the Unix epoch.",
        "name": "syscall.Timespec.Unix",
        "params": [],
        "path": "go/syscall/index#Timespec.Unix",
        "syntax": "func (ts *Timespec) Unix() (sec int64, nsec int64)",
        "type": "syscall"
    },
    "syscall.TimespecToNsec": {
        "descr": "TimespecToNsec converts a Timespec value into a number of nanoseconds since the Unix epoch.",
        "name": "syscall.TimespecToNsec",
        "params": [],
        "path": "go/syscall/index#TimespecToNsec",
        "syntax": "func TimespecToNsec(ts Timespec) int64",
        "type": "syscall"
    },
    "syscall.Timeval": {
        "descr": "",
        "name": "syscall.Timeval",
        "params": [],
        "path": "go/syscall/index#Timeval",
        "syntax": "type Timeval struct { Sec int64 Usec int64 }",
        "type": "syscall"
    },
    "syscall.Timeval.Nano": {
        "descr": "Nano returns tv as the number of nanoseconds elapsed since the Unix epoch.",
        "name": "syscall.Timeval.Nano",
        "params": [],
        "path": "go/syscall/index#Timeval.Nano",
        "syntax": "func (tv *Timeval) Nano() int64",
        "type": "syscall"
    },
    "syscall.Timeval.Unix": {
        "descr": "Unix returns tv as the number of seconds and nanoseconds elapsed since the Unix epoch.",
        "name": "syscall.Timeval.Unix",
        "params": [],
        "path": "go/syscall/index#Timeval.Unix",
        "syntax": "func (tv *Timeval) Unix() (sec int64, nsec int64)",
        "type": "syscall"
    },
    "syscall.TimevalToNsec": {
        "descr": "TimevalToNsec converts a Timeval value into a number of nanoseconds since the Unix epoch.",
        "name": "syscall.TimevalToNsec",
        "params": [],
        "path": "go/syscall/index#TimevalToNsec",
        "syntax": "func TimevalToNsec(tv Timeval) int64",
        "type": "syscall"
    },
    "syscall.Timex": {
        "descr": "",
        "name": "syscall.Timex",
        "params": [],
        "path": "go/syscall/index#Timex",
        "syntax": "type Timex struct { Modes uint32 Pad_cgo_0 [4]byte Offset int64 Freq int64 Maxerror int64 Esterror int64 Status int32 Pad_cgo_1 [4]byte Constant int64 Precision int64 Tolerance int64 Time Timeval Tick int64 Ppsfreq int64 Jitter int64 Shift int32 Pad_cgo_2 [4]byte Stabil int64 Jitcnt int64 Calcnt int64 Errcnt int64 Stbcnt int64 Tai int32 Pad_cgo_3 [44]byte }",
        "type": "syscall"
    },
    "syscall.Tms": {
        "descr": "",
        "name": "syscall.Tms",
        "params": [],
        "path": "go/syscall/index#Tms",
        "syntax": "type Tms struct { Utime int64 Stime int64 Cutime int64 Cstime int64 }",
        "type": "syscall"
    },
    "syscall.Truncate": {
        "descr": "",
        "name": "syscall.Truncate",
        "params": [],
        "path": "go/syscall/index#Truncate",
        "syntax": "func Truncate(path string, length int64) (err error)",
        "type": "syscall"
    },
    "syscall.Ucred": {
        "descr": "",
        "name": "syscall.Ucred",
        "params": [],
        "path": "go/syscall/index#Ucred",
        "syntax": "type Ucred struct { Pid int32 Uid uint32 Gid uint32 }",
        "type": "syscall"
    },
    "syscall.Umask": {
        "descr": "",
        "name": "syscall.Umask",
        "params": [],
        "path": "go/syscall/index#Umask",
        "syntax": "func Umask(mask int) (oldmask int)",
        "type": "syscall"
    },
    "syscall.Uname": {
        "descr": "",
        "name": "syscall.Uname",
        "params": [],
        "path": "go/syscall/index#Uname",
        "syntax": "func Uname(buf *Utsname) (err error)",
        "type": "syscall"
    },
    "syscall.UnixCredentials": {
        "descr": "UnixCredentials encodes credentials into a socket control message for sending to another process. This can be used for authentication.",
        "name": "syscall.UnixCredentials",
        "params": [],
        "path": "go/syscall/index#UnixCredentials",
        "syntax": "func UnixCredentials(ucred *Ucred) []byte",
        "type": "syscall"
    },
    "syscall.UnixRights": {
        "descr": "UnixRights encodes a set of open file descriptors into a socket control message for sending to another process.",
        "name": "syscall.UnixRights",
        "params": [],
        "path": "go/syscall/index#UnixRights",
        "syntax": "func UnixRights(fds ...int) []byte",
        "type": "syscall"
    },
    "syscall.Unlink": {
        "descr": "",
        "name": "syscall.Unlink",
        "params": [],
        "path": "go/syscall/index#Unlink",
        "syntax": "func Unlink(path string) error",
        "type": "syscall"
    },
    "syscall.Unlinkat": {
        "descr": "",
        "name": "syscall.Unlinkat",
        "params": [],
        "path": "go/syscall/index#Unlinkat",
        "syntax": "func Unlinkat(dirfd int, path string) error",
        "type": "syscall"
    },
    "syscall.Unmount": {
        "descr": "",
        "name": "syscall.Unmount",
        "params": [],
        "path": "go/syscall/index#Unmount",
        "syntax": "func Unmount(target string, flags int) (err error)",
        "type": "syscall"
    },
    "syscall.Unsetenv": {
        "descr": "",
        "name": "syscall.Unsetenv",
        "params": [],
        "path": "go/syscall/index#Unsetenv",
        "syntax": "func Unsetenv(key string) error",
        "type": "syscall"
    },
    "syscall.Unshare": {
        "descr": "",
        "name": "syscall.Unshare",
        "params": [],
        "path": "go/syscall/index#Unshare",
        "syntax": "func Unshare(flags int) (err error)",
        "type": "syscall"
    },
    "syscall.Ustat": {
        "descr": "",
        "name": "syscall.Ustat",
        "params": [],
        "path": "go/syscall/index#Ustat",
        "syntax": "func Ustat(dev int, ubuf *Ustat_t) (err error)",
        "type": "syscall"
    },
    "syscall.Ustat_t": {
        "descr": "",
        "name": "syscall.Ustat_t",
        "params": [],
        "path": "go/syscall/index#Ustat_t",
        "syntax": "type Ustat_t struct { Tfree int32 Pad_cgo_0 [4]byte Tinode uint64 Fname [6]int8 Fpack [6]int8 Pad_cgo_1 [4]byte }",
        "type": "syscall"
    },
    "syscall.Utimbuf": {
        "descr": "",
        "name": "syscall.Utimbuf",
        "params": [],
        "path": "go/syscall/index#Utimbuf",
        "syntax": "type Utimbuf struct { Actime int64 Modtime int64 }",
        "type": "syscall"
    },
    "syscall.Utime": {
        "descr": "",
        "name": "syscall.Utime",
        "params": [],
        "path": "go/syscall/index#Utime",
        "syntax": "func Utime(path string, buf *Utimbuf) (err error)",
        "type": "syscall"
    },
    "syscall.Utimes": {
        "descr": "",
        "name": "syscall.Utimes",
        "params": [],
        "path": "go/syscall/index#Utimes",
        "syntax": "func Utimes(path string, tv []Timeval) (err error)",
        "type": "syscall"
    },
    "syscall.UtimesNano": {
        "descr": "",
        "name": "syscall.UtimesNano",
        "params": [],
        "path": "go/syscall/index#UtimesNano",
        "syntax": "func UtimesNano(path string, ts []Timespec) (err error)",
        "type": "syscall"
    },
    "syscall.Utsname": {
        "descr": "",
        "name": "syscall.Utsname",
        "params": [],
        "path": "go/syscall/index#Utsname",
        "syntax": "type Utsname struct { Sysname [65]int8 Nodename [65]int8 Release [65]int8 Version [65]int8 Machine [65]int8 Domainname [65]int8 }",
        "type": "syscall"
    },
    "syscall.Wait4": {
        "descr": "",
        "name": "syscall.Wait4",
        "params": [],
        "path": "go/syscall/index#Wait4",
        "syntax": "func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, err error)",
        "type": "syscall"
    },
    "syscall.WaitStatus": {
        "descr": "",
        "name": "syscall.WaitStatus",
        "params": [],
        "path": "go/syscall/index#WaitStatus",
        "syntax": "type WaitStatus uint32",
        "type": "syscall"
    },
    "syscall.WaitStatus.Continued": {
        "descr": "",
        "name": "syscall.WaitStatus.Continued",
        "params": [],
        "path": "go/syscall/index#WaitStatus.Continued",
        "syntax": "func (w WaitStatus) Continued() bool",
        "type": "syscall"
    },
    "syscall.WaitStatus.CoreDump": {
        "descr": "",
        "name": "syscall.WaitStatus.CoreDump",
        "params": [],
        "path": "go/syscall/index#WaitStatus.CoreDump",
        "syntax": "func (w WaitStatus) CoreDump() bool",
        "type": "syscall"
    },
    "syscall.WaitStatus.ExitStatus": {
        "descr": "",
        "name": "syscall.WaitStatus.ExitStatus",
        "params": [],
        "path": "go/syscall/index#WaitStatus.ExitStatus",
        "syntax": "func (w WaitStatus) ExitStatus() int",
        "type": "syscall"
    },
    "syscall.WaitStatus.Exited": {
        "descr": "",
        "name": "syscall.WaitStatus.Exited",
        "params": [],
        "path": "go/syscall/index#WaitStatus.Exited",
        "syntax": "func (w WaitStatus) Exited() bool",
        "type": "syscall"
    },
    "syscall.WaitStatus.Signal": {
        "descr": "",
        "name": "syscall.WaitStatus.Signal",
        "params": [],
        "path": "go/syscall/index#WaitStatus.Signal",
        "syntax": "func (w WaitStatus) Signal() Signal",
        "type": "syscall"
    },
    "syscall.WaitStatus.Signaled": {
        "descr": "",
        "name": "syscall.WaitStatus.Signaled",
        "params": [],
        "path": "go/syscall/index#WaitStatus.Signaled",
        "syntax": "func (w WaitStatus) Signaled() bool",
        "type": "syscall"
    },
    "syscall.WaitStatus.StopSignal": {
        "descr": "",
        "name": "syscall.WaitStatus.StopSignal",
        "params": [],
        "path": "go/syscall/index#WaitStatus.StopSignal",
        "syntax": "func (w WaitStatus) StopSignal() Signal",
        "type": "syscall"
    },
    "syscall.WaitStatus.Stopped": {
        "descr": "",
        "name": "syscall.WaitStatus.Stopped",
        "params": [],
        "path": "go/syscall/index#WaitStatus.Stopped",
        "syntax": "func (w WaitStatus) Stopped() bool",
        "type": "syscall"
    },
    "syscall.WaitStatus.TrapCause": {
        "descr": "",
        "name": "syscall.WaitStatus.TrapCause",
        "params": [],
        "path": "go/syscall/index#WaitStatus.TrapCause",
        "syntax": "func (w WaitStatus) TrapCause() int",
        "type": "syscall"
    },
    "syscall.Write": {
        "descr": "",
        "name": "syscall.Write",
        "params": [],
        "path": "go/syscall/index#Write",
        "syntax": "func Write(fd int, p []byte) (n int, err error)",
        "type": "syscall"
    },
    "syscall.string": {
        "descr": "",
        "name": "syscall.string",
        "params": [],
        "path": "go/syscall/index#Mount",
        "syntax": "func Mount(source string, target string, fstype string, flags uintptr, data string) (err error)",
        "type": "syscall"
    },
    "syslog.Dial": {
        "descr": "Dial establishes a connection to a log daemon by connecting to address raddr on the specified network. Each write to the returned writer sends a log message with the facility and severity (from priority) and tag. If tag is empty, the os.Args[0] is used. If network is empty, Dial will connect to the local syslog server. Otherwise, see the documentation for net.Dial for valid values of network and raddr.",
        "name": "syslog.Dial",
        "params": [],
        "path": "go/log/syslog/index#Dial",
        "syntax": "func Dial(network, raddr string, priority Priority, tag string) (*Writer, error)",
        "type": "log"
    },
    "syslog.New": {
        "descr": "New establishes a new connection to the system log daemon. Each write to the returned writer sends a log message with the given priority (a combination of the syslog facility and severity) and prefix tag. If tag is empty, the os.Args[0] is used.",
        "name": "syslog.New",
        "params": [],
        "path": "go/log/syslog/index#New",
        "syntax": "func New(priority Priority, tag string) (*Writer, error)",
        "type": "log"
    },
    "syslog.NewLogger": {
        "descr": "NewLogger creates a log.Logger whose output is written to the system log service with the specified priority, a combination of the syslog facility and severity. The logFlag argument is the flag set passed through to log.New to create the Logger.",
        "name": "syslog.NewLogger",
        "params": [],
        "path": "go/log/syslog/index#NewLogger",
        "syntax": "func NewLogger(p Priority, logFlag int) (*log.Logger, error)",
        "type": "log"
    },
    "syslog.Priority": {
        "descr": "The Priority is a combination of the syslog facility and severity. For example, LOG_ALERT | LOG_FTP sends an alert severity message from the FTP facility. The default severity is LOG_EMERG; the default facility is LOG_KERN.",
        "name": "syslog.Priority",
        "params": [],
        "path": "go/log/syslog/index#Priority",
        "syntax": "type Priority int",
        "type": "log"
    },
    "syslog.Writer": {
        "descr": "A Writer is a connection to a syslog server.",
        "name": "syslog.Writer",
        "params": [],
        "path": "go/log/syslog/index#Writer",
        "syntax": "type Writer struct { // contains filtered or unexported fields }",
        "type": "log"
    },
    "syslog.Writer.Alert": {
        "descr": "Alert logs a message with severity LOG_ALERT, ignoring the severity passed to New.",
        "name": "syslog.Writer.Alert",
        "params": [],
        "path": "go/log/syslog/index#Writer.Alert",
        "syntax": "func (w *Writer) Alert(m string) error",
        "type": "log"
    },
    "syslog.Writer.Close": {
        "descr": "Close closes a connection to the syslog daemon.",
        "name": "syslog.Writer.Close",
        "params": [],
        "path": "go/log/syslog/index#Writer.Close",
        "syntax": "func (w *Writer) Close() error",
        "type": "log"
    },
    "syslog.Writer.Crit": {
        "descr": "Crit logs a message with severity LOG_CRIT, ignoring the severity passed to New.",
        "name": "syslog.Writer.Crit",
        "params": [],
        "path": "go/log/syslog/index#Writer.Crit",
        "syntax": "func (w *Writer) Crit(m string) error",
        "type": "log"
    },
    "syslog.Writer.Debug": {
        "descr": "Debug logs a message with severity LOG_DEBUG, ignoring the severity passed to New.",
        "name": "syslog.Writer.Debug",
        "params": [],
        "path": "go/log/syslog/index#Writer.Debug",
        "syntax": "func (w *Writer) Debug(m string) error",
        "type": "log"
    },
    "syslog.Writer.Emerg": {
        "descr": "Emerg logs a message with severity LOG_EMERG, ignoring the severity passed to New.",
        "name": "syslog.Writer.Emerg",
        "params": [],
        "path": "go/log/syslog/index#Writer.Emerg",
        "syntax": "func (w *Writer) Emerg(m string) error",
        "type": "log"
    },
    "syslog.Writer.Err": {
        "descr": "Err logs a message with severity LOG_ERR, ignoring the severity passed to New.",
        "name": "syslog.Writer.Err",
        "params": [],
        "path": "go/log/syslog/index#Writer.Err",
        "syntax": "func (w *Writer) Err(m string) error",
        "type": "log"
    },
    "syslog.Writer.Info": {
        "descr": "Info logs a message with severity LOG_INFO, ignoring the severity passed to New.",
        "name": "syslog.Writer.Info",
        "params": [],
        "path": "go/log/syslog/index#Writer.Info",
        "syntax": "func (w *Writer) Info(m string) error",
        "type": "log"
    },
    "syslog.Writer.Notice": {
        "descr": "Notice logs a message with severity LOG_NOTICE, ignoring the severity passed to New.",
        "name": "syslog.Writer.Notice",
        "params": [],
        "path": "go/log/syslog/index#Writer.Notice",
        "syntax": "func (w *Writer) Notice(m string) error",
        "type": "log"
    },
    "syslog.Writer.Warning": {
        "descr": "Warning logs a message with severity LOG_WARNING, ignoring the severity passed to New.",
        "name": "syslog.Writer.Warning",
        "params": [],
        "path": "go/log/syslog/index#Writer.Warning",
        "syntax": "func (w *Writer) Warning(m string) error",
        "type": "log"
    },
    "syslog.Writer.Write": {
        "descr": "Write sends a log message to the syslog daemon.",
        "name": "syslog.Writer.Write",
        "params": [],
        "path": "go/log/syslog/index#Writer.Write",
        "syntax": "func (w *Writer) Write(b []byte) (int, error)",
        "type": "log"
    },
    "tabwriter.NewWriter": {
        "descr": "NewWriter allocates and initializes a new tabwriter.Writer. The parameters are the same as for the Init function.",
        "name": "tabwriter.NewWriter",
        "params": [],
        "path": "go/text/tabwriter/index#NewWriter",
        "syntax": "func NewWriter(output io.Writer, minwidth, tabwidth, padding int, padchar byte, flags uint) *Writer",
        "type": "text"
    },
    "tabwriter.Writer": {
        "descr": "A Writer is a filter that inserts padding around tab-delimited columns in its input to align them in the output.",
        "name": "tabwriter.Writer",
        "params": [],
        "path": "go/text/tabwriter/index#Writer",
        "syntax": "aaaa|bbb|d aa |b |dd a | aa |cccc|eee",
        "type": "text"
    },
    "tabwriter.Writer.Flush": {
        "descr": "Flush should be called after the last call to Write to ensure that any data buffered in the Writer is written to output. Any incomplete escape sequence at the end is considered complete for formatting purposes.",
        "name": "tabwriter.Writer.Flush",
        "params": [],
        "path": "go/text/tabwriter/index#Writer.Flush",
        "syntax": "func (b *Writer) Flush() error",
        "type": "text"
    },
    "tabwriter.Writer.Init": {
        "descr": "A Writer must be initialized with a call to Init. The first parameter (output) specifies the filter output. The remaining parameters control the formatting:",
        "name": "tabwriter.Writer.Init",
        "params": [],
        "path": "go/text/tabwriter/index#Writer.Init",
        "syntax": "func (b *Writer) Init(output io.Writer, minwidth, tabwidth, padding int, padchar byte, flags uint) *Writer",
        "type": "text"
    },
    "tabwriter.Writer.Write": {
        "descr": "Write writes buf to the writer b. The only errors returned are ones encountered while writing to the underlying output stream.",
        "name": "tabwriter.Writer.Write",
        "params": [],
        "path": "go/text/tabwriter/index#Writer.Write",
        "syntax": "func (b *Writer) Write(buf []byte) (n int, err error)",
        "type": "text"
    },
    "tar.FileInfoHeader": {
        "descr": "FileInfoHeader creates a partially-populated Header from fi. If fi describes a symlink, FileInfoHeader records link as the link target. If fi describes a directory, a slash is appended to the name.",
        "name": "tar.FileInfoHeader",
        "params": [],
        "path": "go/archive/tar/index#FileInfoHeader",
        "syntax": "func FileInfoHeader(fi os.FileInfo, link string) (*Header, error)",
        "type": "archive"
    },
    "tar.Format": {
        "descr": "Format represents the tar archive format.",
        "name": "tar.Format",
        "params": [],
        "path": "go/archive/tar/index#Format",
        "syntax": "| USTAR | PAX | GNU ------------------+--------+-----------+---------- Name | 256B | unlimited | unlimited Linkname | 100B | unlimited | unlimited Size | uint33 | unlimited | uint89 Mode | uint21 | uint21 | uint57 Uid/Gid | uint21 | unlimited | uint57 Uname/Gname | 32B | unlimited | 32B ModTime | uint33 | unlimited | int89 AccessTime | n/a | unlimited | int89 ChangeTime | n/a | unlimited | int89 Devmajor/Devminor | uint21 | uint21 | uint57 ------------------+--------+-----------+---------- string encoding | ASCII | UTF-8 | binary sub-second times | no | yes | no sparse files | no | yes | yes",
        "type": "archive"
    },
    "tar.Format.String": {
        "descr": "",
        "name": "tar.Format.String",
        "params": [],
        "path": "go/archive/tar/index#Format.String",
        "syntax": "func (f Format) String() string",
        "type": "archive"
    },
    "tar.Header": {
        "descr": "A Header represents a single header in a tar archive. Some fields may not be populated.",
        "name": "tar.Header",
        "params": [],
        "path": "go/archive/tar/index#Header",
        "syntax": "type Header struct { // Typeflag is the type of header entry. // The zero value is automatically promoted to either TypeReg or TypeDir // depending on the presence of a trailing slash in Name. Typeflag byte Name string // Name of file entry Linkname string // Target name of link (valid for TypeLink or TypeSymlink) Size int64 // Logical file size in bytes Mode int64 // Permission and mode bits Uid int // User ID of owner Gid int // Group ID of owner Uname string // User name of owner Gname string // Group name of owner // If the Format is unspecified, then Writer.WriteHeader rounds ModTime // to the nearest second and ignores the AccessTime and ChangeTime fields. // // To use AccessTime or ChangeTime, specify the Format as PAX or GNU. // To use sub-second resolution, specify the Format as PAX. ModTime time.Time // Modification time AccessTime time.Time // Access time (requires either PAX or GNU support) ChangeTime time.Time // Change time (requires either PAX or GNU support) Devmajor int64 // Major device number (valid for TypeChar or TypeBlock) Devminor int64 // Minor device number (valid for TypeChar or TypeBlock) // Xattrs stores extended attributes as PAX records under the // \"SCHILY.xattr.\" namespace. // // The following are semantically equivalent: // h.Xattrs[key] = value // h.PAXRecords[\"SCHILY.xattr.\"+key] = value // // When Writer.WriteHeader is called, the contents of Xattrs will take // precedence over those in PAXRecords. // // Deprecated: Use PAXRecords instead. Xattrs map[string]string // Go 1.3 // PAXRecords is a map of PAX extended header records. // // User-defined records should have keys of the following form: // VENDOR.keyword // Where VENDOR is some namespace in all uppercase, and keyword may // not contain the '=' character (e.g., \"GOLANG.pkg.version\"). // The key and value should be non-empty UTF-8 strings. // // When Writer.WriteHeader is called, PAX records derived from the // other fields in Header take precedence over PAXRecords. PAXRecords map[string]string // Go 1.10 // Format specifies the format of the tar header. // // This is set by Reader.Next as a best-effort guess at the format. // Since the Reader liberally reads some non-compliant files, // it is possible for this to be FormatUnknown. // // If the format is unspecified when Writer.WriteHeader is called, // then it uses the first format (in the order of USTAR, PAX, GNU) // capable of encoding this Header (see Format). Format Format // Go 1.10 }",
        "type": "archive"
    },
    "tar.Header.FileInfo": {
        "descr": "FileInfo returns an os.FileInfo for the Header.",
        "name": "tar.Header.FileInfo",
        "params": [],
        "path": "go/archive/tar/index#Header.FileInfo",
        "syntax": "func (h *Header) FileInfo() os.FileInfo",
        "type": "archive"
    },
    "tar.NewReader": {
        "descr": "NewReader creates a new Reader reading from r.",
        "name": "tar.NewReader",
        "params": [],
        "path": "go/archive/tar/index#NewReader",
        "syntax": "func NewReader(r io.Reader) *Reader",
        "type": "archive"
    },
    "tar.NewWriter": {
        "descr": "NewWriter creates a new Writer writing to w.",
        "name": "tar.NewWriter",
        "params": [],
        "path": "go/archive/tar/index#NewWriter",
        "syntax": "func NewWriter(w io.Writer) *Writer",
        "type": "archive"
    },
    "tar.Reader": {
        "descr": "Reader provides sequential access to the contents of a tar archive. Reader.Next advances to the next file in the archive (including the first), and then Reader can be treated as an io.Reader to access the file's data.",
        "name": "tar.Reader",
        "params": [],
        "path": "go/archive/tar/index#Reader",
        "syntax": "type Reader struct { // contains filtered or unexported fields }",
        "type": "archive"
    },
    "tar.Reader.Next": {
        "descr": "Next advances to the next entry in the tar archive. The Header.Size determines how many bytes can be read for the next file. Any remaining data in the current file is automatically discarded.",
        "name": "tar.Reader.Next",
        "params": [],
        "path": "go/archive/tar/index#Reader.Next",
        "syntax": "func (tr *Reader) Next() (*Header, error)",
        "type": "archive"
    },
    "tar.Reader.Read": {
        "descr": "Read reads from the current file in the tar archive. It returns (0, io.EOF) when it reaches the end of that file, until Next is called to advance to the next file.",
        "name": "tar.Reader.Read",
        "params": [],
        "path": "go/archive/tar/index#Reader.Read",
        "syntax": "func (tr *Reader) Read(b []byte) (int, error)",
        "type": "archive"
    },
    "tar.Writer": {
        "descr": "Writer provides sequential writing of a tar archive. Write.WriteHeader begins a new file with the provided Header, and then Writer can be treated as an io.Writer to supply that file's data.",
        "name": "tar.Writer",
        "params": [],
        "path": "go/archive/tar/index#Writer",
        "syntax": "type Writer struct { // contains filtered or unexported fields }",
        "type": "archive"
    },
    "tar.Writer.Close": {
        "descr": "Close closes the tar archive by flushing the padding, and writing the footer. If the current file (from a prior call to WriteHeader) is not fully written, then this returns an error.",
        "name": "tar.Writer.Close",
        "params": [],
        "path": "go/archive/tar/index#Writer.Close",
        "syntax": "func (tw *Writer) Close() error",
        "type": "archive"
    },
    "tar.Writer.Flush": {
        "descr": "Flush finishes writing the current file's block padding. The current file must be fully written before Flush can be called.",
        "name": "tar.Writer.Flush",
        "params": [],
        "path": "go/archive/tar/index#Writer.Flush",
        "syntax": "func (tw *Writer) Flush() error",
        "type": "archive"
    },
    "tar.Writer.Write": {
        "descr": "Write writes to the current file in the tar archive. Write returns the error ErrWriteTooLong if more than Header.Size bytes are written after WriteHeader.",
        "name": "tar.Writer.Write",
        "params": [],
        "path": "go/archive/tar/index#Writer.Write",
        "syntax": "func (tw *Writer) Write(b []byte) (int, error)",
        "type": "archive"
    },
    "tar.Writer.WriteHeader": {
        "descr": "WriteHeader writes hdr and prepares to accept the file's contents. The Header.Size determines how many bytes can be written for the next file. If the current file is not fully written, then this returns an error. This implicitly flushes any padding necessary before writing the header.",
        "name": "tar.Writer.WriteHeader",
        "params": [],
        "path": "go/archive/tar/index#Writer.WriteHeader",
        "syntax": "func (tw *Writer) WriteHeader(hdr *Header) error",
        "type": "archive"
    },
    "template.CSS": {
        "descr": "CSS encapsulates known safe content that matches any of:",
        "name": "template.CSS",
        "params": [],
        "path": "go/html/template/index#CSS",
        "syntax": "1. The CSS3 stylesheet production, such as `p { color: purple }`. 2. The CSS3 rule production, such as `a[href=~\"https:\"].foo#bar`. 3. CSS3 declaration productions, such as `color: red; margin: 2px`. 4. The CSS3 value production, such as `rgba(0, 0, 255, 127)`.",
        "type": "html"
    },
    "template.Error": {
        "descr": "Error describes a problem encountered during template Escaping.",
        "name": "template.Error",
        "params": [],
        "path": "go/html/template/index#Error",
        "syntax": "type Error struct { // ErrorCode describes the kind of error. ErrorCode ErrorCode // Node is the node that caused the problem, if known. // If not nil, it overrides Name and Line. Node parse.Node // Go 1.4 // Name is the name of the template in which the error was encountered. Name string // Line is the line number of the error in the template source or 0. Line int // Description is a human-readable description of the problem. Description string }",
        "type": "html"
    },
    "template.Error.Error": {
        "descr": "",
        "name": "template.Error.Error",
        "params": [],
        "path": "go/html/template/index#Error.Error",
        "syntax": "func (e *Error) Error() string",
        "type": "html"
    },
    "template.ErrorCode": {
        "descr": "ErrorCode is a code for a kind of error.",
        "name": "template.ErrorCode",
        "params": [],
        "path": "go/html/template/index#ErrorCode",
        "syntax": "type ErrorCode int",
        "type": "html"
    },
    "template.ExecError": {
        "descr": "ExecError is the custom error type returned when Execute has an error evaluating its template. (If a write error occurs, the actual error is returned; it will not be of type ExecError.)",
        "name": "template.ExecError",
        "params": [],
        "path": "go/text/template/index#ExecError",
        "syntax": "type ExecError struct { Name string // Name of template. Err error // Pre-formatted error. }",
        "type": "text"
    },
    "template.ExecError.Error": {
        "descr": "",
        "name": "template.ExecError.Error",
        "params": [],
        "path": "go/text/template/index#ExecError.Error",
        "syntax": "func (e ExecError) Error() string",
        "type": "text"
    },
    "template.FuncMap": {
        "descr": "FuncMap is the type of the map defining the mapping from names to functions. Each function must have either a single return value, or two return values of which the second has type error. In that case, if the second (error) return value evaluates to non-nil during execution, execution terminates and Execute returns that error.",
        "name": "template.FuncMap",
        "params": [],
        "path": "go/text/template/index#FuncMap",
        "syntax": "type FuncMap map[string]interface{}",
        "type": "text"
    },
    "template.HTML": {
        "descr": "HTML encapsulates a known safe HTML document fragment. It should not be used for HTML from a third-party, or HTML with unclosed tags or comments. The outputs of a sound HTML sanitizer and a template escaped by this package are fine for use with HTML.",
        "name": "template.HTML",
        "params": [],
        "path": "go/html/template/index#HTML",
        "syntax": "type HTML string",
        "type": "html"
    },
    "template.HTMLAttr": {
        "descr": "HTMLAttr encapsulates an HTML attribute from a trusted source, for example, ` dir=\"ltr\"`.",
        "name": "template.HTMLAttr",
        "params": [],
        "path": "go/html/template/index#HTMLAttr",
        "syntax": "type HTMLAttr string",
        "type": "html"
    },
    "template.HTMLEscape": {
        "descr": "HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.",
        "name": "template.HTMLEscape",
        "params": [],
        "path": "go/html/template/index#HTMLEscape",
        "syntax": "func HTMLEscape(w io.Writer, b []byte)",
        "type": "html"
    },
    "template.HTMLEscapeString": {
        "descr": "HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.",
        "name": "template.HTMLEscapeString",
        "params": [],
        "path": "go/text/template/index#HTMLEscapeString",
        "syntax": "func HTMLEscapeString(s string) string",
        "type": "text"
    },
    "template.HTMLEscaper": {
        "descr": "HTMLEscaper returns the escaped HTML equivalent of the textual representation of its arguments.",
        "name": "template.HTMLEscaper",
        "params": [],
        "path": "go/html/template/index#HTMLEscaper",
        "syntax": "func HTMLEscaper(args ...interface{}) string",
        "type": "html"
    },
    "template.IsTrue": {
        "descr": "IsTrue reports whether the value is 'true', in the sense of not the zero of its type, and whether the value has a meaningful truth value. This is the definition of truth used by if and other such actions.",
        "name": "template.IsTrue",
        "params": [],
        "path": "go/html/template/index#IsTrue",
        "syntax": "func IsTrue(val interface{}) (truth, ok bool)",
        "type": "html"
    },
    "template.JS": {
        "descr": "JS encapsulates a known safe EcmaScript5 Expression, for example, `(x + y * z())`. Template authors are responsible for ensuring that typed expressions do not break the intended precedence and that there is no statement/expression ambiguity as when passing an expression like \"{ foo: bar() }\\n['foo']()\", which is both a valid Expression and a valid Program with a very different meaning.",
        "name": "template.JS",
        "params": [],
        "path": "go/html/template/index#JS",
        "syntax": "type JS string",
        "type": "html"
    },
    "template.JSEscape": {
        "descr": "JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.",
        "name": "template.JSEscape",
        "params": [],
        "path": "go/html/template/index#JSEscape",
        "syntax": "func JSEscape(w io.Writer, b []byte)",
        "type": "html"
    },
    "template.JSEscapeString": {
        "descr": "JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.",
        "name": "template.JSEscapeString",
        "params": [],
        "path": "go/html/template/index#JSEscapeString",
        "syntax": "func JSEscapeString(s string) string",
        "type": "html"
    },
    "template.JSEscaper": {
        "descr": "JSEscaper returns the escaped JavaScript equivalent of the textual representation of its arguments.",
        "name": "template.JSEscaper",
        "params": [],
        "path": "go/text/template/index#JSEscaper",
        "syntax": "func JSEscaper(args ...interface{}) string",
        "type": "text"
    },
    "template.JSStr": {
        "descr": "JSStr encapsulates a sequence of characters meant to be embedded between quotes in a JavaScript expression. The string must match a series of StringCharacters:",
        "name": "template.JSStr",
        "params": [],
        "path": "go/html/template/index#JSStr",
        "syntax": "StringCharacter :: SourceCharacter but not `\\` or LineTerminator | EscapeSequence",
        "type": "html"
    },
    "template.Must": {
        "descr": "Must is a helper that wraps a call to a function returning (*Template, error) and panics if the error is non-nil. It is intended for use in variable initializations such as",
        "name": "template.Must",
        "params": [],
        "path": "go/text/template/index#Must",
        "syntax": "func Must(t *Template, err error) *Template",
        "type": "text"
    },
    "template.New": {
        "descr": "New allocates a new HTML template with the given name.",
        "name": "template.New",
        "params": [],
        "path": "go/html/template/index#New",
        "syntax": "func New(name string) *Template",
        "type": "html"
    },
    "template.ParseFiles": {
        "descr": "ParseFiles creates a new Template and parses the template definitions from the named files. The returned template's name will have the base name and parsed contents of the first file. There must be at least one file. If an error occurs, parsing stops and the returned *Template is nil.",
        "name": "template.ParseFiles",
        "params": [],
        "path": "go/text/template/index#ParseFiles",
        "syntax": "func ParseFiles(filenames ...string) (*Template, error)",
        "type": "text"
    },
    "template.ParseGlob": {
        "descr": "ParseGlob creates a new Template and parses the template definitions from the files identified by the pattern, which must match at least one file. The returned template will have the (base) name and (parsed) contents of the first file matched by the pattern. ParseGlob is equivalent to calling ParseFiles with the list of files matched by the pattern.",
        "name": "template.ParseGlob",
        "params": [],
        "path": "go/html/template/index#ParseGlob",
        "syntax": "func ParseGlob(pattern string) (*Template, error)",
        "type": "html"
    },
    "template.Srcset": {
        "descr": "Srcset encapsulates a known safe srcset attribute (see https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset).",
        "name": "template.Srcset",
        "params": [],
        "path": "go/html/template/index#Srcset",
        "syntax": "type Srcset string",
        "type": "html"
    },
    "template.Template": {
        "descr": "Template is the representation of a parsed template. The *parse.Tree field is exported only for use by html/template and should be treated as unexported by all other clients.",
        "name": "template.Template",
        "params": [],
        "path": "go/text/template/index#Template",
        "syntax": "type Template struct { *parse.Tree // contains filtered or unexported fields }",
        "type": "text"
    },
    "template.Template.AddParseTree": {
        "descr": "AddParseTree adds parse tree for template with given name and associates it with t. If the template does not already exist, it will create a new one. If the template does exist, it will be replaced.",
        "name": "template.Template.AddParseTree",
        "params": [],
        "path": "go/text/template/index#Template.AddParseTree",
        "syntax": "func (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error)",
        "type": "text"
    },
    "template.Template.Clone": {
        "descr": "Clone returns a duplicate of the template, including all associated templates. The actual representation is not copied, but the name space of associated templates is, so further calls to Parse in the copy will add templates to the copy but not to the original. Clone can be used to prepare common templates and use them with variant definitions for other templates by adding the variants after the clone is made.",
        "name": "template.Template.Clone",
        "params": [],
        "path": "go/text/template/index#Template.Clone",
        "syntax": "func (t *Template) Clone() (*Template, error)",
        "type": "text"
    },
    "template.Template.DefinedTemplates": {
        "descr": "DefinedTemplates returns a string listing the defined templates, prefixed by the string \"; defined templates are: \". If there are none, it returns the empty string. Used to generate an error message.",
        "name": "template.Template.DefinedTemplates",
        "params": [],
        "path": "go/html/template/index#Template.DefinedTemplates",
        "syntax": "func (t *Template) DefinedTemplates() string",
        "type": "html"
    },
    "template.Template.Delims": {
        "descr": "Delims sets the action delimiters to the specified strings, to be used in subsequent calls to Parse, ParseFiles, or ParseGlob. Nested template definitions will inherit the settings. An empty delimiter stands for the corresponding default: {{ or }}. The return value is the template, so calls can be chained.",
        "name": "template.Template.Delims",
        "params": [],
        "path": "go/html/template/index#Template.Delims",
        "syntax": "func (t *Template) Delims(left, right string) *Template",
        "type": "html"
    },
    "template.Template.Execute": {
        "descr": "Execute applies a parsed template to the specified data object, and writes the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved.",
        "name": "template.Template.Execute",
        "params": [],
        "path": "go/text/template/index#Template.Execute",
        "syntax": "func (t *Template) Execute(wr io.Writer, data interface{}) error",
        "type": "text"
    },
    "template.Template.ExecuteTemplate": {
        "descr": "ExecuteTemplate applies the template associated with t that has the given name to the specified data object and writes the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved.",
        "name": "template.Template.ExecuteTemplate",
        "params": [],
        "path": "go/text/template/index#Template.ExecuteTemplate",
        "syntax": "func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error",
        "type": "text"
    },
    "template.Template.Funcs": {
        "descr": "Funcs adds the elements of the argument map to the template's function map. It must be called before the template is parsed. It panics if a value in the map is not a function with appropriate return type. However, it is legal to overwrite elements of the map. The return value is the template, so calls can be chained.",
        "name": "template.Template.Funcs",
        "params": [],
        "path": "go/html/template/index#Template.Funcs",
        "syntax": "func (t *Template) Funcs(funcMap FuncMap) *Template",
        "type": "html"
    },
    "template.Template.Lookup": {
        "descr": "Lookup returns the template with the given name that is associated with t, or nil if there is no such template.",
        "name": "template.Template.Lookup",
        "params": [],
        "path": "go/html/template/index#Template.Lookup",
        "syntax": "func (t *Template) Lookup(name string) *Template",
        "type": "html"
    },
    "template.Template.Name": {
        "descr": "Name returns the name of the template.",
        "name": "template.Template.Name",
        "params": [],
        "path": "go/html/template/index#Template.Name",
        "syntax": "func (t *Template) Name() string",
        "type": "html"
    },
    "template.Template.New": {
        "descr": "New allocates a new, undefined template associated with the given one and with the same delimiters. The association, which is transitive, allows one template to invoke another with a {{template}} action.",
        "name": "template.Template.New",
        "params": [],
        "path": "go/text/template/index#Template.New",
        "syntax": "func (t *Template) New(name string) *Template",
        "type": "text"
    },
    "template.Template.Option": {
        "descr": "Option sets options for the template. Options are described by strings, either a simple string or \"key=value\". There can be at most one equals sign in an option string. If the option string is unrecognized or otherwise invalid, Option panics.",
        "name": "template.Template.Option",
        "params": [],
        "path": "go/text/template/index#Template.Option",
        "syntax": "func (t *Template) Option(opt ...string) *Template",
        "type": "text"
    },
    "template.Template.Parse": {
        "descr": "Parse parses text as a template body for t. Named template definitions ({{define ...}} or {{block ...}} statements) in text define additional templates associated with t and are removed from the definition of t itself.",
        "name": "template.Template.Parse",
        "params": [],
        "path": "go/text/template/index#Template.Parse",
        "syntax": "func (t *Template) Parse(text string) (*Template, error)",
        "type": "text"
    },
    "template.Template.ParseFiles": {
        "descr": "ParseFiles parses the named files and associates the resulting templates with t. If an error occurs, parsing stops and the returned template is nil; otherwise it is t. There must be at least one file. Since the templates created by ParseFiles are named by the base names of the argument files, t should usually have the name of one of the (base) names of the files. If it does not, depending on t's contents before calling ParseFiles, t.Execute may fail. In that case use t.ExecuteTemplate to execute a valid template.",
        "name": "template.Template.ParseFiles",
        "params": [],
        "path": "go/text/template/index#Template.ParseFiles",
        "syntax": "func (t *Template) ParseFiles(filenames ...string) (*Template, error)",
        "type": "text"
    },
    "template.Template.ParseGlob": {
        "descr": "ParseGlob parses the template definitions in the files identified by the pattern and associates the resulting templates with t. The pattern is processed by filepath.Glob and must match at least one file. ParseGlob is equivalent to calling t.ParseFiles with the list of files matched by the pattern.",
        "name": "template.Template.ParseGlob",
        "params": [],
        "path": "go/text/template/index#Template.ParseGlob",
        "syntax": "func (t *Template) ParseGlob(pattern string) (*Template, error)",
        "type": "text"
    },
    "template.Template.Templates": {
        "descr": "Templates returns a slice of the templates associated with t, including t itself.",
        "name": "template.Template.Templates",
        "params": [],
        "path": "go/html/template/index#Template.Templates",
        "syntax": "func (t *Template) Templates() []*Template",
        "type": "html"
    },
    "template.URL": {
        "descr": "URL encapsulates a known safe URL or URL substring (see RFC 3986). A URL like `javascript:checkThatFormNotEditedBeforeLeavingPage()` from a trusted source should go in the page, but by default dynamic `javascript:` URLs are filtered out since they are a frequently exploited injection vector.",
        "name": "template.URL",
        "params": [],
        "path": "go/html/template/index#URL",
        "syntax": "type URL string",
        "type": "html"
    },
    "template.URLQueryEscaper": {
        "descr": "URLQueryEscaper returns the escaped value of the textual representation of its arguments in a form suitable for embedding in a URL query.",
        "name": "template.URLQueryEscaper",
        "params": [],
        "path": "go/text/template/index#URLQueryEscaper",
        "syntax": "func URLQueryEscaper(args ...interface{}) string",
        "type": "text"
    },
    "testing.AllocsPerRun": {
        "descr": "AllocsPerRun returns the average number of allocations during calls to f. Although the return value has type float64, it will always be an integral value.",
        "name": "testing.AllocsPerRun",
        "params": [],
        "path": "go/testing/index#AllocsPerRun",
        "syntax": "func AllocsPerRun(runs int, f func()) (avg float64)",
        "type": "testing"
    },
    "testing.B": {
        "descr": "B is a type passed to Benchmark functions to manage benchmark timing and to specify the number of iterations to run.",
        "name": "testing.B",
        "params": [],
        "path": "go/testing/index#B",
        "syntax": "type B struct { N int // contains filtered or unexported fields }",
        "type": "testing"
    },
    "testing.B.Error": {
        "descr": "Error is equivalent to Log followed by Fail.",
        "name": "testing.B.Error",
        "params": [],
        "path": "go/testing/index#B.Error",
        "syntax": "func (c *B) Error(args ...interface{})",
        "type": "testing"
    },
    "testing.B.Errorf": {
        "descr": "Errorf is equivalent to Logf followed by Fail.",
        "name": "testing.B.Errorf",
        "params": [],
        "path": "go/testing/index#B.Errorf",
        "syntax": "func (c *B) Errorf(format string, args ...interface{})",
        "type": "testing"
    },
    "testing.B.Fail": {
        "descr": "Fail marks the function as having failed but continues execution.",
        "name": "testing.B.Fail",
        "params": [],
        "path": "go/testing/index#B.Fail",
        "syntax": "func (c *B) Fail()",
        "type": "testing"
    },
    "testing.B.FailNow": {
        "descr": "FailNow marks the function as having failed and stops its execution by calling runtime.Goexit (which then runs all deferred calls in the current goroutine). Execution will continue at the next test or benchmark. FailNow must be called from the goroutine running the test or benchmark function, not from other goroutines created during the test. Calling FailNow does not stop those other goroutines.",
        "name": "testing.B.FailNow",
        "params": [],
        "path": "go/testing/index#B.FailNow",
        "syntax": "func (c *B) FailNow()",
        "type": "testing"
    },
    "testing.B.Failed": {
        "descr": "Failed reports whether the function has failed.",
        "name": "testing.B.Failed",
        "params": [],
        "path": "go/testing/index#B.Failed",
        "syntax": "func (c *B) Failed() bool",
        "type": "testing"
    },
    "testing.B.Fatal": {
        "descr": "Fatal is equivalent to Log followed by FailNow.",
        "name": "testing.B.Fatal",
        "params": [],
        "path": "go/testing/index#B.Fatal",
        "syntax": "func (c *B) Fatal(args ...interface{})",
        "type": "testing"
    },
    "testing.B.Fatalf": {
        "descr": "Fatalf is equivalent to Logf followed by FailNow.",
        "name": "testing.B.Fatalf",
        "params": [],
        "path": "go/testing/index#B.Fatalf",
        "syntax": "func (c *B) Fatalf(format string, args ...interface{})",
        "type": "testing"
    },
    "testing.B.Helper": {
        "descr": "Helper marks the calling function as a test helper function. When printing file and line information, that function will be skipped. Helper may be called simultaneously from multiple goroutines.",
        "name": "testing.B.Helper",
        "params": [],
        "path": "go/testing/index#B.Helper",
        "syntax": "func (c *B) Helper()",
        "type": "testing"
    },
    "testing.B.Log": {
        "descr": "Log formats its arguments using default formatting, analogous to Println, and records the text in the error log. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag.",
        "name": "testing.B.Log",
        "params": [],
        "path": "go/testing/index#B.Log",
        "syntax": "func (c *B) Log(args ...interface{})",
        "type": "testing"
    },
    "testing.B.Logf": {
        "descr": "Logf formats its arguments according to the format, analogous to Printf, and records the text in the error log. A final newline is added if not provided. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag.",
        "name": "testing.B.Logf",
        "params": [],
        "path": "go/testing/index#B.Logf",
        "syntax": "func (c *B) Logf(format string, args ...interface{})",
        "type": "testing"
    },
    "testing.B.Name": {
        "descr": "Name returns the name of the running test or benchmark.",
        "name": "testing.B.Name",
        "params": [],
        "path": "go/testing/index#B.Name",
        "syntax": "func (c *B) Name() string",
        "type": "testing"
    },
    "testing.B.ReportAllocs": {
        "descr": "ReportAllocs enables malloc statistics for this benchmark. It is equivalent to setting -test.benchmem, but it only affects the benchmark function that calls ReportAllocs.",
        "name": "testing.B.ReportAllocs",
        "params": [],
        "path": "go/testing/index#B.ReportAllocs",
        "syntax": "func (b *B) ReportAllocs()",
        "type": "testing"
    },
    "testing.B.ResetTimer": {
        "descr": "ResetTimer zeros the elapsed benchmark time and memory allocation counters. It does not affect whether the timer is running.",
        "name": "testing.B.ResetTimer",
        "params": [],
        "path": "go/testing/index#B.ResetTimer",
        "syntax": "func (b *B) ResetTimer()",
        "type": "testing"
    },
    "testing.B.Run": {
        "descr": "Run benchmarks f as a subbenchmark with the given name. It reports whether there were any failures.",
        "name": "testing.B.Run",
        "params": [],
        "path": "go/testing/index#B.Run",
        "syntax": "func (b *B) Run(name string, f func(b *B)) bool",
        "type": "testing"
    },
    "testing.B.RunParallel": {
        "descr": "RunParallel runs a benchmark in parallel. It creates multiple goroutines and distributes b.N iterations among them. The number of goroutines defaults to GOMAXPROCS. To increase parallelism for non-CPU-bound benchmarks, call SetParallelism before RunParallel. RunParallel is usually used with the go test -cpu flag.",
        "name": "testing.B.RunParallel",
        "params": [],
        "path": "go/testing/index#B.RunParallel",
        "syntax": "func (b *B) RunParallel(body func(*PB))",
        "type": "testing"
    },
    "testing.B.SetBytes": {
        "descr": "SetBytes records the number of bytes processed in a single operation. If this is called, the benchmark will report ns/op and MB/s.",
        "name": "testing.B.SetBytes",
        "params": [],
        "path": "go/testing/index#B.SetBytes",
        "syntax": "func (b *B) SetBytes(n int64)",
        "type": "testing"
    },
    "testing.B.SetParallelism": {
        "descr": "SetParallelism sets the number of goroutines used by RunParallel to p*GOMAXPROCS. There is usually no need to call SetParallelism for CPU-bound benchmarks. If p is less than 1, this call will have no effect.",
        "name": "testing.B.SetParallelism",
        "params": [],
        "path": "go/testing/index#B.SetParallelism",
        "syntax": "func (b *B) SetParallelism(p int)",
        "type": "testing"
    },
    "testing.B.Skip": {
        "descr": "Skip is equivalent to Log followed by SkipNow.",
        "name": "testing.B.Skip",
        "params": [],
        "path": "go/testing/index#B.Skip",
        "syntax": "func (c *B) Skip(args ...interface{})",
        "type": "testing"
    },
    "testing.B.SkipNow": {
        "descr": "SkipNow marks the test as having been skipped and stops its execution by calling runtime.Goexit. If a test fails (see Error, Errorf, Fail) and is then skipped, it is still considered to have failed. Execution will continue at the next test or benchmark. See also FailNow. SkipNow must be called from the goroutine running the test, not from other goroutines created during the test. Calling SkipNow does not stop those other goroutines.",
        "name": "testing.B.SkipNow",
        "params": [],
        "path": "go/testing/index#B.SkipNow",
        "syntax": "func (c *B) SkipNow()",
        "type": "testing"
    },
    "testing.B.Skipf": {
        "descr": "Skipf is equivalent to Logf followed by SkipNow.",
        "name": "testing.B.Skipf",
        "params": [],
        "path": "go/testing/index#B.Skipf",
        "syntax": "func (c *B) Skipf(format string, args ...interface{})",
        "type": "testing"
    },
    "testing.B.Skipped": {
        "descr": "Skipped reports whether the test was skipped.",
        "name": "testing.B.Skipped",
        "params": [],
        "path": "go/testing/index#B.Skipped",
        "syntax": "func (c *B) Skipped() bool",
        "type": "testing"
    },
    "testing.B.StartTimer": {
        "descr": "StartTimer starts timing a test. This function is called automatically before a benchmark starts, but it can also used to resume timing after a call to StopTimer.",
        "name": "testing.B.StartTimer",
        "params": [],
        "path": "go/testing/index#B.StartTimer",
        "syntax": "func (b *B) StartTimer()",
        "type": "testing"
    },
    "testing.B.StopTimer": {
        "descr": "StopTimer stops timing a test. This can be used to pause the timer while performing complex initialization that you don't want to measure.",
        "name": "testing.B.StopTimer",
        "params": [],
        "path": "go/testing/index#B.StopTimer",
        "syntax": "func (b *B) StopTimer()",
        "type": "testing"
    },
    "testing.Benchmark": {
        "descr": "Benchmark benchmarks a single function. Useful for creating custom benchmarks that do not use the \"go test\" command.",
        "name": "testing.Benchmark",
        "params": [],
        "path": "go/testing/index#Benchmark",
        "syntax": "func Benchmark(f func(b *B)) BenchmarkResult",
        "type": "testing"
    },
    "testing.BenchmarkResult": {
        "descr": "The results of a benchmark run.",
        "name": "testing.BenchmarkResult",
        "params": [],
        "path": "go/testing/index#BenchmarkResult",
        "syntax": "type BenchmarkResult struct { N int // The number of iterations. T time.Duration // The total time taken. Bytes int64 // Bytes processed in one iteration. MemAllocs uint64 // The total number of memory allocations; added in Go 1.1 MemBytes uint64 // The total number of bytes allocated; added in Go 1.1 }",
        "type": "testing"
    },
    "testing.BenchmarkResult.AllocedBytesPerOp": {
        "descr": "AllocedBytesPerOp returns r.MemBytes / r.N.",
        "name": "testing.BenchmarkResult.AllocedBytesPerOp",
        "params": [],
        "path": "go/testing/index#BenchmarkResult.AllocedBytesPerOp",
        "syntax": "func (r BenchmarkResult) AllocedBytesPerOp() int64",
        "type": "testing"
    },
    "testing.BenchmarkResult.AllocsPerOp": {
        "descr": "AllocsPerOp returns r.MemAllocs / r.N.",
        "name": "testing.BenchmarkResult.AllocsPerOp",
        "params": [],
        "path": "go/testing/index#BenchmarkResult.AllocsPerOp",
        "syntax": "func (r BenchmarkResult) AllocsPerOp() int64",
        "type": "testing"
    },
    "testing.BenchmarkResult.MemString": {
        "descr": "MemString returns r.AllocedBytesPerOp and r.AllocsPerOp in the same format as 'go test'.",
        "name": "testing.BenchmarkResult.MemString",
        "params": [],
        "path": "go/testing/index#BenchmarkResult.MemString",
        "syntax": "func (r BenchmarkResult) MemString() string",
        "type": "testing"
    },
    "testing.BenchmarkResult.NsPerOp": {
        "descr": "",
        "name": "testing.BenchmarkResult.NsPerOp",
        "params": [],
        "path": "go/testing/index#BenchmarkResult.NsPerOp",
        "syntax": "func (r BenchmarkResult) NsPerOp() int64",
        "type": "testing"
    },
    "testing.BenchmarkResult.String": {
        "descr": "",
        "name": "testing.BenchmarkResult.String",
        "params": [],
        "path": "go/testing/index#BenchmarkResult.String",
        "syntax": "func (r BenchmarkResult) String() string",
        "type": "testing"
    },
    "testing.Cover": {
        "descr": "Cover records information about test coverage checking. NOTE: This struct is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines.",
        "name": "testing.Cover",
        "params": [],
        "path": "go/testing/index#Cover",
        "syntax": "type Cover struct { Mode string Counters map[string][]uint32 Blocks map[string][]CoverBlock CoveredPackages string }",
        "type": "testing"
    },
    "testing.CoverBlock": {
        "descr": "CoverBlock records the coverage data for a single basic block. The fields are 1-indexed, as in an editor: The opening line of the file is number 1, for example. Columns are measured in bytes. NOTE: This struct is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines.",
        "name": "testing.CoverBlock",
        "params": [],
        "path": "go/testing/index#CoverBlock",
        "syntax": "type CoverBlock struct { Line0 uint32 // Line number for block start. Col0 uint16 // Column number for block start. Line1 uint32 // Line number for block end. Col1 uint16 // Column number for block end. Stmts uint16 // Number of statements included in this block. }",
        "type": "testing"
    },
    "testing.CoverMode": {
        "descr": "CoverMode reports what the test coverage mode is set to. The values are \"set\", \"count\", or \"atomic\". The return value will be empty if test coverage is not enabled.",
        "name": "testing.CoverMode",
        "params": [],
        "path": "go/testing/index#CoverMode",
        "syntax": "func CoverMode() string",
        "type": "testing"
    },
    "testing.Coverage": {
        "descr": "Coverage reports the current code coverage as a fraction in the range [0, 1]. If coverage is not enabled, Coverage returns 0.",
        "name": "testing.Coverage",
        "params": [],
        "path": "go/testing/index#Coverage",
        "syntax": "func Coverage() float64",
        "type": "testing"
    },
    "testing.InternalBenchmark": {
        "descr": "An internal type but exported because it is cross-package; part of the implementation of the \"go test\" command.",
        "name": "testing.InternalBenchmark",
        "params": [],
        "path": "go/testing/index#InternalBenchmark",
        "syntax": "type InternalBenchmark struct { Name string F func(b *B) }",
        "type": "testing"
    },
    "testing.InternalExample": {
        "descr": "",
        "name": "testing.InternalExample",
        "params": [],
        "path": "go/testing/index#InternalExample",
        "syntax": "type InternalExample struct { Name string F func() Output string Unordered bool // Go 1.7 }",
        "type": "testing"
    },
    "testing.InternalTest": {
        "descr": "An internal type but exported because it is cross-package; part of the implementation of the \"go test\" command.",
        "name": "testing.InternalTest",
        "params": [],
        "path": "go/testing/index#InternalTest",
        "syntax": "type InternalTest struct { Name string F func(*T) }",
        "type": "testing"
    },
    "testing.M": {
        "descr": "M is a type passed to a TestMain function to run the actual tests.",
        "name": "testing.M",
        "params": [],
        "path": "go/testing/index#M",
        "syntax": "type M struct { // contains filtered or unexported fields }",
        "type": "testing"
    },
    "testing.M.Run": {
        "descr": "Run runs the tests. It returns an exit code to pass to os.Exit.",
        "name": "testing.M.Run",
        "params": [],
        "path": "go/testing/index#M.Run",
        "syntax": "func (m *M) Run() int",
        "type": "testing"
    },
    "testing.Main": {
        "descr": "Main is an internal function, part of the implementation of the \"go test\" command. It was exported because it is cross-package and predates \"internal\" packages. It is no longer used by \"go test\" but preserved, as much as possible, for other systems that simulate \"go test\" using Main, but Main sometimes cannot be updated as new functionality is added to the testing package. Systems simulating \"go test\" should be updated to use MainStart.",
        "name": "testing.Main",
        "params": [],
        "path": "go/testing/index#Main",
        "syntax": "func Main(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)",
        "type": "testing"
    },
    "testing.MainStart": {
        "descr": "MainStart is meant for use by tests generated by 'go test'. It is not meant to be called directly and is not subject to the Go 1 compatibility document. It may change signature from release to release.",
        "name": "testing.MainStart",
        "params": [],
        "path": "go/testing/index#MainStart",
        "syntax": "func MainStart(deps testDeps, tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample) *M",
        "type": "testing"
    },
    "testing.PB": {
        "descr": "A PB is used by RunParallel for running parallel benchmarks.",
        "name": "testing.PB",
        "params": [],
        "path": "go/testing/index#PB",
        "syntax": "type PB struct { // contains filtered or unexported fields }",
        "type": "testing"
    },
    "testing.PB.Next": {
        "descr": "Next reports whether there are more iterations to execute.",
        "name": "testing.PB.Next",
        "params": [],
        "path": "go/testing/index#PB.Next",
        "syntax": "func (pb *PB) Next() bool",
        "type": "testing"
    },
    "testing.RegisterCover": {
        "descr": "RegisterCover records the coverage data accumulators for the tests. NOTE: This function is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines.",
        "name": "testing.RegisterCover",
        "params": [],
        "path": "go/testing/index#RegisterCover",
        "syntax": "func RegisterCover(c Cover)",
        "type": "testing"
    },
    "testing.RunBenchmarks": {
        "descr": "An internal function but exported because it is cross-package; part of the implementation of the \"go test\" command.",
        "name": "testing.RunBenchmarks",
        "params": [],
        "path": "go/testing/index#RunBenchmarks",
        "syntax": "func RunBenchmarks(matchString func(pat, str string) (bool, error), benchmarks []InternalBenchmark)",
        "type": "testing"
    },
    "testing.RunExamples": {
        "descr": "An internal function but exported because it is cross-package; part of the implementation of the \"go test\" command.",
        "name": "testing.RunExamples",
        "params": [],
        "path": "go/testing/index#RunExamples",
        "syntax": "func RunExamples(matchString func(pat, str string) (bool, error), examples []InternalExample) (ok bool)",
        "type": "testing"
    },
    "testing.RunTests": {
        "descr": "An internal function but exported because it is cross-package; part of the implementation of the \"go test\" command.",
        "name": "testing.RunTests",
        "params": [],
        "path": "go/testing/index#RunTests",
        "syntax": "func RunTests(matchString func(pat, str string) (bool, error), tests []InternalTest) (ok bool)",
        "type": "testing"
    },
    "testing.Short": {
        "descr": "Short reports whether the -test.short flag is set.",
        "name": "testing.Short",
        "params": [],
        "path": "go/testing/index#Short",
        "syntax": "func Short() bool",
        "type": "testing"
    },
    "testing.T": {
        "descr": "T is a type passed to Test functions to manage test state and support formatted test logs. Logs are accumulated during execution and dumped to standard output when done.",
        "name": "testing.T",
        "params": [],
        "path": "go/testing/index#T",
        "syntax": "type T struct { // contains filtered or unexported fields }",
        "type": "testing"
    },
    "testing.T.Error": {
        "descr": "Error is equivalent to Log followed by Fail.",
        "name": "testing.T.Error",
        "params": [],
        "path": "go/testing/index#T.Error",
        "syntax": "func (c *T) Error(args ...interface{})",
        "type": "testing"
    },
    "testing.T.Errorf": {
        "descr": "Errorf is equivalent to Logf followed by Fail.",
        "name": "testing.T.Errorf",
        "params": [],
        "path": "go/testing/index#T.Errorf",
        "syntax": "func (c *T) Errorf(format string, args ...interface{})",
        "type": "testing"
    },
    "testing.T.Fail": {
        "descr": "Fail marks the function as having failed but continues execution.",
        "name": "testing.T.Fail",
        "params": [],
        "path": "go/testing/index#T.Fail",
        "syntax": "func (c *T) Fail()",
        "type": "testing"
    },
    "testing.T.FailNow": {
        "descr": "FailNow marks the function as having failed and stops its execution by calling runtime.Goexit (which then runs all deferred calls in the current goroutine). Execution will continue at the next test or benchmark. FailNow must be called from the goroutine running the test or benchmark function, not from other goroutines created during the test. Calling FailNow does not stop those other goroutines.",
        "name": "testing.T.FailNow",
        "params": [],
        "path": "go/testing/index#T.FailNow",
        "syntax": "func (c *T) FailNow()",
        "type": "testing"
    },
    "testing.T.Failed": {
        "descr": "Failed reports whether the function has failed.",
        "name": "testing.T.Failed",
        "params": [],
        "path": "go/testing/index#T.Failed",
        "syntax": "func (c *T) Failed() bool",
        "type": "testing"
    },
    "testing.T.Fatal": {
        "descr": "Fatal is equivalent to Log followed by FailNow.",
        "name": "testing.T.Fatal",
        "params": [],
        "path": "go/testing/index#T.Fatal",
        "syntax": "func (c *T) Fatal(args ...interface{})",
        "type": "testing"
    },
    "testing.T.Fatalf": {
        "descr": "Fatalf is equivalent to Logf followed by FailNow.",
        "name": "testing.T.Fatalf",
        "params": [],
        "path": "go/testing/index#T.Fatalf",
        "syntax": "func (c *T) Fatalf(format string, args ...interface{})",
        "type": "testing"
    },
    "testing.T.Helper": {
        "descr": "Helper marks the calling function as a test helper function. When printing file and line information, that function will be skipped. Helper may be called simultaneously from multiple goroutines.",
        "name": "testing.T.Helper",
        "params": [],
        "path": "go/testing/index#T.Helper",
        "syntax": "func (c *T) Helper()",
        "type": "testing"
    },
    "testing.T.Log": {
        "descr": "Log formats its arguments using default formatting, analogous to Println, and records the text in the error log. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag.",
        "name": "testing.T.Log",
        "params": [],
        "path": "go/testing/index#T.Log",
        "syntax": "func (c *T) Log(args ...interface{})",
        "type": "testing"
    },
    "testing.T.Logf": {
        "descr": "Logf formats its arguments according to the format, analogous to Printf, and records the text in the error log. A final newline is added if not provided. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag.",
        "name": "testing.T.Logf",
        "params": [],
        "path": "go/testing/index#T.Logf",
        "syntax": "func (c *T) Logf(format string, args ...interface{})",
        "type": "testing"
    },
    "testing.T.Name": {
        "descr": "Name returns the name of the running test or benchmark.",
        "name": "testing.T.Name",
        "params": [],
        "path": "go/testing/index#T.Name",
        "syntax": "func (c *T) Name() string",
        "type": "testing"
    },
    "testing.T.Parallel": {
        "descr": "Parallel signals that this test is to be run in parallel with (and only with) other parallel tests. When a test is run multiple times due to use of -test.count or -test.cpu, multiple instances of a single test never run in parallel with each other.",
        "name": "testing.T.Parallel",
        "params": [],
        "path": "go/testing/index#T.Parallel",
        "syntax": "func (t *T) Parallel()",
        "type": "testing"
    },
    "testing.T.Run": {
        "descr": "Run runs f as a subtest of t called name. It runs f in a separate goroutine and blocks until f returns or calls t.Parallel to become a parallel test. Run reports whether f succeeded (or at least did not fail before calling t.Parallel).",
        "name": "testing.T.Run",
        "params": [],
        "path": "go/testing/index#T.Run",
        "syntax": "func (t *T) Run(name string, f func(t *T)) bool",
        "type": "testing"
    },
    "testing.T.Skip": {
        "descr": "Skip is equivalent to Log followed by SkipNow.",
        "name": "testing.T.Skip",
        "params": [],
        "path": "go/testing/index#T.Skip",
        "syntax": "func (c *T) Skip(args ...interface{})",
        "type": "testing"
    },
    "testing.T.SkipNow": {
        "descr": "SkipNow marks the test as having been skipped and stops its execution by calling runtime.Goexit. If a test fails (see Error, Errorf, Fail) and is then skipped, it is still considered to have failed. Execution will continue at the next test or benchmark. See also FailNow. SkipNow must be called from the goroutine running the test, not from other goroutines created during the test. Calling SkipNow does not stop those other goroutines.",
        "name": "testing.T.SkipNow",
        "params": [],
        "path": "go/testing/index#T.SkipNow",
        "syntax": "func (c *T) SkipNow()",
        "type": "testing"
    },
    "testing.T.Skipf": {
        "descr": "Skipf is equivalent to Logf followed by SkipNow.",
        "name": "testing.T.Skipf",
        "params": [],
        "path": "go/testing/index#T.Skipf",
        "syntax": "func (c *T) Skipf(format string, args ...interface{})",
        "type": "testing"
    },
    "testing.T.Skipped": {
        "descr": "Skipped reports whether the test was skipped.",
        "name": "testing.T.Skipped",
        "params": [],
        "path": "go/testing/index#T.Skipped",
        "syntax": "func (c *T) Skipped() bool",
        "type": "testing"
    },
    "testing.TB": {
        "descr": "TB is the interface common to T and B.",
        "name": "testing.TB",
        "params": [],
        "path": "go/testing/index#TB",
        "syntax": "type TB interface { Error(args ...interface{}) Errorf(format string, args ...interface{}) Fail() FailNow() Failed() bool Fatal(args ...interface{}) Fatalf(format string, args ...interface{}) Log(args ...interface{}) Logf(format string, args ...interface{}) Name() string Skip(args ...interface{}) SkipNow() Skipf(format string, args ...interface{}) Skipped() bool Helper() // contains filtered or unexported methods }",
        "type": "testing"
    },
    "testing.Verbose": {
        "descr": "Verbose reports whether the -test.v flag is set.",
        "name": "testing.Verbose",
        "params": [],
        "path": "go/testing/index#Verbose",
        "syntax": "func Verbose() bool",
        "type": "testing"
    },
    "textproto.CanonicalMIMEHeaderKey": {
        "descr": "CanonicalMIMEHeaderKey returns the canonical format of the MIME header key s. The canonicalization converts the first letter and any letter following a hyphen to upper case; the rest are converted to lowercase. For example, the canonical key for \"accept-encoding\" is \"Accept-Encoding\". MIME header keys are assumed to be ASCII only. If s contains a space or invalid header field bytes, it is returned without modifications.",
        "name": "textproto.CanonicalMIMEHeaderKey",
        "params": [],
        "path": "go/net/textproto/index#CanonicalMIMEHeaderKey",
        "syntax": "func CanonicalMIMEHeaderKey(s string) string",
        "type": "net/textproto"
    },
    "textproto.Conn": {
        "descr": "A Conn represents a textual network protocol connection. It consists of a Reader and Writer to manage I/O and a Pipeline to sequence concurrent requests on the connection. These embedded types carry methods with them; see the documentation of those types for details.",
        "name": "textproto.Conn",
        "params": [],
        "path": "go/net/textproto/index#Conn",
        "syntax": "type Conn struct { Reader Writer Pipeline // contains filtered or unexported fields }",
        "type": "net/textproto"
    },
    "textproto.Conn.Close": {
        "descr": "Close closes the connection.",
        "name": "textproto.Conn.Close",
        "params": [],
        "path": "go/net/textproto/index#Conn.Close",
        "syntax": "func (c *Conn) Close() error",
        "type": "net/textproto"
    },
    "textproto.Conn.Cmd": {
        "descr": "Cmd is a convenience method that sends a command after waiting its turn in the pipeline. The command text is the result of formatting format with args and appending \\r\\n. Cmd returns the id of the command, for use with StartResponse and EndResponse.",
        "name": "textproto.Conn.Cmd",
        "params": [],
        "path": "go/net/textproto/index#Conn.Cmd",
        "syntax": "func (c *Conn) Cmd(format string, args ...interface{}) (id uint, err error)",
        "type": "net/textproto"
    },
    "textproto.Dial": {
        "descr": "Dial connects to the given address on the given network using net.Dial and then returns a new Conn for the connection.",
        "name": "textproto.Dial",
        "params": [],
        "path": "go/net/textproto/index#Dial",
        "syntax": "func Dial(network, addr string) (*Conn, error)",
        "type": "net/textproto"
    },
    "textproto.Error": {
        "descr": "An Error represents a numeric error response from a server.",
        "name": "textproto.Error",
        "params": [],
        "path": "go/net/textproto/index#Error",
        "syntax": "type Error struct { Code int Msg string }",
        "type": "net/textproto"
    },
    "textproto.Error.Error": {
        "descr": "",
        "name": "textproto.Error.Error",
        "params": [],
        "path": "go/net/textproto/index#Error.Error",
        "syntax": "func (e *Error) Error() string",
        "type": "net/textproto"
    },
    "textproto.MIMEHeader": {
        "descr": "A MIMEHeader represents a MIME-style header mapping keys to sets of values.",
        "name": "textproto.MIMEHeader",
        "params": [],
        "path": "go/net/textproto/index#MIMEHeader",
        "syntax": "type MIMEHeader map[string][]string",
        "type": "net/textproto"
    },
    "textproto.MIMEHeader.Add": {
        "descr": "Add adds the key, value pair to the header. It appends to any existing values associated with key.",
        "name": "textproto.MIMEHeader.Add",
        "params": [],
        "path": "go/net/textproto/index#MIMEHeader.Add",
        "syntax": "func (h MIMEHeader) Add(key, value string)",
        "type": "net/textproto"
    },
    "textproto.MIMEHeader.Del": {
        "descr": "Del deletes the values associated with key.",
        "name": "textproto.MIMEHeader.Del",
        "params": [],
        "path": "go/net/textproto/index#MIMEHeader.Del",
        "syntax": "func (h MIMEHeader) Del(key string)",
        "type": "net/textproto"
    },
    "textproto.MIMEHeader.Get": {
        "descr": "Get gets the first value associated with the given key. It is case insensitive; CanonicalMIMEHeaderKey is used to canonicalize the provided key. If there are no values associated with the key, Get returns \"\". To access multiple values of a key, or to use non-canonical keys, access the map directly.",
        "name": "textproto.MIMEHeader.Get",
        "params": [],
        "path": "go/net/textproto/index#MIMEHeader.Get",
        "syntax": "func (h MIMEHeader) Get(key string) string",
        "type": "net/textproto"
    },
    "textproto.MIMEHeader.Set": {
        "descr": "Set sets the header entries associated with key to the single element value. It replaces any existing values associated with key.",
        "name": "textproto.MIMEHeader.Set",
        "params": [],
        "path": "go/net/textproto/index#MIMEHeader.Set",
        "syntax": "func (h MIMEHeader) Set(key, value string)",
        "type": "net/textproto"
    },
    "textproto.NewConn": {
        "descr": "NewConn returns a new Conn using conn for I/O.",
        "name": "textproto.NewConn",
        "params": [],
        "path": "go/net/textproto/index#NewConn",
        "syntax": "func NewConn(conn io.ReadWriteCloser) *Conn",
        "type": "net/textproto"
    },
    "textproto.NewReader": {
        "descr": "NewReader returns a new Reader reading from r.",
        "name": "textproto.NewReader",
        "params": [],
        "path": "go/net/textproto/index#NewReader",
        "syntax": "func NewReader(r *bufio.Reader) *Reader",
        "type": "net/textproto"
    },
    "textproto.NewWriter": {
        "descr": "NewWriter returns a new Writer writing to w.",
        "name": "textproto.NewWriter",
        "params": [],
        "path": "go/net/textproto/index#NewWriter",
        "syntax": "func NewWriter(w *bufio.Writer) *Writer",
        "type": "net/textproto"
    },
    "textproto.Pipeline": {
        "descr": "A Pipeline manages a pipelined in-order request/response sequence.",
        "name": "textproto.Pipeline",
        "params": [],
        "path": "go/net/textproto/index#Pipeline",
        "syntax": "id := p.Next() // take a number p.StartRequest(id) // wait for turn to send request send request p.EndRequest(id) // notify Pipeline that request is sent p.StartResponse(id) // wait for turn to read response read response p.EndResponse(id) // notify Pipeline that response is read",
        "type": "net/textproto"
    },
    "textproto.Pipeline.EndRequest": {
        "descr": "EndRequest notifies p that the request with the given id has been sent (or, if this is a server, received).",
        "name": "textproto.Pipeline.EndRequest",
        "params": [],
        "path": "go/net/textproto/index#Pipeline.EndRequest",
        "syntax": "func (p *Pipeline) EndRequest(id uint)",
        "type": "net/textproto"
    },
    "textproto.Pipeline.EndResponse": {
        "descr": "EndResponse notifies p that the response with the given id has been received (or, if this is a server, sent).",
        "name": "textproto.Pipeline.EndResponse",
        "params": [],
        "path": "go/net/textproto/index#Pipeline.EndResponse",
        "syntax": "func (p *Pipeline) EndResponse(id uint)",
        "type": "net/textproto"
    },
    "textproto.Pipeline.Next": {
        "descr": "Next returns the next id for a request/response pair.",
        "name": "textproto.Pipeline.Next",
        "params": [],
        "path": "go/net/textproto/index#Pipeline.Next",
        "syntax": "func (p *Pipeline) Next() uint",
        "type": "net/textproto"
    },
    "textproto.Pipeline.StartRequest": {
        "descr": "StartRequest blocks until it is time to send (or, if this is a server, receive) the request with the given id.",
        "name": "textproto.Pipeline.StartRequest",
        "params": [],
        "path": "go/net/textproto/index#Pipeline.StartRequest",
        "syntax": "func (p *Pipeline) StartRequest(id uint)",
        "type": "net/textproto"
    },
    "textproto.Pipeline.StartResponse": {
        "descr": "StartResponse blocks until it is time to receive (or, if this is a server, send) the request with the given id.",
        "name": "textproto.Pipeline.StartResponse",
        "params": [],
        "path": "go/net/textproto/index#Pipeline.StartResponse",
        "syntax": "func (p *Pipeline) StartResponse(id uint)",
        "type": "net/textproto"
    },
    "textproto.ProtocolError": {
        "descr": "A ProtocolError describes a protocol violation such as an invalid response or a hung-up connection.",
        "name": "textproto.ProtocolError",
        "params": [],
        "path": "go/net/textproto/index#ProtocolError",
        "syntax": "type ProtocolError string",
        "type": "net/textproto"
    },
    "textproto.ProtocolError.Error": {
        "descr": "",
        "name": "textproto.ProtocolError.Error",
        "params": [],
        "path": "go/net/textproto/index#ProtocolError.Error",
        "syntax": "func (p ProtocolError) Error() string",
        "type": "net/textproto"
    },
    "textproto.Reader": {
        "descr": "A Reader implements convenience methods for reading requests or responses from a text protocol network connection.",
        "name": "textproto.Reader",
        "params": [],
        "path": "go/net/textproto/index#Reader",
        "syntax": "type Reader struct { R *bufio.Reader // contains filtered or unexported fields }",
        "type": "net/textproto"
    },
    "textproto.Reader.DotReader": {
        "descr": "DotReader returns a new Reader that satisfies Reads using the decoded text of a dot-encoded block read from r. The returned Reader is only valid until the next call to a method on r.",
        "name": "textproto.Reader.DotReader",
        "params": [],
        "path": "go/net/textproto/index#Reader.DotReader",
        "syntax": "func (r *Reader) DotReader() io.Reader",
        "type": "net/textproto"
    },
    "textproto.Reader.ReadCodeLine": {
        "descr": "ReadCodeLine reads a response code line of the form",
        "name": "textproto.Reader.ReadCodeLine",
        "params": [],
        "path": "go/net/textproto/index#Reader.ReadCodeLine",
        "syntax": "func (r *Reader) ReadCodeLine(expectCode int) (code int, message string, err error)",
        "type": "net/textproto"
    },
    "textproto.Reader.ReadContinuedLine": {
        "descr": "ReadContinuedLine reads a possibly continued line from r, eliding the final trailing ASCII white space. Lines after the first are considered continuations if they begin with a space or tab character. In the returned data, continuation lines are separated from the previous line only by a single space: the newline and leading white space are removed.",
        "name": "textproto.Reader.ReadContinuedLine",
        "params": [],
        "path": "go/net/textproto/index#Reader.ReadContinuedLine",
        "syntax": "func (r *Reader) ReadContinuedLine() (string, error)",
        "type": "net/textproto"
    },
    "textproto.Reader.ReadContinuedLineBytes": {
        "descr": "ReadContinuedLineBytes is like ReadContinuedLine but returns a []byte instead of a string.",
        "name": "textproto.Reader.ReadContinuedLineBytes",
        "params": [],
        "path": "go/net/textproto/index#Reader.ReadContinuedLineBytes",
        "syntax": "func (r *Reader) ReadContinuedLineBytes() ([]byte, error)",
        "type": "net/textproto"
    },
    "textproto.Reader.ReadDotBytes": {
        "descr": "ReadDotBytes reads a dot-encoding and returns the decoded data.",
        "name": "textproto.Reader.ReadDotBytes",
        "params": [],
        "path": "go/net/textproto/index#Reader.ReadDotBytes",
        "syntax": "func (r *Reader) ReadDotBytes() ([]byte, error)",
        "type": "net/textproto"
    },
    "textproto.Reader.ReadDotLines": {
        "descr": "ReadDotLines reads a dot-encoding and returns a slice containing the decoded lines, with the final \\r\\n or \\n elided from each.",
        "name": "textproto.Reader.ReadDotLines",
        "params": [],
        "path": "go/net/textproto/index#Reader.ReadDotLines",
        "syntax": "func (r *Reader) ReadDotLines() ([]string, error)",
        "type": "net/textproto"
    },
    "textproto.Reader.ReadLine": {
        "descr": "ReadLine reads a single line from r, eliding the final \\n or \\r\\n from the returned string.",
        "name": "textproto.Reader.ReadLine",
        "params": [],
        "path": "go/net/textproto/index#Reader.ReadLine",
        "syntax": "func (r *Reader) ReadLine() (string, error)",
        "type": "net/textproto"
    },
    "textproto.Reader.ReadLineBytes": {
        "descr": "ReadLineBytes is like ReadLine but returns a []byte instead of a string.",
        "name": "textproto.Reader.ReadLineBytes",
        "params": [],
        "path": "go/net/textproto/index#Reader.ReadLineBytes",
        "syntax": "func (r *Reader) ReadLineBytes() ([]byte, error)",
        "type": "net/textproto"
    },
    "textproto.Reader.ReadMIMEHeader": {
        "descr": "ReadMIMEHeader reads a MIME-style header from r. The header is a sequence of possibly continued Key: Value lines ending in a blank line. The returned map m maps CanonicalMIMEHeaderKey(key) to a sequence of values in the same order encountered in the input.",
        "name": "textproto.Reader.ReadMIMEHeader",
        "params": [],
        "path": "go/net/textproto/index#Reader.ReadMIMEHeader",
        "syntax": "func (r *Reader) ReadMIMEHeader() (MIMEHeader, error)",
        "type": "net/textproto"
    },
    "textproto.Reader.ReadResponse": {
        "descr": "ReadResponse reads a multi-line response of the form:",
        "name": "textproto.Reader.ReadResponse",
        "params": [],
        "path": "go/net/textproto/index#Reader.ReadResponse",
        "syntax": "func (r *Reader) ReadResponse(expectCode int) (code int, message string, err error)",
        "type": "net/textproto"
    },
    "textproto.TrimBytes": {
        "descr": "TrimBytes returns b without leading and trailing ASCII space.",
        "name": "textproto.TrimBytes",
        "params": [],
        "path": "go/net/textproto/index#TrimBytes",
        "syntax": "func TrimBytes(b []byte) []byte",
        "type": "net/textproto"
    },
    "textproto.TrimString": {
        "descr": "TrimString returns s without leading and trailing ASCII space.",
        "name": "textproto.TrimString",
        "params": [],
        "path": "go/net/textproto/index#TrimString",
        "syntax": "func TrimString(s string) string",
        "type": "net/textproto"
    },
    "textproto.Writer": {
        "descr": "A Writer implements convenience methods for writing requests or responses to a text protocol network connection.",
        "name": "textproto.Writer",
        "params": [],
        "path": "go/net/textproto/index#Writer",
        "syntax": "type Writer struct { W *bufio.Writer // contains filtered or unexported fields }",
        "type": "net/textproto"
    },
    "textproto.Writer.DotWriter": {
        "descr": "DotWriter returns a writer that can be used to write a dot-encoding to w. It takes care of inserting leading dots when necessary, translating line-ending \\n into \\r\\n, and adding the final .\\r\\n line when the DotWriter is closed. The caller should close the DotWriter before the next call to a method on w.",
        "name": "textproto.Writer.DotWriter",
        "params": [],
        "path": "go/net/textproto/index#Writer.DotWriter",
        "syntax": "func (w *Writer) DotWriter() io.WriteCloser",
        "type": "net/textproto"
    },
    "textproto.Writer.PrintfLine": {
        "descr": "PrintfLine writes the formatted output followed by \\r\\n.",
        "name": "textproto.Writer.PrintfLine",
        "params": [],
        "path": "go/net/textproto/index#Writer.PrintfLine",
        "syntax": "func (w *Writer) PrintfLine(format string, args ...interface{}) error",
        "type": "net/textproto"
    },
    "time": {
        "descr": "These are predefined layouts for use in Time.Format and time.Parse. The reference time used in the layouts is the specific time:",
        "name": "time",
        "params": [],
        "path": "go/time/index#pkg-constants",
        "syntax": "Mon Jan 2 15:04:05 MST 2006",
        "type": "time"
    },
    "time.After": {
        "descr": "After waits for the duration to elapse and then sends the current time on the returned channel. It is equivalent to NewTimer(d).C. The underlying Timer is not recovered by the garbage collector until the timer fires. If efficiency is a concern, use NewTimer instead and call Timer.Stop if the timer is no longer needed.",
        "name": "time.After",
        "params": [],
        "path": "go/time/index#After",
        "syntax": "func After(d Duration) <-chan Time",
        "type": "time"
    },
    "time.AfterFunc": {
        "descr": "AfterFunc waits for the duration to elapse and then calls f in its own goroutine. It returns a Timer that can be used to cancel the call using its Stop method.",
        "name": "time.AfterFunc",
        "params": [],
        "path": "go/time/index#AfterFunc",
        "syntax": "func AfterFunc(d Duration, f func()) *Timer",
        "type": "time"
    },
    "time.Date": {
        "descr": "Date returns the Time corresponding to",
        "name": "time.Date",
        "params": [],
        "path": "go/time/index#Date",
        "syntax": "func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time",
        "type": "time"
    },
    "time.Duration": {
        "descr": "A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.",
        "name": "time.Duration",
        "params": [],
        "path": "go/time/index#Duration",
        "syntax": "type Duration int64",
        "type": "time"
    },
    "time.Duration.Hours": {
        "descr": "Hours returns the duration as a floating point number of hours.",
        "name": "time.Duration.Hours",
        "params": [],
        "path": "go/time/index#Duration.Hours",
        "syntax": "func (d Duration) Hours() float64",
        "type": "time"
    },
    "time.Duration.Minutes": {
        "descr": "Minutes returns the duration as a floating point number of minutes.",
        "name": "time.Duration.Minutes",
        "params": [],
        "path": "go/time/index#Duration.Minutes",
        "syntax": "func (d Duration) Minutes() float64",
        "type": "time"
    },
    "time.Duration.Nanoseconds": {
        "descr": "Nanoseconds returns the duration as an integer nanosecond count.",
        "name": "time.Duration.Nanoseconds",
        "params": [],
        "path": "go/time/index#Duration.Nanoseconds",
        "syntax": "func (d Duration) Nanoseconds() int64",
        "type": "time"
    },
    "time.Duration.Round": {
        "descr": "Round returns the result of rounding d to the nearest multiple of m. The rounding behavior for halfway values is to round away from zero. If the result exceeds the maximum (or minimum) value that can be stored in a Duration, Round returns the maximum (or minimum) duration. If m <= 0, Round returns d unchanged.",
        "name": "time.Duration.Round",
        "params": [],
        "path": "go/time/index#Duration.Round",
        "syntax": "func (d Duration) Round(m Duration) Duration",
        "type": "time"
    },
    "time.Duration.Seconds": {
        "descr": "Seconds returns the duration as a floating point number of seconds.",
        "name": "time.Duration.Seconds",
        "params": [],
        "path": "go/time/index#Duration.Seconds",
        "syntax": "func (d Duration) Seconds() float64",
        "type": "time"
    },
    "time.Duration.String": {
        "descr": "String returns a string representing the duration in the form \"72h3m0.5s\". Leading zero units are omitted. As a special case, durations less than one second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure that the leading digit is non-zero. The zero duration formats as 0s.",
        "name": "time.Duration.String",
        "params": [],
        "path": "go/time/index#Duration.String",
        "syntax": "func (d Duration) String() string",
        "type": "time"
    },
    "time.Duration.Truncate": {
        "descr": "Truncate returns the result of rounding d toward zero to a multiple of m. If m <= 0, Truncate returns d unchanged.",
        "name": "time.Duration.Truncate",
        "params": [],
        "path": "go/time/index#Duration.Truncate",
        "syntax": "func (d Duration) Truncate(m Duration) Duration",
        "type": "time"
    },
    "time.FixedZone": {
        "descr": "FixedZone returns a Location that always uses the given zone name and offset (seconds east of UTC).",
        "name": "time.FixedZone",
        "params": [],
        "path": "go/time/index#FixedZone",
        "syntax": "func FixedZone(name string, offset int) *Location",
        "type": "time"
    },
    "time.LoadLocation": {
        "descr": "LoadLocation returns the Location with the given name.",
        "name": "time.LoadLocation",
        "params": [],
        "path": "go/time/index#LoadLocation",
        "syntax": "func LoadLocation(name string) (*Location, error)",
        "type": "time"
    },
    "time.LoadLocationFromTZData": {
        "descr": "LoadLocationFromTZData returns a Location with the given name initialized from the IANA Time Zone database-formatted data. The data should be in the format of a standard IANA time zone file (for example, the content of /etc/localtime on Unix systems).",
        "name": "time.LoadLocationFromTZData",
        "params": [],
        "path": "go/time/index#LoadLocationFromTZData",
        "syntax": "func LoadLocationFromTZData(name string, data []byte) (*Location, error)",
        "type": "time"
    },
    "time.Location": {
        "descr": "A Location maps time instants to the zone in use at that time. Typically, the Location represents the collection of time offsets in use in a geographical area, such as CEST and CET for central Europe.",
        "name": "time.Location",
        "params": [],
        "path": "go/time/index#Location",
        "syntax": "type Location struct { // contains filtered or unexported fields }",
        "type": "time"
    },
    "time.Location.String": {
        "descr": "String returns a descriptive name for the time zone information, corresponding to the name argument to LoadLocation or FixedZone.",
        "name": "time.Location.String",
        "params": [],
        "path": "go/time/index#Location.String",
        "syntax": "func (l *Location) String() string",
        "type": "time"
    },
    "time.Month": {
        "descr": "A Month specifies a month of the year (January = 1, ...).",
        "name": "time.Month",
        "params": [],
        "path": "go/time/index#Month",
        "syntax": "type Month int",
        "type": "time"
    },
    "time.Month.String": {
        "descr": "String returns the English name of the month (\"January\", \"February\", ...).",
        "name": "time.Month.String",
        "params": [],
        "path": "go/time/index#Month.String",
        "syntax": "func (m Month) String() string",
        "type": "time"
    },
    "time.NewTicker": {
        "descr": "NewTicker returns a new Ticker containing a channel that will send the time with a period specified by the duration argument. It adjusts the intervals or drops ticks to make up for slow receivers. The duration d must be greater than zero; if not, NewTicker will panic. Stop the ticker to release associated resources.",
        "name": "time.NewTicker",
        "params": [],
        "path": "go/time/index#NewTicker",
        "syntax": "func NewTicker(d Duration) *Ticker",
        "type": "time"
    },
    "time.NewTimer": {
        "descr": "NewTimer creates a new Timer that will send the current time on its channel after at least duration d.",
        "name": "time.NewTimer",
        "params": [],
        "path": "go/time/index#NewTimer",
        "syntax": "func NewTimer(d Duration) *Timer",
        "type": "time"
    },
    "time.Now": {
        "descr": "Now returns the current local time.",
        "name": "time.Now",
        "params": [],
        "path": "go/time/index#Now",
        "syntax": "func Now() Time",
        "type": "time"
    },
    "time.Parse": {
        "descr": "Parse parses a formatted string and returns the time value it represents. The layout defines the format by showing how the reference time, defined to be",
        "name": "time.Parse",
        "params": [],
        "path": "go/time/index#Parse",
        "syntax": "func Parse(layout, value string) (Time, error)",
        "type": "time"
    },
    "time.ParseDuration": {
        "descr": "ParseDuration parses a duration string. A duration string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as \"300ms\", \"-1.5h\" or \"2h45m\". Valid time units are \"ns\", \"us\" (or \"s\"), \"ms\", \"s\", \"m\", \"h\".",
        "name": "time.ParseDuration",
        "params": [],
        "path": "go/time/index#ParseDuration",
        "syntax": "func ParseDuration(s string) (Duration, error)",
        "type": "time"
    },
    "time.ParseError": {
        "descr": "ParseError describes a problem parsing a time string.",
        "name": "time.ParseError",
        "params": [],
        "path": "go/time/index#ParseError",
        "syntax": "type ParseError struct { Layout string Value string LayoutElem string ValueElem string Message string }",
        "type": "time"
    },
    "time.ParseError.Error": {
        "descr": "Error returns the string representation of a ParseError.",
        "name": "time.ParseError.Error",
        "params": [],
        "path": "go/time/index#ParseError.Error",
        "syntax": "func (e *ParseError) Error() string",
        "type": "time"
    },
    "time.ParseInLocation": {
        "descr": "ParseInLocation is like Parse but differs in two important ways. First, in the absence of time zone information, Parse interprets a time as UTC; ParseInLocation interprets the time as in the given location. Second, when given a zone offset or abbreviation, Parse tries to match it against the Local location; ParseInLocation uses the given location.",
        "name": "time.ParseInLocation",
        "params": [],
        "path": "go/time/index#ParseInLocation",
        "syntax": "func ParseInLocation(layout, value string, loc *Location) (Time, error)",
        "type": "time"
    },
    "time.Since": {
        "descr": "Since returns the time elapsed since t. It is shorthand for time.Now().Sub(t).",
        "name": "time.Since",
        "params": [],
        "path": "go/time/index#Since",
        "syntax": "func Since(t Time) Duration",
        "type": "time"
    },
    "time.Sleep": {
        "descr": "Sleep pauses the current goroutine for at least the duration d. A negative or zero duration causes Sleep to return immediately.",
        "name": "time.Sleep",
        "params": [],
        "path": "go/time/index#Sleep",
        "syntax": "func Sleep(d Duration)",
        "type": "time"
    },
    "time.Tick": {
        "descr": "Tick is a convenience wrapper for NewTicker providing access to the ticking channel only. While Tick is useful for clients that have no need to shut down the Ticker, be aware that without a way to shut it down the underlying Ticker cannot be recovered by the garbage collector; it \"leaks\". Unlike NewTicker, Tick will return nil if d <= 0.",
        "name": "time.Tick",
        "params": [],
        "path": "go/time/index#Tick",
        "syntax": "func Tick(d Duration) <-chan Time",
        "type": "time"
    },
    "time.Ticker": {
        "descr": "A Ticker holds a channel that delivers `ticks' of a clock at intervals.",
        "name": "time.Ticker",
        "params": [],
        "path": "go/time/index#Ticker",
        "syntax": "type Ticker struct { C <-chan Time // The channel on which the ticks are delivered. // contains filtered or unexported fields }",
        "type": "time"
    },
    "time.Ticker.Stop": {
        "descr": "Stop turns off a ticker. After Stop, no more ticks will be sent. Stop does not close the channel, to prevent a concurrent goroutine reading from the channel from seeing an erroneous \"tick\".",
        "name": "time.Ticker.Stop",
        "params": [],
        "path": "go/time/index#Ticker.Stop",
        "syntax": "func (t *Ticker) Stop()",
        "type": "time"
    },
    "time.Time": {
        "descr": "A Time represents an instant in time with nanosecond precision.",
        "name": "time.Time",
        "params": [],
        "path": "go/time/index#Time",
        "syntax": "type Time struct { // contains filtered or unexported fields }",
        "type": "time"
    },
    "time.Time.Add": {
        "descr": "Add returns the time t+d.",
        "name": "time.Time.Add",
        "params": [],
        "path": "go/time/index#Time.Add",
        "syntax": "func (t Time) Add(d Duration) Time",
        "type": "time"
    },
    "time.Time.AddDate": {
        "descr": "AddDate returns the time corresponding to adding the given number of years, months, and days to t. For example, AddDate(-1, 2, 3) applied to January 1, 2011 returns March 4, 2010.",
        "name": "time.Time.AddDate",
        "params": [],
        "path": "go/time/index#Time.AddDate",
        "syntax": "func (t Time) AddDate(years int, months int, days int) Time",
        "type": "time"
    },
    "time.Time.After": {
        "descr": "After reports whether the time instant t is after u.",
        "name": "time.Time.After",
        "params": [],
        "path": "go/time/index#Time.After",
        "syntax": "func (t Time) After(u Time) bool",
        "type": "time"
    },
    "time.Time.AppendFormat": {
        "descr": "AppendFormat is like Format but appends the textual representation to b and returns the extended buffer.",
        "name": "time.Time.AppendFormat",
        "params": [],
        "path": "go/time/index#Time.AppendFormat",
        "syntax": "func (t Time) AppendFormat(b []byte, layout string) []byte",
        "type": "time"
    },
    "time.Time.Before": {
        "descr": "Before reports whether the time instant t is before u.",
        "name": "time.Time.Before",
        "params": [],
        "path": "go/time/index#Time.Before",
        "syntax": "func (t Time) Before(u Time) bool",
        "type": "time"
    },
    "time.Time.Clock": {
        "descr": "Clock returns the hour, minute, and second within the day specified by t.",
        "name": "time.Time.Clock",
        "params": [],
        "path": "go/time/index#Time.Clock",
        "syntax": "func (t Time) Clock() (hour, min, sec int)",
        "type": "time"
    },
    "time.Time.Date": {
        "descr": "Date returns the year, month, and day in which t occurs.",
        "name": "time.Time.Date",
        "params": [],
        "path": "go/time/index#Time.Date",
        "syntax": "func (t Time) Date() (year int, month Month, day int)",
        "type": "time"
    },
    "time.Time.Day": {
        "descr": "Day returns the day of the month specified by t.",
        "name": "time.Time.Day",
        "params": [],
        "path": "go/time/index#Time.Day",
        "syntax": "func (t Time) Day() int",
        "type": "time"
    },
    "time.Time.Equal": {
        "descr": "Equal reports whether t and u represent the same time instant. Two times can be equal even if they are in different locations. For example, 6:00 +0200 CEST and 4:00 UTC are Equal. See the documentation on the Time type for the pitfalls of using == with Time values; most code should use Equal instead.",
        "name": "time.Time.Equal",
        "params": [],
        "path": "go/time/index#Time.Equal",
        "syntax": "func (t Time) Equal(u Time) bool",
        "type": "time"
    },
    "time.Time.Format": {
        "descr": "Format returns a textual representation of the time value formatted according to layout, which defines the format by showing how the reference time, defined to be",
        "name": "time.Time.Format",
        "params": [],
        "path": "go/time/index#Time.Format",
        "syntax": "func (t Time) Format(layout string) string",
        "type": "time"
    },
    "time.Time.GobDecode": {
        "descr": "GobDecode implements the gob.GobDecoder interface.",
        "name": "time.Time.GobDecode",
        "params": [],
        "path": "go/time/index#Time.GobDecode",
        "syntax": "func (t *Time) GobDecode(data []byte) error",
        "type": "time"
    },
    "time.Time.GobEncode": {
        "descr": "GobEncode implements the gob.GobEncoder interface.",
        "name": "time.Time.GobEncode",
        "params": [],
        "path": "go/time/index#Time.GobEncode",
        "syntax": "func (t Time) GobEncode() ([]byte, error)",
        "type": "time"
    },
    "time.Time.Hour": {
        "descr": "Hour returns the hour within the day specified by t, in the range [0, 23].",
        "name": "time.Time.Hour",
        "params": [],
        "path": "go/time/index#Time.Hour",
        "syntax": "func (t Time) Hour() int",
        "type": "time"
    },
    "time.Time.ISOWeek": {
        "descr": "ISOWeek returns the ISO 8601 year and week number in which t occurs. Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1 of year n+1.",
        "name": "time.Time.ISOWeek",
        "params": [],
        "path": "go/time/index#Time.ISOWeek",
        "syntax": "func (t Time) ISOWeek() (year, week int)",
        "type": "time"
    },
    "time.Time.In": {
        "descr": "In returns a copy of t representating the same time instant, but with the copy's location information set to loc for display purposes.",
        "name": "time.Time.In",
        "params": [],
        "path": "go/time/index#Time.In",
        "syntax": "func (t Time) In(loc *Location) Time",
        "type": "time"
    },
    "time.Time.IsZero": {
        "descr": "IsZero reports whether t represents the zero time instant, January 1, year 1, 00:00:00 UTC.",
        "name": "time.Time.IsZero",
        "params": [],
        "path": "go/time/index#Time.IsZero",
        "syntax": "func (t Time) IsZero() bool",
        "type": "time"
    },
    "time.Time.Local": {
        "descr": "Local returns t with the location set to local time.",
        "name": "time.Time.Local",
        "params": [],
        "path": "go/time/index#Time.Local",
        "syntax": "func (t Time) Local() Time",
        "type": "time"
    },
    "time.Time.Location": {
        "descr": "Location returns the time zone information associated with t.",
        "name": "time.Time.Location",
        "params": [],
        "path": "go/time/index#Time.Location",
        "syntax": "func (t Time) Location() *Location",
        "type": "time"
    },
    "time.Time.MarshalBinary": {
        "descr": "MarshalBinary implements the encoding.BinaryMarshaler interface.",
        "name": "time.Time.MarshalBinary",
        "params": [],
        "path": "go/time/index#Time.MarshalBinary",
        "syntax": "func (t Time) MarshalBinary() ([]byte, error)",
        "type": "time"
    },
    "time.Time.MarshalJSON": {
        "descr": "MarshalJSON implements the json.Marshaler interface. The time is a quoted string in RFC 3339 format, with sub-second precision added if present.",
        "name": "time.Time.MarshalJSON",
        "params": [],
        "path": "go/time/index#Time.MarshalJSON",
        "syntax": "func (t Time) MarshalJSON() ([]byte, error)",
        "type": "time"
    },
    "time.Time.MarshalText": {
        "descr": "MarshalText implements the encoding.TextMarshaler interface. The time is formatted in RFC 3339 format, with sub-second precision added if present.",
        "name": "time.Time.MarshalText",
        "params": [],
        "path": "go/time/index#Time.MarshalText",
        "syntax": "func (t Time) MarshalText() ([]byte, error)",
        "type": "time"
    },
    "time.Time.Minute": {
        "descr": "Minute returns the minute offset within the hour specified by t, in the range [0, 59].",
        "name": "time.Time.Minute",
        "params": [],
        "path": "go/time/index#Time.Minute",
        "syntax": "func (t Time) Minute() int",
        "type": "time"
    },
    "time.Time.Month": {
        "descr": "Month returns the month of the year specified by t.",
        "name": "time.Time.Month",
        "params": [],
        "path": "go/time/index#Time.Month",
        "syntax": "func (t Time) Month() Month",
        "type": "time"
    },
    "time.Time.Nanosecond": {
        "descr": "Nanosecond returns the nanosecond offset within the second specified by t, in the range [0, 999999999].",
        "name": "time.Time.Nanosecond",
        "params": [],
        "path": "go/time/index#Time.Nanosecond",
        "syntax": "func (t Time) Nanosecond() int",
        "type": "time"
    },
    "time.Time.Round": {
        "descr": "Round returns the result of rounding t to the nearest multiple of d (since the zero time). The rounding behavior for halfway values is to round up. If d <= 0, Round returns t stripped of any monotonic clock reading but otherwise unchanged.",
        "name": "time.Time.Round",
        "params": [],
        "path": "go/time/index#Time.Round",
        "syntax": "func (t Time) Round(d Duration) Time",
        "type": "time"
    },
    "time.Time.Second": {
        "descr": "Second returns the second offset within the minute specified by t, in the range [0, 59].",
        "name": "time.Time.Second",
        "params": [],
        "path": "go/time/index#Time.Second",
        "syntax": "func (t Time) Second() int",
        "type": "time"
    },
    "time.Time.String": {
        "descr": "String returns the time formatted using the format string",
        "name": "time.Time.String",
        "params": [],
        "path": "go/time/index#Time.String",
        "syntax": "func (t Time) String() string",
        "type": "time"
    },
    "time.Time.Sub": {
        "descr": "Sub returns the duration t-u. If the result exceeds the maximum (or minimum) value that can be stored in a Duration, the maximum (or minimum) duration will be returned. To compute t-d for a duration d, use t.Add(-d).",
        "name": "time.Time.Sub",
        "params": [],
        "path": "go/time/index#Time.Sub",
        "syntax": "func (t Time) Sub(u Time) Duration",
        "type": "time"
    },
    "time.Time.Truncate": {
        "descr": "Truncate returns the result of rounding t down to a multiple of d (since the zero time). If d <= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged.",
        "name": "time.Time.Truncate",
        "params": [],
        "path": "go/time/index#Time.Truncate",
        "syntax": "func (t Time) Truncate(d Duration) Time",
        "type": "time"
    },
    "time.Time.UTC": {
        "descr": "UTC returns t with the location set to UTC.",
        "name": "time.Time.UTC",
        "params": [],
        "path": "go/time/index#Time.UTC",
        "syntax": "func (t Time) UTC() Time",
        "type": "time"
    },
    "time.Time.Unix": {
        "descr": "Unix returns t as a Unix time, the number of seconds elapsed since January 1, 1970 UTC. The result does not depend on the location associated with t.",
        "name": "time.Time.Unix",
        "params": [],
        "path": "go/time/index#Time.Unix",
        "syntax": "func (t Time) Unix() int64",
        "type": "time"
    },
    "time.Time.UnixNano": {
        "descr": "UnixNano returns t as a Unix time, the number of nanoseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in nanoseconds cannot be represented by an int64 (a date before the year 1678 or after 2262). Note that this means the result of calling UnixNano on the zero Time is undefined. The result does not depend on the location associated with t.",
        "name": "time.Time.UnixNano",
        "params": [],
        "path": "go/time/index#Time.UnixNano",
        "syntax": "func (t Time) UnixNano() int64",
        "type": "time"
    },
    "time.Time.UnmarshalBinary": {
        "descr": "UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.",
        "name": "time.Time.UnmarshalBinary",
        "params": [],
        "path": "go/time/index#Time.UnmarshalBinary",
        "syntax": "func (t *Time) UnmarshalBinary(data []byte) error",
        "type": "time"
    },
    "time.Time.UnmarshalJSON": {
        "descr": "UnmarshalJSON implements the json.Unmarshaler interface. The time is expected to be a quoted string in RFC 3339 format.",
        "name": "time.Time.UnmarshalJSON",
        "params": [],
        "path": "go/time/index#Time.UnmarshalJSON",
        "syntax": "func (t *Time) UnmarshalJSON(data []byte) error",
        "type": "time"
    },
    "time.Time.UnmarshalText": {
        "descr": "UnmarshalText implements the encoding.TextUnmarshaler interface. The time is expected to be in RFC 3339 format.",
        "name": "time.Time.UnmarshalText",
        "params": [],
        "path": "go/time/index#Time.UnmarshalText",
        "syntax": "func (t *Time) UnmarshalText(data []byte) error",
        "type": "time"
    },
    "time.Time.Weekday": {
        "descr": "Weekday returns the day of the week specified by t.",
        "name": "time.Time.Weekday",
        "params": [],
        "path": "go/time/index#Time.Weekday",
        "syntax": "func (t Time) Weekday() Weekday",
        "type": "time"
    },
    "time.Time.Year": {
        "descr": "Year returns the year in which t occurs.",
        "name": "time.Time.Year",
        "params": [],
        "path": "go/time/index#Time.Year",
        "syntax": "func (t Time) Year() int",
        "type": "time"
    },
    "time.Time.YearDay": {
        "descr": "YearDay returns the day of the year specified by t, in the range [1,365] for non-leap years, and [1,366] in leap years.",
        "name": "time.Time.YearDay",
        "params": [],
        "path": "go/time/index#Time.YearDay",
        "syntax": "func (t Time) YearDay() int",
        "type": "time"
    },
    "time.Time.Zone": {
        "descr": "Zone computes the time zone in effect at time t, returning the abbreviated name of the zone (such as \"CET\") and its offset in seconds east of UTC.",
        "name": "time.Time.Zone",
        "params": [],
        "path": "go/time/index#Time.Zone",
        "syntax": "func (t Time) Zone() (name string, offset int)",
        "type": "time"
    },
    "time.Timer": {
        "descr": "The Timer type represents a single event. When the Timer expires, the current time will be sent on C, unless the Timer was created by AfterFunc. A Timer must be created with NewTimer or AfterFunc.",
        "name": "time.Timer",
        "params": [],
        "path": "go/time/index#Timer",
        "syntax": "type Timer struct { C <-chan Time // contains filtered or unexported fields }",
        "type": "time"
    },
    "time.Timer.Reset": {
        "descr": "Reset changes the timer to expire after duration d. It returns true if the timer had been active, false if the timer had expired or been stopped.",
        "name": "time.Timer.Reset",
        "params": [],
        "path": "go/time/index#Timer.Reset",
        "syntax": "func (t *Timer) Reset(d Duration) bool",
        "type": "time"
    },
    "time.Timer.Stop": {
        "descr": "Stop prevents the Timer from firing. It returns true if the call stops the timer, false if the timer has already expired or been stopped. Stop does not close the channel, to prevent a read from the channel succeeding incorrectly.",
        "name": "time.Timer.Stop",
        "params": [],
        "path": "go/time/index#Timer.Stop",
        "syntax": "func (t *Timer) Stop() bool",
        "type": "time"
    },
    "time.Unix": {
        "descr": "Unix returns the local Time corresponding to the given Unix time, sec seconds and nsec nanoseconds since January 1, 1970 UTC. It is valid to pass nsec outside the range [0, 999999999]. Not all sec values have a corresponding time value. One such value is 1<<63-1 (the largest int64 value).",
        "name": "time.Unix",
        "params": [],
        "path": "go/time/index#Unix",
        "syntax": "func Unix(sec int64, nsec int64) Time",
        "type": "time"
    },
    "time.Until": {
        "descr": "Until returns the duration until t. It is shorthand for t.Sub(time.Now()).",
        "name": "time.Until",
        "params": [],
        "path": "go/time/index#Until",
        "syntax": "func Until(t Time) Duration",
        "type": "time"
    },
    "time.Weekday": {
        "descr": "A Weekday specifies a day of the week (Sunday = 0, ...).",
        "name": "time.Weekday",
        "params": [],
        "path": "go/time/index#Weekday",
        "syntax": "type Weekday int",
        "type": "time"
    },
    "time.Weekday.String": {
        "descr": "String returns the English name of the day (\"Sunday\", \"Monday\", ...).",
        "name": "time.Weekday.String",
        "params": [],
        "path": "go/time/index#Weekday.String",
        "syntax": "func (d Weekday) String() string",
        "type": "time"
    },
    "tls.Certificate": {
        "descr": "A Certificate is a chain of one or more certificates, leaf first.",
        "name": "tls.Certificate",
        "params": [],
        "path": "go/crypto/tls/index#Certificate",
        "syntax": "type Certificate struct { Certificate [][]byte // PrivateKey contains the private key corresponding to the public key // in Leaf. For a server, this must implement crypto.Signer and/or // crypto.Decrypter, with an RSA or ECDSA PublicKey. For a client // (performing client authentication), this must be a crypto.Signer // with an RSA or ECDSA PublicKey. PrivateKey crypto.PrivateKey // OCSPStaple contains an optional OCSP response which will be served // to clients that request it. OCSPStaple []byte // SignedCertificateTimestamps contains an optional list of Signed // Certificate Timestamps which will be served to clients that request it. SignedCertificateTimestamps [][]byte // Go 1.5 // Leaf is the parsed form of the leaf certificate, which may be // initialized using x509.ParseCertificate to reduce per-handshake // processing for TLS clients doing client authentication. If nil, the // leaf certificate will be parsed as needed. Leaf *x509.Certificate }",
        "type": "crypto"
    },
    "tls.CertificateRequestInfo": {
        "descr": "CertificateRequestInfo contains information from a server's CertificateRequest message, which is used to demand a certificate and proof of control from a client.",
        "name": "tls.CertificateRequestInfo",
        "params": [],
        "path": "go/crypto/tls/index#CertificateRequestInfo",
        "syntax": "type CertificateRequestInfo struct { // AcceptableCAs contains zero or more, DER-encoded, X.501 // Distinguished Names. These are the names of root or intermediate CAs // that the server wishes the returned certificate to be signed by. An // empty slice indicates that the server has no preference. AcceptableCAs [][]byte // SignatureSchemes lists the signature schemes that the server is // willing to verify. SignatureSchemes []SignatureScheme }",
        "type": "crypto"
    },
    "tls.Client": {
        "descr": "Client returns a new TLS client side connection using conn as the underlying transport. The config cannot be nil: users must set either ServerName or InsecureSkipVerify in the config.",
        "name": "tls.Client",
        "params": [],
        "path": "go/crypto/tls/index#Client",
        "syntax": "func Client(conn net.Conn, config *Config) *Conn",
        "type": "crypto"
    },
    "tls.ClientAuthType": {
        "descr": "ClientAuthType declares the policy the server will follow for TLS Client Authentication.",
        "name": "tls.ClientAuthType",
        "params": [],
        "path": "go/crypto/tls/index#ClientAuthType",
        "syntax": "type ClientAuthType int",
        "type": "crypto"
    },
    "tls.ClientHelloInfo": {
        "descr": "ClientHelloInfo contains information from a ClientHello message in order to guide certificate selection in the GetCertificate callback.",
        "name": "tls.ClientHelloInfo",
        "params": [],
        "path": "go/crypto/tls/index#ClientHelloInfo",
        "syntax": "type ClientHelloInfo struct { // CipherSuites lists the CipherSuites supported by the client (e.g. // TLS_RSA_WITH_RC4_128_SHA). CipherSuites []uint16 // ServerName indicates the name of the server requested by the client // in order to support virtual hosting. ServerName is only set if the // client is using SNI (see // https://tools.ietf.org/html/rfc4366#section-3.1). ServerName string // SupportedCurves lists the elliptic curves supported by the client. // SupportedCurves is set only if the Supported Elliptic Curves // Extension is being used (see // https://tools.ietf.org/html/rfc4492#section-5.1.1). SupportedCurves []CurveID // SupportedPoints lists the point formats supported by the client. // SupportedPoints is set only if the Supported Point Formats Extension // is being used (see // https://tools.ietf.org/html/rfc4492#section-5.1.2). SupportedPoints []uint8 // SignatureSchemes lists the signature and hash schemes that the client // is willing to verify. SignatureSchemes is set only if the Signature // Algorithms Extension is being used (see // https://tools.ietf.org/html/rfc5246#section-7.4.1.4.1). SignatureSchemes []SignatureScheme // Go 1.8 // SupportedProtos lists the application protocols supported by the client. // SupportedProtos is set only if the Application-Layer Protocol // Negotiation Extension is being used (see // https://tools.ietf.org/html/rfc7301#section-3.1). // // Servers can select a protocol by setting Config.NextProtos in a // GetConfigForClient return value. SupportedProtos []string // Go 1.8 // SupportedVersions lists the TLS versions supported by the client. // For TLS versions less than 1.3, this is extrapolated from the max // version advertised by the client, so values other than the greatest // might be rejected if used. SupportedVersions []uint16 // Go 1.8 // Conn is the underlying net.Conn for the connection. Do not read // from, or write to, this connection; that will cause the TLS // connection to fail. Conn net.Conn // Go 1.8 }",
        "type": "crypto"
    },
    "tls.ClientSessionCache": {
        "descr": "ClientSessionCache is a cache of ClientSessionState objects that can be used by a client to resume a TLS session with a given server. ClientSessionCache implementations should expect to be called concurrently from different goroutines. Only ticket-based resumption is supported, not SessionID-based resumption.",
        "name": "tls.ClientSessionCache",
        "params": [],
        "path": "go/crypto/tls/index#ClientSessionCache",
        "syntax": "type ClientSessionCache interface { // Get searches for a ClientSessionState associated with the given key. // On return, ok is true if one was found. Get(sessionKey string) (session *ClientSessionState, ok bool) // Put adds the ClientSessionState to the cache with the given key. Put(sessionKey string, cs *ClientSessionState) }",
        "type": "crypto"
    },
    "tls.ClientSessionState": {
        "descr": "ClientSessionState contains the state needed by clients to resume TLS sessions.",
        "name": "tls.ClientSessionState",
        "params": [],
        "path": "go/crypto/tls/index#ClientSessionState",
        "syntax": "type ClientSessionState struct { // contains filtered or unexported fields }",
        "type": "crypto"
    },
    "tls.Config": {
        "descr": "A Config structure is used to configure a TLS client or server. After one has been passed to a TLS function it must not be modified. A Config may be reused; the tls package will also not modify it.",
        "name": "tls.Config",
        "params": [],
        "path": "go/crypto/tls/index#Config",
        "syntax": "type Config struct { // Rand provides the source of entropy for nonces and RSA blinding. // If Rand is nil, TLS uses the cryptographic random reader in package // crypto/rand. // The Reader must be safe for use by multiple goroutines. Rand io.Reader // Time returns the current time as the number of seconds since the epoch. // If Time is nil, TLS uses time.Now. Time func() time.Time // Certificates contains one or more certificate chains to present to // the other side of the connection. Server configurations must include // at least one certificate or else set GetCertificate. Clients doing // client-authentication may set either Certificates or // GetClientCertificate. Certificates []Certificate // NameToCertificate maps from a certificate name to an element of // Certificates. Note that a certificate name can be of the form // '*.example.com' and so doesn't have to be a domain name as such. // See Config.BuildNameToCertificate // The nil value causes the first element of Certificates to be used // for all connections. NameToCertificate map[string]*Certificate // GetCertificate returns a Certificate based on the given // ClientHelloInfo. It will only be called if the client supplies SNI // information or if Certificates is empty. // // If GetCertificate is nil or returns nil, then the certificate is // retrieved from NameToCertificate. If NameToCertificate is nil, the // first element of Certificates will be used. GetCertificate func(*ClientHelloInfo) (*Certificate, error) // Go 1.4 // GetClientCertificate, if not nil, is called when a server requests a // certificate from a client. If set, the contents of Certificates will // be ignored. // // If GetClientCertificate returns an error, the handshake will be // aborted and that error will be returned. Otherwise // GetClientCertificate must return a non-nil Certificate. If // Certificate.Certificate is empty then no certificate will be sent to // the server. If this is unacceptable to the server then it may abort // the handshake. // // GetClientCertificate may be called multiple times for the same // connection if renegotiation occurs or if TLS 1.3 is in use. GetClientCertificate func(*CertificateRequestInfo) (*Certificate, error) // Go 1.8 // GetConfigForClient, if not nil, is called after a ClientHello is // received from a client. It may return a non-nil Config in order to // change the Config that will be used to handle this connection. If // the returned Config is nil, the original Config will be used. The // Config returned by this callback may not be subsequently modified. // // If GetConfigForClient is nil, the Config passed to Server() will be // used for all connections. // // Uniquely for the fields in the returned Config, session ticket keys // will be duplicated from the original Config if not set. // Specifically, if SetSessionTicketKeys was called on the original // config but not on the returned config then the ticket keys from the // original config will be copied into the new config before use. // Otherwise, if SessionTicketKey was set in the original config but // not in the returned config then it will be copied into the returned // config before use. If neither of those cases applies then the key // material from the returned config will be used for session tickets. GetConfigForClient func(*ClientHelloInfo) (*Config, error) // Go 1.8 // VerifyPeerCertificate, if not nil, is called after normal // certificate verification by either a TLS client or server. It // receives the raw ASN.1 certificates provided by the peer and also // any verified chains that normal processing found. If it returns a // non-nil error, the handshake is aborted and that error results. // // If normal verification fails then the handshake will abort before // considering this callback. If normal verification is disabled by // setting InsecureSkipVerify, or (for a server) when ClientAuth is // RequestClientCert or RequireAnyClientCert, then this callback will // be considered but the verifiedChains argument will always be nil. VerifyPeerCertificate func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error // Go 1.8 // RootCAs defines the set of root certificate authorities // that clients use when verifying server certificates. // If RootCAs is nil, TLS uses the host's root CA set. RootCAs *x509.CertPool // NextProtos is a list of supported, application level protocols. NextProtos []string // ServerName is used to verify the hostname on the returned // certificates unless InsecureSkipVerify is given. It is also included // in the client's handshake to support virtual hosting unless it is // an IP address. ServerName string // ClientAuth determines the server's policy for // TLS Client Authentication. The default is NoClientCert. ClientAuth ClientAuthType // ClientCAs defines the set of root certificate authorities // that servers use if required to verify a client certificate // by the policy in ClientAuth. ClientCAs *x509.CertPool // InsecureSkipVerify controls whether a client verifies the // server's certificate chain and host name. // If InsecureSkipVerify is true, TLS accepts any certificate // presented by the server and any host name in that certificate. // In this mode, TLS is susceptible to man-in-the-middle attacks. // This should be used only for testing. InsecureSkipVerify bool // CipherSuites is a list of supported cipher suites. If CipherSuites // is nil, TLS uses a list of suites supported by the implementation. CipherSuites []uint16 // PreferServerCipherSuites controls whether the server selects the // client's most preferred ciphersuite, or the server's most preferred // ciphersuite. If true then the server's preference, as expressed in // the order of elements in CipherSuites, is used. PreferServerCipherSuites bool // Go 1.1 // SessionTicketsDisabled may be set to true to disable session ticket // (resumption) support. Note that on clients, session ticket support is // also disabled if ClientSessionCache is nil. SessionTicketsDisabled bool // Go 1.1 // SessionTicketKey is used by TLS servers to provide session // resumption. See RFC 5077. If zero, it will be filled with // random data before the first server handshake. // // If multiple servers are terminating connections for the same host // they should all have the same SessionTicketKey. If the // SessionTicketKey leaks, previously recorded and future TLS // connections using that key are compromised. SessionTicketKey [32]byte // Go 1.1 // ClientSessionCache is a cache of ClientSessionState entries for TLS // session resumption. It is only used by clients. ClientSessionCache ClientSessionCache // Go 1.3 // MinVersion contains the minimum SSL/TLS version that is acceptable. // If zero, then TLS 1.0 is taken as the minimum. MinVersion uint16 // Go 1.2 // MaxVersion contains the maximum SSL/TLS version that is acceptable. // If zero, then the maximum version supported by this package is used, // which is currently TLS 1.2. MaxVersion uint16 // Go 1.2 // CurvePreferences contains the elliptic curves that will be used in // an ECDHE handshake, in preference order. If empty, the default will // be used. CurvePreferences []CurveID // Go 1.3 // DynamicRecordSizingDisabled disables adaptive sizing of TLS records. // When true, the largest possible TLS record size is always used. When // false, the size of TLS records may be adjusted in an attempt to // improve latency. DynamicRecordSizingDisabled bool // Go 1.7 // Renegotiation controls what types of renegotiation are supported. // The default, none, is correct for the vast majority of applications. Renegotiation RenegotiationSupport // Go 1.7 // KeyLogWriter optionally specifies a destination for TLS master secrets // in NSS key log format that can be used to allow external programs // such as Wireshark to decrypt TLS connections. // See https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format. // Use of KeyLogWriter compromises security and should only be // used for debugging. KeyLogWriter io.Writer // Go 1.8 // contains filtered or unexported fields }",
        "type": "crypto"
    },
    "tls.Config.BuildNameToCertificate": {
        "descr": "BuildNameToCertificate parses c.Certificates and builds c.NameToCertificate from the CommonName and SubjectAlternateName fields of each of the leaf certificates.",
        "name": "tls.Config.BuildNameToCertificate",
        "params": [],
        "path": "go/crypto/tls/index#Config.BuildNameToCertificate",
        "syntax": "func (c *Config) BuildNameToCertificate()",
        "type": "crypto"
    },
    "tls.Config.Clone": {
        "descr": "Clone returns a shallow clone of c. It is safe to clone a Config that is being used concurrently by a TLS client or server.",
        "name": "tls.Config.Clone",
        "params": [],
        "path": "go/crypto/tls/index#Config.Clone",
        "syntax": "func (c *Config) Clone() *Config",
        "type": "crypto"
    },
    "tls.Config.SetSessionTicketKeys": {
        "descr": "SetSessionTicketKeys updates the session ticket keys for a server. The first key will be used when creating new tickets, while all keys can be used for decrypting tickets. It is safe to call this function while the server is running in order to rotate the session ticket keys. The function will panic if keys is empty.",
        "name": "tls.Config.SetSessionTicketKeys",
        "params": [],
        "path": "go/crypto/tls/index#Config.SetSessionTicketKeys",
        "syntax": "func (c *Config) SetSessionTicketKeys(keys [][32]byte)",
        "type": "crypto"
    },
    "tls.Conn": {
        "descr": "A Conn represents a secured connection. It implements the net.Conn interface.",
        "name": "tls.Conn",
        "params": [],
        "path": "go/crypto/tls/index#Conn",
        "syntax": "type Conn struct { // contains filtered or unexported fields }",
        "type": "crypto"
    },
    "tls.Conn.Close": {
        "descr": "Close closes the connection.",
        "name": "tls.Conn.Close",
        "params": [],
        "path": "go/crypto/tls/index#Conn.Close",
        "syntax": "func (c *Conn) Close() error",
        "type": "crypto"
    },
    "tls.Conn.CloseWrite": {
        "descr": "CloseWrite shuts down the writing side of the connection. It should only be called once the handshake has completed and does not call CloseWrite on the underlying connection. Most callers should just use Close.",
        "name": "tls.Conn.CloseWrite",
        "params": [],
        "path": "go/crypto/tls/index#Conn.CloseWrite",
        "syntax": "func (c *Conn) CloseWrite() error",
        "type": "crypto"
    },
    "tls.Conn.ConnectionState": {
        "descr": "ConnectionState returns basic TLS details about the connection.",
        "name": "tls.Conn.ConnectionState",
        "params": [],
        "path": "go/crypto/tls/index#Conn.ConnectionState",
        "syntax": "func (c *Conn) ConnectionState() ConnectionState",
        "type": "crypto"
    },
    "tls.Conn.Handshake": {
        "descr": "Handshake runs the client or server handshake protocol if it has not yet been run. Most uses of this package need not call Handshake explicitly: the first Read or Write will call it automatically.",
        "name": "tls.Conn.Handshake",
        "params": [],
        "path": "go/crypto/tls/index#Conn.Handshake",
        "syntax": "func (c *Conn) Handshake() error",
        "type": "crypto"
    },
    "tls.Conn.LocalAddr": {
        "descr": "LocalAddr returns the local network address.",
        "name": "tls.Conn.LocalAddr",
        "params": [],
        "path": "go/crypto/tls/index#Conn.LocalAddr",
        "syntax": "func (c *Conn) LocalAddr() net.Addr",
        "type": "crypto"
    },
    "tls.Conn.OCSPResponse": {
        "descr": "OCSPResponse returns the stapled OCSP response from the TLS server, if any. (Only valid for client connections.)",
        "name": "tls.Conn.OCSPResponse",
        "params": [],
        "path": "go/crypto/tls/index#Conn.OCSPResponse",
        "syntax": "func (c *Conn) OCSPResponse() []byte",
        "type": "crypto"
    },
    "tls.Conn.Read": {
        "descr": "Read can be made to time out and return a net.Error with Timeout() == true after a fixed time limit; see SetDeadline and SetReadDeadline.",
        "name": "tls.Conn.Read",
        "params": [],
        "path": "go/crypto/tls/index#Conn.Read",
        "syntax": "func (c *Conn) Read(b []byte) (n int, err error)",
        "type": "crypto"
    },
    "tls.Conn.RemoteAddr": {
        "descr": "RemoteAddr returns the remote network address.",
        "name": "tls.Conn.RemoteAddr",
        "params": [],
        "path": "go/crypto/tls/index#Conn.RemoteAddr",
        "syntax": "func (c *Conn) RemoteAddr() net.Addr",
        "type": "crypto"
    },
    "tls.Conn.SetDeadline": {
        "descr": "SetDeadline sets the read and write deadlines associated with the connection. A zero value for t means Read and Write will not time out. After a Write has timed out, the TLS state is corrupt and all future writes will return the same error.",
        "name": "tls.Conn.SetDeadline",
        "params": [],
        "path": "go/crypto/tls/index#Conn.SetDeadline",
        "syntax": "func (c *Conn) SetDeadline(t time.Time) error",
        "type": "crypto"
    },
    "tls.Conn.SetReadDeadline": {
        "descr": "SetReadDeadline sets the read deadline on the underlying connection. A zero value for t means Read will not time out.",
        "name": "tls.Conn.SetReadDeadline",
        "params": [],
        "path": "go/crypto/tls/index#Conn.SetReadDeadline",
        "syntax": "func (c *Conn) SetReadDeadline(t time.Time) error",
        "type": "crypto"
    },
    "tls.Conn.SetWriteDeadline": {
        "descr": "SetWriteDeadline sets the write deadline on the underlying connection. A zero value for t means Write will not time out. After a Write has timed out, the TLS state is corrupt and all future writes will return the same error.",
        "name": "tls.Conn.SetWriteDeadline",
        "params": [],
        "path": "go/crypto/tls/index#Conn.SetWriteDeadline",
        "syntax": "func (c *Conn) SetWriteDeadline(t time.Time) error",
        "type": "crypto"
    },
    "tls.Conn.VerifyHostname": {
        "descr": "VerifyHostname checks that the peer certificate chain is valid for connecting to host. If so, it returns nil; if not, it returns an error describing the problem.",
        "name": "tls.Conn.VerifyHostname",
        "params": [],
        "path": "go/crypto/tls/index#Conn.VerifyHostname",
        "syntax": "func (c *Conn) VerifyHostname(host string) error",
        "type": "crypto"
    },
    "tls.Conn.Write": {
        "descr": "Write writes data to the connection.",
        "name": "tls.Conn.Write",
        "params": [],
        "path": "go/crypto/tls/index#Conn.Write",
        "syntax": "func (c *Conn) Write(b []byte) (int, error)",
        "type": "crypto"
    },
    "tls.ConnectionState": {
        "descr": "ConnectionState records basic TLS details about the connection.",
        "name": "tls.ConnectionState",
        "params": [],
        "path": "go/crypto/tls/index#ConnectionState",
        "syntax": "type ConnectionState struct { Version uint16 // TLS version used by the connection (e.g. VersionTLS12);\n or  added in Go 1.3 HandshakeComplete bool // TLS handshake is complete DidResume bool // connection resumes a previous TLS connection; added in Go 1.1 CipherSuite uint16 // cipher suite in use (TLS_RSA_WITH_RC4_128_SHA, ...) NegotiatedProtocol string // negotiated next protocol (not guaranteed to be from Config.NextProtos) NegotiatedProtocolIsMutual bool // negotiated protocol was advertised by server (client side only) ServerName string // server name requested by client, if any (server side only) PeerCertificates []*x509.Certificate // certificate chain presented by remote peer VerifiedChains [][]*x509.Certificate // verified chains built from PeerCertificates SignedCertificateTimestamps [][]byte // SCTs from the server, if any; added in Go 1.5 OCSPResponse []byte // stapled OCSP response from server, if any; added in Go 1.5 // TLSUnique contains the \"tls-unique\" channel binding value (see RFC // 5929, section 3). For resumed sessions this value will be nil // because resumption does not include enough context (see // https://mitls.org/pages/attacks/3SHAKE#channelbindings). This will // change in future versions of Go once the TLS master-secret fix has // been standardized and implemented. TLSUnique []byte // Go 1.4 // contains filtered or unexported fields });",
        "type": "crypto"
    },
    "tls.ConnectionState.ExportKeyingMaterial": {
        "descr": "ExportKeyingMaterial returns length bytes of exported key material in a new slice as defined in https://tools.ietf.org/html/rfc5705. If context is nil, it is not used as part of the seed. If the connection was set to allow renegotiation via Config.Renegotiation, this function will return an error.",
        "name": "tls.ConnectionState.ExportKeyingMaterial",
        "params": [],
        "path": "go/crypto/tls/index#ConnectionState.ExportKeyingMaterial",
        "syntax": "func (cs *ConnectionState) ExportKeyingMaterial(label string, context []byte, length int) ([]byte, error)",
        "type": "crypto"
    },
    "tls.CurveID": {
        "descr": "CurveID is the type of a TLS identifier for an elliptic curve. See https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8",
        "name": "tls.CurveID",
        "params": [],
        "path": "go/crypto/tls/index#CurveID",
        "syntax": "type CurveID uint16",
        "type": "crypto"
    },
    "tls.Dial": {
        "descr": "Dial connects to the given network address using net.Dial and then initiates a TLS handshake, returning the resulting TLS connection. Dial interprets a nil configuration as equivalent to the zero configuration; see the documentation of Config for the defaults.",
        "name": "tls.Dial",
        "params": [],
        "path": "go/crypto/tls/index#Dial",
        "syntax": "func Dial(network, addr string, config *Config) (*Conn, error)",
        "type": "crypto"
    },
    "tls.DialWithDialer": {
        "descr": "DialWithDialer connects to the given network address using dialer.Dial and then initiates a TLS handshake, returning the resulting TLS connection. Any timeout or deadline given in the dialer apply to connection and TLS handshake as a whole.",
        "name": "tls.DialWithDialer",
        "params": [],
        "path": "go/crypto/tls/index#DialWithDialer",
        "syntax": "func DialWithDialer(dialer *net.Dialer, network, addr string, config *Config) (*Conn, error)",
        "type": "crypto"
    },
    "tls.Listen": {
        "descr": "Listen creates a TLS listener accepting connections on the given network address using net.Listen. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate.",
        "name": "tls.Listen",
        "params": [],
        "path": "go/crypto/tls/index#Listen",
        "syntax": "func Listen(network, laddr string, config *Config) (net.Listener, error)",
        "type": "crypto"
    },
    "tls.LoadX509KeyPair": {
        "descr": "LoadX509KeyPair reads and parses a public/private key pair from a pair of files. The files must contain PEM encoded data. The certificate file may contain intermediate certificates following the leaf certificate to form a certificate chain. On successful return, Certificate.Leaf will be nil because the parsed form of the certificate is not retained.",
        "name": "tls.LoadX509KeyPair",
        "params": [],
        "path": "go/crypto/tls/index#LoadX509KeyPair",
        "syntax": "func LoadX509KeyPair(certFile, keyFile string) (Certificate, error)",
        "type": "crypto"
    },
    "tls.NewLRUClientSessionCache": {
        "descr": "NewLRUClientSessionCache returns a ClientSessionCache with the given capacity that uses an LRU strategy. If capacity is < 1, a default capacity is used instead.",
        "name": "tls.NewLRUClientSessionCache",
        "params": [],
        "path": "go/crypto/tls/index#NewLRUClientSessionCache",
        "syntax": "func NewLRUClientSessionCache(capacity int) ClientSessionCache",
        "type": "crypto"
    },
    "tls.NewListener": {
        "descr": "NewListener creates a Listener which accepts connections from an inner Listener and wraps each connection with Server. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate.",
        "name": "tls.NewListener",
        "params": [],
        "path": "go/crypto/tls/index#NewListener",
        "syntax": "func NewListener(inner net.Listener, config *Config) net.Listener",
        "type": "crypto"
    },
    "tls.RecordHeaderError": {
        "descr": "RecordHeaderError results when a TLS record header is invalid.",
        "name": "tls.RecordHeaderError",
        "params": [],
        "path": "go/crypto/tls/index#RecordHeaderError",
        "syntax": "type RecordHeaderError struct { // Msg contains a human readable string that describes the error. Msg string // RecordHeader contains the five bytes of TLS record header that // triggered the error. RecordHeader [5]byte }",
        "type": "crypto"
    },
    "tls.RecordHeaderError.Error": {
        "descr": "",
        "name": "tls.RecordHeaderError.Error",
        "params": [],
        "path": "go/crypto/tls/index#RecordHeaderError.Error",
        "syntax": "func (e RecordHeaderError) Error() string",
        "type": "crypto"
    },
    "tls.RenegotiationSupport": {
        "descr": "RenegotiationSupport enumerates the different levels of support for TLS renegotiation. TLS renegotiation is the act of performing subsequent handshakes on a connection after the first. This significantly complicates the state machine and has been the source of numerous, subtle security issues. Initiating a renegotiation is not supported, but support for accepting renegotiation requests may be enabled.",
        "name": "tls.RenegotiationSupport",
        "params": [],
        "path": "go/crypto/tls/index#RenegotiationSupport",
        "syntax": "type RenegotiationSupport int",
        "type": "crypto"
    },
    "tls.Server": {
        "descr": "Server returns a new TLS server side connection using conn as the underlying transport. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate.",
        "name": "tls.Server",
        "params": [],
        "path": "go/crypto/tls/index#Server",
        "syntax": "func Server(conn net.Conn, config *Config) *Conn",
        "type": "crypto"
    },
    "tls.SignatureScheme": {
        "descr": "SignatureScheme identifies a signature algorithm supported by TLS. See https://tools.ietf.org/html/draft-ietf-tls-tls13-18#section-4.2.3.",
        "name": "tls.SignatureScheme",
        "params": [],
        "path": "go/crypto/tls/index#SignatureScheme",
        "syntax": "type SignatureScheme uint16",
        "type": "crypto"
    },
    "tls.X509KeyPair": {
        "descr": "X509KeyPair parses a public/private key pair from a pair of PEM encoded data. On successful return, Certificate.Leaf will be nil because the parsed form of the certificate is not retained.",
        "name": "tls.X509KeyPair",
        "params": [],
        "path": "go/crypto/tls/index#X509KeyPair",
        "syntax": "func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (Certificate, error)",
        "type": "crypto"
    },
    "token.File": {
        "descr": "A File is a handle for a file belonging to a FileSet. A File has a name, size, and line offset table.",
        "name": "token.File",
        "params": [],
        "path": "go/go/token/index#File",
        "syntax": "type File struct { // contains filtered or unexported fields }",
        "type": "go"
    },
    "token.File.AddLine": {
        "descr": "AddLine adds the line offset for a new line. The line offset must be larger than the offset for the previous line and smaller than the file size; otherwise the line offset is ignored.",
        "name": "token.File.AddLine",
        "params": [],
        "path": "go/go/token/index#File.AddLine",
        "syntax": "func (f *File) AddLine(offset int)",
        "type": "go"
    },
    "token.File.AddLineColumnInfo": {
        "descr": "AddLineColumnInfo adds alternative file, line, and column number information for a given file offset. The offset must be larger than the offset for the previously added alternative line info and smaller than the file size; otherwise the information is ignored.",
        "name": "token.File.AddLineColumnInfo",
        "params": [],
        "path": "go/go/token/index#File.AddLineColumnInfo",
        "syntax": "func (f *File) AddLineColumnInfo(offset int, filename string, line, column int)",
        "type": "go"
    },
    "token.File.AddLineInfo": {
        "descr": "AddLineInfo is like AddLineColumnInfo with a column = 1 argument. It is here for backward-compatibility for code prior to Go 1.11.",
        "name": "token.File.AddLineInfo",
        "params": [],
        "path": "go/go/token/index#File.AddLineInfo",
        "syntax": "func (f *File) AddLineInfo(offset int, filename string, line int)",
        "type": "go"
    },
    "token.File.Base": {
        "descr": "Base returns the base offset of file f as registered with AddFile.",
        "name": "token.File.Base",
        "params": [],
        "path": "go/go/token/index#File.Base",
        "syntax": "func (f *File) Base() int",
        "type": "go"
    },
    "token.File.Line": {
        "descr": "Line returns the line number for the given file position p; p must be a Pos value in that file or NoPos.",
        "name": "token.File.Line",
        "params": [],
        "path": "go/go/token/index#File.Line",
        "syntax": "func (f *File) Line(p Pos) int",
        "type": "go"
    },
    "token.File.LineCount": {
        "descr": "LineCount returns the number of lines in file f.",
        "name": "token.File.LineCount",
        "params": [],
        "path": "go/go/token/index#File.LineCount",
        "syntax": "func (f *File) LineCount() int",
        "type": "go"
    },
    "token.File.MergeLine": {
        "descr": "MergeLine merges a line with the following line. It is akin to replacing the newline character at the end of the line with a space (to not change the remaining offsets). To obtain the line number, consult e.g. Position.Line. MergeLine will panic if given an invalid line number.",
        "name": "token.File.MergeLine",
        "params": [],
        "path": "go/go/token/index#File.MergeLine",
        "syntax": "func (f *File) MergeLine(line int)",
        "type": "go"
    },
    "token.File.Name": {
        "descr": "Name returns the file name of file f as registered with AddFile.",
        "name": "token.File.Name",
        "params": [],
        "path": "go/go/token/index#File.Name",
        "syntax": "func (f *File) Name() string",
        "type": "go"
    },
    "token.File.Offset": {
        "descr": "Offset returns the offset for the given file position p; p must be a valid Pos value in that file. f.Offset(f.Pos(offset)) == offset.",
        "name": "token.File.Offset",
        "params": [],
        "path": "go/go/token/index#File.Offset",
        "syntax": "func (f *File) Offset(p Pos) int",
        "type": "go"
    },
    "token.File.Pos": {
        "descr": "Pos returns the Pos value for the given file offset; the offset must be <= f.Size(). f.Pos(f.Offset(p)) == p.",
        "name": "token.File.Pos",
        "params": [],
        "path": "go/go/token/index#File.Pos",
        "syntax": "func (f *File) Pos(offset int) Pos",
        "type": "go"
    },
    "token.File.Position": {
        "descr": "Position returns the Position value for the given file position p. Calling f.Position(p) is equivalent to calling f.PositionFor(p, true).",
        "name": "token.File.Position",
        "params": [],
        "path": "go/go/token/index#File.Position",
        "syntax": "func (f *File) Position(p Pos) (pos Position)",
        "type": "go"
    },
    "token.File.PositionFor": {
        "descr": "PositionFor returns the Position value for the given file position p. If adjusted is set, the position may be adjusted by position-altering //line comments; otherwise those comments are ignored. p must be a Pos value in f or NoPos.",
        "name": "token.File.PositionFor",
        "params": [],
        "path": "go/go/token/index#File.PositionFor",
        "syntax": "func (f *File) PositionFor(p Pos, adjusted bool) (pos Position)",
        "type": "go"
    },
    "token.File.SetLines": {
        "descr": "SetLines sets the line offsets for a file and reports whether it succeeded. The line offsets are the offsets of the first character of each line; for instance for the content \"ab\\nc\\n\" the line offsets are {0, 3}. An empty file has an empty line offset table. Each line offset must be larger than the offset for the previous line and smaller than the file size; otherwise SetLines fails and returns false. Callers must not mutate the provided slice after SetLines returns.",
        "name": "token.File.SetLines",
        "params": [],
        "path": "go/go/token/index#File.SetLines",
        "syntax": "func (f *File) SetLines(lines []int) bool",
        "type": "go"
    },
    "token.File.SetLinesForContent": {
        "descr": "SetLinesForContent sets the line offsets for the given file content. It ignores position-altering //line comments.",
        "name": "token.File.SetLinesForContent",
        "params": [],
        "path": "go/go/token/index#File.SetLinesForContent",
        "syntax": "func (f *File) SetLinesForContent(content []byte)",
        "type": "go"
    },
    "token.File.Size": {
        "descr": "Size returns the size of file f as registered with AddFile.",
        "name": "token.File.Size",
        "params": [],
        "path": "go/go/token/index#File.Size",
        "syntax": "func (f *File) Size() int",
        "type": "go"
    },
    "token.FileSet": {
        "descr": "A FileSet represents a set of source files. Methods of file sets are synchronized; multiple goroutines may invoke them concurrently.",
        "name": "token.FileSet",
        "params": [],
        "path": "go/go/token/index#FileSet",
        "syntax": "type FileSet struct { // contains filtered or unexported fields }",
        "type": "go"
    },
    "token.FileSet.AddFile": {
        "descr": "AddFile adds a new file with a given filename, base offset, and file size to the file set s and returns the file. Multiple files may have the same name. The base offset must not be smaller than the FileSet's Base(), and size must not be negative. As a special case, if a negative base is provided, the current value of the FileSet's Base() is used instead.",
        "name": "token.FileSet.AddFile",
        "params": [],
        "path": "go/go/token/index#FileSet.AddFile",
        "syntax": "func (s *FileSet) AddFile(filename string, base, size int) *File",
        "type": "go"
    },
    "token.FileSet.Base": {
        "descr": "Base returns the minimum base offset that must be provided to AddFile when adding the next file.",
        "name": "token.FileSet.Base",
        "params": [],
        "path": "go/go/token/index#FileSet.Base",
        "syntax": "func (s *FileSet) Base() int",
        "type": "go"
    },
    "token.FileSet.File": {
        "descr": "File returns the file that contains the position p. If no such file is found (for instance for p == NoPos), the result is nil.",
        "name": "token.FileSet.File",
        "params": [],
        "path": "go/go/token/index#FileSet.File",
        "syntax": "func (s *FileSet) File(p Pos) (f *File)",
        "type": "go"
    },
    "token.FileSet.Iterate": {
        "descr": "Iterate calls f for the files in the file set in the order they were added until f returns false.",
        "name": "token.FileSet.Iterate",
        "params": [],
        "path": "go/go/token/index#FileSet.Iterate",
        "syntax": "func (s *FileSet) Iterate(f func(*File) bool)",
        "type": "go"
    },
    "token.FileSet.Position": {
        "descr": "Position converts a Pos p in the fileset into a Position value. Calling s.Position(p) is equivalent to calling s.PositionFor(p, true).",
        "name": "token.FileSet.Position",
        "params": [],
        "path": "go/go/token/index#FileSet.Position",
        "syntax": "func (s *FileSet) Position(p Pos) (pos Position)",
        "type": "go"
    },
    "token.FileSet.PositionFor": {
        "descr": "PositionFor converts a Pos p in the fileset into a Position value. If adjusted is set, the position may be adjusted by position-altering //line comments; otherwise those comments are ignored. p must be a Pos value in s or NoPos.",
        "name": "token.FileSet.PositionFor",
        "params": [],
        "path": "go/go/token/index#FileSet.PositionFor",
        "syntax": "func (s *FileSet) PositionFor(p Pos, adjusted bool) (pos Position)",
        "type": "go"
    },
    "token.FileSet.Read": {
        "descr": "Read calls decode to deserialize a file set into s; s must not be nil.",
        "name": "token.FileSet.Read",
        "params": [],
        "path": "go/go/token/index#FileSet.Read",
        "syntax": "func (s *FileSet) Read(decode func(interface{}) error) error",
        "type": "go"
    },
    "token.FileSet.Write": {
        "descr": "Write calls encode to serialize the file set s.",
        "name": "token.FileSet.Write",
        "params": [],
        "path": "go/go/token/index#FileSet.Write",
        "syntax": "func (s *FileSet) Write(encode func(interface{}) error) error",
        "type": "go"
    },
    "token.Lookup": {
        "descr": "Lookup maps an identifier to its keyword token or IDENT (if not a keyword).",
        "name": "token.Lookup",
        "params": [],
        "path": "go/go/token/index#Lookup",
        "syntax": "func Lookup(ident string) Token",
        "type": "go"
    },
    "token.NewFileSet": {
        "descr": "NewFileSet creates a new file set.",
        "name": "token.NewFileSet",
        "params": [],
        "path": "go/go/token/index#NewFileSet",
        "syntax": "func NewFileSet() *FileSet",
        "type": "go"
    },
    "token.Pos": {
        "descr": "Pos is a compact encoding of a source position within a file set. It can be converted into a Position for a more convenient, but much larger, representation.",
        "name": "token.Pos",
        "params": [],
        "path": "go/go/token/index#Pos",
        "syntax": "type Pos int",
        "type": "go"
    },
    "token.Pos.IsValid": {
        "descr": "IsValid reports whether the position is valid.",
        "name": "token.Pos.IsValid",
        "params": [],
        "path": "go/go/token/index#Pos.IsValid",
        "syntax": "func (p Pos) IsValid() bool",
        "type": "go"
    },
    "token.Position": {
        "descr": "Position describes an arbitrary source position including the file, line, and column location. A Position is valid if the line number is > 0.",
        "name": "token.Position",
        "params": [],
        "path": "go/go/token/index#Position",
        "syntax": "type Position struct { Filename string // filename, if any Offset int // offset, starting at 0 Line int // line number, starting at 1 Column int // column number, starting at 1 (byte count) }",
        "type": "go"
    },
    "token.Position.IsValid": {
        "descr": "IsValid reports whether the position is valid.",
        "name": "token.Position.IsValid",
        "params": [],
        "path": "go/go/token/index#Position.IsValid",
        "syntax": "func (pos *Position) IsValid() bool",
        "type": "go"
    },
    "token.Position.String": {
        "descr": "String returns a string in one of several forms:",
        "name": "token.Position.String",
        "params": [],
        "path": "go/go/token/index#Position.String",
        "syntax": "func (pos Position) String() string",
        "type": "go"
    },
    "token.Token": {
        "descr": "Token is the set of lexical tokens of the Go programming language.",
        "name": "token.Token",
        "params": [],
        "path": "go/go/token/index#Token",
        "syntax": "type Token int",
        "type": "go"
    },
    "token.Token.IsKeyword": {
        "descr": "IsKeyword returns true for tokens corresponding to keywords; it returns false otherwise.",
        "name": "token.Token.IsKeyword",
        "params": [],
        "path": "go/go/token/index#Token.IsKeyword",
        "syntax": "func (tok Token) IsKeyword() bool",
        "type": "go"
    },
    "token.Token.IsLiteral": {
        "descr": "IsLiteral returns true for tokens corresponding to identifiers and basic type literals; it returns false otherwise.",
        "name": "token.Token.IsLiteral",
        "params": [],
        "path": "go/go/token/index#Token.IsLiteral",
        "syntax": "func (tok Token) IsLiteral() bool",
        "type": "go"
    },
    "token.Token.IsOperator": {
        "descr": "IsOperator returns true for tokens corresponding to operators and delimiters; it returns false otherwise.",
        "name": "token.Token.IsOperator",
        "params": [],
        "path": "go/go/token/index#Token.IsOperator",
        "syntax": "func (tok Token) IsOperator() bool",
        "type": "go"
    },
    "token.Token.Precedence": {
        "descr": "Precedence returns the operator precedence of the binary operator op. If op is not a binary operator, the result is LowestPrecedence.",
        "name": "token.Token.Precedence",
        "params": [],
        "path": "go/go/token/index#Token.Precedence",
        "syntax": "func (op Token) Precedence() int",
        "type": "go"
    },
    "token.Token.String": {
        "descr": "String returns the string corresponding to the token tok. For operators, delimiters, and keywords the string is the actual token character sequence (e.g., for the token ADD, the string is \"+\"). For all other tokens the string corresponds to the token constant name (e.g. for the token IDENT, the string is \"IDENT\").",
        "name": "token.Token.String",
        "params": [],
        "path": "go/go/token/index#Token.String",
        "syntax": "func (tok Token) String() string",
        "type": "go"
    },
    "trace.IsEnabled": {
        "descr": "IsEnabled returns whether tracing is enabled. The information is advisory only. The tracing status may have changed by the time this function returns.",
        "name": "trace.IsEnabled",
        "params": [],
        "path": "go/runtime/trace/index#IsEnabled",
        "syntax": "func IsEnabled() bool",
        "type": "runtime"
    },
    "trace.Log": {
        "descr": "Log emits a one-off event with the given category and message. Category can be empty and the API assumes there are only a handful of unique categories in the system.",
        "name": "trace.Log",
        "params": [],
        "path": "go/runtime/trace/index#Log",
        "syntax": "func Log(ctx context.Context, category, message string)",
        "type": "runtime"
    },
    "trace.Logf": {
        "descr": "Logf is like Log, but the value is formatted using the specified format spec.",
        "name": "trace.Logf",
        "params": [],
        "path": "go/runtime/trace/index#Logf",
        "syntax": "func Logf(ctx context.Context, category, format string, args ...interface{})",
        "type": "runtime"
    },
    "trace.NewTask": {
        "descr": "NewTask creates a task instance with the type taskType and returns it along with a Context that carries the task. If the input context contains a task, the new task is its subtask.",
        "name": "trace.NewTask",
        "params": [],
        "path": "go/runtime/trace/index#NewTask",
        "syntax": "func NewTask(pctx context.Context, taskType string) (ctx context.Context, task *Task)",
        "type": "runtime"
    },
    "trace.Region": {
        "descr": "Region is a region of code whose execution time interval is traced.",
        "name": "trace.Region",
        "params": [],
        "path": "go/runtime/trace/index#Region",
        "syntax": "type Region struct { // contains filtered or unexported fields }",
        "type": "runtime"
    },
    "trace.Region.End": {
        "descr": "End marks the end of the traced code region.",
        "name": "trace.Region.End",
        "params": [],
        "path": "go/runtime/trace/index#Region.End",
        "syntax": "func (r *Region) End()",
        "type": "runtime"
    },
    "trace.Start": {
        "descr": "Start enables tracing for the current program. While tracing, the trace will be buffered and written to w. Start returns an error if tracing is already enabled.",
        "name": "trace.Start",
        "params": [],
        "path": "go/runtime/trace/index#Start",
        "syntax": "func Start(w io.Writer) error",
        "type": "runtime"
    },
    "trace.StartRegion": {
        "descr": "StartRegion starts a region and returns a function for marking the end of the region. The returned Region's End function must be called from the same goroutine where the region was started. Within each goroutine, regions must nest. That is, regions started after this region must be ended before this region can be ended. Recommended usage is",
        "name": "trace.StartRegion",
        "params": [],
        "path": "go/runtime/trace/index#StartRegion",
        "syntax": "func StartRegion(ctx context.Context, regionType string) *Region",
        "type": "runtime"
    },
    "trace.Stop": {
        "descr": "Stop stops the current tracing, if any. Stop only returns after all the writes for the trace have completed.",
        "name": "trace.Stop",
        "params": [],
        "path": "go/runtime/trace/index#Stop",
        "syntax": "func Stop()",
        "type": "runtime"
    },
    "trace.Task": {
        "descr": "Task is a data type for tracing a user-defined, logical operation.",
        "name": "trace.Task",
        "params": [],
        "path": "go/runtime/trace/index#Task",
        "syntax": "type Task struct { // contains filtered or unexported fields }",
        "type": "runtime"
    },
    "trace.Task.End": {
        "descr": "End marks the end of the operation represented by the Task.",
        "name": "trace.Task.End",
        "params": [],
        "path": "go/runtime/trace/index#Task.End",
        "syntax": "func (t *Task) End()",
        "type": "runtime"
    },
    "trace.WithRegion": {
        "descr": "WithRegion starts a region associated with its calling goroutine, runs fn, and then ends the region. If the context carries a task, the region is associated with the task. Otherwise, the region is attached to the background task.",
        "name": "trace.WithRegion",
        "params": [],
        "path": "go/runtime/trace/index#WithRegion",
        "syntax": "func WithRegion(ctx context.Context, regionType string, fn func())",
        "type": "runtime"
    },
    "types.Array": {
        "descr": "An Array represents an array type.",
        "name": "types.Array",
        "params": [],
        "path": "go/go/types/index#Array",
        "syntax": "type Array struct { // contains filtered or unexported fields }",
        "type": "go"
    },
    "types.Array.Elem": {
        "descr": "Elem returns element type of array a.",
        "name": "types.Array.Elem",
        "params": [],
        "path": "go/go/types/index#Array.Elem",
        "syntax": "func (a *Array) Elem() Type",
        "type": "go"
    },
    "types.Array.Len": {
        "descr": "Len returns the length of array a. A negative result indicates an unknown length.",
        "name": "types.Array.Len",
        "params": [],
        "path": "go/go/types/index#Array.Len",
        "syntax": "func (a *Array) Len() int64",
        "type": "go"
    },
    "types.Array.String": {
        "descr": "",
        "name": "types.Array.String",
        "params": [],
        "path": "go/go/types/index#Array.String",
        "syntax": "func (a *Array) String() string",
        "type": "go"
    },
    "types.Array.Underlying": {
        "descr": "",
        "name": "types.Array.Underlying",
        "params": [],
        "path": "go/go/types/index#Array.Underlying",
        "syntax": "func (a *Array) Underlying() Type",
        "type": "go"
    },
    "types.AssertableTo": {
        "descr": "AssertableTo reports whether a value of type V can be asserted to have type T.",
        "name": "types.AssertableTo",
        "params": [],
        "path": "go/go/types/index#AssertableTo",
        "syntax": "func AssertableTo(V *Interface, T Type) bool",
        "type": "go"
    },
    "types.AssignableTo": {
        "descr": "AssignableTo reports whether a value of type V is assignable to a variable of type T.",
        "name": "types.AssignableTo",
        "params": [],
        "path": "go/go/types/index#AssignableTo",
        "syntax": "func AssignableTo(V, T Type) bool",
        "type": "go"
    },
    "types.Basic": {
        "descr": "A Basic represents a basic type.",
        "name": "types.Basic",
        "params": [],
        "path": "go/go/types/index#Basic",
        "syntax": "type Basic struct { // contains filtered or unexported fields }",
        "type": "go"
    },
    "types.Basic.Info": {
        "descr": "Info returns information about properties of basic type b.",
        "name": "types.Basic.Info",
        "params": [],
        "path": "go/go/types/index#Basic.Info",
        "syntax": "func (b *Basic) Info() BasicInfo",
        "type": "go"
    },
    "types.Basic.Kind": {
        "descr": "Kind returns the kind of basic type b.",
        "name": "types.Basic.Kind",
        "params": [],
        "path": "go/go/types/index#Basic.Kind",
        "syntax": "func (b *Basic) Kind() BasicKind",
        "type": "go"
    },
    "types.Basic.Name": {
        "descr": "Name returns the name of basic type b.",
        "name": "types.Basic.Name",
        "params": [],
        "path": "go/go/types/index#Basic.Name",
        "syntax": "func (b *Basic) Name() string",
        "type": "go"
    },
    "types.Basic.String": {
        "descr": "",
        "name": "types.Basic.String",
        "params": [],
        "path": "go/go/types/index#Basic.String",
        "syntax": "func (b *Basic) String() string",
        "type": "go"
    },
    "types.Basic.Underlying": {
        "descr": "",
        "name": "types.Basic.Underlying",
        "params": [],
        "path": "go/go/types/index#Basic.Underlying",
        "syntax": "func (b *Basic) Underlying() Type",
        "type": "go"
    },
    "types.BasicInfo": {
        "descr": "BasicInfo is a set of flags describing properties of a basic type.",
        "name": "types.BasicInfo",
        "params": [],
        "path": "go/go/types/index#BasicInfo",
        "syntax": "type BasicInfo int",
        "type": "go"
    },
    "types.BasicKind": {
        "descr": "BasicKind describes the kind of basic type.",
        "name": "types.BasicKind",
        "params": [],
        "path": "go/go/types/index#BasicKind",
        "syntax": "type BasicKind int",
        "type": "go"
    },
    "types.Builtin": {
        "descr": "A Builtin represents a built-in function. Builtins don't have a valid type.",
        "name": "types.Builtin",
        "params": [],
        "path": "go/go/types/index#Builtin",
        "syntax": "type Builtin struct { // contains filtered or unexported fields }",
        "type": "go"
    },
    "types.Builtin.Exported": {
        "descr": "Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not.",
        "name": "types.Builtin.Exported",
        "params": [],
        "path": "go/go/types/index#Builtin.Exported",
        "syntax": "func (obj *Builtin) Exported() bool",
        "type": "go"
    },
    "types.Builtin.Id": {
        "descr": "Id is a wrapper for Id(obj.Pkg(), obj.Name()).",
        "name": "types.Builtin.Id",
        "params": [],
        "path": "go/go/types/index#Builtin.Id",
        "syntax": "func (obj *Builtin) Id() string",
        "type": "go"
    },
    "types.Builtin.Name": {
        "descr": "Name returns the object's (package-local, unqualified) name.",
        "name": "types.Builtin.Name",
        "params": [],
        "path": "go/go/types/index#Builtin.Name",
        "syntax": "func (obj *Builtin) Name() string",
        "type": "go"
    },
    "types.Builtin.Parent": {
        "descr": "Parent returns the scope in which the object is declared. The result is nil for methods and struct fields.",
        "name": "types.Builtin.Parent",
        "params": [],
        "path": "go/go/types/index#Builtin.Parent",
        "syntax": "func (obj *Builtin) Parent() *Scope",
        "type": "go"
    },
    "types.Builtin.Pkg": {
        "descr": "Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope.",
        "name": "types.Builtin.Pkg",
        "params": [],
        "path": "go/go/types/index#Builtin.Pkg",
        "syntax": "func (obj *Builtin) Pkg() *Package",
        "type": "go"
    },
    "types.Builtin.Pos": {
        "descr": "Pos returns the declaration position of the object's identifier.",
        "name": "types.Builtin.Pos",
        "params": [],
        "path": "go/go/types/index#Builtin.Pos",
        "syntax": "func (obj *Builtin) Pos() token.Pos",
        "type": "go"
    },
    "types.Builtin.String": {
        "descr": "",
        "name": "types.Builtin.String",
        "params": [],
        "path": "go/go/types/index#Builtin.String",
        "syntax": "func (obj *Builtin) String() string",
        "type": "go"
    },
    "types.Builtin.Type": {
        "descr": "Type returns the object's type.",
        "name": "types.Builtin.Type",
        "params": [],
        "path": "go/go/types/index#Builtin.Type",
        "syntax": "func (obj *Builtin) Type() Type",
        "type": "go"
    },
    "types.Chan": {
        "descr": "A Chan represents a channel type.",
        "name": "types.Chan",
        "params": [],
        "path": "go/go/types/index#Chan",
        "syntax": "type Chan struct { // contains filtered or unexported fields }",
        "type": "go"
    },
    "types.Chan.Dir": {
        "descr": "Dir returns the direction of channel c.",
        "name": "types.Chan.Dir",
        "params": [],
        "path": "go/go/types/index#Chan.Dir",
        "syntax": "func (c *Chan) Dir() ChanDir",
        "type": "go"
    },
    "types.Chan.Elem": {
        "descr": "Elem returns the element type of channel c.",
        "name": "types.Chan.Elem",
        "params": [],
        "path": "go/go/types/index#Chan.Elem",
        "syntax": "func (c *Chan) Elem() Type",
        "type": "go"
    },
    "types.Chan.String": {
        "descr": "",
        "name": "types.Chan.String",
        "params": [],
        "path": "go/go/types/index#Chan.String",
        "syntax": "func (c *Chan) String() string",
        "type": "go"
    },
    "types.Chan.Underlying": {
        "descr": "",
        "name": "types.Chan.Underlying",
        "params": [],
        "path": "go/go/types/index#Chan.Underlying",
        "syntax": "func (c *Chan) Underlying() Type",
        "type": "go"
    },
    "types.ChanDir": {
        "descr": "A ChanDir value indicates a channel direction.",
        "name": "types.ChanDir",
        "params": [],
        "path": "go/go/types/index#ChanDir",
        "syntax": "type ChanDir int",
        "type": "go"
    },
    "types.Checker": {
        "descr": "A Checker maintains the state of the type checker. It must be created with NewChecker.",
        "name": "types.Checker",
        "params": [],
        "path": "go/go/types/index#Checker",
        "syntax": "type Checker struct { *Info // contains filtered or unexported fields }",
        "type": "go"
    },
    "types.Checker.Files": {
        "descr": "Files checks the provided files as part of the checker's package.",
        "name": "types.Checker.Files",
        "params": [],
        "path": "go/go/types/index#Checker.Files",
        "syntax": "func (check *Checker) Files(files []*ast.File) error",
        "type": "go"
    },
    "types.Comparable": {
        "descr": "Comparable reports whether values of type T are comparable.",
        "name": "types.Comparable",
        "params": [],
        "path": "go/go/types/index#Comparable",
        "syntax": "func Comparable(T Type) bool",
        "type": "go"
    },
    "types.Config": {
        "descr": "A Config specifies the configuration for type checking. The zero value for Config is a ready-to-use default configuration.",
        "name": "types.Config",
        "params": [],
        "path": "go/go/types/index#Config",
        "syntax": "type Config struct { // If IgnoreFuncBodies is set, function bodies are not // type-checked. IgnoreFuncBodies bool // If FakeImportC is set, `import \"C\"` (for packages requiring Cgo) // declares an empty \"C\" package and errors are omitted for qualified // identifiers referring to package C (which won't find an object). // This feature is intended for the standard library cmd/api tool. // // Caution: Effects may be unpredictable due to follow-on errors. // Do not use casually! FakeImportC bool // If Error != nil, it is called with each error found // during type checking; err has dynamic type Error. // Secondary errors (for instance, to enumerate all types // involved in an invalid recursive type declaration) have // error strings that start with a '\\t' character. // If Error == nil, type-checking stops with the first // error found. Error func(err error) // An importer is used to import packages referred to from // import declarations. // If the installed importer implements ImporterFrom, the type // checker calls ImportFrom instead of Import. // The type checker reports an error if an importer is needed // but none was installed. Importer Importer // If Sizes != nil, it provides the sizing functions for package unsafe. // Otherwise SizesFor(\"gc\", \"amd64\") is used instead. Sizes Sizes // If DisableUnusedImportCheck is set, packages are not checked // for unused imports. DisableUnusedImportCheck bool }",
        "type": "go"
    },
    "types.Config.Check": {
        "descr": "Check type-checks a package and returns the resulting package object and the first error if any. Additionally, if info != nil, Check populates each of the non-nil maps in the Info struct.",
        "name": "types.Config.Check",
        "params": [],
        "path": "go/go/types/index#Config.Check",
        "syntax": "func (conf *Config) Check(path string, fset *token.FileSet, files []*ast.File, info *Info) (*Package, error)",
        "type": "go"
    },
    "types.Const": {
        "descr": "A Const represents a declared constant.",
        "name": "types.Const",
        "params": [],
        "path": "go/go/types/index#Const",
        "syntax": "type Const struct { // contains filtered or unexported fields }",
        "type": "go"
    },
    "types.Const.Exported": {
        "descr": "Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not.",
        "name": "types.Const.Exported",
        "params": [],
        "path": "go/go/types/index#Const.Exported",
        "syntax": "func (obj *Const) Exported() bool",
        "type": "go"
    },
    "types.Const.Id": {
        "descr": "Id is a wrapper for Id(obj.Pkg(), obj.Name()).",
        "name": "types.Const.Id",
        "params": [],
        "path": "go/go/types/index#Const.Id",
        "syntax": "func (obj *Const) Id() string",
        "type": "go"
    },
    "types.Const.Name": {
        "descr": "Name returns the object's (package-local, unqualified) name.",
        "name": "types.Const.Name",
        "params": [],
        "path": "go/go/types/index#Const.Name",
        "syntax": "func (obj *Const) Name() string",
        "type": "go"
    },
    "types.Const.Parent": {
        "descr": "Parent returns the scope in which the object is declared. The result is nil for methods and struct fields.",
        "name": "types.Const.Parent",
        "params": [],
        "path": "go/go/types/index#Const.Parent",
        "syntax": "func (obj *Const) Parent() *Scope",
        "type": "go"
    },
    "types.Const.Pkg": {
        "descr": "Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope.",
        "name": "types.Const.Pkg",
        "params": [],
        "path": "go/go/types/index#Const.Pkg",
        "syntax": "func (obj *Const) Pkg() *Package",
        "type": "go"
    },
    "types.Const.Pos": {
        "descr": "Pos returns the declaration position of the object's identifier.",
        "name": "types.Const.Pos",
        "params": [],
        "path": "go/go/types/index#Const.Pos",
        "syntax": "func (obj *Const) Pos() token.Pos",
        "type": "go"
    },
    "types.Const.String": {
        "descr": "",
        "name": "types.Const.String",
        "params": [],
        "path": "go/go/types/index#Const.String",
        "syntax": "func (obj *Const) String() string",
        "type": "go"
    },
    "types.Const.Type": {
        "descr": "Type returns the object's type.",
        "name": "types.Const.Type",
        "params": [],
        "path": "go/go/types/index#Const.Type",
        "syntax": "func (obj *Const) Type() Type",
        "type": "go"
    },
    "types.Const.Val": {
        "descr": "Val returns the constant's value.",
        "name": "types.Const.Val",
        "params": [],
        "path": "go/go/types/index#Const.Val",
        "syntax": "func (obj *Const) Val() constant.Value",
        "type": "go"
    },
    "types.ConvertibleTo": {
        "descr": "ConvertibleTo reports whether a value of type V is convertible to a value of type T.",
        "name": "types.ConvertibleTo",
        "params": [],
        "path": "go/go/types/index#ConvertibleTo",
        "syntax": "func ConvertibleTo(V, T Type) bool",
        "type": "go"
    },
    "types.DefPredeclaredTestFuncs": {
        "descr": "DefPredeclaredTestFuncs defines the assert and trace built-ins. These built-ins are intended for debugging and testing of this package only.",
        "name": "types.DefPredeclaredTestFuncs",
        "params": [],
        "path": "go/go/types/index#DefPredeclaredTestFuncs",
        "syntax": "func DefPredeclaredTestFuncs()",
        "type": "go"
    },
    "types.Default": {
        "descr": "Default returns the default \"typed\" type for an \"untyped\" type; it returns the incoming type for all other types. The default type for untyped nil is untyped nil.",
        "name": "types.Default",
        "params": [],
        "path": "go/go/types/index#Default",
        "syntax": "func Default(typ Type) Type",
        "type": "go"
    },
    "types.Error": {
        "descr": "An Error describes a type-checking error; it implements the error interface. A \"soft\" error is an error that still permits a valid interpretation of a package (such as \"unused variable\"); \"hard\" errors may lead to unpredictable behavior if ignored.",
        "name": "types.Error",
        "params": [],
        "path": "go/go/types/index#Error",
        "syntax": "type Error struct { Fset *token.FileSet // file set for interpretation of Pos Pos token.Pos // error position Msg string // error message Soft bool // if set, error is \"soft\" }",
        "type": "go"
    },
    "types.Error.Error": {
        "descr": "Error returns an error string formatted as follows: filename:line:column: message",
        "name": "types.Error.Error",
        "params": [],
        "path": "go/go/types/index#Error.Error",
        "syntax": "func (err Error) Error() string",
        "type": "go"
    },
    "types.Eval": {
        "descr": "Eval returns the type and, if constant, the value for the expression expr, evaluated at position pos of package pkg, which must have been derived from type-checking an AST with complete position information relative to the provided file set.",
        "name": "types.Eval",
        "params": [],
        "path": "go/go/types/index#Eval",
        "syntax": "func Eval(fset *token.FileSet, pkg *Package, pos token.Pos, expr string) (_ TypeAndValue, err error)",
        "type": "go"
    },
    "types.ExprString": {
        "descr": "ExprString returns the (possibly shortened) string representation for x. Shortened representations are suitable for user interfaces but may not necessarily follow Go syntax.",
        "name": "types.ExprString",
        "params": [],
        "path": "go/go/types/index#ExprString",
        "syntax": "func ExprString(x ast.Expr) string",
        "type": "go"
    },
    "types.Func": {
        "descr": "A Func represents a declared function, concrete method, or abstract (interface) method. Its Type() is always a *Signature. An abstract method may belong to many interfaces due to embedding.",
        "name": "types.Func",
        "params": [],
        "path": "go/go/types/index#Func",
        "syntax": "type Func struct { // contains filtered or unexported fields }",
        "type": "go"
    },
    "types.Func.Exported": {
        "descr": "Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not.",
        "name": "types.Func.Exported",
        "params": [],
        "path": "go/go/types/index#Func.Exported",
        "syntax": "func (obj *Func) Exported() bool",
        "type": "go"
    },
    "types.Func.FullName": {
        "descr": "FullName returns the package- or receiver-type-qualified name of function or method obj.",
        "name": "types.Func.FullName",
        "params": [],
        "path": "go/go/types/index#Func.FullName",
        "syntax": "func (obj *Func) FullName() string",
        "type": "go"
    },
    "types.Func.Id": {
        "descr": "Id is a wrapper for Id(obj.Pkg(), obj.Name()).",
        "name": "types.Func.Id",
        "params": [],
        "path": "go/go/types/index#Func.Id",
        "syntax": "func (obj *Func) Id() string",
        "type": "go"
    },
    "types.Func.Name": {
        "descr": "Name returns the object's (package-local, unqualified) name.",
        "name": "types.Func.Name",
        "params": [],
        "path": "go/go/types/index#Func.Name",
        "syntax": "func (obj *Func) Name() string",
        "type": "go"
    },
    "types.Func.Parent": {
        "descr": "Parent returns the scope in which the object is declared. The result is nil for methods and struct fields.",
        "name": "types.Func.Parent",
        "params": [],
        "path": "go/go/types/index#Func.Parent",
        "syntax": "func (obj *Func) Parent() *Scope",
        "type": "go"
    },
    "types.Func.Pkg": {
        "descr": "Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope.",
        "name": "types.Func.Pkg",
        "params": [],
        "path": "go/go/types/index#Func.Pkg",
        "syntax": "func (obj *Func) Pkg() *Package",
        "type": "go"
    },
    "types.Func.Pos": {
        "descr": "Pos returns the declaration position of the object's identifier.",
        "name": "types.Func.Pos",
        "params": [],
        "path": "go/go/types/index#Func.Pos",
        "syntax": "func (obj *Func) Pos() token.Pos",
        "type": "go"
    },
    "types.Func.Scope": {
        "descr": "Scope returns the scope of the function's body block.",
        "name": "types.Func.Scope",
        "params": [],
        "path": "go/go/types/index#Func.Scope",
        "syntax": "func (obj *Func) Scope() *Scope",
        "type": "go"
    },
    "types.Func.String": {
        "descr": "",
        "name": "types.Func.String",
        "params": [],
        "path": "go/go/types/index#Func.String",
        "syntax": "func (obj *Func) String() string",
        "type": "go"
    },
    "types.Func.Type": {
        "descr": "Type returns the object's type.",
        "name": "types.Func.Type",
        "params": [],
        "path": "go/go/types/index#Func.Type",
        "syntax": "func (obj *Func) Type() Type",
        "type": "go"
    },
    "types.Id": {
        "descr": "Id returns name if it is exported, otherwise it returns the name qualified with the package path.",
        "name": "types.Id",
        "params": [],
        "path": "go/go/types/index#Id",
        "syntax": "func Id(pkg *Package, name string) string",
        "type": "go"
    },
    "types.Identical": {
        "descr": "Identical reports whether x and y are identical types. Receivers of Signature types are ignored.",
        "name": "types.Identical",
        "params": [],
        "path": "go/go/types/index#Identical",
        "syntax": "func Identical(x, y Type) bool",
        "type": "go"
    },
    "types.IdenticalIgnoreTags": {
        "descr": "IdenticalIgnoreTags reports whether x and y are identical types if tags are ignored. Receivers of Signature types are ignored.",
        "name": "types.IdenticalIgnoreTags",
        "params": [],
        "path": "go/go/types/index#IdenticalIgnoreTags",
        "syntax": "func IdenticalIgnoreTags(x, y Type) bool",
        "type": "go"
    },
    "types.Implements": {
        "descr": "Implements reports whether type V implements interface T.",
        "name": "types.Implements",
        "params": [],
        "path": "go/go/types/index#Implements",
        "syntax": "func Implements(V Type, T *Interface) bool",
        "type": "go"
    },
    "types.ImportMode": {
        "descr": "ImportMode is reserved for future use.",
        "name": "types.ImportMode",
        "params": [],
        "path": "go/go/types/index#ImportMode",
        "syntax": "type ImportMode int",
        "type": "go"
    },
    "types.Importer": {
        "descr": "An Importer resolves import paths to Packages.",
        "name": "types.Importer",
        "params": [],
        "path": "go/go/types/index#Importer",
        "syntax": "type Importer interface { // Import returns the imported package for the given import path. // The semantics is like for ImporterFrom.ImportFrom except that // dir and mode are ignored (since they are not present). Import(path string) (*Package, error) }",
        "type": "go"
    },
    "types.ImporterFrom": {
        "descr": "An ImporterFrom resolves import paths to packages; it supports vendoring per https://golang.org/s/go15vendor. Use go/importer to obtain an ImporterFrom implementation.",
        "name": "types.ImporterFrom",
        "params": [],
        "path": "go/go/types/index#ImporterFrom",
        "syntax": "type ImporterFrom interface { // Importer is present for backward-compatibility. Calling // Import(path) is the same as calling ImportFrom(path, \"\", 0);\n or  // i.e., locally vendored packages may not be found. // The types package does not call Import if an ImporterFrom // is present. Importer // ImportFrom returns the imported package for the given import // path when imported by a package file located in dir. // If the import failed, besides returning an error, ImportFrom // is encouraged to cache and return a package anyway, if one // was created. This will reduce package inconsistencies and // follow-on type checker errors due to the missing package. // The mode value must be 0; it is reserved for future use. // Two calls to ImportFrom with the same path and dir must // return the same package. ImportFrom(path, dir string, mode ImportMode) (*Package, error) });",
        "type": "go"
    },
    "types.Info": {
        "descr": "Info holds result type information for a type-checked package. Only the information for which a map is provided is collected. If the package has type errors, the collected information may be incomplete.",
        "name": "types.Info",
        "params": [],
        "path": "go/go/types/index#Info",
        "syntax": "type Info struct { // Types maps expressions to their types, and for constant // expressions, also their values. Invalid expressions are // omitted. // // For (possibly parenthesized) identifiers denoting built-in // functions, the recorded signatures are call-site specific: // if the call result is not a constant, the recorded type is // an argument-specific signature. Otherwise, the recorded type // is invalid. // // The Types map does not record the type of every identifier, // only those that appear where an arbitrary expression is // permitted. For instance, the identifier f in a selector // expression x.f is found only in the Selections map, the // identifier z in a variable declaration 'var z int' is found // only in the Defs map, and identifiers denoting packages in // qualified identifiers are collected in the Uses map. Types map[ast.Expr]TypeAndValue // Defs maps identifiers to the objects they define (including // package names, dots \".\" of dot-imports, and blank \"_\" identifiers). // For identifiers that do not denote objects (e.g., the package name // in package clauses, or symbolic variables t in t := x.(type) of // type switch headers), the corresponding objects are nil. // // For an embedded field, Defs returns the field *Var it defines. // // Invariant: Defs[id] == nil || Defs[id].Pos() == id.Pos() Defs map[*ast.Ident]Object // Uses maps identifiers to the objects they denote. // // For an embedded field, Uses returns the *TypeName it denotes. // // Invariant: Uses[id].Pos() != id.Pos() Uses map[*ast.Ident]Object // Implicits maps nodes to their implicitly declared objects, if any. // The following node and object types may appear: // // node declared object // // *ast.ImportSpec *PkgName for imports without renames // *ast.CaseClause type-specific *Var for each type switch case clause (incl. default) // *ast.Field anonymous parameter *Var // Implicits map[ast.Node]Object // Selections maps selector expressions (excluding qualified identifiers) // to their corresponding selections. Selections map[*ast.SelectorExpr]*Selection // Scopes maps ast.Nodes to the scopes they define. Package scopes are not // associated with a specific node but with all files belonging to a package. // Thus, the package scope can be found in the type-checked Package object. // Scopes nest, with the Universe scope being the outermost scope, enclosing // the package scope, which contains (one or more) files scopes, which enclose // function scopes which in turn enclose statement and function literal scopes. // Note that even though package-level functions are declared in the package // scope, the function scopes are embedded in the file scope of the file // containing the function declaration. // // The following node types may appear in Scopes: // // *ast.File // *ast.FuncType // *ast.BlockStmt // *ast.IfStmt // *ast.SwitchStmt // *ast.TypeSwitchStmt // *ast.CaseClause // *ast.CommClause // *ast.ForStmt // *ast.RangeStmt // Scopes map[ast.Node]*Scope // InitOrder is the list of package-level initializers in the order in which // they must be executed. Initializers referring to variables related by an // initialization dependency appear in topological order, the others appear // in source order. Variables without an initialization expression do not // appear in this list. InitOrder []*Initializer }",
        "type": "go"
    },
    "types.Info.ObjectOf": {
        "descr": "ObjectOf returns the object denoted by the specified id, or nil if not found.",
        "name": "types.Info.ObjectOf",
        "params": [],
        "path": "go/go/types/index#Info.ObjectOf",
        "syntax": "func (info *Info) ObjectOf(id *ast.Ident) Object",
        "type": "go"
    },
    "types.Info.TypeOf": {
        "descr": "TypeOf returns the type of expression e, or nil if not found. Precondition: the Types, Uses and Defs maps are populated.",
        "name": "types.Info.TypeOf",
        "params": [],
        "path": "go/go/types/index#Info.TypeOf",
        "syntax": "func (info *Info) TypeOf(e ast.Expr) Type",
        "type": "go"
    },
    "types.Initializer": {
        "descr": "An Initializer describes a package-level variable, or a list of variables in case of a multi-valued initialization expression, and the corresponding initialization expression.",
        "name": "types.Initializer",
        "params": [],
        "path": "go/go/types/index#Initializer",
        "syntax": "type Initializer struct { Lhs []*Var // var Lhs = Rhs Rhs ast.Expr }",
        "type": "go"
    },
    "types.Initializer.String": {
        "descr": "",
        "name": "types.Initializer.String",
        "params": [],
        "path": "go/go/types/index#Initializer.String",
        "syntax": "func (init *Initializer) String() string",
        "type": "go"
    },
    "types.Interface": {
        "descr": "An Interface represents an interface type.",
        "name": "types.Interface",
        "params": [],
        "path": "go/go/types/index#Interface",
        "syntax": "type Interface struct { // contains filtered or unexported fields }",
        "type": "go"
    },
    "types.Interface.Complete": {
        "descr": "Complete computes the interface's method set. It must be called by users of NewInterfaceType and NewInterface after the interface's embedded types are fully defined and before using the interface type in any way other than to form other types. Complete returns the receiver.",
        "name": "types.Interface.Complete",
        "params": [],
        "path": "go/go/types/index#Interface.Complete",
        "syntax": "func (t *Interface) Complete() *Interface",
        "type": "go"
    },
    "types.Interface.Embedded": {
        "descr": "Embedded returns the i'th embedded defined (*Named) type of interface t for 0 <= i < t.NumEmbeddeds(). The result is nil if the i'th embedded type is not a defined type.",
        "name": "types.Interface.Embedded",
        "params": [],
        "path": "go/go/types/index#Interface.Embedded",
        "syntax": "func (t *Interface) Embedded(i int) *Named",
        "type": "go"
    },
    "types.Interface.EmbeddedType": {
        "descr": "EmbeddedType returns the i'th embedded type of interface t for 0 <= i < t.NumEmbeddeds().",
        "name": "types.Interface.EmbeddedType",
        "params": [],
        "path": "go/go/types/index#Interface.EmbeddedType",
        "syntax": "func (t *Interface) EmbeddedType(i int) Type",
        "type": "go"
    },
    "types.Interface.Empty": {
        "descr": "Empty returns true if t is the empty interface.",
        "name": "types.Interface.Empty",
        "params": [],
        "path": "go/go/types/index#Interface.Empty",
        "syntax": "func (t *Interface) Empty() bool",
        "type": "go"
    },
    "types.Interface.ExplicitMethod": {
        "descr": "ExplicitMethod returns the i'th explicitly declared method of interface t for 0 <= i < t.NumExplicitMethods(). The methods are ordered by their unique Id.",
        "name": "types.Interface.ExplicitMethod",
        "params": [],
        "path": "go/go/types/index#Interface.ExplicitMethod",
        "syntax": "func (t *Interface) ExplicitMethod(i int) *Func",
        "type": "go"
    },
    "types.Interface.Method": {
        "descr": "Method returns the i'th method of interface t for 0 <= i < t.NumMethods(). The methods are ordered by their unique Id.",
        "name": "types.Interface.Method",
        "params": [],
        "path": "go/go/types/index#Interface.Method",
        "syntax": "func (t *Interface) Method(i int) *Func",
        "type": "go"
    },
    "types.Interface.NumEmbeddeds": {
        "descr": "NumEmbeddeds returns the number of embedded types in interface t.",
        "name": "types.Interface.NumEmbeddeds",
        "params": [],
        "path": "go/go/types/index#Interface.NumEmbeddeds",
        "syntax": "func (t *Interface) NumEmbeddeds() int",
        "type": "go"
    },
    "types.Interface.NumExplicitMethods": {
        "descr": "NumExplicitMethods returns the number of explicitly declared methods of interface t.",
        "name": "types.Interface.NumExplicitMethods",
        "params": [],
        "path": "go/go/types/index#Interface.NumExplicitMethods",
        "syntax": "func (t *Interface) NumExplicitMethods() int",
        "type": "go"
    },
    "types.Interface.NumMethods": {
        "descr": "NumMethods returns the total number of methods of interface t.",
        "name": "types.Interface.NumMethods",
        "params": [],
        "path": "go/go/types/index#Interface.NumMethods",
        "syntax": "func (t *Interface) NumMethods() int",
        "type": "go"
    },
    "types.Interface.String": {
        "descr": "",
        "name": "types.Interface.String",
        "params": [],
        "path": "go/go/types/index#Interface.String",
        "syntax": "func (t *Interface) String() string",
        "type": "go"
    },
    "types.Interface.Underlying": {
        "descr": "",
        "name": "types.Interface.Underlying",
        "params": [],
        "path": "go/go/types/index#Interface.Underlying",
        "syntax": "func (t *Interface) Underlying() Type",
        "type": "go"
    },
    "types.IsInterface": {
        "descr": "IsInterface reports whether typ is an interface type.",
        "name": "types.IsInterface",
        "params": [],
        "path": "go/go/types/index#IsInterface",
        "syntax": "func IsInterface(typ Type) bool",
        "type": "go"
    },
    "types.Label": {
        "descr": "A Label represents a declared label. Labels don't have a type.",
        "name": "types.Label",
        "params": [],
        "path": "go/go/types/index#Label",
        "syntax": "type Label struct { // contains filtered or unexported fields }",
        "type": "go"
    },
    "types.Label.Exported": {
        "descr": "Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not.",
        "name": "types.Label.Exported",
        "params": [],
        "path": "go/go/types/index#Label.Exported",
        "syntax": "func (obj *Label) Exported() bool",
        "type": "go"
    },
    "types.Label.Id": {
        "descr": "Id is a wrapper for Id(obj.Pkg(), obj.Name()).",
        "name": "types.Label.Id",
        "params": [],
        "path": "go/go/types/index#Label.Id",
        "syntax": "func (obj *Label) Id() string",
        "type": "go"
    },
    "types.Label.Name": {
        "descr": "Name returns the object's (package-local, unqualified) name.",
        "name": "types.Label.Name",
        "params": [],
        "path": "go/go/types/index#Label.Name",
        "syntax": "func (obj *Label) Name() string",
        "type": "go"
    },
    "types.Label.Parent": {
        "descr": "Parent returns the scope in which the object is declared. The result is nil for methods and struct fields.",
        "name": "types.Label.Parent",
        "params": [],
        "path": "go/go/types/index#Label.Parent",
        "syntax": "func (obj *Label) Parent() *Scope",
        "type": "go"
    },
    "types.Label.Pkg": {
        "descr": "Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope.",
        "name": "types.Label.Pkg",
        "params": [],
        "path": "go/go/types/index#Label.Pkg",
        "syntax": "func (obj *Label) Pkg() *Package",
        "type": "go"
    },
    "types.Label.Pos": {
        "descr": "Pos returns the declaration position of the object's identifier.",
        "name": "types.Label.Pos",
        "params": [],
        "path": "go/go/types/index#Label.Pos",
        "syntax": "func (obj *Label) Pos() token.Pos",
        "type": "go"
    },
    "types.Label.String": {
        "descr": "",
        "name": "types.Label.String",
        "params": [],
        "path": "go/go/types/index#Label.String",
        "syntax": "func (obj *Label) String() string",
        "type": "go"
    },
    "types.Label.Type": {
        "descr": "Type returns the object's type.",
        "name": "types.Label.Type",
        "params": [],
        "path": "go/go/types/index#Label.Type",
        "syntax": "func (obj *Label) Type() Type",
        "type": "go"
    },
    "types.LookupFieldOrMethod": {
        "descr": "LookupFieldOrMethod looks up a field or method with given package and name in T and returns the corresponding *Var or *Func, an index sequence, and a bool indicating if there were any pointer indirections on the path to the field or method. If addressable is set, T is the type of an addressable variable (only matters for method lookups).",
        "name": "types.LookupFieldOrMethod",
        "params": [],
        "path": "go/go/types/index#LookupFieldOrMethod",
        "syntax": "func LookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool)",
        "type": "go"
    },
    "types.Map": {
        "descr": "A Map represents a map type.",
        "name": "types.Map",
        "params": [],
        "path": "go/go/types/index#Map",
        "syntax": "type Map struct { // contains filtered or unexported fields }",
        "type": "go"
    },
    "types.Map.Elem": {
        "descr": "Elem returns the element type of map m.",
        "name": "types.Map.Elem",
        "params": [],
        "path": "go/go/types/index#Map.Elem",
        "syntax": "func (m *Map) Elem() Type",
        "type": "go"
    },
    "types.Map.Key": {
        "descr": "Key returns the key type of map m.",
        "name": "types.Map.Key",
        "params": [],
        "path": "go/go/types/index#Map.Key",
        "syntax": "func (m *Map) Key() Type",
        "type": "go"
    },
    "types.Map.String": {
        "descr": "",
        "name": "types.Map.String",
        "params": [],
        "path": "go/go/types/index#Map.String",
        "syntax": "func (m *Map) String() string",
        "type": "go"
    },
    "types.Map.Underlying": {
        "descr": "",
        "name": "types.Map.Underlying",
        "params": [],
        "path": "go/go/types/index#Map.Underlying",
        "syntax": "func (m *Map) Underlying() Type",
        "type": "go"
    },
    "types.MethodSet": {
        "descr": "A MethodSet is an ordered set of concrete or abstract (interface) methods; a method is a MethodVal selection, and they are ordered by ascending m.Obj().Id(). The zero value for a MethodSet is a ready-to-use empty method set.",
        "name": "types.MethodSet",
        "params": [],
        "path": "go/go/types/index#MethodSet",
        "syntax": "type MethodSet struct { // contains filtered or unexported fields }",
        "type": "go"
    },
    "types.MethodSet.At": {
        "descr": "At returns the i'th method in s for 0 <= i < s.Len().",
        "name": "types.MethodSet.At",
        "params": [],
        "path": "go/go/types/index#MethodSet.At",
        "syntax": "func (s *MethodSet) At(i int) *Selection",
        "type": "go"
    },
    "types.MethodSet.Len": {
        "descr": "Len returns the number of methods in s.",
        "name": "types.MethodSet.Len",
        "params": [],
        "path": "go/go/types/index#MethodSet.Len",
        "syntax": "func (s *MethodSet) Len() int",
        "type": "go"
    },
    "types.MethodSet.Lookup": {
        "descr": "Lookup returns the method with matching package and name, or nil if not found.",
        "name": "types.MethodSet.Lookup",
        "params": [],
        "path": "go/go/types/index#MethodSet.Lookup",
        "syntax": "func (s *MethodSet) Lookup(pkg *Package, name string) *Selection",
        "type": "go"
    },
    "types.MethodSet.String": {
        "descr": "",
        "name": "types.MethodSet.String",
        "params": [],
        "path": "go/go/types/index#MethodSet.String",
        "syntax": "func (s *MethodSet) String() string",
        "type": "go"
    },
    "types.MissingMethod": {
        "descr": "MissingMethod returns (nil, false) if V implements T, otherwise it returns a missing method required by T and whether it is missing or just has the wrong type.",
        "name": "types.MissingMethod",
        "params": [],
        "path": "go/go/types/index#MissingMethod",
        "syntax": "func MissingMethod(V Type, T *Interface, static bool) (method *Func, wrongType bool)",
        "type": "go"
    },
    "types.Named": {
        "descr": "A Named represents a named type.",
        "name": "types.Named",
        "params": [],
        "path": "go/go/types/index#Named",
        "syntax": "type Named struct { // contains filtered or unexported fields }",
        "type": "go"
    },
    "types.Named.AddMethod": {
        "descr": "AddMethod adds method m unless it is already in the method list.",
        "name": "types.Named.AddMethod",
        "params": [],
        "path": "go/go/types/index#Named.AddMethod",
        "syntax": "func (t *Named) AddMethod(m *Func)",
        "type": "go"
    },
    "types.Named.Method": {
        "descr": "Method returns the i'th method of named type t for 0 <= i < t.NumMethods().",
        "name": "types.Named.Method",
        "params": [],
        "path": "go/go/types/index#Named.Method",
        "syntax": "func (t *Named) Method(i int) *Func",
        "type": "go"
    },
    "types.Named.NumMethods": {
        "descr": "NumMethods returns the number of explicit methods whose receiver is named type t.",
        "name": "types.Named.NumMethods",
        "params": [],
        "path": "go/go/types/index#Named.NumMethods",
        "syntax": "func (t *Named) NumMethods() int",
        "type": "go"
    },
    "types.Named.Obj": {
        "descr": "Obj returns the type name for the named type t.",
        "name": "types.Named.Obj",
        "params": [],
        "path": "go/go/types/index#Named.Obj",
        "syntax": "func (t *Named) Obj() *TypeName",
        "type": "go"
    },
    "types.Named.SetUnderlying": {
        "descr": "SetUnderlying sets the underlying type and marks t as complete.",
        "name": "types.Named.SetUnderlying",
        "params": [],
        "path": "go/go/types/index#Named.SetUnderlying",
        "syntax": "func (t *Named) SetUnderlying(underlying Type)",
        "type": "go"
    },
    "types.Named.String": {
        "descr": "",
        "name": "types.Named.String",
        "params": [],
        "path": "go/go/types/index#Named.String",
        "syntax": "func (t *Named) String() string",
        "type": "go"
    },
    "types.Named.Underlying": {
        "descr": "",
        "name": "types.Named.Underlying",
        "params": [],
        "path": "go/go/types/index#Named.Underlying",
        "syntax": "func (t *Named) Underlying() Type",
        "type": "go"
    },
    "types.NewArray": {
        "descr": "NewArray returns a new array type for the given element type and length. A negative length indicates an unknown length.",
        "name": "types.NewArray",
        "params": [],
        "path": "go/go/types/index#NewArray",
        "syntax": "func NewArray(elem Type, len int64) *Array",
        "type": "go"
    },
    "types.NewChan": {
        "descr": "NewChan returns a new channel type for the given direction and element type.",
        "name": "types.NewChan",
        "params": [],
        "path": "go/go/types/index#NewChan",
        "syntax": "func NewChan(dir ChanDir, elem Type) *Chan",
        "type": "go"
    },
    "types.NewChecker": {
        "descr": "NewChecker returns a new Checker instance for a given package. Package files may be added incrementally via checker.Files.",
        "name": "types.NewChecker",
        "params": [],
        "path": "go/go/types/index#NewChecker",
        "syntax": "func NewChecker(conf *Config, fset *token.FileSet, pkg *Package, info *Info) *Checker",
        "type": "go"
    },
    "types.NewConst": {
        "descr": "NewConst returns a new constant with value val. The remaining arguments set the attributes found with all Objects.",
        "name": "types.NewConst",
        "params": [],
        "path": "go/go/types/index#NewConst",
        "syntax": "func NewConst(pos token.Pos, pkg *Package, name string, typ Type, val constant.Value) *Const",
        "type": "go"
    },
    "types.NewField": {
        "descr": "NewField returns a new variable representing a struct field. For embedded fields, the name is the unqualified type name / under which the field is accessible.",
        "name": "types.NewField",
        "params": [],
        "path": "go/go/types/index#NewField",
        "syntax": "func NewField(pos token.Pos, pkg *Package, name string, typ Type, embedded bool) *Var",
        "type": "go"
    },
    "types.NewFunc": {
        "descr": "NewFunc returns a new function with the given signature, representing the function's type.",
        "name": "types.NewFunc",
        "params": [],
        "path": "go/go/types/index#NewFunc",
        "syntax": "func NewFunc(pos token.Pos, pkg *Package, name string, sig *Signature) *Func",
        "type": "go"
    },
    "types.NewInterface": {
        "descr": "NewInterface returns a new (incomplete) interface for the given methods and embedded types. Each embedded type must have an underlying type of interface type. NewInterface takes ownership of the provided methods and may modify their types by setting missing receivers. To compute the method set of the interface, Complete must be called.",
        "name": "types.NewInterface",
        "params": [],
        "path": "go/go/types/index#NewInterface",
        "syntax": "func NewInterface(methods []*Func, embeddeds []*Named) *Interface",
        "type": "go"
    },
    "types.NewInterfaceType": {
        "descr": "NewInterfaceType returns a new (incomplete) interface for the given methods and embedded types. Each embedded type must have an underlying type of interface type (this property is not verified for defined types, which may be in the process of being set up and which don't have a valid underlying type yet). NewInterfaceType takes ownership of the provided methods and may modify their types by setting missing receivers. To compute the method set of the interface, Complete must be called.",
        "name": "types.NewInterfaceType",
        "params": [],
        "path": "go/go/types/index#NewInterfaceType",
        "syntax": "func NewInterfaceType(methods []*Func, embeddeds []Type) *Interface",
        "type": "go"
    },
    "types.NewLabel": {
        "descr": "NewLabel returns a new label.",
        "name": "types.NewLabel",
        "params": [],
        "path": "go/go/types/index#NewLabel",
        "syntax": "func NewLabel(pos token.Pos, pkg *Package, name string) *Label",
        "type": "go"
    },
    "types.NewMap": {
        "descr": "NewMap returns a new map for the given key and element types.",
        "name": "types.NewMap",
        "params": [],
        "path": "go/go/types/index#NewMap",
        "syntax": "func NewMap(key, elem Type) *Map",
        "type": "go"
    },
    "types.NewMethodSet": {
        "descr": "NewMethodSet returns the method set for the given type T. It always returns a non-nil method set, even if it is empty.",
        "name": "types.NewMethodSet",
        "params": [],
        "path": "go/go/types/index#NewMethodSet",
        "syntax": "func NewMethodSet(T Type) *MethodSet",
        "type": "go"
    },
    "types.NewNamed": {
        "descr": "NewNamed returns a new named type for the given type name, underlying type, and associated methods. If the given type name obj doesn't have a type yet, its type is set to the returned named type. The underlying type must not be a *Named.",
        "name": "types.NewNamed",
        "params": [],
        "path": "go/go/types/index#NewNamed",
        "syntax": "func NewNamed(obj *TypeName, underlying Type, methods []*Func) *Named",
        "type": "go"
    },
    "types.NewPackage": {
        "descr": "NewPackage returns a new Package for the given package path and name. The package is not complete and contains no explicit imports.",
        "name": "types.NewPackage",
        "params": [],
        "path": "go/go/types/index#NewPackage",
        "syntax": "func NewPackage(path, name string) *Package",
        "type": "go"
    },
    "types.NewParam": {
        "descr": "NewParam returns a new variable representing a function parameter.",
        "name": "types.NewParam",
        "params": [],
        "path": "go/go/types/index#NewParam",
        "syntax": "func NewParam(pos token.Pos, pkg *Package, name string, typ Type) *Var",
        "type": "go"
    },
    "types.NewPkgName": {
        "descr": "NewPkgName returns a new PkgName object representing an imported package. The remaining arguments set the attributes found with all Objects.",
        "name": "types.NewPkgName",
        "params": [],
        "path": "go/go/types/index#NewPkgName",
        "syntax": "func NewPkgName(pos token.Pos, pkg *Package, name string, imported *Package) *PkgName",
        "type": "go"
    },
    "types.NewPointer": {
        "descr": "NewPointer returns a new pointer type for the given element (base) type.",
        "name": "types.NewPointer",
        "params": [],
        "path": "go/go/types/index#NewPointer",
        "syntax": "func NewPointer(elem Type) *Pointer",
        "type": "go"
    },
    "types.NewScope": {
        "descr": "NewScope returns a new, empty scope contained in the given parent scope, if any. The comment is for debugging only.",
        "name": "types.NewScope",
        "params": [],
        "path": "go/go/types/index#NewScope",
        "syntax": "func NewScope(parent *Scope, pos, end token.Pos, comment string) *Scope",
        "type": "go"
    },
    "types.NewSignature": {
        "descr": "NewSignature returns a new function type for the given receiver, parameters, and results, either of which may be nil. If variadic is set, the function is variadic, it must have at least one parameter, and the last parameter must be of unnamed slice type.",
        "name": "types.NewSignature",
        "params": [],
        "path": "go/go/types/index#NewSignature",
        "syntax": "func NewSignature(recv *Var, params, results *Tuple, variadic bool) *Signature",
        "type": "go"
    },
    "types.NewSlice": {
        "descr": "NewSlice returns a new slice type for the given element type.",
        "name": "types.NewSlice",
        "params": [],
        "path": "go/go/types/index#NewSlice",
        "syntax": "func NewSlice(elem Type) *Slice",
        "type": "go"
    },
    "types.NewStruct": {
        "descr": "NewStruct returns a new struct with the given fields and corresponding field tags. If a field with index i has a tag, tags[i] must be that tag, but len(tags) may be only as long as required to hold the tag with the largest index i. Consequently, if no field has a tag, tags may be nil.",
        "name": "types.NewStruct",
        "params": [],
        "path": "go/go/types/index#NewStruct",
        "syntax": "func NewStruct(fields []*Var, tags []string) *Struct",
        "type": "go"
    },
    "types.NewTuple": {
        "descr": "NewTuple returns a new tuple for the given variables.",
        "name": "types.NewTuple",
        "params": [],
        "path": "go/go/types/index#NewTuple",
        "syntax": "func NewTuple(x ...*Var) *Tuple",
        "type": "go"
    },
    "types.NewTypeName": {
        "descr": "NewTypeName returns a new type name denoting the given typ. The remaining arguments set the attributes found with all Objects.",
        "name": "types.NewTypeName",
        "params": [],
        "path": "go/go/types/index#NewTypeName",
        "syntax": "func NewTypeName(pos token.Pos, pkg *Package, name string, typ Type) *TypeName",
        "type": "go"
    },
    "types.NewVar": {
        "descr": "NewVar returns a new variable. The arguments set the attributes found with all Objects.",
        "name": "types.NewVar",
        "params": [],
        "path": "go/go/types/index#NewVar",
        "syntax": "func NewVar(pos token.Pos, pkg *Package, name string, typ Type) *Var",
        "type": "go"
    },
    "types.Nil": {
        "descr": "Nil represents the predeclared value nil.",
        "name": "types.Nil",
        "params": [],
        "path": "go/go/types/index#Nil",
        "syntax": "type Nil struct { // contains filtered or unexported fields }",
        "type": "go"
    },
    "types.Nil.Exported": {
        "descr": "Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not.",
        "name": "types.Nil.Exported",
        "params": [],
        "path": "go/go/types/index#Nil.Exported",
        "syntax": "func (obj *Nil) Exported() bool",
        "type": "go"
    },
    "types.Nil.Id": {
        "descr": "Id is a wrapper for Id(obj.Pkg(), obj.Name()).",
        "name": "types.Nil.Id",
        "params": [],
        "path": "go/go/types/index#Nil.Id",
        "syntax": "func (obj *Nil) Id() string",
        "type": "go"
    },
    "types.Nil.Name": {
        "descr": "Name returns the object's (package-local, unqualified) name.",
        "name": "types.Nil.Name",
        "params": [],
        "path": "go/go/types/index#Nil.Name",
        "syntax": "func (obj *Nil) Name() string",
        "type": "go"
    },
    "types.Nil.Parent": {
        "descr": "Parent returns the scope in which the object is declared. The result is nil for methods and struct fields.",
        "name": "types.Nil.Parent",
        "params": [],
        "path": "go/go/types/index#Nil.Parent",
        "syntax": "func (obj *Nil) Parent() *Scope",
        "type": "go"
    },
    "types.Nil.Pkg": {
        "descr": "Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope.",
        "name": "types.Nil.Pkg",
        "params": [],
        "path": "go/go/types/index#Nil.Pkg",
        "syntax": "func (obj *Nil) Pkg() *Package",
        "type": "go"
    },
    "types.Nil.Pos": {
        "descr": "Pos returns the declaration position of the object's identifier.",
        "name": "types.Nil.Pos",
        "params": [],
        "path": "go/go/types/index#Nil.Pos",
        "syntax": "func (obj *Nil) Pos() token.Pos",
        "type": "go"
    },
    "types.Nil.String": {
        "descr": "",
        "name": "types.Nil.String",
        "params": [],
        "path": "go/go/types/index#Nil.String",
        "syntax": "func (obj *Nil) String() string",
        "type": "go"
    },
    "types.Nil.Type": {
        "descr": "Type returns the object's type.",
        "name": "types.Nil.Type",
        "params": [],
        "path": "go/go/types/index#Nil.Type",
        "syntax": "func (obj *Nil) Type() Type",
        "type": "go"
    },
    "types.Object": {
        "descr": "An Object describes a named language entity such as a package, constant, type, variable, function (incl. methods), or label. All objects implement the Object interface.",
        "name": "types.Object",
        "params": [],
        "path": "go/go/types/index#Object",
        "syntax": "type Object interface { Parent() *Scope // scope in which this object is declared; nil for methods and struct fields Pos() token.Pos // position of object identifier in declaration Pkg() *Package // package to which this object belongs; nil for labels and objects in the Universe scope Name() string // package local object name Type() Type // object type Exported() bool // reports whether the name starts with a capital letter Id() string // object name if exported, qualified name if not exported (see func Id) // String returns a human-readable string of the object. String() string // contains filtered or unexported methods }",
        "type": "go"
    },
    "types.ObjectString": {
        "descr": "ObjectString returns the string form of obj. The Qualifier controls the printing of package-level objects, and may be nil.",
        "name": "types.ObjectString",
        "params": [],
        "path": "go/go/types/index#ObjectString",
        "syntax": "func ObjectString(obj Object, qf Qualifier) string",
        "type": "go"
    },
    "types.Package": {
        "descr": "A Package describes a Go package.",
        "name": "types.Package",
        "params": [],
        "path": "go/go/types/index#Package",
        "syntax": "type Package struct { // contains filtered or unexported fields }",
        "type": "go"
    },
    "types.Package.Complete": {
        "descr": "A package is complete if its scope contains (at least) all exported objects; otherwise it is incomplete.",
        "name": "types.Package.Complete",
        "params": [],
        "path": "go/go/types/index#Package.Complete",
        "syntax": "func (pkg *Package) Complete() bool",
        "type": "go"
    },
    "types.Package.Imports": {
        "descr": "Imports returns the list of packages directly imported by pkg; the list is in source order.",
        "name": "types.Package.Imports",
        "params": [],
        "path": "go/go/types/index#Package.Imports",
        "syntax": "func (pkg *Package) Imports() []*Package",
        "type": "go"
    },
    "types.Package.MarkComplete": {
        "descr": "MarkComplete marks a package as complete.",
        "name": "types.Package.MarkComplete",
        "params": [],
        "path": "go/go/types/index#Package.MarkComplete",
        "syntax": "func (pkg *Package) MarkComplete()",
        "type": "go"
    },
    "types.Package.Name": {
        "descr": "Name returns the package name.",
        "name": "types.Package.Name",
        "params": [],
        "path": "go/go/types/index#Package.Name",
        "syntax": "func (pkg *Package) Name() string",
        "type": "go"
    },
    "types.Package.Path": {
        "descr": "Path returns the package path.",
        "name": "types.Package.Path",
        "params": [],
        "path": "go/go/types/index#Package.Path",
        "syntax": "func (pkg *Package) Path() string",
        "type": "go"
    },
    "types.Package.Scope": {
        "descr": "Scope returns the (complete or incomplete) package scope holding the objects declared at package level (TypeNames, Consts, Vars, and Funcs).",
        "name": "types.Package.Scope",
        "params": [],
        "path": "go/go/types/index#Package.Scope",
        "syntax": "func (pkg *Package) Scope() *Scope",
        "type": "go"
    },
    "types.Package.SetImports": {
        "descr": "SetImports sets the list of explicitly imported packages to list. It is the caller's responsibility to make sure list elements are unique.",
        "name": "types.Package.SetImports",
        "params": [],
        "path": "go/go/types/index#Package.SetImports",
        "syntax": "func (pkg *Package) SetImports(list []*Package)",
        "type": "go"
    },
    "types.Package.SetName": {
        "descr": "SetName sets the package name.",
        "name": "types.Package.SetName",
        "params": [],
        "path": "go/go/types/index#Package.SetName",
        "syntax": "func (pkg *Package) SetName(name string)",
        "type": "go"
    },
    "types.Package.String": {
        "descr": "",
        "name": "types.Package.String",
        "params": [],
        "path": "go/go/types/index#Package.String",
        "syntax": "func (pkg *Package) String() string",
        "type": "go"
    },
    "types.PkgName": {
        "descr": "A PkgName represents an imported Go package. PkgNames don't have a type.",
        "name": "types.PkgName",
        "params": [],
        "path": "go/go/types/index#PkgName",
        "syntax": "type PkgName struct { // contains filtered or unexported fields }",
        "type": "go"
    },
    "types.PkgName.Exported": {
        "descr": "Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not.",
        "name": "types.PkgName.Exported",
        "params": [],
        "path": "go/go/types/index#PkgName.Exported",
        "syntax": "func (obj *PkgName) Exported() bool",
        "type": "go"
    },
    "types.PkgName.Id": {
        "descr": "Id is a wrapper for Id(obj.Pkg(), obj.Name()).",
        "name": "types.PkgName.Id",
        "params": [],
        "path": "go/go/types/index#PkgName.Id",
        "syntax": "func (obj *PkgName) Id() string",
        "type": "go"
    },
    "types.PkgName.Imported": {
        "descr": "Imported returns the package that was imported. It is distinct from Pkg(), which is the package containing the import statement.",
        "name": "types.PkgName.Imported",
        "params": [],
        "path": "go/go/types/index#PkgName.Imported",
        "syntax": "func (obj *PkgName) Imported() *Package",
        "type": "go"
    },
    "types.PkgName.Name": {
        "descr": "Name returns the object's (package-local, unqualified) name.",
        "name": "types.PkgName.Name",
        "params": [],
        "path": "go/go/types/index#PkgName.Name",
        "syntax": "func (obj *PkgName) Name() string",
        "type": "go"
    },
    "types.PkgName.Parent": {
        "descr": "Parent returns the scope in which the object is declared. The result is nil for methods and struct fields.",
        "name": "types.PkgName.Parent",
        "params": [],
        "path": "go/go/types/index#PkgName.Parent",
        "syntax": "func (obj *PkgName) Parent() *Scope",
        "type": "go"
    },
    "types.PkgName.Pkg": {
        "descr": "Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope.",
        "name": "types.PkgName.Pkg",
        "params": [],
        "path": "go/go/types/index#PkgName.Pkg",
        "syntax": "func (obj *PkgName) Pkg() *Package",
        "type": "go"
    },
    "types.PkgName.Pos": {
        "descr": "Pos returns the declaration position of the object's identifier.",
        "name": "types.PkgName.Pos",
        "params": [],
        "path": "go/go/types/index#PkgName.Pos",
        "syntax": "func (obj *PkgName) Pos() token.Pos",
        "type": "go"
    },
    "types.PkgName.String": {
        "descr": "",
        "name": "types.PkgName.String",
        "params": [],
        "path": "go/go/types/index#PkgName.String",
        "syntax": "func (obj *PkgName) String() string",
        "type": "go"
    },
    "types.PkgName.Type": {
        "descr": "Type returns the object's type.",
        "name": "types.PkgName.Type",
        "params": [],
        "path": "go/go/types/index#PkgName.Type",
        "syntax": "func (obj *PkgName) Type() Type",
        "type": "go"
    },
    "types.Pointer": {
        "descr": "A Pointer represents a pointer type.",
        "name": "types.Pointer",
        "params": [],
        "path": "go/go/types/index#Pointer",
        "syntax": "type Pointer struct { // contains filtered or unexported fields }",
        "type": "go"
    },
    "types.Pointer.Elem": {
        "descr": "Elem returns the element type for the given pointer p.",
        "name": "types.Pointer.Elem",
        "params": [],
        "path": "go/go/types/index#Pointer.Elem",
        "syntax": "func (p *Pointer) Elem() Type",
        "type": "go"
    },
    "types.Pointer.String": {
        "descr": "",
        "name": "types.Pointer.String",
        "params": [],
        "path": "go/go/types/index#Pointer.String",
        "syntax": "func (p *Pointer) String() string",
        "type": "go"
    },
    "types.Pointer.Underlying": {
        "descr": "",
        "name": "types.Pointer.Underlying",
        "params": [],
        "path": "go/go/types/index#Pointer.Underlying",
        "syntax": "func (p *Pointer) Underlying() Type",
        "type": "go"
    },
    "types.Qualifier": {
        "descr": "A Qualifier controls how named package-level objects are printed in calls to TypeString, ObjectString, and SelectionString.",
        "name": "types.Qualifier",
        "params": [],
        "path": "go/go/types/index#Qualifier",
        "syntax": "type Qualifier func(*Package) string",
        "type": "go"
    },
    "types.RelativeTo": {
        "descr": "RelativeTo(pkg) returns a Qualifier that fully qualifies members of all packages other than pkg.",
        "name": "types.RelativeTo",
        "params": [],
        "path": "go/go/types/index#RelativeTo",
        "syntax": "func RelativeTo(pkg *Package) Qualifier",
        "type": "go"
    },
    "types.Scope": {
        "descr": "A Scope maintains a set of objects and links to its containing (parent) and contained (children) scopes. Objects may be inserted and looked up by name. The zero value for Scope is a ready-to-use empty scope.",
        "name": "types.Scope",
        "params": [],
        "path": "go/go/types/index#Scope",
        "syntax": "type Scope struct { // contains filtered or unexported fields }",
        "type": "go"
    },
    "types.Scope.Child": {
        "descr": "Child returns the i'th child scope for 0 <= i < NumChildren().",
        "name": "types.Scope.Child",
        "params": [],
        "path": "go/go/types/index#Scope.Child",
        "syntax": "func (s *Scope) Child(i int) *Scope",
        "type": "go"
    },
    "types.Scope.Contains": {
        "descr": "Contains returns true if pos is within the scope's extent. The result is guaranteed to be valid only if the type-checked AST has complete position information.",
        "name": "types.Scope.Contains",
        "params": [],
        "path": "go/go/types/index#Scope.Contains",
        "syntax": "func (s *Scope) Contains(pos token.Pos) bool",
        "type": "go"
    },
    "types.Scope.End": {
        "descr": "",
        "name": "types.Scope.End",
        "params": [],
        "path": "go/go/types/index#Scope.End",
        "syntax": "func (s *Scope) End() token.Pos",
        "type": "go"
    },
    "types.Scope.Innermost": {
        "descr": "Innermost returns the innermost (child) scope containing pos. If pos is not within any scope, the result is nil. The result is also nil for the Universe scope. The result is guaranteed to be valid only if the type-checked AST has complete position information.",
        "name": "types.Scope.Innermost",
        "params": [],
        "path": "go/go/types/index#Scope.Innermost",
        "syntax": "func (s *Scope) Innermost(pos token.Pos) *Scope",
        "type": "go"
    },
    "types.Scope.Insert": {
        "descr": "Insert attempts to insert an object obj into scope s. If s already contains an alternative object alt with the same name, Insert leaves s unchanged and returns alt. Otherwise it inserts obj, sets the object's parent scope if not already set, and returns nil.",
        "name": "types.Scope.Insert",
        "params": [],
        "path": "go/go/types/index#Scope.Insert",
        "syntax": "func (s *Scope) Insert(obj Object) Object",
        "type": "go"
    },
    "types.Scope.Len": {
        "descr": "Len() returns the number of scope elements.",
        "name": "types.Scope.Len",
        "params": [],
        "path": "go/go/types/index#Scope.Len",
        "syntax": "func (s *Scope) Len() int",
        "type": "go"
    },
    "types.Scope.Lookup": {
        "descr": "Lookup returns the object in scope s with the given name if such an object exists; otherwise the result is nil.",
        "name": "types.Scope.Lookup",
        "params": [],
        "path": "go/go/types/index#Scope.Lookup",
        "syntax": "func (s *Scope) Lookup(name string) Object",
        "type": "go"
    },
    "types.Scope.LookupParent": {
        "descr": "LookupParent follows the parent chain of scopes starting with s until it finds a scope where Lookup(name) returns a non-nil object, and then returns that scope and object. If a valid position pos is provided, only objects that were declared at or before pos are considered. If no such scope and object exists, the result is (nil, nil).",
        "name": "types.Scope.LookupParent",
        "params": [],
        "path": "go/go/types/index#Scope.LookupParent",
        "syntax": "func (s *Scope) LookupParent(name string, pos token.Pos) (*Scope, Object)",
        "type": "go"
    },
    "types.Scope.Names": {
        "descr": "Names returns the scope's element names in sorted order.",
        "name": "types.Scope.Names",
        "params": [],
        "path": "go/go/types/index#Scope.Names",
        "syntax": "func (s *Scope) Names() []string",
        "type": "go"
    },
    "types.Scope.NumChildren": {
        "descr": "NumChildren() returns the number of scopes nested in s.",
        "name": "types.Scope.NumChildren",
        "params": [],
        "path": "go/go/types/index#Scope.NumChildren",
        "syntax": "func (s *Scope) NumChildren() int",
        "type": "go"
    },
    "types.Scope.Parent": {
        "descr": "Parent returns the scope's containing (parent) scope.",
        "name": "types.Scope.Parent",
        "params": [],
        "path": "go/go/types/index#Scope.Parent",
        "syntax": "func (s *Scope) Parent() *Scope",
        "type": "go"
    },
    "types.Scope.Pos": {
        "descr": "Pos and End describe the scope's source code extent [pos, end). The results are guaranteed to be valid only if the type-checked AST has complete position information. The extent is undefined for Universe and package scopes.",
        "name": "types.Scope.Pos",
        "params": [],
        "path": "go/go/types/index#Scope.Pos",
        "syntax": "func (s *Scope) Pos() token.Pos",
        "type": "go"
    },
    "types.Scope.String": {
        "descr": "String returns a string representation of the scope, for debugging.",
        "name": "types.Scope.String",
        "params": [],
        "path": "go/go/types/index#Scope.String",
        "syntax": "func (s *Scope) String() string",
        "type": "go"
    },
    "types.Scope.WriteTo": {
        "descr": "WriteTo writes a string representation of the scope to w, with the scope elements sorted by name. The level of indentation is controlled by n >= 0, with n == 0 for no indentation. If recurse is set, it also writes nested (children) scopes.",
        "name": "types.Scope.WriteTo",
        "params": [],
        "path": "go/go/types/index#Scope.WriteTo",
        "syntax": "func (s *Scope) WriteTo(w io.Writer, n int, recurse bool)",
        "type": "go"
    },
    "types.Selection": {
        "descr": "A Selection describes a selector expression x.f. For the declarations:",
        "name": "types.Selection",
        "params": [],
        "path": "go/go/types/index#Selection",
        "syntax": "type T struct{ x int; E } type E struct{} func (e E) m() {} var p *T",
        "type": "go"
    },
    "types.Selection.Index": {
        "descr": "Index describes the path from x to f in x.f. The last index entry is the field or method index of the type declaring f; either:",
        "name": "types.Selection.Index",
        "params": [],
        "path": "go/go/types/index#Selection.Index",
        "syntax": "func (s *Selection) Index() []int",
        "type": "go"
    },
    "types.Selection.Indirect": {
        "descr": "Indirect reports whether any pointer indirection was required to get from x to f in x.f.",
        "name": "types.Selection.Indirect",
        "params": [],
        "path": "go/go/types/index#Selection.Indirect",
        "syntax": "func (s *Selection) Indirect() bool",
        "type": "go"
    },
    "types.Selection.Kind": {
        "descr": "Kind returns the selection kind.",
        "name": "types.Selection.Kind",
        "params": [],
        "path": "go/go/types/index#Selection.Kind",
        "syntax": "func (s *Selection) Kind() SelectionKind",
        "type": "go"
    },
    "types.Selection.Obj": {
        "descr": "Obj returns the object denoted by x.f; a *Var for a field selection, and a *Func in all other cases.",
        "name": "types.Selection.Obj",
        "params": [],
        "path": "go/go/types/index#Selection.Obj",
        "syntax": "func (s *Selection) Obj() Object",
        "type": "go"
    },
    "types.Selection.Recv": {
        "descr": "Recv returns the type of x in x.f.",
        "name": "types.Selection.Recv",
        "params": [],
        "path": "go/go/types/index#Selection.Recv",
        "syntax": "func (s *Selection) Recv() Type",
        "type": "go"
    },
    "types.Selection.String": {
        "descr": "",
        "name": "types.Selection.String",
        "params": [],
        "path": "go/go/types/index#Selection.String",
        "syntax": "func (s *Selection) String() string",
        "type": "go"
    },
    "types.Selection.Type": {
        "descr": "Type returns the type of x.f, which may be different from the type of f. See Selection for more information.",
        "name": "types.Selection.Type",
        "params": [],
        "path": "go/go/types/index#Selection.Type",
        "syntax": "func (s *Selection) Type() Type",
        "type": "go"
    },
    "types.SelectionKind": {
        "descr": "SelectionKind describes the kind of a selector expression x.f (excluding qualified identifiers).",
        "name": "types.SelectionKind",
        "params": [],
        "path": "go/go/types/index#SelectionKind",
        "syntax": "type SelectionKind int",
        "type": "go"
    },
    "types.SelectionString": {
        "descr": "SelectionString returns the string form of s. The Qualifier controls the printing of package-level objects, and may be nil.",
        "name": "types.SelectionString",
        "params": [],
        "path": "go/go/types/index#SelectionString",
        "syntax": "func SelectionString(s *Selection, qf Qualifier) string",
        "type": "go"
    },
    "types.Signature": {
        "descr": "A Signature represents a (non-builtin) function or method type. The receiver is ignored when comparing signatures for identity.",
        "name": "types.Signature",
        "params": [],
        "path": "go/go/types/index#Signature",
        "syntax": "type Signature struct { // contains filtered or unexported fields }",
        "type": "go"
    },
    "types.Signature.Params": {
        "descr": "Params returns the parameters of signature s, or nil.",
        "name": "types.Signature.Params",
        "params": [],
        "path": "go/go/types/index#Signature.Params",
        "syntax": "func (s *Signature) Params() *Tuple",
        "type": "go"
    },
    "types.Signature.Recv": {
        "descr": "Recv returns the receiver of signature s (if a method), or nil if a function. It is ignored when comparing signatures for identity.",
        "name": "types.Signature.Recv",
        "params": [],
        "path": "go/go/types/index#Signature.Recv",
        "syntax": "func (s *Signature) Recv() *Var",
        "type": "go"
    },
    "types.Signature.Results": {
        "descr": "Results returns the results of signature s, or nil.",
        "name": "types.Signature.Results",
        "params": [],
        "path": "go/go/types/index#Signature.Results",
        "syntax": "func (s *Signature) Results() *Tuple",
        "type": "go"
    },
    "types.Signature.String": {
        "descr": "",
        "name": "types.Signature.String",
        "params": [],
        "path": "go/go/types/index#Signature.String",
        "syntax": "func (s *Signature) String() string",
        "type": "go"
    },
    "types.Signature.Underlying": {
        "descr": "",
        "name": "types.Signature.Underlying",
        "params": [],
        "path": "go/go/types/index#Signature.Underlying",
        "syntax": "func (s *Signature) Underlying() Type",
        "type": "go"
    },
    "types.Signature.Variadic": {
        "descr": "Variadic reports whether the signature s is variadic.",
        "name": "types.Signature.Variadic",
        "params": [],
        "path": "go/go/types/index#Signature.Variadic",
        "syntax": "func (s *Signature) Variadic() bool",
        "type": "go"
    },
    "types.Sizes": {
        "descr": "Sizes defines the sizing functions for package unsafe.",
        "name": "types.Sizes",
        "params": [],
        "path": "go/go/types/index#Sizes",
        "syntax": "type Sizes interface { // Alignof returns the alignment of a variable of type T. // Alignof must implement the alignment guarantees required by the spec. Alignof(T Type) int64 // Offsetsof returns the offsets of the given struct fields, in bytes. // Offsetsof must implement the offset guarantees required by the spec. Offsetsof(fields []*Var) []int64 // Sizeof returns the size of a variable of type T. // Sizeof must implement the size guarantees required by the spec. Sizeof(T Type) int64 }",
        "type": "go"
    },
    "types.SizesFor": {
        "descr": "SizesFor returns the Sizes used by a compiler for an architecture. The result is nil if a compiler/architecture pair is not known.",
        "name": "types.SizesFor",
        "params": [],
        "path": "go/go/types/index#SizesFor",
        "syntax": "func SizesFor(compiler, arch string) Sizes",
        "type": "go"
    },
    "types.Slice": {
        "descr": "A Slice represents a slice type.",
        "name": "types.Slice",
        "params": [],
        "path": "go/go/types/index#Slice",
        "syntax": "type Slice struct { // contains filtered or unexported fields }",
        "type": "go"
    },
    "types.Slice.Elem": {
        "descr": "Elem returns the element type of slice s.",
        "name": "types.Slice.Elem",
        "params": [],
        "path": "go/go/types/index#Slice.Elem",
        "syntax": "func (s *Slice) Elem() Type",
        "type": "go"
    },
    "types.Slice.String": {
        "descr": "",
        "name": "types.Slice.String",
        "params": [],
        "path": "go/go/types/index#Slice.String",
        "syntax": "func (s *Slice) String() string",
        "type": "go"
    },
    "types.Slice.Underlying": {
        "descr": "",
        "name": "types.Slice.Underlying",
        "params": [],
        "path": "go/go/types/index#Slice.Underlying",
        "syntax": "func (s *Slice) Underlying() Type",
        "type": "go"
    },
    "types.StdSizes": {
        "descr": "StdSizes is a convenience type for creating commonly used Sizes. It makes the following simplifying assumptions:",
        "name": "types.StdSizes",
        "params": [],
        "path": "go/go/types/index#StdSizes",
        "syntax": "- The size of explicitly sized basic types (int16, etc.) is the specified size. - The size of strings and interfaces is 2*WordSize. - The size of slices is 3*WordSize. - The size of an array of n elements corresponds to the size of a struct of n consecutive fields of the array's element type. - The size of a struct is the offset of the last field plus that field's size. As with all element types, if the struct is used in an array its size must first be aligned to a multiple of the struct's alignment. - All other types have size WordSize. - Arrays and structs are aligned per spec definition; all other types are naturally aligned with a maximum alignment MaxAlign.",
        "type": "go"
    },
    "types.StdSizes.Alignof": {
        "descr": "",
        "name": "types.StdSizes.Alignof",
        "params": [],
        "path": "go/go/types/index#StdSizes.Alignof",
        "syntax": "func (s *StdSizes) Alignof(T Type) int64",
        "type": "go"
    },
    "types.StdSizes.Offsetsof": {
        "descr": "",
        "name": "types.StdSizes.Offsetsof",
        "params": [],
        "path": "go/go/types/index#StdSizes.Offsetsof",
        "syntax": "func (s *StdSizes) Offsetsof(fields []*Var) []int64",
        "type": "go"
    },
    "types.StdSizes.Sizeof": {
        "descr": "",
        "name": "types.StdSizes.Sizeof",
        "params": [],
        "path": "go/go/types/index#StdSizes.Sizeof",
        "syntax": "func (s *StdSizes) Sizeof(T Type) int64",
        "type": "go"
    },
    "types.Struct": {
        "descr": "A Struct represents a struct type.",
        "name": "types.Struct",
        "params": [],
        "path": "go/go/types/index#Struct",
        "syntax": "type Struct struct { // contains filtered or unexported fields }",
        "type": "go"
    },
    "types.Struct.Field": {
        "descr": "Field returns the i'th field for 0 <= i < NumFields().",
        "name": "types.Struct.Field",
        "params": [],
        "path": "go/go/types/index#Struct.Field",
        "syntax": "func (s *Struct) Field(i int) *Var",
        "type": "go"
    },
    "types.Struct.NumFields": {
        "descr": "NumFields returns the number of fields in the struct (including blank and embedded fields).",
        "name": "types.Struct.NumFields",
        "params": [],
        "path": "go/go/types/index#Struct.NumFields",
        "syntax": "func (s *Struct) NumFields() int",
        "type": "go"
    },
    "types.Struct.String": {
        "descr": "",
        "name": "types.Struct.String",
        "params": [],
        "path": "go/go/types/index#Struct.String",
        "syntax": "func (s *Struct) String() string",
        "type": "go"
    },
    "types.Struct.Tag": {
        "descr": "Tag returns the i'th field tag for 0 <= i < NumFields().",
        "name": "types.Struct.Tag",
        "params": [],
        "path": "go/go/types/index#Struct.Tag",
        "syntax": "func (s *Struct) Tag(i int) string",
        "type": "go"
    },
    "types.Struct.Underlying": {
        "descr": "",
        "name": "types.Struct.Underlying",
        "params": [],
        "path": "go/go/types/index#Struct.Underlying",
        "syntax": "func (s *Struct) Underlying() Type",
        "type": "go"
    },
    "types.Tuple": {
        "descr": "A Tuple represents an ordered list of variables; a nil *Tuple is a valid (empty) tuple. Tuples are used as components of signatures and to represent the type of multiple assignments; they are not first class types of Go.",
        "name": "types.Tuple",
        "params": [],
        "path": "go/go/types/index#Tuple",
        "syntax": "type Tuple struct { // contains filtered or unexported fields }",
        "type": "go"
    },
    "types.Tuple.At": {
        "descr": "At returns the i'th variable of tuple t.",
        "name": "types.Tuple.At",
        "params": [],
        "path": "go/go/types/index#Tuple.At",
        "syntax": "func (t *Tuple) At(i int) *Var",
        "type": "go"
    },
    "types.Tuple.Len": {
        "descr": "Len returns the number variables of tuple t.",
        "name": "types.Tuple.Len",
        "params": [],
        "path": "go/go/types/index#Tuple.Len",
        "syntax": "func (t *Tuple) Len() int",
        "type": "go"
    },
    "types.Tuple.String": {
        "descr": "",
        "name": "types.Tuple.String",
        "params": [],
        "path": "go/go/types/index#Tuple.String",
        "syntax": "func (t *Tuple) String() string",
        "type": "go"
    },
    "types.Tuple.Underlying": {
        "descr": "",
        "name": "types.Tuple.Underlying",
        "params": [],
        "path": "go/go/types/index#Tuple.Underlying",
        "syntax": "func (t *Tuple) Underlying() Type",
        "type": "go"
    },
    "types.Type": {
        "descr": "A Type represents a type of Go. All types implement the Type interface.",
        "name": "types.Type",
        "params": [],
        "path": "go/go/types/index#Type",
        "syntax": "type Type interface { // Underlying returns the underlying type of a type. Underlying() Type // String returns a string representation of a type. String() string }",
        "type": "go"
    },
    "types.TypeAndValue": {
        "descr": "TypeAndValue reports the type and value (for constants) of the corresponding expression.",
        "name": "types.TypeAndValue",
        "params": [],
        "path": "go/go/types/index#TypeAndValue",
        "syntax": "type TypeAndValue struct { Type Type Value constant.Value // contains filtered or unexported fields }",
        "type": "go"
    },
    "types.TypeAndValue.Addressable": {
        "descr": "Addressable reports whether the corresponding expression is addressable (https://golang.org/ref/spec#Address_operators).",
        "name": "types.TypeAndValue.Addressable",
        "params": [],
        "path": "go/go/types/index#TypeAndValue.Addressable",
        "syntax": "func (tv TypeAndValue) Addressable() bool",
        "type": "go"
    },
    "types.TypeAndValue.Assignable": {
        "descr": "Assignable reports whether the corresponding expression is assignable to (provided a value of the right type).",
        "name": "types.TypeAndValue.Assignable",
        "params": [],
        "path": "go/go/types/index#TypeAndValue.Assignable",
        "syntax": "func (tv TypeAndValue) Assignable() bool",
        "type": "go"
    },
    "types.TypeAndValue.HasOk": {
        "descr": "HasOk reports whether the corresponding expression may be used on the rhs of a comma-ok assignment.",
        "name": "types.TypeAndValue.HasOk",
        "params": [],
        "path": "go/go/types/index#TypeAndValue.HasOk",
        "syntax": "func (tv TypeAndValue) HasOk() bool",
        "type": "go"
    },
    "types.TypeAndValue.IsBuiltin": {
        "descr": "IsBuiltin reports whether the corresponding expression denotes a (possibly parenthesized) built-in function.",
        "name": "types.TypeAndValue.IsBuiltin",
        "params": [],
        "path": "go/go/types/index#TypeAndValue.IsBuiltin",
        "syntax": "func (tv TypeAndValue) IsBuiltin() bool",
        "type": "go"
    },
    "types.TypeAndValue.IsNil": {
        "descr": "IsNil reports whether the corresponding expression denotes the predeclared value nil.",
        "name": "types.TypeAndValue.IsNil",
        "params": [],
        "path": "go/go/types/index#TypeAndValue.IsNil",
        "syntax": "func (tv TypeAndValue) IsNil() bool",
        "type": "go"
    },
    "types.TypeAndValue.IsType": {
        "descr": "IsType reports whether the corresponding expression specifies a type.",
        "name": "types.TypeAndValue.IsType",
        "params": [],
        "path": "go/go/types/index#TypeAndValue.IsType",
        "syntax": "func (tv TypeAndValue) IsType() bool",
        "type": "go"
    },
    "types.TypeAndValue.IsValue": {
        "descr": "IsValue reports whether the corresponding expression is a value. Builtins are not considered values. Constant values have a non- nil Value.",
        "name": "types.TypeAndValue.IsValue",
        "params": [],
        "path": "go/go/types/index#TypeAndValue.IsValue",
        "syntax": "func (tv TypeAndValue) IsValue() bool",
        "type": "go"
    },
    "types.TypeAndValue.IsVoid": {
        "descr": "IsVoid reports whether the corresponding expression is a function call without results.",
        "name": "types.TypeAndValue.IsVoid",
        "params": [],
        "path": "go/go/types/index#TypeAndValue.IsVoid",
        "syntax": "func (tv TypeAndValue) IsVoid() bool",
        "type": "go"
    },
    "types.TypeName": {
        "descr": "A TypeName represents a name for a (defined or alias) type.",
        "name": "types.TypeName",
        "params": [],
        "path": "go/go/types/index#TypeName",
        "syntax": "type TypeName struct { // contains filtered or unexported fields }",
        "type": "go"
    },
    "types.TypeName.Exported": {
        "descr": "Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not.",
        "name": "types.TypeName.Exported",
        "params": [],
        "path": "go/go/types/index#TypeName.Exported",
        "syntax": "func (obj *TypeName) Exported() bool",
        "type": "go"
    },
    "types.TypeName.Id": {
        "descr": "Id is a wrapper for Id(obj.Pkg(), obj.Name()).",
        "name": "types.TypeName.Id",
        "params": [],
        "path": "go/go/types/index#TypeName.Id",
        "syntax": "func (obj *TypeName) Id() string",
        "type": "go"
    },
    "types.TypeName.IsAlias": {
        "descr": "IsAlias reports whether obj is an alias name for a type.",
        "name": "types.TypeName.IsAlias",
        "params": [],
        "path": "go/go/types/index#TypeName.IsAlias",
        "syntax": "func (obj *TypeName) IsAlias() bool",
        "type": "go"
    },
    "types.TypeName.Name": {
        "descr": "Name returns the object's (package-local, unqualified) name.",
        "name": "types.TypeName.Name",
        "params": [],
        "path": "go/go/types/index#TypeName.Name",
        "syntax": "func (obj *TypeName) Name() string",
        "type": "go"
    },
    "types.TypeName.Parent": {
        "descr": "Parent returns the scope in which the object is declared. The result is nil for methods and struct fields.",
        "name": "types.TypeName.Parent",
        "params": [],
        "path": "go/go/types/index#TypeName.Parent",
        "syntax": "func (obj *TypeName) Parent() *Scope",
        "type": "go"
    },
    "types.TypeName.Pkg": {
        "descr": "Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope.",
        "name": "types.TypeName.Pkg",
        "params": [],
        "path": "go/go/types/index#TypeName.Pkg",
        "syntax": "func (obj *TypeName) Pkg() *Package",
        "type": "go"
    },
    "types.TypeName.Pos": {
        "descr": "Pos returns the declaration position of the object's identifier.",
        "name": "types.TypeName.Pos",
        "params": [],
        "path": "go/go/types/index#TypeName.Pos",
        "syntax": "func (obj *TypeName) Pos() token.Pos",
        "type": "go"
    },
    "types.TypeName.String": {
        "descr": "",
        "name": "types.TypeName.String",
        "params": [],
        "path": "go/go/types/index#TypeName.String",
        "syntax": "func (obj *TypeName) String() string",
        "type": "go"
    },
    "types.TypeName.Type": {
        "descr": "Type returns the object's type.",
        "name": "types.TypeName.Type",
        "params": [],
        "path": "go/go/types/index#TypeName.Type",
        "syntax": "func (obj *TypeName) Type() Type",
        "type": "go"
    },
    "types.TypeString": {
        "descr": "TypeString returns the string representation of typ. The Qualifier controls the printing of package-level objects, and may be nil.",
        "name": "types.TypeString",
        "params": [],
        "path": "go/go/types/index#TypeString",
        "syntax": "func TypeString(typ Type, qf Qualifier) string",
        "type": "go"
    },
    "types.Var": {
        "descr": "A Variable represents a declared variable (including function parameters and results, and struct fields).",
        "name": "types.Var",
        "params": [],
        "path": "go/go/types/index#Var",
        "syntax": "type Var struct { // contains filtered or unexported fields }",
        "type": "go"
    },
    "types.Var.Anonymous": {
        "descr": "Anonymous reports whether the variable is an embedded field. Same as Embedded; only present for backward-compatibility.",
        "name": "types.Var.Anonymous",
        "params": [],
        "path": "go/go/types/index#Var.Anonymous",
        "syntax": "func (obj *Var) Anonymous() bool",
        "type": "go"
    },
    "types.Var.Embedded": {
        "descr": "Embedded reports whether the variable is an embedded field.",
        "name": "types.Var.Embedded",
        "params": [],
        "path": "go/go/types/index#Var.Embedded",
        "syntax": "func (obj *Var) Embedded() bool",
        "type": "go"
    },
    "types.Var.Exported": {
        "descr": "Exported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not.",
        "name": "types.Var.Exported",
        "params": [],
        "path": "go/go/types/index#Var.Exported",
        "syntax": "func (obj *Var) Exported() bool",
        "type": "go"
    },
    "types.Var.Id": {
        "descr": "Id is a wrapper for Id(obj.Pkg(), obj.Name()).",
        "name": "types.Var.Id",
        "params": [],
        "path": "go/go/types/index#Var.Id",
        "syntax": "func (obj *Var) Id() string",
        "type": "go"
    },
    "types.Var.IsField": {
        "descr": "IsField reports whether the variable is a struct field.",
        "name": "types.Var.IsField",
        "params": [],
        "path": "go/go/types/index#Var.IsField",
        "syntax": "func (obj *Var) IsField() bool",
        "type": "go"
    },
    "types.Var.Name": {
        "descr": "Name returns the object's (package-local, unqualified) name.",
        "name": "types.Var.Name",
        "params": [],
        "path": "go/go/types/index#Var.Name",
        "syntax": "func (obj *Var) Name() string",
        "type": "go"
    },
    "types.Var.Parent": {
        "descr": "Parent returns the scope in which the object is declared. The result is nil for methods and struct fields.",
        "name": "types.Var.Parent",
        "params": [],
        "path": "go/go/types/index#Var.Parent",
        "syntax": "func (obj *Var) Parent() *Scope",
        "type": "go"
    },
    "types.Var.Pkg": {
        "descr": "Pkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope.",
        "name": "types.Var.Pkg",
        "params": [],
        "path": "go/go/types/index#Var.Pkg",
        "syntax": "func (obj *Var) Pkg() *Package",
        "type": "go"
    },
    "types.Var.Pos": {
        "descr": "Pos returns the declaration position of the object's identifier.",
        "name": "types.Var.Pos",
        "params": [],
        "path": "go/go/types/index#Var.Pos",
        "syntax": "func (obj *Var) Pos() token.Pos",
        "type": "go"
    },
    "types.Var.String": {
        "descr": "",
        "name": "types.Var.String",
        "params": [],
        "path": "go/go/types/index#Var.String",
        "syntax": "func (obj *Var) String() string",
        "type": "go"
    },
    "types.Var.Type": {
        "descr": "Type returns the object's type.",
        "name": "types.Var.Type",
        "params": [],
        "path": "go/go/types/index#Var.Type",
        "syntax": "func (obj *Var) Type() Type",
        "type": "go"
    },
    "types.WriteExpr": {
        "descr": "WriteExpr writes the (possibly shortened) string representation for x to buf. Shortened representations are suitable for user interfaces but may not necessarily follow Go syntax.",
        "name": "types.WriteExpr",
        "params": [],
        "path": "go/go/types/index#WriteExpr",
        "syntax": "func WriteExpr(buf *bytes.Buffer, x ast.Expr)",
        "type": "go"
    },
    "types.WriteSignature": {
        "descr": "WriteSignature writes the representation of the signature sig to buf, without a leading \"func\" keyword. The Qualifier controls the printing of package-level objects, and may be nil.",
        "name": "types.WriteSignature",
        "params": [],
        "path": "go/go/types/index#WriteSignature",
        "syntax": "func WriteSignature(buf *bytes.Buffer, sig *Signature, qf Qualifier)",
        "type": "go"
    },
    "types.WriteType": {
        "descr": "WriteType writes the string representation of typ to buf. The Qualifier controls the printing of package-level objects, and may be nil.",
        "name": "types.WriteType",
        "params": [],
        "path": "go/go/types/index#WriteType",
        "syntax": "func WriteType(buf *bytes.Buffer, typ Type, qf Qualifier)",
        "type": "go"
    },
    "uint": {
        "descr": "uint is an unsigned integer type that is at least 32 bits in size. It is a distinct type, however, and not an alias for, say, uint32.",
        "name": "builtin.uint",
        "params": [],
        "path": "go/builtin/index#uint",
        "syntax": "type uint uint",
        "type": "builtin"
    },
    "uint16": {
        "descr": "uint16 is the set of all unsigned 16-bit integers. Range: 0 through 65535.",
        "name": "builtin.uint16",
        "params": [],
        "path": "go/builtin/index#uint16",
        "syntax": "type uint16 uint16",
        "type": "builtin"
    },
    "uint32": {
        "descr": "uint32 is the set of all unsigned 32-bit integers. Range: 0 through 4294967295.",
        "name": "builtin.uint32",
        "params": [],
        "path": "go/builtin/index#uint32",
        "syntax": "type uint32 uint32",
        "type": "builtin"
    },
    "uint64": {
        "descr": "uint64 is the set of all unsigned 64-bit integers. Range: 0 through 18446744073709551615.",
        "name": "builtin.uint64",
        "params": [],
        "path": "go/builtin/index#uint64",
        "syntax": "type uint64 uint64",
        "type": "builtin"
    },
    "uint8": {
        "descr": "uint8 is the set of all unsigned 8-bit integers. Range: 0 through 255.",
        "name": "builtin.uint8",
        "params": [],
        "path": "go/builtin/index#uint8",
        "syntax": "type uint8 uint8",
        "type": "builtin"
    },
    "uintptr": {
        "descr": "uintptr is an integer type that is large enough to hold the bit pattern of any pointer.",
        "name": "builtin.uintptr",
        "params": [],
        "path": "go/builtin/index#uintptr",
        "syntax": "type uintptr uintptr",
        "type": "builtin"
    },
    "unicode": {
        "descr": "These variables have type *RangeTable.",
        "name": "unicode",
        "params": [],
        "path": "go/unicode/index#pkg-variables",
        "syntax": "var ( Cc = _Cc // Cc is the set of Unicode characters in category Cc. Cf = _Cf // Cf is the set of Unicode characters in category Cf. Co = _Co // Co is the set of Unicode characters in category Co. Cs = _Cs // Cs is the set of Unicode characters in category Cs. Digit = _Nd // Digit is the set of Unicode characters with the \"decimal digit\" property. Nd = _Nd // Nd is the set of Unicode characters in category Nd. Letter = _L // Letter/L is the set of Unicode letters, category L. L = _L Lm = _Lm // Lm is the set of Unicode characters in category Lm. Lo = _Lo // Lo is the set of Unicode characters in category Lo. Lower = _Ll // Lower is the set of Unicode lower case letters. Ll = _Ll // Ll is the set of Unicode characters in category Ll. Mark = _M // Mark/M is the set of Unicode mark characters, category M. M = _M Mc = _Mc // Mc is the set of Unicode characters in category Mc. Me = _Me // Me is the set of Unicode characters in category Me. Mn = _Mn // Mn is the set of Unicode characters in category Mn. Nl = _Nl // Nl is the set of Unicode characters in category Nl. No = _No // No is the set of Unicode characters in category No. Number = _N // Number/N is the set of Unicode number characters, category N. N = _N Other = _C // Other/C is the set of Unicode control and special characters, category C. C = _C Pc = _Pc // Pc is the set of Unicode characters in category Pc. Pd = _Pd // Pd is the set of Unicode characters in category Pd. Pe = _Pe // Pe is the set of Unicode characters in category Pe. Pf = _Pf // Pf is the set of Unicode characters in category Pf. Pi = _Pi // Pi is the set of Unicode characters in category Pi. Po = _Po // Po is the set of Unicode characters in category Po. Ps = _Ps // Ps is the set of Unicode characters in category Ps. Punct = _P // Punct/P is the set of Unicode punctuation characters, category P. P = _P Sc = _Sc // Sc is the set of Unicode characters in category Sc. Sk = _Sk // Sk is the set of Unicode characters in category Sk. Sm = _Sm // Sm is the set of Unicode characters in category Sm. So = _So // So is the set of Unicode characters in category So. Space = _Z // Space/Z is the set of Unicode space characters, category Z. Z = _Z Symbol = _S // Symbol/S is the set of Unicode symbol characters, category S. S = _S Title = _Lt // Title is the set of Unicode title case letters. Lt = _Lt // Lt is the set of Unicode characters in category Lt. Upper = _Lu // Upper is the set of Unicode upper case letters. Lu = _Lu // Lu is the set of Unicode characters in category Lu. Zl = _Zl // Zl is the set of Unicode characters in category Zl. Zp = _Zp // Zp is the set of Unicode characters in category Zp. Zs = _Zs // Zs is the set of Unicode characters in category Zs. )",
        "type": "unicode"
    },
    "unicode.CaseRange": {
        "descr": "CaseRange represents a range of Unicode code points for simple (one code point to one code point) case conversion. The range runs from Lo to Hi inclusive, with a fixed stride of 1. Deltas are the number to add to the code point to reach the code point for a different case for that character. They may be negative. If zero, it means the character is in the corresponding case. There is a special case representing sequences of alternating corresponding Upper and Lower pairs. It appears with a fixed Delta of",
        "name": "unicode.CaseRange",
        "params": [],
        "path": "go/unicode/index#CaseRange",
        "syntax": "{UpperLower, UpperLower, UpperLower}",
        "type": "unicode"
    },
    "unicode.In": {
        "descr": "In reports whether the rune is a member of one of the ranges.",
        "name": "unicode.In",
        "params": [],
        "path": "go/unicode/index#In",
        "syntax": "func In(r rune, ranges ...*RangeTable) bool",
        "type": "unicode"
    },
    "unicode.Is": {
        "descr": "Is reports whether the rune is in the specified table of ranges.",
        "name": "unicode.Is",
        "params": [],
        "path": "go/unicode/index#Is",
        "syntax": "func Is(rangeTab *RangeTable, r rune) bool",
        "type": "unicode"
    },
    "unicode.IsControl": {
        "descr": "IsControl reports whether the rune is a control character. The C (Other) Unicode category includes more code points such as surrogates; use Is(C, r) to test for them.",
        "name": "unicode.IsControl",
        "params": [],
        "path": "go/unicode/index#IsControl",
        "syntax": "func IsControl(r rune) bool",
        "type": "unicode"
    },
    "unicode.IsDigit": {
        "descr": "IsDigit reports whether the rune is a decimal digit.",
        "name": "unicode.IsDigit",
        "params": [],
        "path": "go/unicode/index#IsDigit",
        "syntax": "func IsDigit(r rune) bool",
        "type": "unicode"
    },
    "unicode.IsGraphic": {
        "descr": "IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such characters include letters, marks, numbers, punctuation, symbols, and spaces, from categories L, M, N, P, S, Zs.",
        "name": "unicode.IsGraphic",
        "params": [],
        "path": "go/unicode/index#IsGraphic",
        "syntax": "func IsGraphic(r rune) bool",
        "type": "unicode"
    },
    "unicode.IsLetter": {
        "descr": "IsLetter reports whether the rune is a letter (category L).",
        "name": "unicode.IsLetter",
        "params": [],
        "path": "go/unicode/index#IsLetter",
        "syntax": "func IsLetter(r rune) bool",
        "type": "unicode"
    },
    "unicode.IsLower": {
        "descr": "IsLower reports whether the rune is a lower case letter.",
        "name": "unicode.IsLower",
        "params": [],
        "path": "go/unicode/index#IsLower",
        "syntax": "func IsLower(r rune) bool",
        "type": "unicode"
    },
    "unicode.IsMark": {
        "descr": "IsMark reports whether the rune is a mark character (category M).",
        "name": "unicode.IsMark",
        "params": [],
        "path": "go/unicode/index#IsMark",
        "syntax": "func IsMark(r rune) bool",
        "type": "unicode"
    },
    "unicode.IsNumber": {
        "descr": "IsNumber reports whether the rune is a number (category N).",
        "name": "unicode.IsNumber",
        "params": [],
        "path": "go/unicode/index#IsNumber",
        "syntax": "func IsNumber(r rune) bool",
        "type": "unicode"
    },
    "unicode.IsOneOf": {
        "descr": "IsOneOf reports whether the rune is a member of one of the ranges. The function \"In\" provides a nicer signature and should be used in preference to IsOneOf.",
        "name": "unicode.IsOneOf",
        "params": [],
        "path": "go/unicode/index#IsOneOf",
        "syntax": "func IsOneOf(ranges []*RangeTable, r rune) bool",
        "type": "unicode"
    },
    "unicode.IsPrint": {
        "descr": "IsPrint reports whether the rune is defined as printable by Go. Such characters include letters, marks, numbers, punctuation, symbols, and the ASCII space character, from categories L, M, N, P, S and the ASCII space character. This categorization is the same as IsGraphic except that the only spacing character is ASCII space, U+0020.",
        "name": "unicode.IsPrint",
        "params": [],
        "path": "go/unicode/index#IsPrint",
        "syntax": "func IsPrint(r rune) bool",
        "type": "unicode"
    },
    "unicode.IsPunct": {
        "descr": "IsPunct reports whether the rune is a Unicode punctuation character (category P).",
        "name": "unicode.IsPunct",
        "params": [],
        "path": "go/unicode/index#IsPunct",
        "syntax": "func IsPunct(r rune) bool",
        "type": "unicode"
    },
    "unicode.IsSpace": {
        "descr": "IsSpace reports whether the rune is a space character as defined by Unicode's White Space property; in the Latin-1 space this is",
        "name": "unicode.IsSpace",
        "params": [],
        "path": "go/unicode/index#IsSpace",
        "syntax": "func IsSpace(r rune) bool",
        "type": "unicode"
    },
    "unicode.IsSymbol": {
        "descr": "IsSymbol reports whether the rune is a symbolic character.",
        "name": "unicode.IsSymbol",
        "params": [],
        "path": "go/unicode/index#IsSymbol",
        "syntax": "func IsSymbol(r rune) bool",
        "type": "unicode"
    },
    "unicode.IsTitle": {
        "descr": "IsTitle reports whether the rune is a title case letter.",
        "name": "unicode.IsTitle",
        "params": [],
        "path": "go/unicode/index#IsTitle",
        "syntax": "func IsTitle(r rune) bool",
        "type": "unicode"
    },
    "unicode.IsUpper": {
        "descr": "IsUpper reports whether the rune is an upper case letter.",
        "name": "unicode.IsUpper",
        "params": [],
        "path": "go/unicode/index#IsUpper",
        "syntax": "func IsUpper(r rune) bool",
        "type": "unicode"
    },
    "unicode.Range16": {
        "descr": "Range16 represents of a range of 16-bit Unicode code points. The range runs from Lo to Hi inclusive and has the specified stride.",
        "name": "unicode.Range16",
        "params": [],
        "path": "go/unicode/index#Range16",
        "syntax": "type Range16 struct { Lo uint16 Hi uint16 Stride uint16 }",
        "type": "unicode"
    },
    "unicode.Range32": {
        "descr": "Range32 represents of a range of Unicode code points and is used when one or more of the values will not fit in 16 bits. The range runs from Lo to Hi inclusive and has the specified stride. Lo and Hi must always be >= 1<<16.",
        "name": "unicode.Range32",
        "params": [],
        "path": "go/unicode/index#Range32",
        "syntax": "type Range32 struct { Lo uint32 Hi uint32 Stride uint32 }",
        "type": "unicode"
    },
    "unicode.RangeTable": {
        "descr": "RangeTable defines a set of Unicode code points by listing the ranges of code points within the set. The ranges are listed in two slices to save space: a slice of 16-bit ranges and a slice of 32-bit ranges. The two slices must be in sorted order and non-overlapping. Also, R32 should contain only values >= 0x10000 (1<<16).",
        "name": "unicode.RangeTable",
        "params": [],
        "path": "go/unicode/index#RangeTable",
        "syntax": "type RangeTable struct { R16 []Range16 R32 []Range32 LatinOffset int // number of entries in R16 with Hi <= MaxLatin1; added in Go 1.1 }",
        "type": "unicode"
    },
    "unicode.SimpleFold": {
        "descr": "SimpleFold iterates over Unicode code points equivalent under the Unicode-defined simple case folding. Among the code points equivalent to rune (including rune itself), SimpleFold returns the smallest rune > r if one exists, or else the smallest rune >= 0. If r is not a valid Unicode code point, SimpleFold(r) returns r.",
        "name": "unicode.SimpleFold",
        "params": [],
        "path": "go/unicode/index#SimpleFold",
        "syntax": "func SimpleFold(r rune) rune",
        "type": "unicode"
    },
    "unicode.SpecialCase": {
        "descr": "SpecialCase represents language-specific case mappings such as Turkish. Methods of SpecialCase customize (by overriding) the standard mappings.",
        "name": "unicode.SpecialCase",
        "params": [],
        "path": "go/unicode/index#SpecialCase",
        "syntax": "type SpecialCase []CaseRange",
        "type": "unicode"
    },
    "unicode.SpecialCase.ToLower": {
        "descr": "ToLower maps the rune to lower case giving priority to the special mapping.",
        "name": "unicode.SpecialCase.ToLower",
        "params": [],
        "path": "go/unicode/index#SpecialCase.ToLower",
        "syntax": "func (special SpecialCase) ToLower(r rune) rune",
        "type": "unicode"
    },
    "unicode.SpecialCase.ToTitle": {
        "descr": "ToTitle maps the rune to title case giving priority to the special mapping.",
        "name": "unicode.SpecialCase.ToTitle",
        "params": [],
        "path": "go/unicode/index#SpecialCase.ToTitle",
        "syntax": "func (special SpecialCase) ToTitle(r rune) rune",
        "type": "unicode"
    },
    "unicode.SpecialCase.ToUpper": {
        "descr": "ToUpper maps the rune to upper case giving priority to the special mapping.",
        "name": "unicode.SpecialCase.ToUpper",
        "params": [],
        "path": "go/unicode/index#SpecialCase.ToUpper",
        "syntax": "func (special SpecialCase) ToUpper(r rune) rune",
        "type": "unicode"
    },
    "unicode.To": {
        "descr": "To maps the rune to the specified case: UpperCase, LowerCase, or TitleCase.",
        "name": "unicode.To",
        "params": [],
        "path": "go/unicode/index#To",
        "syntax": "func To(_case int, r rune) rune",
        "type": "unicode"
    },
    "unicode.ToLower": {
        "descr": "ToLower maps the rune to lower case.",
        "name": "unicode.ToLower",
        "params": [],
        "path": "go/unicode/index#ToLower",
        "syntax": "func ToLower(r rune) rune",
        "type": "unicode"
    },
    "unicode.ToTitle": {
        "descr": "ToTitle maps the rune to title case.",
        "name": "unicode.ToTitle",
        "params": [],
        "path": "go/unicode/index#ToTitle",
        "syntax": "func ToTitle(r rune) rune",
        "type": "unicode"
    },
    "unicode.ToUpper": {
        "descr": "ToUpper maps the rune to upper case.",
        "name": "unicode.ToUpper",
        "params": [],
        "path": "go/unicode/index#ToUpper",
        "syntax": "func ToUpper(r rune) rune",
        "type": "unicode"
    },
    "unsafe.Alignof": {
        "descr": "Alignof takes an expression x of any type and returns the required alignment of a hypothetical variable v as if v was declared via var v = x. It is the largest value m such that the address of v is always zero mod m. It is the same as the value returned by reflect.TypeOf(x).Align(). As a special case, if a variable s is of struct type and f is a field within that struct, then Alignof(s.f) will return the required alignment of a field of that type within a struct. This case is the same as the value returned by reflect.TypeOf(s.f).FieldAlign().",
        "name": "unsafe.Alignof",
        "params": [],
        "path": "go/unsafe/index#Alignof",
        "syntax": "func Alignof(x ArbitraryType) uintptr",
        "type": "unsafe"
    },
    "unsafe.ArbitraryType": {
        "descr": "ArbitraryType is here for the purposes of documentation only and is not actually part of the unsafe package. It represents the type of an arbitrary Go expression.",
        "name": "unsafe.ArbitraryType",
        "params": [],
        "path": "go/unsafe/index#ArbitraryType",
        "syntax": "type ArbitraryType int",
        "type": "unsafe"
    },
    "unsafe.Offsetof": {
        "descr": "Offsetof returns the offset within the struct of the field represented by x, which must be of the form structValue.field. In other words, it returns the number of bytes between the start of the struct and the start of the field.",
        "name": "unsafe.Offsetof",
        "params": [],
        "path": "go/unsafe/index#Offsetof",
        "syntax": "func Offsetof(x ArbitraryType) uintptr",
        "type": "unsafe"
    },
    "unsafe.Pointer": {
        "descr": "Pointer represents a pointer to an arbitrary type. There are four special operations available for type Pointer that are not available for other types:",
        "name": "unsafe.Pointer",
        "params": [],
        "path": "go/unsafe/index#Pointer",
        "syntax": "- A pointer value of any type can be converted to a Pointer. - A Pointer can be converted to a pointer value of any type. - A uintptr can be converted to a Pointer. - A Pointer can be converted to a uintptr.",
        "type": "unsafe"
    },
    "unsafe.Sizeof": {
        "descr": "Sizeof takes an expression x of any type and returns the size in bytes of a hypothetical variable v as if v was declared via var v = x. The size does not include any memory possibly referenced by x. For instance, if x is a slice, Sizeof returns the size of the slice descriptor, not the size of the memory referenced by the slice.",
        "name": "unsafe.Sizeof",
        "params": [],
        "path": "go/unsafe/index#Sizeof",
        "syntax": "func Sizeof(x ArbitraryType) uintptr",
        "type": "unsafe"
    },
    "url.Error": {
        "descr": "Error reports an error and the operation and URL that caused it.",
        "name": "url.Error",
        "params": [],
        "path": "go/net/url/index#Error",
        "syntax": "type Error struct { Op string URL string Err error }",
        "type": "net/url"
    },
    "url.Error.Error": {
        "descr": "",
        "name": "url.Error.Error",
        "params": [],
        "path": "go/net/url/index#Error.Error",
        "syntax": "func (e *Error) Error() string",
        "type": "net/url"
    },
    "url.Error.Temporary": {
        "descr": "",
        "name": "url.Error.Temporary",
        "params": [],
        "path": "go/net/url/index#Error.Temporary",
        "syntax": "func (e *Error) Temporary() bool",
        "type": "net/url"
    },
    "url.Error.Timeout": {
        "descr": "",
        "name": "url.Error.Timeout",
        "params": [],
        "path": "go/net/url/index#Error.Timeout",
        "syntax": "func (e *Error) Timeout() bool",
        "type": "net/url"
    },
    "url.EscapeError": {
        "descr": "",
        "name": "url.EscapeError",
        "params": [],
        "path": "go/net/url/index#EscapeError",
        "syntax": "type EscapeError string",
        "type": "net/url"
    },
    "url.EscapeError.Error": {
        "descr": "",
        "name": "url.EscapeError.Error",
        "params": [],
        "path": "go/net/url/index#EscapeError.Error",
        "syntax": "func (e EscapeError) Error() string",
        "type": "net/url"
    },
    "url.InvalidHostError": {
        "descr": "",
        "name": "url.InvalidHostError",
        "params": [],
        "path": "go/net/url/index#InvalidHostError",
        "syntax": "type InvalidHostError string",
        "type": "net/url"
    },
    "url.InvalidHostError.Error": {
        "descr": "",
        "name": "url.InvalidHostError.Error",
        "params": [],
        "path": "go/net/url/index#InvalidHostError.Error",
        "syntax": "func (e InvalidHostError) Error() string",
        "type": "net/url"
    },
    "url.Parse": {
        "descr": "Parse parses rawurl into a URL structure.",
        "name": "url.Parse",
        "params": [],
        "path": "go/net/url/index#Parse",
        "syntax": "func Parse(rawurl string) (*URL, error)",
        "type": "net/url"
    },
    "url.ParseQuery": {
        "descr": "ParseQuery parses the URL-encoded query string and returns a map listing the values specified for each key. ParseQuery always returns a non-nil map containing all the valid query parameters found; err describes the first decoding error encountered, if any.",
        "name": "url.ParseQuery",
        "params": [],
        "path": "go/net/url/index#ParseQuery",
        "syntax": "func ParseQuery(query string) (Values, error)",
        "type": "net/url"
    },
    "url.ParseRequestURI": {
        "descr": "ParseRequestURI parses rawurl into a URL structure. It assumes that rawurl was received in an HTTP request, so the rawurl is interpreted only as an absolute URI or an absolute path. The string rawurl is assumed not to have a #fragment suffix. (Web browsers strip #fragment before sending the URL to a web server.)",
        "name": "url.ParseRequestURI",
        "params": [],
        "path": "go/net/url/index#ParseRequestURI",
        "syntax": "func ParseRequestURI(rawurl string) (*URL, error)",
        "type": "net/url"
    },
    "url.PathEscape": {
        "descr": "PathEscape escapes the string so it can be safely placed inside a URL path segment.",
        "name": "url.PathEscape",
        "params": [],
        "path": "go/net/url/index#PathEscape",
        "syntax": "func PathEscape(s string) string",
        "type": "net/url"
    },
    "url.PathUnescape": {
        "descr": "PathUnescape does the inverse transformation of PathEscape, converting each 3-byte encoded substring of the form \"%AB\" into the hex-decoded byte 0xAB. It returns an error if any % is not followed by two hexadecimal digits.",
        "name": "url.PathUnescape",
        "params": [],
        "path": "go/net/url/index#PathUnescape",
        "syntax": "func PathUnescape(s string) (string, error)",
        "type": "net/url"
    },
    "url.QueryEscape": {
        "descr": "QueryEscape escapes the string so it can be safely placed inside a URL query.",
        "name": "url.QueryEscape",
        "params": [],
        "path": "go/net/url/index#QueryEscape",
        "syntax": "func QueryEscape(s string) string",
        "type": "net/url"
    },
    "url.QueryUnescape": {
        "descr": "QueryUnescape does the inverse transformation of QueryEscape, converting each 3-byte encoded substring of the form \"%AB\" into the hex-decoded byte 0xAB. It returns an error if any % is not followed by two hexadecimal digits.",
        "name": "url.QueryUnescape",
        "params": [],
        "path": "go/net/url/index#QueryUnescape",
        "syntax": "func QueryUnescape(s string) (string, error)",
        "type": "net/url"
    },
    "url.URL": {
        "descr": "A URL represents a parsed URL (technically, a URI reference).",
        "name": "url.URL",
        "params": [],
        "path": "go/net/url/index#URL",
        "syntax": "[scheme:][//[userinfo@]host][/]path[?query][#fragment]",
        "type": "net/url"
    },
    "url.URL.EscapedPath": {
        "descr": "EscapedPath returns the escaped form of u.Path. In general there are multiple possible escaped forms of any path. EscapedPath returns u.RawPath when it is a valid escaping of u.Path. Otherwise EscapedPath ignores u.RawPath and computes an escaped form on its own. The String and RequestURI methods use EscapedPath to construct their results. In general, code should call EscapedPath instead of reading u.RawPath directly.",
        "name": "url.URL.EscapedPath",
        "params": [],
        "path": "go/net/url/index#URL.EscapedPath",
        "syntax": "func (u *URL) EscapedPath() string",
        "type": "net/url"
    },
    "url.URL.Hostname": {
        "descr": "Hostname returns u.Host, without any port number.",
        "name": "url.URL.Hostname",
        "params": [],
        "path": "go/net/url/index#URL.Hostname",
        "syntax": "func (u *URL) Hostname() string",
        "type": "net/url"
    },
    "url.URL.IsAbs": {
        "descr": "IsAbs reports whether the URL is absolute. Absolute means that it has a non-empty scheme.",
        "name": "url.URL.IsAbs",
        "params": [],
        "path": "go/net/url/index#URL.IsAbs",
        "syntax": "func (u *URL) IsAbs() bool",
        "type": "net/url"
    },
    "url.URL.MarshalBinary": {
        "descr": "",
        "name": "url.URL.MarshalBinary",
        "params": [],
        "path": "go/net/url/index#URL.MarshalBinary",
        "syntax": "func (u *URL) MarshalBinary() (text []byte, err error)",
        "type": "net/url"
    },
    "url.URL.Parse": {
        "descr": "Parse parses a URL in the context of the receiver. The provided URL may be relative or absolute. Parse returns nil, err on parse failure, otherwise its return value is the same as ResolveReference.",
        "name": "url.URL.Parse",
        "params": [],
        "path": "go/net/url/index#URL.Parse",
        "syntax": "func (u *URL) Parse(ref string) (*URL, error)",
        "type": "net/url"
    },
    "url.URL.Port": {
        "descr": "Port returns the port part of u.Host, without the leading colon. If u.Host doesn't contain a port, Port returns an empty string.",
        "name": "url.URL.Port",
        "params": [],
        "path": "go/net/url/index#URL.Port",
        "syntax": "func (u *URL) Port() string",
        "type": "net/url"
    },
    "url.URL.Query": {
        "descr": "Query parses RawQuery and returns the corresponding values. It silently discards malformed value pairs. To check errors use ParseQuery.",
        "name": "url.URL.Query",
        "params": [],
        "path": "go/net/url/index#URL.Query",
        "syntax": "func (u *URL) Query() Values",
        "type": "net/url"
    },
    "url.URL.RequestURI": {
        "descr": "RequestURI returns the encoded path?query or opaque?query string that would be used in an HTTP request for u.",
        "name": "url.URL.RequestURI",
        "params": [],
        "path": "go/net/url/index#URL.RequestURI",
        "syntax": "func (u *URL) RequestURI() string",
        "type": "net/url"
    },
    "url.URL.ResolveReference": {
        "descr": "ResolveReference resolves a URI reference to an absolute URI from an absolute base URI u, per RFC 3986 Section 5.2. The URI reference may be relative or absolute. ResolveReference always returns a new URL instance, even if the returned URL is identical to either the base or reference. If ref is an absolute URL, then ResolveReference ignores base and returns a copy of ref.",
        "name": "url.URL.ResolveReference",
        "params": [],
        "path": "go/net/url/index#URL.ResolveReference",
        "syntax": "func (u *URL) ResolveReference(ref *URL) *URL",
        "type": "net/url"
    },
    "url.URL.String": {
        "descr": "String reassembles the URL into a valid URL string. The general form of the result is one of:",
        "name": "url.URL.String",
        "params": [],
        "path": "go/net/url/index#URL.String",
        "syntax": "func (u *URL) String() string",
        "type": "net/url"
    },
    "url.URL.UnmarshalBinary": {
        "descr": "",
        "name": "url.URL.UnmarshalBinary",
        "params": [],
        "path": "go/net/url/index#URL.UnmarshalBinary",
        "syntax": "func (u *URL) UnmarshalBinary(text []byte) error",
        "type": "net/url"
    },
    "url.User": {
        "descr": "User returns a Userinfo containing the provided username and no password set.",
        "name": "url.User",
        "params": [],
        "path": "go/net/url/index#User",
        "syntax": "func User(username string) *Userinfo",
        "type": "net/url"
    },
    "url.UserPassword": {
        "descr": "UserPassword returns a Userinfo containing the provided username and password.",
        "name": "url.UserPassword",
        "params": [],
        "path": "go/net/url/index#UserPassword",
        "syntax": "func UserPassword(username, password string) *Userinfo",
        "type": "net/url"
    },
    "url.Userinfo": {
        "descr": "The Userinfo type is an immutable encapsulation of username and password details for a URL. An existing Userinfo value is guaranteed to have a username set (potentially empty, as allowed by RFC 2396), and optionally a password.",
        "name": "url.Userinfo",
        "params": [],
        "path": "go/net/url/index#Userinfo",
        "syntax": "type Userinfo struct { // contains filtered or unexported fields }",
        "type": "net/url"
    },
    "url.Userinfo.Password": {
        "descr": "Password returns the password in case it is set, and whether it is set.",
        "name": "url.Userinfo.Password",
        "params": [],
        "path": "go/net/url/index#Userinfo.Password",
        "syntax": "func (u *Userinfo) Password() (string, bool)",
        "type": "net/url"
    },
    "url.Userinfo.String": {
        "descr": "String returns the encoded userinfo information in the standard form of \"username[:password]\".",
        "name": "url.Userinfo.String",
        "params": [],
        "path": "go/net/url/index#Userinfo.String",
        "syntax": "func (u *Userinfo) String() string",
        "type": "net/url"
    },
    "url.Userinfo.Username": {
        "descr": "Username returns the username.",
        "name": "url.Userinfo.Username",
        "params": [],
        "path": "go/net/url/index#Userinfo.Username",
        "syntax": "func (u *Userinfo) Username() string",
        "type": "net/url"
    },
    "url.Values": {
        "descr": "Values maps a string key to a list of values. It is typically used for query parameters and form values. Unlike in the http.Header map, the keys in a Values map are case-sensitive.",
        "name": "url.Values",
        "params": [],
        "path": "go/net/url/index#Values",
        "syntax": "type Values map[string][]string",
        "type": "net/url"
    },
    "url.Values.Add": {
        "descr": "Add adds the value to key. It appends to any existing values associated with key.",
        "name": "url.Values.Add",
        "params": [],
        "path": "go/net/url/index#Values.Add",
        "syntax": "func (v Values) Add(key, value string)",
        "type": "net/url"
    },
    "url.Values.Del": {
        "descr": "Del deletes the values associated with key.",
        "name": "url.Values.Del",
        "params": [],
        "path": "go/net/url/index#Values.Del",
        "syntax": "func (v Values) Del(key string)",
        "type": "net/url"
    },
    "url.Values.Encode": {
        "descr": "Encode encodes the values into URL encoded form (\"bar=baz&foo=quux\") sorted by key.",
        "name": "url.Values.Encode",
        "params": [],
        "path": "go/net/url/index#Values.Encode",
        "syntax": "func (v Values) Encode() string",
        "type": "net/url"
    },
    "url.Values.Get": {
        "descr": "Get gets the first value associated with the given key. If there are no values associated with the key, Get returns the empty string. To access multiple values, use the map directly.",
        "name": "url.Values.Get",
        "params": [],
        "path": "go/net/url/index#Values.Get",
        "syntax": "func (v Values) Get(key string) string",
        "type": "net/url"
    },
    "url.Values.Set": {
        "descr": "Set sets the key to value. It replaces any existing values.",
        "name": "url.Values.Set",
        "params": [],
        "path": "go/net/url/index#Values.Set",
        "syntax": "func (v Values) Set(key, value string)",
        "type": "net/url"
    },
    "user.Current": {
        "descr": "Current returns the current user.",
        "name": "user.Current",
        "params": [],
        "path": "go/os/user/index#Current",
        "syntax": "func Current() (*User, error)",
        "type": "os"
    },
    "user.Group": {
        "descr": "Group represents a grouping of users.",
        "name": "user.Group",
        "params": [],
        "path": "go/os/user/index#Group",
        "syntax": "type Group struct { Gid string // group ID Name string // group name }",
        "type": "os"
    },
    "user.Lookup": {
        "descr": "Lookup looks up a user by username. If the user cannot be found, the returned error is of type UnknownUserError.",
        "name": "user.Lookup",
        "params": [],
        "path": "go/os/user/index#Lookup",
        "syntax": "func Lookup(username string) (*User, error)",
        "type": "os"
    },
    "user.LookupGroup": {
        "descr": "LookupGroup looks up a group by name. If the group cannot be found, the returned error is of type UnknownGroupError.",
        "name": "user.LookupGroup",
        "params": [],
        "path": "go/os/user/index#LookupGroup",
        "syntax": "func LookupGroup(name string) (*Group, error)",
        "type": "os"
    },
    "user.LookupGroupId": {
        "descr": "LookupGroupId looks up a group by groupid. If the group cannot be found, the returned error is of type UnknownGroupIdError.",
        "name": "user.LookupGroupId",
        "params": [],
        "path": "go/os/user/index#LookupGroupId",
        "syntax": "func LookupGroupId(gid string) (*Group, error)",
        "type": "os"
    },
    "user.LookupId": {
        "descr": "LookupId looks up a user by userid. If the user cannot be found, the returned error is of type UnknownUserIdError.",
        "name": "user.LookupId",
        "params": [],
        "path": "go/os/user/index#LookupId",
        "syntax": "func LookupId(uid string) (*User, error)",
        "type": "os"
    },
    "user.UnknownGroupError": {
        "descr": "UnknownGroupError is returned by LookupGroup when a group cannot be found.",
        "name": "user.UnknownGroupError",
        "params": [],
        "path": "go/os/user/index#UnknownGroupError",
        "syntax": "type UnknownGroupError string",
        "type": "os"
    },
    "user.UnknownGroupError.Error": {
        "descr": "",
        "name": "user.UnknownGroupError.Error",
        "params": [],
        "path": "go/os/user/index#UnknownGroupError.Error",
        "syntax": "func (e UnknownGroupError) Error() string",
        "type": "os"
    },
    "user.UnknownGroupIdError": {
        "descr": "UnknownGroupIdError is returned by LookupGroupId when a group cannot be found.",
        "name": "user.UnknownGroupIdError",
        "params": [],
        "path": "go/os/user/index#UnknownGroupIdError",
        "syntax": "type UnknownGroupIdError string",
        "type": "os"
    },
    "user.UnknownGroupIdError.Error": {
        "descr": "",
        "name": "user.UnknownGroupIdError.Error",
        "params": [],
        "path": "go/os/user/index#UnknownGroupIdError.Error",
        "syntax": "func (e UnknownGroupIdError) Error() string",
        "type": "os"
    },
    "user.UnknownUserError": {
        "descr": "UnknownUserError is returned by Lookup when a user cannot be found.",
        "name": "user.UnknownUserError",
        "params": [],
        "path": "go/os/user/index#UnknownUserError",
        "syntax": "type UnknownUserError string",
        "type": "os"
    },
    "user.UnknownUserError.Error": {
        "descr": "",
        "name": "user.UnknownUserError.Error",
        "params": [],
        "path": "go/os/user/index#UnknownUserError.Error",
        "syntax": "func (e UnknownUserError) Error() string",
        "type": "os"
    },
    "user.UnknownUserIdError": {
        "descr": "UnknownUserIdError is returned by LookupId when a user cannot be found.",
        "name": "user.UnknownUserIdError",
        "params": [],
        "path": "go/os/user/index#UnknownUserIdError",
        "syntax": "type UnknownUserIdError int",
        "type": "os"
    },
    "user.UnknownUserIdError.Error": {
        "descr": "",
        "name": "user.UnknownUserIdError.Error",
        "params": [],
        "path": "go/os/user/index#UnknownUserIdError.Error",
        "syntax": "func (e UnknownUserIdError) Error() string",
        "type": "os"
    },
    "user.User": {
        "descr": "User represents a user account.",
        "name": "user.User",
        "params": [],
        "path": "go/os/user/index#User",
        "syntax": "type User struct { // Uid is the user ID. // On POSIX systems, this is a decimal number representing the uid. // On Windows, this is a security identifier (SID) in a string format. // On Plan 9, this is the contents of /dev/user. Uid string // Gid is the primary group ID. // On POSIX systems, this is a decimal number representing the gid. // On Windows, this is a SID in a string format. // On Plan 9, this is the contents of /dev/user. Gid string // Username is the login name. Username string // Name is the user's real or display name. // It might be blank. // On POSIX systems, this is the first (or only) entry in the GECOS field // list. // On Windows, this is the user's display name. // On Plan 9, this is the contents of /dev/user. Name string // HomeDir is the path to the user's home directory (if they have one). HomeDir string }",
        "type": "os"
    },
    "user.User.GroupIds": {
        "descr": "GroupIds returns the list of group IDs that the user is a member of.",
        "name": "user.User.GroupIds",
        "params": [],
        "path": "go/os/user/index#User.GroupIds",
        "syntax": "func (u *User) GroupIds() ([]string, error)",
        "type": "os"
    },
    "utf16.Decode": {
        "descr": "Decode returns the Unicode code point sequence represented by the UTF-16 encoding s.",
        "name": "utf16.Decode",
        "params": [],
        "path": "go/unicode/utf16/index#Decode",
        "syntax": "func Decode(s []uint16) []rune",
        "type": "unicode"
    },
    "utf16.DecodeRune": {
        "descr": "DecodeRune returns the UTF-16 decoding of a surrogate pair. If the pair is not a valid UTF-16 surrogate pair, DecodeRune returns the Unicode replacement code point U+FFFD.",
        "name": "utf16.DecodeRune",
        "params": [],
        "path": "go/unicode/utf16/index#DecodeRune",
        "syntax": "func DecodeRune(r1, r2 rune) rune",
        "type": "unicode"
    },
    "utf16.Encode": {
        "descr": "Encode returns the UTF-16 encoding of the Unicode code point sequence s.",
        "name": "utf16.Encode",
        "params": [],
        "path": "go/unicode/utf16/index#Encode",
        "syntax": "func Encode(s []rune) []uint16",
        "type": "unicode"
    },
    "utf16.EncodeRune": {
        "descr": "EncodeRune returns the UTF-16 surrogate pair r1, r2 for the given rune. If the rune is not a valid Unicode code point or does not need encoding, EncodeRune returns U+FFFD, U+FFFD.",
        "name": "utf16.EncodeRune",
        "params": [],
        "path": "go/unicode/utf16/index#EncodeRune",
        "syntax": "func EncodeRune(r rune) (r1, r2 rune)",
        "type": "unicode"
    },
    "utf16.IsSurrogate": {
        "descr": "IsSurrogate reports whether the specified Unicode code point can appear in a surrogate pair.",
        "name": "utf16.IsSurrogate",
        "params": [],
        "path": "go/unicode/utf16/index#IsSurrogate",
        "syntax": "func IsSurrogate(r rune) bool",
        "type": "unicode"
    },
    "utf8.DecodeLastRune": {
        "descr": "DecodeLastRune unpacks the last UTF-8 encoding in p and returns the rune and its width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8.",
        "name": "utf8.DecodeLastRune",
        "params": [],
        "path": "go/unicode/utf8/index#DecodeLastRune",
        "syntax": "func DecodeLastRune(p []byte) (r rune, size int)",
        "type": "unicode"
    },
    "utf8.DecodeLastRuneInString": {
        "descr": "DecodeLastRuneInString is like DecodeLastRune but its input is a string. If s is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8.",
        "name": "utf8.DecodeLastRuneInString",
        "params": [],
        "path": "go/unicode/utf8/index#DecodeLastRuneInString",
        "syntax": "func DecodeLastRuneInString(s string) (r rune, size int)",
        "type": "unicode"
    },
    "utf8.DecodeRune": {
        "descr": "DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and its width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8.",
        "name": "utf8.DecodeRune",
        "params": [],
        "path": "go/unicode/utf8/index#DecodeRune",
        "syntax": "func DecodeRune(p []byte) (r rune, size int)",
        "type": "unicode"
    },
    "utf8.DecodeRuneInString": {
        "descr": "DecodeRuneInString is like DecodeRune but its input is a string. If s is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it returns (RuneError, 1). Both are impossible results for correct, non-empty UTF-8.",
        "name": "utf8.DecodeRuneInString",
        "params": [],
        "path": "go/unicode/utf8/index#DecodeRuneInString",
        "syntax": "func DecodeRuneInString(s string) (r rune, size int)",
        "type": "unicode"
    },
    "utf8.EncodeRune": {
        "descr": "EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune. It returns the number of bytes written.",
        "name": "utf8.EncodeRune",
        "params": [],
        "path": "go/unicode/utf8/index#EncodeRune",
        "syntax": "func EncodeRune(p []byte, r rune) int",
        "type": "unicode"
    },
    "utf8.FullRune": {
        "descr": "FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune. An invalid encoding is considered a full Rune since it will convert as a width-1 error rune.",
        "name": "utf8.FullRune",
        "params": [],
        "path": "go/unicode/utf8/index#FullRune",
        "syntax": "func FullRune(p []byte) bool",
        "type": "unicode"
    },
    "utf8.FullRuneInString": {
        "descr": "FullRuneInString is like FullRune but its input is a string.",
        "name": "utf8.FullRuneInString",
        "params": [],
        "path": "go/unicode/utf8/index#FullRuneInString",
        "syntax": "func FullRuneInString(s string) bool",
        "type": "unicode"
    },
    "utf8.RuneCount": {
        "descr": "RuneCount returns the number of runes in p. Erroneous and short encodings are treated as single runes of width 1 byte.",
        "name": "utf8.RuneCount",
        "params": [],
        "path": "go/unicode/utf8/index#RuneCount",
        "syntax": "func RuneCount(p []byte) int",
        "type": "unicode"
    },
    "utf8.RuneCountInString": {
        "descr": "RuneCountInString is like RuneCount but its input is a string.",
        "name": "utf8.RuneCountInString",
        "params": [],
        "path": "go/unicode/utf8/index#RuneCountInString",
        "syntax": "func RuneCountInString(s string) (n int)",
        "type": "unicode"
    },
    "utf8.RuneLen": {
        "descr": "RuneLen returns the number of bytes required to encode the rune. It returns -1 if the rune is not a valid value to encode in UTF-8.",
        "name": "utf8.RuneLen",
        "params": [],
        "path": "go/unicode/utf8/index#RuneLen",
        "syntax": "func RuneLen(r rune) int",
        "type": "unicode"
    },
    "utf8.RuneStart": {
        "descr": "RuneStart reports whether the byte could be the first byte of an encoded, possibly invalid rune. Second and subsequent bytes always have the top two bits set to 10.",
        "name": "utf8.RuneStart",
        "params": [],
        "path": "go/unicode/utf8/index#RuneStart",
        "syntax": "func RuneStart(b byte) bool",
        "type": "unicode"
    },
    "utf8.Valid": {
        "descr": "Valid reports whether p consists entirely of valid UTF-8-encoded runes.",
        "name": "utf8.Valid",
        "params": [],
        "path": "go/unicode/utf8/index#Valid",
        "syntax": "func Valid(p []byte) bool",
        "type": "unicode"
    },
    "utf8.ValidRune": {
        "descr": "ValidRune reports whether r can be legally encoded as UTF-8. Code points that are out of range or a surrogate half are illegal.",
        "name": "utf8.ValidRune",
        "params": [],
        "path": "go/unicode/utf8/index#ValidRune",
        "syntax": "func ValidRune(r rune) bool",
        "type": "unicode"
    },
    "utf8.ValidString": {
        "descr": "ValidString reports whether s consists entirely of valid UTF-8-encoded runes.",
        "name": "utf8.ValidString",
        "params": [],
        "path": "go/unicode/utf8/index#ValidString",
        "syntax": "func ValidString(s string) bool",
        "type": "unicode"
    },
    "x509.CertPool": {
        "descr": "CertPool is a set of certificates.",
        "name": "x509.CertPool",
        "params": [],
        "path": "go/crypto/x509/index#CertPool",
        "syntax": "type CertPool struct { // contains filtered or unexported fields }",
        "type": "crypto"
    },
    "x509.CertPool.AddCert": {
        "descr": "AddCert adds a certificate to a pool.",
        "name": "x509.CertPool.AddCert",
        "params": [],
        "path": "go/crypto/x509/index#CertPool.AddCert",
        "syntax": "func (s *CertPool) AddCert(cert *Certificate)",
        "type": "crypto"
    },
    "x509.CertPool.AppendCertsFromPEM": {
        "descr": "AppendCertsFromPEM attempts to parse a series of PEM encoded certificates. It appends any certificates found to s and reports whether any certificates were successfully parsed.",
        "name": "x509.CertPool.AppendCertsFromPEM",
        "params": [],
        "path": "go/crypto/x509/index#CertPool.AppendCertsFromPEM",
        "syntax": "func (s *CertPool) AppendCertsFromPEM(pemCerts []byte) (ok bool)",
        "type": "crypto"
    },
    "x509.CertPool.Subjects": {
        "descr": "Subjects returns a list of the DER-encoded subjects of all of the certificates in the pool.",
        "name": "x509.CertPool.Subjects",
        "params": [],
        "path": "go/crypto/x509/index#CertPool.Subjects",
        "syntax": "func (s *CertPool) Subjects() [][]byte",
        "type": "crypto"
    },
    "x509.Certificate": {
        "descr": "A Certificate represents an X.509 certificate.",
        "name": "x509.Certificate",
        "params": [],
        "path": "go/crypto/x509/index#Certificate",
        "syntax": "type Certificate struct { Raw []byte // Complete ASN.1 DER content (certificate, signature algorithm and signature). RawTBSCertificate []byte // Certificate part of raw ASN.1 DER content. RawSubjectPublicKeyInfo []byte // DER encoded SubjectPublicKeyInfo. RawSubject []byte // DER encoded Subject RawIssuer []byte // DER encoded Issuer Signature []byte SignatureAlgorithm SignatureAlgorithm PublicKeyAlgorithm PublicKeyAlgorithm PublicKey interface{} Version int SerialNumber *big.Int Issuer pkix.Name Subject pkix.Name NotBefore, NotAfter time.Time // Validity bounds. KeyUsage KeyUsage // Extensions contains raw X.509 extensions. When parsing certificates, // this can be used to extract non-critical extensions that are not // parsed by this package. When marshaling certificates, the Extensions // field is ignored, see ExtraExtensions. Extensions []pkix.Extension // Go 1.2 // ExtraExtensions contains extensions to be copied, raw, into any // marshaled certificates. Values override any extensions that would // otherwise be produced based on the other fields. The ExtraExtensions // field is not populated when parsing certificates, see Extensions. ExtraExtensions []pkix.Extension // Go 1.2 // UnhandledCriticalExtensions contains a list of extension IDs that // were not (fully) processed when parsing. Verify will fail if this // slice is non-empty, unless verification is delegated to an OS // library which understands all the critical extensions. // // Users can access these extensions using Extensions and can remove // elements from this slice if they believe that they have been // handled. UnhandledCriticalExtensions []asn1.ObjectIdentifier // Go 1.5 ExtKeyUsage []ExtKeyUsage // Sequence of extended key usages. UnknownExtKeyUsage []asn1.ObjectIdentifier // Encountered extended key usages unknown to this package. // BasicConstraintsValid indicates whether IsCA, MaxPathLen, // and MaxPathLenZero are valid. BasicConstraintsValid bool IsCA bool // MaxPathLen and MaxPathLenZero indicate the presence and // value of the BasicConstraints' \"pathLenConstraint\". // // When parsing a certificate, a positive non-zero MaxPathLen // means that the field was specified, -1 means it was unset, // and MaxPathLenZero being true mean that the field was // explicitly set to zero. The case of MaxPathLen==0 with MaxPathLenZero==false // should be treated equivalent to -1 (unset). // // When generating a certificate, an unset pathLenConstraint // can be requested with either MaxPathLen == -1 or using the // zero value for both MaxPathLen and MaxPathLenZero. MaxPathLen int // MaxPathLenZero indicates that BasicConstraintsValid==true // and MaxPathLen==0 should be interpreted as an actual // maximum path length of zero. Otherwise, that combination is // interpreted as MaxPathLen not being set. MaxPathLenZero bool // Go 1.4 SubjectKeyId []byte AuthorityKeyId []byte // RFC 5280, 4.2.2.1 (Authority Information Access) OCSPServer []string // Go 1.2 IssuingCertificateURL []string // Go 1.2 // Subject Alternate Name values. (Note that these values may not be valid // if invalid values were contained within a parsed certificate. For // example, an element of DNSNames may not be a valid DNS domain name.) DNSNames []string EmailAddresses []string IPAddresses []net.IP // Go 1.1 URIs []*url.URL // Go 1.10 // Name constraints PermittedDNSDomainsCritical bool // if true then the name constraints are marked critical. PermittedDNSDomains []string ExcludedDNSDomains []string // Go 1.9 PermittedIPRanges []*net.IPNet // Go 1.10 ExcludedIPRanges []*net.IPNet // Go 1.10 PermittedEmailAddresses []string // Go 1.10 ExcludedEmailAddresses []string // Go 1.10 PermittedURIDomains []string // Go 1.10 ExcludedURIDomains []string // Go 1.10 // CRL Distribution Points CRLDistributionPoints []string // Go 1.2 PolicyIdentifiers []asn1.ObjectIdentifier }",
        "type": "crypto"
    },
    "x509.Certificate.CheckCRLSignature": {
        "descr": "CheckCRLSignature checks that the signature in crl is from c.",
        "name": "x509.Certificate.CheckCRLSignature",
        "params": [],
        "path": "go/crypto/x509/index#Certificate.CheckCRLSignature",
        "syntax": "func (c *Certificate) CheckCRLSignature(crl *pkix.CertificateList) error",
        "type": "crypto"
    },
    "x509.Certificate.CheckSignature": {
        "descr": "CheckSignature verifies that signature is a valid signature over signed from c's public key.",
        "name": "x509.Certificate.CheckSignature",
        "params": [],
        "path": "go/crypto/x509/index#Certificate.CheckSignature",
        "syntax": "func (c *Certificate) CheckSignature(algo SignatureAlgorithm, signed, signature []byte) error",
        "type": "crypto"
    },
    "x509.Certificate.CheckSignatureFrom": {
        "descr": "CheckSignatureFrom verifies that the signature on c is a valid signature from parent.",
        "name": "x509.Certificate.CheckSignatureFrom",
        "params": [],
        "path": "go/crypto/x509/index#Certificate.CheckSignatureFrom",
        "syntax": "func (c *Certificate) CheckSignatureFrom(parent *Certificate) error",
        "type": "crypto"
    },
    "x509.Certificate.CreateCRL": {
        "descr": "CreateCRL returns a DER encoded CRL, signed by this Certificate, that contains the given list of revoked certificates.",
        "name": "x509.Certificate.CreateCRL",
        "params": [],
        "path": "go/crypto/x509/index#Certificate.CreateCRL",
        "syntax": "func (c *Certificate) CreateCRL(rand io.Reader, priv interface{}, revokedCerts []pkix.RevokedCertificate, now, expiry time.Time) (crlBytes []byte, err error)",
        "type": "crypto"
    },
    "x509.Certificate.Equal": {
        "descr": "",
        "name": "x509.Certificate.Equal",
        "params": [],
        "path": "go/crypto/x509/index#Certificate.Equal",
        "syntax": "func (c *Certificate) Equal(other *Certificate) bool",
        "type": "crypto"
    },
    "x509.Certificate.Verify": {
        "descr": "Verify attempts to verify c by building one or more chains from c to a certificate in opts.Roots, using certificates in opts.Intermediates if needed. If successful, it returns one or more chains where the first element of the chain is c and the last element is from opts.Roots.",
        "name": "x509.Certificate.Verify",
        "params": [],
        "path": "go/crypto/x509/index#Certificate.Verify",
        "syntax": "func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err error)",
        "type": "crypto"
    },
    "x509.Certificate.VerifyHostname": {
        "descr": "VerifyHostname returns nil if c is a valid certificate for the named host. Otherwise it returns an error describing the mismatch.",
        "name": "x509.Certificate.VerifyHostname",
        "params": [],
        "path": "go/crypto/x509/index#Certificate.VerifyHostname",
        "syntax": "func (c *Certificate) VerifyHostname(h string) error",
        "type": "crypto"
    },
    "x509.CertificateInvalidError": {
        "descr": "CertificateInvalidError results when an odd error occurs. Users of this library probably want to handle all these errors uniformly.",
        "name": "x509.CertificateInvalidError",
        "params": [],
        "path": "go/crypto/x509/index#CertificateInvalidError",
        "syntax": "type CertificateInvalidError struct { Cert *Certificate Reason InvalidReason Detail string // Go 1.10 }",
        "type": "crypto"
    },
    "x509.CertificateInvalidError.Error": {
        "descr": "",
        "name": "x509.CertificateInvalidError.Error",
        "params": [],
        "path": "go/crypto/x509/index#CertificateInvalidError.Error",
        "syntax": "func (e CertificateInvalidError) Error() string",
        "type": "crypto"
    },
    "x509.CertificateRequest": {
        "descr": "CertificateRequest represents a PKCS #10, certificate signature request.",
        "name": "x509.CertificateRequest",
        "params": [],
        "path": "go/crypto/x509/index#CertificateRequest",
        "syntax": "type CertificateRequest struct { Raw []byte // Complete ASN.1 DER content (CSR, signature algorithm and signature). RawTBSCertificateRequest []byte // Certificate request info part of raw ASN.1 DER content. RawSubjectPublicKeyInfo []byte // DER encoded SubjectPublicKeyInfo. RawSubject []byte // DER encoded Subject. Version int Signature []byte SignatureAlgorithm SignatureAlgorithm PublicKeyAlgorithm PublicKeyAlgorithm PublicKey interface{} Subject pkix.Name // Attributes is the dried husk of a bug and shouldn't be used. Attributes []pkix.AttributeTypeAndValueSET // Extensions contains raw X.509 extensions. When parsing CSRs, this // can be used to extract extensions that are not parsed by this // package. Extensions []pkix.Extension // ExtraExtensions contains extensions to be copied, raw, into any // marshaled CSR. Values override any extensions that would otherwise // be produced based on the other fields but are overridden by any // extensions specified in Attributes. // // The ExtraExtensions field is not populated when parsing CSRs, see // Extensions. ExtraExtensions []pkix.Extension // Subject Alternate Name values. DNSNames []string EmailAddresses []string IPAddresses []net.IP URIs []*url.URL // Go 1.10 }",
        "type": "crypto"
    },
    "x509.CertificateRequest.CheckSignature": {
        "descr": "CheckSignature reports whether the signature on c is valid.",
        "name": "x509.CertificateRequest.CheckSignature",
        "params": [],
        "path": "go/crypto/x509/index#CertificateRequest.CheckSignature",
        "syntax": "func (c *CertificateRequest) CheckSignature() error",
        "type": "crypto"
    },
    "x509.ConstraintViolationError": {
        "descr": "ConstraintViolationError results when a requested usage is not permitted by a certificate. For example: checking a signature when the public key isn't a certificate signing key.",
        "name": "x509.ConstraintViolationError",
        "params": [],
        "path": "go/crypto/x509/index#ConstraintViolationError",
        "syntax": "type ConstraintViolationError struct{}",
        "type": "crypto"
    },
    "x509.ConstraintViolationError.Error": {
        "descr": "",
        "name": "x509.ConstraintViolationError.Error",
        "params": [],
        "path": "go/crypto/x509/index#ConstraintViolationError.Error",
        "syntax": "func (ConstraintViolationError) Error() string",
        "type": "crypto"
    },
    "x509.CreateCertificate": {
        "descr": "CreateCertificate creates a new X.509v3 certificate based on a template. The following members of template are used:",
        "name": "x509.CreateCertificate",
        "params": [],
        "path": "go/crypto/x509/index#CreateCertificate",
        "syntax": "func CreateCertificate(rand io.Reader, template, parent *Certificate, pub, priv interface{}) (cert []byte, err error)",
        "type": "crypto"
    },
    "x509.CreateCertificateRequest": {
        "descr": "CreateCertificateRequest creates a new certificate request based on a template. The following members of template are used:",
        "name": "x509.CreateCertificateRequest",
        "params": [],
        "path": "go/crypto/x509/index#CreateCertificateRequest",
        "syntax": "func CreateCertificateRequest(rand io.Reader, template *CertificateRequest, priv interface{}) (csr []byte, err error)",
        "type": "crypto"
    },
    "x509.DecryptPEMBlock": {
        "descr": "DecryptPEMBlock takes a password encrypted PEM block and the password used to encrypt it and returns a slice of decrypted DER encoded bytes. It inspects the DEK-Info header to determine the algorithm used for decryption. If no DEK-Info header is present, an error is returned. If an incorrect password is detected an IncorrectPasswordError is returned. Because of deficiencies in the encrypted-PEM format, it's not always possible to detect an incorrect password. In these cases no error will be returned but the decrypted DER bytes will be random noise.",
        "name": "x509.DecryptPEMBlock",
        "params": [],
        "path": "go/crypto/x509/index#DecryptPEMBlock",
        "syntax": "func DecryptPEMBlock(b *pem.Block, password []byte) ([]byte, error)",
        "type": "crypto"
    },
    "x509.EncryptPEMBlock": {
        "descr": "EncryptPEMBlock returns a PEM block of the specified type holding the given DER-encoded data encrypted with the specified algorithm and password.",
        "name": "x509.EncryptPEMBlock",
        "params": [],
        "path": "go/crypto/x509/index#EncryptPEMBlock",
        "syntax": "func EncryptPEMBlock(rand io.Reader, blockType string, data, password []byte, alg PEMCipher) (*pem.Block, error)",
        "type": "crypto"
    },
    "x509.ExtKeyUsage": {
        "descr": "ExtKeyUsage represents an extended set of actions that are valid for a given key. Each of the ExtKeyUsage* constants define a unique action.",
        "name": "x509.ExtKeyUsage",
        "params": [],
        "path": "go/crypto/x509/index#ExtKeyUsage",
        "syntax": "type ExtKeyUsage int",
        "type": "crypto"
    },
    "x509.HostnameError": {
        "descr": "HostnameError results when the set of authorized names doesn't match the requested name.",
        "name": "x509.HostnameError",
        "params": [],
        "path": "go/crypto/x509/index#HostnameError",
        "syntax": "type HostnameError struct { Certificate *Certificate Host string }",
        "type": "crypto"
    },
    "x509.HostnameError.Error": {
        "descr": "",
        "name": "x509.HostnameError.Error",
        "params": [],
        "path": "go/crypto/x509/index#HostnameError.Error",
        "syntax": "func (h HostnameError) Error() string",
        "type": "crypto"
    },
    "x509.InsecureAlgorithmError": {
        "descr": "An InsecureAlgorithmError",
        "name": "x509.InsecureAlgorithmError",
        "params": [],
        "path": "go/crypto/x509/index#InsecureAlgorithmError",
        "syntax": "type InsecureAlgorithmError SignatureAlgorithm",
        "type": "crypto"
    },
    "x509.InsecureAlgorithmError.Error": {
        "descr": "",
        "name": "x509.InsecureAlgorithmError.Error",
        "params": [],
        "path": "go/crypto/x509/index#InsecureAlgorithmError.Error",
        "syntax": "func (e InsecureAlgorithmError) Error() string",
        "type": "crypto"
    },
    "x509.InvalidReason": {
        "descr": "",
        "name": "x509.InvalidReason",
        "params": [],
        "path": "go/crypto/x509/index#InvalidReason",
        "syntax": "type InvalidReason int",
        "type": "crypto"
    },
    "x509.IsEncryptedPEMBlock": {
        "descr": "IsEncryptedPEMBlock returns if the PEM block is password encrypted.",
        "name": "x509.IsEncryptedPEMBlock",
        "params": [],
        "path": "go/crypto/x509/index#IsEncryptedPEMBlock",
        "syntax": "func IsEncryptedPEMBlock(b *pem.Block) bool",
        "type": "crypto"
    },
    "x509.KeyUsage": {
        "descr": "KeyUsage represents the set of actions that are valid for a given key. It's a bitmap of the KeyUsage* constants.",
        "name": "x509.KeyUsage",
        "params": [],
        "path": "go/crypto/x509/index#KeyUsage",
        "syntax": "type KeyUsage int",
        "type": "crypto"
    },
    "x509.MarshalECPrivateKey": {
        "descr": "MarshalECPrivateKey marshals an EC private key into ASN.1, DER format.",
        "name": "x509.MarshalECPrivateKey",
        "params": [],
        "path": "go/crypto/x509/index#MarshalECPrivateKey",
        "syntax": "func MarshalECPrivateKey(key *ecdsa.PrivateKey) ([]byte, error)",
        "type": "crypto"
    },
    "x509.MarshalPKCS1PrivateKey": {
        "descr": "MarshalPKCS1PrivateKey converts a private key to ASN.1 DER encoded form.",
        "name": "x509.MarshalPKCS1PrivateKey",
        "params": [],
        "path": "go/crypto/x509/index#MarshalPKCS1PrivateKey",
        "syntax": "func MarshalPKCS1PrivateKey(key *rsa.PrivateKey) []byte",
        "type": "crypto"
    },
    "x509.MarshalPKCS1PublicKey": {
        "descr": "MarshalPKCS1PublicKey converts an RSA public key to PKCS#1, ASN.1 DER form.",
        "name": "x509.MarshalPKCS1PublicKey",
        "params": [],
        "path": "go/crypto/x509/index#MarshalPKCS1PublicKey",
        "syntax": "func MarshalPKCS1PublicKey(key *rsa.PublicKey) []byte",
        "type": "crypto"
    },
    "x509.MarshalPKCS8PrivateKey": {
        "descr": "MarshalPKCS8PrivateKey converts a private key to PKCS#8 encoded form. The following key types are supported: *rsa.PrivateKey, *ecdsa.PrivateKey. Unsupported key types result in an error.",
        "name": "x509.MarshalPKCS8PrivateKey",
        "params": [],
        "path": "go/crypto/x509/index#MarshalPKCS8PrivateKey",
        "syntax": "func MarshalPKCS8PrivateKey(key interface{}) ([]byte, error)",
        "type": "crypto"
    },
    "x509.MarshalPKIXPublicKey": {
        "descr": "MarshalPKIXPublicKey serialises a public key to DER-encoded PKIX format.",
        "name": "x509.MarshalPKIXPublicKey",
        "params": [],
        "path": "go/crypto/x509/index#MarshalPKIXPublicKey",
        "syntax": "func MarshalPKIXPublicKey(pub interface{}) ([]byte, error)",
        "type": "crypto"
    },
    "x509.NewCertPool": {
        "descr": "NewCertPool returns a new, empty CertPool.",
        "name": "x509.NewCertPool",
        "params": [],
        "path": "go/crypto/x509/index#NewCertPool",
        "syntax": "func NewCertPool() *CertPool",
        "type": "crypto"
    },
    "x509.PEMCipher": {
        "descr": "Possible values for the EncryptPEMBlock encryption algorithm.",
        "name": "x509.PEMCipher",
        "params": [],
        "path": "go/crypto/x509/index#PEMCipher",
        "syntax": "type PEMCipher int",
        "type": "crypto"
    },
    "x509.ParseCRL": {
        "descr": "ParseCRL parses a CRL from the given bytes. It's often the case that PEM encoded CRLs will appear where they should be DER encoded, so this function will transparently handle PEM encoding as long as there isn't any leading garbage.",
        "name": "x509.ParseCRL",
        "params": [],
        "path": "go/crypto/x509/index#ParseCRL",
        "syntax": "func ParseCRL(crlBytes []byte) (*pkix.CertificateList, error)",
        "type": "crypto"
    },
    "x509.ParseCertificate": {
        "descr": "ParseCertificate parses a single certificate from the given ASN.1 DER data.",
        "name": "x509.ParseCertificate",
        "params": [],
        "path": "go/crypto/x509/index#ParseCertificate",
        "syntax": "func ParseCertificate(asn1Data []byte) (*Certificate, error)",
        "type": "crypto"
    },
    "x509.ParseCertificateRequest": {
        "descr": "ParseCertificateRequest parses a single certificate request from the given ASN.1 DER data.",
        "name": "x509.ParseCertificateRequest",
        "params": [],
        "path": "go/crypto/x509/index#ParseCertificateRequest",
        "syntax": "func ParseCertificateRequest(asn1Data []byte) (*CertificateRequest, error)",
        "type": "crypto"
    },
    "x509.ParseCertificates": {
        "descr": "ParseCertificates parses one or more certificates from the given ASN.1 DER data. The certificates must be concatenated with no intermediate padding.",
        "name": "x509.ParseCertificates",
        "params": [],
        "path": "go/crypto/x509/index#ParseCertificates",
        "syntax": "func ParseCertificates(asn1Data []byte) ([]*Certificate, error)",
        "type": "crypto"
    },
    "x509.ParseDERCRL": {
        "descr": "ParseDERCRL parses a DER encoded CRL from the given bytes.",
        "name": "x509.ParseDERCRL",
        "params": [],
        "path": "go/crypto/x509/index#ParseDERCRL",
        "syntax": "func ParseDERCRL(derBytes []byte) (*pkix.CertificateList, error)",
        "type": "crypto"
    },
    "x509.ParseECPrivateKey": {
        "descr": "ParseECPrivateKey parses an ASN.1 Elliptic Curve Private Key Structure.",
        "name": "x509.ParseECPrivateKey",
        "params": [],
        "path": "go/crypto/x509/index#ParseECPrivateKey",
        "syntax": "func ParseECPrivateKey(der []byte) (*ecdsa.PrivateKey, error)",
        "type": "crypto"
    },
    "x509.ParsePKCS1PrivateKey": {
        "descr": "ParsePKCS1PrivateKey returns an RSA private key from its ASN.1 PKCS#1 DER encoded form.",
        "name": "x509.ParsePKCS1PrivateKey",
        "params": [],
        "path": "go/crypto/x509/index#ParsePKCS1PrivateKey",
        "syntax": "func ParsePKCS1PrivateKey(der []byte) (*rsa.PrivateKey, error)",
        "type": "crypto"
    },
    "x509.ParsePKCS1PublicKey": {
        "descr": "ParsePKCS1PublicKey parses a PKCS#1 public key in ASN.1 DER form.",
        "name": "x509.ParsePKCS1PublicKey",
        "params": [],
        "path": "go/crypto/x509/index#ParsePKCS1PublicKey",
        "syntax": "func ParsePKCS1PublicKey(der []byte) (*rsa.PublicKey, error)",
        "type": "crypto"
    },
    "x509.ParsePKCS8PrivateKey": {
        "descr": "ParsePKCS8PrivateKey parses an unencrypted, PKCS#8 private key. See RFC 5208.",
        "name": "x509.ParsePKCS8PrivateKey",
        "params": [],
        "path": "go/crypto/x509/index#ParsePKCS8PrivateKey",
        "syntax": "func ParsePKCS8PrivateKey(der []byte) (key interface{}, err error)",
        "type": "crypto"
    },
    "x509.ParsePKIXPublicKey": {
        "descr": "ParsePKIXPublicKey parses a DER encoded public key. These values are typically found in PEM blocks with \"BEGIN PUBLIC KEY\".",
        "name": "x509.ParsePKIXPublicKey",
        "params": [],
        "path": "go/crypto/x509/index#ParsePKIXPublicKey",
        "syntax": "func ParsePKIXPublicKey(derBytes []byte) (pub interface{}, err error)",
        "type": "crypto"
    },
    "x509.PublicKeyAlgorithm": {
        "descr": "",
        "name": "x509.PublicKeyAlgorithm",
        "params": [],
        "path": "go/crypto/x509/index#PublicKeyAlgorithm",
        "syntax": "type PublicKeyAlgorithm int",
        "type": "crypto"
    },
    "x509.PublicKeyAlgorithm.String": {
        "descr": "",
        "name": "x509.PublicKeyAlgorithm.String",
        "params": [],
        "path": "go/crypto/x509/index#PublicKeyAlgorithm.String",
        "syntax": "func (algo PublicKeyAlgorithm) String() string",
        "type": "crypto"
    },
    "x509.SignatureAlgorithm": {
        "descr": "",
        "name": "x509.SignatureAlgorithm",
        "params": [],
        "path": "go/crypto/x509/index#SignatureAlgorithm",
        "syntax": "type SignatureAlgorithm int",
        "type": "crypto"
    },
    "x509.SignatureAlgorithm.String": {
        "descr": "",
        "name": "x509.SignatureAlgorithm.String",
        "params": [],
        "path": "go/crypto/x509/index#SignatureAlgorithm.String",
        "syntax": "func (algo SignatureAlgorithm) String() string",
        "type": "crypto"
    },
    "x509.SystemCertPool": {
        "descr": "SystemCertPool returns a copy of the system cert pool.",
        "name": "x509.SystemCertPool",
        "params": [],
        "path": "go/crypto/x509/index#SystemCertPool",
        "syntax": "func SystemCertPool() (*CertPool, error)",
        "type": "crypto"
    },
    "x509.SystemRootsError": {
        "descr": "SystemRootsError results when we fail to load the system root certificates.",
        "name": "x509.SystemRootsError",
        "params": [],
        "path": "go/crypto/x509/index#SystemRootsError",
        "syntax": "type SystemRootsError struct { Err error // Go 1.7 }",
        "type": "crypto"
    },
    "x509.SystemRootsError.Error": {
        "descr": "",
        "name": "x509.SystemRootsError.Error",
        "params": [],
        "path": "go/crypto/x509/index#SystemRootsError.Error",
        "syntax": "func (se SystemRootsError) Error() string",
        "type": "crypto"
    },
    "x509.UnhandledCriticalExtension": {
        "descr": "",
        "name": "x509.UnhandledCriticalExtension",
        "params": [],
        "path": "go/crypto/x509/index#UnhandledCriticalExtension",
        "syntax": "type UnhandledCriticalExtension struct{}",
        "type": "crypto"
    },
    "x509.UnhandledCriticalExtension.Error": {
        "descr": "",
        "name": "x509.UnhandledCriticalExtension.Error",
        "params": [],
        "path": "go/crypto/x509/index#UnhandledCriticalExtension.Error",
        "syntax": "func (h UnhandledCriticalExtension) Error() string",
        "type": "crypto"
    },
    "x509.UnknownAuthorityError": {
        "descr": "UnknownAuthorityError results when the certificate issuer is unknown",
        "name": "x509.UnknownAuthorityError",
        "params": [],
        "path": "go/crypto/x509/index#UnknownAuthorityError",
        "syntax": "type UnknownAuthorityError struct { Cert *Certificate // Go 1.8 // contains filtered or unexported fields }",
        "type": "crypto"
    },
    "x509.UnknownAuthorityError.Error": {
        "descr": "",
        "name": "x509.UnknownAuthorityError.Error",
        "params": [],
        "path": "go/crypto/x509/index#UnknownAuthorityError.Error",
        "syntax": "func (e UnknownAuthorityError) Error() string",
        "type": "crypto"
    },
    "x509.VerifyOptions": {
        "descr": "VerifyOptions contains parameters for Certificate.Verify. It's a structure because other PKIX verification APIs have ended up needing many options.",
        "name": "x509.VerifyOptions",
        "params": [],
        "path": "go/crypto/x509/index#VerifyOptions",
        "syntax": "type VerifyOptions struct { DNSName string Intermediates *CertPool Roots *CertPool // if nil, the system roots are used CurrentTime time.Time // if zero, the current time is used // KeyUsage specifies which Extended Key Usage values are acceptable. A leaf // certificate is accepted if it contains any of the listed values. An empty // list means ExtKeyUsageServerAuth. To accept any key usage, include // ExtKeyUsageAny. // // Certificate chains are required to nest these extended key usage values. // (This matches the Windows CryptoAPI behavior, but not the spec.) KeyUsages []ExtKeyUsage // Go 1.1 // MaxConstraintComparisions is the maximum number of comparisons to // perform when checking a given certificate's name constraints. If // zero, a sensible default is used. This limit prevents pathological // certificates from consuming excessive amounts of CPU time when // validating. MaxConstraintComparisions int // Go 1.10 }",
        "type": "crypto"
    },
    "xml.Attr": {
        "descr": "An Attr represents an attribute in an XML element (Name=Value).",
        "name": "xml.Attr",
        "params": [],
        "path": "go/encoding/xml/index#Attr",
        "syntax": "type Attr struct { Name Name Value string }",
        "type": "encoding"
    },
    "xml.CharData": {
        "descr": "A CharData represents XML character data (raw text), in which XML escape sequences have been replaced by the characters they represent.",
        "name": "xml.CharData",
        "params": [],
        "path": "go/encoding/xml/index#CharData",
        "syntax": "type CharData []byte",
        "type": "encoding"
    },
    "xml.CharData.Copy": {
        "descr": "Copy creates a new copy of CharData.",
        "name": "xml.CharData.Copy",
        "params": [],
        "path": "go/encoding/xml/index#CharData.Copy",
        "syntax": "func (c CharData) Copy() CharData",
        "type": "encoding"
    },
    "xml.Comment": {
        "descr": "A Comment represents an XML comment of the form <!--comment-->. The bytes do not include the <!-- and --> comment markers.",
        "name": "xml.Comment",
        "params": [],
        "path": "go/encoding/xml/index#Comment",
        "syntax": "type Comment []byte",
        "type": "encoding"
    },
    "xml.Comment.Copy": {
        "descr": "Copy creates a new copy of Comment.",
        "name": "xml.Comment.Copy",
        "params": [],
        "path": "go/encoding/xml/index#Comment.Copy",
        "syntax": "func (c Comment) Copy() Comment",
        "type": "encoding"
    },
    "xml.CopyToken": {
        "descr": "CopyToken returns a copy of a Token.",
        "name": "xml.CopyToken",
        "params": [],
        "path": "go/encoding/xml/index#CopyToken",
        "syntax": "func CopyToken(t Token) Token",
        "type": "encoding"
    },
    "xml.Decoder": {
        "descr": "A Decoder represents an XML parser reading a particular input stream. The parser assumes that its input is encoded in UTF-8.",
        "name": "xml.Decoder",
        "params": [],
        "path": "go/encoding/xml/index#Decoder",
        "syntax": "type Decoder struct { // Strict defaults to true, enforcing the requirements // of the XML specification. // If set to false, the parser allows input containing common // mistakes: // * If an element is missing an end tag, the parser invents // end tags as necessary to keep the return values from Token // properly balanced. // * In attribute values and character data, unknown or malformed // character entities (sequences beginning with &) are left alone. // // Setting: // // d.Strict = false // d.AutoClose = xml.HTMLAutoClose // d.Entity = xml.HTMLEntity // // creates a parser that can handle typical HTML. // // Strict mode does not enforce the requirements of the XML name spaces TR. // In particular it does not reject name space tags using undefined prefixes. // Such tags are recorded with the unknown prefix as the name space URL. Strict bool // When Strict == false, AutoClose indicates a set of elements to // consider closed immediately after they are opened, regardless // of whether an end element is present. AutoClose []string // Entity can be used to map non-standard entity names to string replacements. // The parser behaves as if these standard mappings are present in the map, // regardless of the actual map content: // // \"lt\": \"<\", // \"gt\": \">\", // \"amp\": \"&\", // \"apos\": \"'\", // \"quot\": `\"`, Entity map[string]string // CharsetReader, if non-nil, defines a function to generate // charset-conversion readers, converting from the provided // non-UTF-8 charset into UTF-8. If CharsetReader is nil or // returns an error, parsing stops with an error. One of the // CharsetReader's result values must be non-nil. CharsetReader func(charset string, input io.Reader) (io.Reader, error) // DefaultSpace sets the default name space used for unadorned tags, // as if the entire XML stream were wrapped in an element containing // the attribute xmlns=\"DefaultSpace\". DefaultSpace string // Go 1.1 // contains filtered or unexported fields }",
        "type": "encoding"
    },
    "xml.Decoder.Decode": {
        "descr": "Decode works like Unmarshal, except it reads the decoder stream to find the start element.",
        "name": "xml.Decoder.Decode",
        "params": [],
        "path": "go/encoding/xml/index#Decoder.Decode",
        "syntax": "func (d *Decoder) Decode(v interface{}) error",
        "type": "encoding"
    },
    "xml.Decoder.DecodeElement": {
        "descr": "DecodeElement works like Unmarshal except that it takes a pointer to the start XML element to decode into v. It is useful when a client reads some raw XML tokens itself but also wants to defer to Unmarshal for some elements.",
        "name": "xml.Decoder.DecodeElement",
        "params": [],
        "path": "go/encoding/xml/index#Decoder.DecodeElement",
        "syntax": "func (d *Decoder) DecodeElement(v interface{}, start *StartElement) error",
        "type": "encoding"
    },
    "xml.Decoder.InputOffset": {
        "descr": "InputOffset returns the input stream byte offset of the current decoder position. The offset gives the location of the end of the most recently returned token and the beginning of the next token.",
        "name": "xml.Decoder.InputOffset",
        "params": [],
        "path": "go/encoding/xml/index#Decoder.InputOffset",
        "syntax": "func (d *Decoder) InputOffset() int64",
        "type": "encoding"
    },
    "xml.Decoder.RawToken": {
        "descr": "RawToken is like Token but does not verify that start and end elements match and does not translate name space prefixes to their corresponding URLs.",
        "name": "xml.Decoder.RawToken",
        "params": [],
        "path": "go/encoding/xml/index#Decoder.RawToken",
        "syntax": "func (d *Decoder) RawToken() (Token, error)",
        "type": "encoding"
    },
    "xml.Decoder.Skip": {
        "descr": "Skip reads tokens until it has consumed the end element matching the most recent start element already consumed. It recurs if it encounters a start element, so it can be used to skip nested structures. It returns nil if it finds an end element matching the start element; otherwise it returns an error describing the problem.",
        "name": "xml.Decoder.Skip",
        "params": [],
        "path": "go/encoding/xml/index#Decoder.Skip",
        "syntax": "func (d *Decoder) Skip() error",
        "type": "encoding"
    },
    "xml.Decoder.Token": {
        "descr": "Token returns the next XML token in the input stream. At the end of the input stream, Token returns nil, io.EOF.",
        "name": "xml.Decoder.Token",
        "params": [],
        "path": "go/encoding/xml/index#Decoder.Token",
        "syntax": "func (d *Decoder) Token() (Token, error)",
        "type": "encoding"
    },
    "xml.Directive": {
        "descr": "A Directive represents an XML directive of the form <!text>. The bytes do not include the <! and > markers.",
        "name": "xml.Directive",
        "params": [],
        "path": "go/encoding/xml/index#Directive",
        "syntax": "type Directive []byte",
        "type": "encoding"
    },
    "xml.Directive.Copy": {
        "descr": "Copy creates a new copy of Directive.",
        "name": "xml.Directive.Copy",
        "params": [],
        "path": "go/encoding/xml/index#Directive.Copy",
        "syntax": "func (d Directive) Copy() Directive",
        "type": "encoding"
    },
    "xml.Encoder": {
        "descr": "An Encoder writes XML data to an output stream.",
        "name": "xml.Encoder",
        "params": [],
        "path": "go/encoding/xml/index#Encoder",
        "syntax": "type Encoder struct { // contains filtered or unexported fields }",
        "type": "encoding"
    },
    "xml.Encoder.Encode": {
        "descr": "Encode writes the XML encoding of v to the stream.",
        "name": "xml.Encoder.Encode",
        "params": [],
        "path": "go/encoding/xml/index#Encoder.Encode",
        "syntax": "func (enc *Encoder) Encode(v interface{}) error",
        "type": "encoding"
    },
    "xml.Encoder.EncodeElement": {
        "descr": "EncodeElement writes the XML encoding of v to the stream, using start as the outermost tag in the encoding.",
        "name": "xml.Encoder.EncodeElement",
        "params": [],
        "path": "go/encoding/xml/index#Encoder.EncodeElement",
        "syntax": "func (enc *Encoder) EncodeElement(v interface{}, start StartElement) error",
        "type": "encoding"
    },
    "xml.Encoder.EncodeToken": {
        "descr": "EncodeToken writes the given XML token to the stream. It returns an error if StartElement and EndElement tokens are not properly matched.",
        "name": "xml.Encoder.EncodeToken",
        "params": [],
        "path": "go/encoding/xml/index#Encoder.EncodeToken",
        "syntax": "func (enc *Encoder) EncodeToken(t Token) error",
        "type": "encoding"
    },
    "xml.Encoder.Flush": {
        "descr": "Flush flushes any buffered XML to the underlying writer. See the EncodeToken documentation for details about when it is necessary.",
        "name": "xml.Encoder.Flush",
        "params": [],
        "path": "go/encoding/xml/index#Encoder.Flush",
        "syntax": "func (enc *Encoder) Flush() error",
        "type": "encoding"
    },
    "xml.Encoder.Indent": {
        "descr": "Indent sets the encoder to generate XML in which each element begins on a new indented line that starts with prefix and is followed by one or more copies of indent according to the nesting depth.",
        "name": "xml.Encoder.Indent",
        "params": [],
        "path": "go/encoding/xml/index#Encoder.Indent",
        "syntax": "func (enc *Encoder) Indent(prefix, indent string)",
        "type": "encoding"
    },
    "xml.EndElement": {
        "descr": "An EndElement represents an XML end element.",
        "name": "xml.EndElement",
        "params": [],
        "path": "go/encoding/xml/index#EndElement",
        "syntax": "type EndElement struct { Name Name }",
        "type": "encoding"
    },
    "xml.Escape": {
        "descr": "Escape is like EscapeText but omits the error return value. It is provided for backwards compatibility with Go 1.0. Code targeting Go 1.1 or later should use EscapeText.",
        "name": "xml.Escape",
        "params": [],
        "path": "go/encoding/xml/index#Escape",
        "syntax": "func Escape(w io.Writer, s []byte)",
        "type": "encoding"
    },
    "xml.EscapeText": {
        "descr": "EscapeText writes to w the properly escaped XML equivalent of the plain text data s.",
        "name": "xml.EscapeText",
        "params": [],
        "path": "go/encoding/xml/index#EscapeText",
        "syntax": "func EscapeText(w io.Writer, s []byte) error",
        "type": "encoding"
    },
    "xml.Marshal": {
        "descr": "Marshal returns the XML encoding of v.",
        "name": "xml.Marshal",
        "params": [],
        "path": "go/encoding/xml/index#Marshal",
        "syntax": "func Marshal(v interface{}) ([]byte, error)",
        "type": "encoding"
    },
    "xml.MarshalIndent": {
        "descr": "MarshalIndent works like Marshal, but each XML element begins on a new indented line that starts with prefix and is followed by one or more copies of indent according to the nesting depth.",
        "name": "xml.MarshalIndent",
        "params": [],
        "path": "go/encoding/xml/index#MarshalIndent",
        "syntax": "func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)",
        "type": "encoding"
    },
    "xml.Marshaler": {
        "descr": "Marshaler is the interface implemented by objects that can marshal themselves into valid XML elements.",
        "name": "xml.Marshaler",
        "params": [],
        "path": "go/encoding/xml/index#Marshaler",
        "syntax": "type Marshaler interface { MarshalXML(e *Encoder, start StartElement) error }",
        "type": "encoding"
    },
    "xml.MarshalerAttr": {
        "descr": "MarshalerAttr is the interface implemented by objects that can marshal themselves into valid XML attributes.",
        "name": "xml.MarshalerAttr",
        "params": [],
        "path": "go/encoding/xml/index#MarshalerAttr",
        "syntax": "type MarshalerAttr interface { MarshalXMLAttr(name Name) (Attr, error) }",
        "type": "encoding"
    },
    "xml.Name": {
        "descr": "A Name represents an XML name (Local) annotated with a name space identifier (Space). In tokens returned by Decoder.Token, the Space identifier is given as a canonical URL, not the short prefix used in the document being parsed.",
        "name": "xml.Name",
        "params": [],
        "path": "go/encoding/xml/index#Name",
        "syntax": "type Name struct { Space, Local string }",
        "type": "encoding"
    },
    "xml.NewDecoder": {
        "descr": "NewDecoder creates a new XML parser reading from r. If r does not implement io.ByteReader, NewDecoder will do its own buffering.",
        "name": "xml.NewDecoder",
        "params": [],
        "path": "go/encoding/xml/index#NewDecoder",
        "syntax": "func NewDecoder(r io.Reader) *Decoder",
        "type": "encoding"
    },
    "xml.NewEncoder": {
        "descr": "NewEncoder returns a new encoder that writes to w.",
        "name": "xml.NewEncoder",
        "params": [],
        "path": "go/encoding/xml/index#NewEncoder",
        "syntax": "func NewEncoder(w io.Writer) *Encoder",
        "type": "encoding"
    },
    "xml.NewTokenDecoder": {
        "descr": "NewTokenDecoder creates a new XML parser using an underlying token stream.",
        "name": "xml.NewTokenDecoder",
        "params": [],
        "path": "go/encoding/xml/index#NewTokenDecoder",
        "syntax": "func NewTokenDecoder(t TokenReader) *Decoder",
        "type": "encoding"
    },
    "xml.ProcInst": {
        "descr": "A ProcInst represents an XML processing instruction of the form <?target inst?>",
        "name": "xml.ProcInst",
        "params": [],
        "path": "go/encoding/xml/index#ProcInst",
        "syntax": "type ProcInst struct { Target string Inst []byte }",
        "type": "encoding"
    },
    "xml.ProcInst.Copy": {
        "descr": "Copy creates a new copy of ProcInst.",
        "name": "xml.ProcInst.Copy",
        "params": [],
        "path": "go/encoding/xml/index#ProcInst.Copy",
        "syntax": "func (p ProcInst) Copy() ProcInst",
        "type": "encoding"
    },
    "xml.StartElement": {
        "descr": "A StartElement represents an XML start element.",
        "name": "xml.StartElement",
        "params": [],
        "path": "go/encoding/xml/index#StartElement",
        "syntax": "type StartElement struct { Name Name Attr []Attr }",
        "type": "encoding"
    },
    "xml.StartElement.Copy": {
        "descr": "Copy creates a new copy of StartElement.",
        "name": "xml.StartElement.Copy",
        "params": [],
        "path": "go/encoding/xml/index#StartElement.Copy",
        "syntax": "func (e StartElement) Copy() StartElement",
        "type": "encoding"
    },
    "xml.StartElement.End": {
        "descr": "End returns the corresponding XML end element.",
        "name": "xml.StartElement.End",
        "params": [],
        "path": "go/encoding/xml/index#StartElement.End",
        "syntax": "func (e StartElement) End() EndElement",
        "type": "encoding"
    },
    "xml.SyntaxError": {
        "descr": "A SyntaxError represents a syntax error in the XML input stream.",
        "name": "xml.SyntaxError",
        "params": [],
        "path": "go/encoding/xml/index#SyntaxError",
        "syntax": "type SyntaxError struct { Msg string Line int }",
        "type": "encoding"
    },
    "xml.SyntaxError.Error": {
        "descr": "",
        "name": "xml.SyntaxError.Error",
        "params": [],
        "path": "go/encoding/xml/index#SyntaxError.Error",
        "syntax": "func (e *SyntaxError) Error() string",
        "type": "encoding"
    },
    "xml.TagPathError": {
        "descr": "A TagPathError represents an error in the unmarshaling process caused by the use of field tags with conflicting paths.",
        "name": "xml.TagPathError",
        "params": [],
        "path": "go/encoding/xml/index#TagPathError",
        "syntax": "type TagPathError struct { Struct reflect.Type Field1, Tag1 string Field2, Tag2 string }",
        "type": "encoding"
    },
    "xml.TagPathError.Error": {
        "descr": "",
        "name": "xml.TagPathError.Error",
        "params": [],
        "path": "go/encoding/xml/index#TagPathError.Error",
        "syntax": "func (e *TagPathError) Error() string",
        "type": "encoding"
    },
    "xml.Token": {
        "descr": "A Token is an interface holding one of the token types: StartElement, EndElement, CharData, Comment, ProcInst, or Directive.",
        "name": "xml.Token",
        "params": [],
        "path": "go/encoding/xml/index#Token",
        "syntax": "type Token interface{}",
        "type": "encoding"
    },
    "xml.TokenReader": {
        "descr": "A TokenReader is anything that can decode a stream of XML tokens, including a Decoder.",
        "name": "xml.TokenReader",
        "params": [],
        "path": "go/encoding/xml/index#TokenReader",
        "syntax": "type TokenReader interface { Token() (Token, error) }",
        "type": "encoding"
    },
    "xml.Unmarshal": {
        "descr": "Unmarshal parses the XML-encoded data and stores the result in the value pointed to by v, which must be an arbitrary struct, slice, or string. Well-formed data that does not fit into v is discarded.",
        "name": "xml.Unmarshal",
        "params": [],
        "path": "go/encoding/xml/index#Unmarshal",
        "syntax": "func Unmarshal(data []byte, v interface{}) error",
        "type": "encoding"
    },
    "xml.UnmarshalError": {
        "descr": "An UnmarshalError represents an error in the unmarshaling process.",
        "name": "xml.UnmarshalError",
        "params": [],
        "path": "go/encoding/xml/index#UnmarshalError",
        "syntax": "type UnmarshalError string",
        "type": "encoding"
    },
    "xml.UnmarshalError.Error": {
        "descr": "",
        "name": "xml.UnmarshalError.Error",
        "params": [],
        "path": "go/encoding/xml/index#UnmarshalError.Error",
        "syntax": "func (e UnmarshalError) Error() string",
        "type": "encoding"
    },
    "xml.Unmarshaler": {
        "descr": "Unmarshaler is the interface implemented by objects that can unmarshal an XML element description of themselves.",
        "name": "xml.Unmarshaler",
        "params": [],
        "path": "go/encoding/xml/index#Unmarshaler",
        "syntax": "type Unmarshaler interface { UnmarshalXML(d *Decoder, start StartElement) error }",
        "type": "encoding"
    },
    "xml.UnmarshalerAttr": {
        "descr": "UnmarshalerAttr is the interface implemented by objects that can unmarshal an XML attribute description of themselves.",
        "name": "xml.UnmarshalerAttr",
        "params": [],
        "path": "go/encoding/xml/index#UnmarshalerAttr",
        "syntax": "type UnmarshalerAttr interface { UnmarshalXMLAttr(attr Attr) error }",
        "type": "encoding"
    },
    "xml.UnsupportedTypeError": {
        "descr": "UnsupportedTypeError is returned when Marshal encounters a type that cannot be converted into XML.",
        "name": "xml.UnsupportedTypeError",
        "params": [],
        "path": "go/encoding/xml/index#UnsupportedTypeError",
        "syntax": "type UnsupportedTypeError struct { Type reflect.Type }",
        "type": "encoding"
    },
    "xml.UnsupportedTypeError.Error": {
        "descr": "",
        "name": "xml.UnsupportedTypeError.Error",
        "params": [],
        "path": "go/encoding/xml/index#UnsupportedTypeError.Error",
        "syntax": "func (e *UnsupportedTypeError) Error() string",
        "type": "encoding"
    },
    "zip.Compressor": {
        "descr": "A Compressor returns a new compressing writer, writing to w. The WriteCloser's Close method must be used to flush pending data to w. The Compressor itself must be safe to invoke from multiple goroutines simultaneously, but each returned writer will be used only by one goroutine at a time.",
        "name": "zip.Compressor",
        "params": [],
        "path": "go/archive/zip/index#Compressor",
        "syntax": "type Compressor func(w io.Writer) (io.WriteCloser, error)",
        "type": "archive"
    },
    "zip.Decompressor": {
        "descr": "A Decompressor returns a new decompressing reader, reading from r. The ReadCloser's Close method must be used to release associated resources. The Decompressor itself must be safe to invoke from multiple goroutines simultaneously, but each returned reader will be used only by one goroutine at a time.",
        "name": "zip.Decompressor",
        "params": [],
        "path": "go/archive/zip/index#Decompressor",
        "syntax": "type Decompressor func(r io.Reader) io.ReadCloser",
        "type": "archive"
    },
    "zip.File": {
        "descr": "",
        "name": "zip.File",
        "params": [],
        "path": "go/archive/zip/index#File",
        "syntax": "type File struct { FileHeader // contains filtered or unexported fields }",
        "type": "archive"
    },
    "zip.File.DataOffset": {
        "descr": "DataOffset returns the offset of the file's possibly-compressed data, relative to the beginning of the zip file.",
        "name": "zip.File.DataOffset",
        "params": [],
        "path": "go/archive/zip/index#File.DataOffset",
        "syntax": "func (f *File) DataOffset() (offset int64, err error)",
        "type": "archive"
    },
    "zip.File.Open": {
        "descr": "Open returns a ReadCloser that provides access to the File's contents. Multiple files may be read concurrently.",
        "name": "zip.File.Open",
        "params": [],
        "path": "go/archive/zip/index#File.Open",
        "syntax": "func (f *File) Open() (io.ReadCloser, error)",
        "type": "archive"
    },
    "zip.FileHeader": {
        "descr": "FileHeader describes a file within a zip file. See the zip spec for details.",
        "name": "zip.FileHeader",
        "params": [],
        "path": "go/archive/zip/index#FileHeader",
        "syntax": "type FileHeader struct { // Name is the name of the file. // // It must be a relative path, not start with a drive letter (such as \"C:\"), // and must use forward slashes instead of back slashes. A trailing slash // indicates that this file is a directory and should have no data. // // When reading zip files, the Name field is populated from // the zip file directly and is not validated for correctness. // It is the caller's responsibility to sanitize it as // appropriate, including canonicalizing slash directions, // validating that paths are relative, and preventing path // traversal through filenames (\"../../../\"). Name string // Comment is any arbitrary user-defined string shorter than 64KiB. Comment string // NonUTF8 indicates that Name and Comment are not encoded in UTF-8. // // By specification, the only other encoding permitted should be CP-437, // but historically many ZIP readers interpret Name and Comment as whatever // the system's local character encoding happens to be. // // This flag should only be set if the user intends to encode a non-portable // ZIP file for a specific localized region. Otherwise, the Writer // automatically sets the ZIP format's UTF-8 flag for valid UTF-8 strings. NonUTF8 bool // Go 1.10 CreatorVersion uint16 ReaderVersion uint16 Flags uint16 // Method is the compression method. If zero, Store is used. Method uint16 // Modified is the modified time of the file. // // When reading, an extended timestamp is preferred over the legacy MS-DOS // date field, and the offset between the times is used as the timezone. // If only the MS-DOS date is present, the timezone is assumed to be UTC. // // When writing, an extended timestamp (which is timezone-agnostic) is // always emitted. The legacy MS-DOS date field is encoded according to the // location of the Modified time. Modified time.Time // Go 1.10 ModifiedTime uint16 // Deprecated: Legacy MS-DOS date; use Modified instead. ModifiedDate uint16 // Deprecated: Legacy MS-DOS time; use Modified instead. CRC32 uint32 CompressedSize uint32 // Deprecated: Use CompressedSize64 instead. UncompressedSize uint32 // Deprecated: Use UncompressedSize64 instead. CompressedSize64 uint64 // Go 1.1 UncompressedSize64 uint64 // Go 1.1 Extra []byte ExternalAttrs uint32 // Meaning depends on CreatorVersion }",
        "type": "archive"
    },
    "zip.FileHeader.FileInfo": {
        "descr": "FileInfo returns an os.FileInfo for the FileHeader.",
        "name": "zip.FileHeader.FileInfo",
        "params": [],
        "path": "go/archive/zip/index#FileHeader.FileInfo",
        "syntax": "func (h *FileHeader) FileInfo() os.FileInfo",
        "type": "archive"
    },
    "zip.FileHeader.ModTime": {
        "descr": "ModTime returns the modification time in UTC using the legacy ModifiedDate and ModifiedTime fields.",
        "name": "zip.FileHeader.ModTime",
        "params": [],
        "path": "go/archive/zip/index#FileHeader.ModTime",
        "syntax": "func (h *FileHeader) ModTime() time.Time",
        "type": "archive"
    },
    "zip.FileHeader.Mode": {
        "descr": "Mode returns the permission and mode bits for the FileHeader.",
        "name": "zip.FileHeader.Mode",
        "params": [],
        "path": "go/archive/zip/index#FileHeader.Mode",
        "syntax": "func (h *FileHeader) Mode() (mode os.FileMode)",
        "type": "archive"
    },
    "zip.FileHeader.SetModTime": {
        "descr": "SetModTime sets the Modified, ModifiedTime, and ModifiedDate fields to the given time in UTC.",
        "name": "zip.FileHeader.SetModTime",
        "params": [],
        "path": "go/archive/zip/index#FileHeader.SetModTime",
        "syntax": "func (h *FileHeader) SetModTime(t time.Time)",
        "type": "archive"
    },
    "zip.FileHeader.SetMode": {
        "descr": "SetMode changes the permission and mode bits for the FileHeader.",
        "name": "zip.FileHeader.SetMode",
        "params": [],
        "path": "go/archive/zip/index#FileHeader.SetMode",
        "syntax": "func (h *FileHeader) SetMode(mode os.FileMode)",
        "type": "archive"
    },
    "zip.FileInfoHeader": {
        "descr": "FileInfoHeader creates a partially-populated FileHeader from an os.FileInfo. Because os.FileInfo's Name method returns only the base name of the file it describes, it may be necessary to modify the Name field of the returned header to provide the full path name of the file. If compression is desired, callers should set the FileHeader.Method field; it is unset by default.",
        "name": "zip.FileInfoHeader",
        "params": [],
        "path": "go/archive/zip/index#FileInfoHeader",
        "syntax": "func FileInfoHeader(fi os.FileInfo) (*FileHeader, error)",
        "type": "archive"
    },
    "zip.NewReader": {
        "descr": "NewReader returns a new Reader reading from r, which is assumed to have the given size in bytes.",
        "name": "zip.NewReader",
        "params": [],
        "path": "go/archive/zip/index#NewReader",
        "syntax": "func NewReader(r io.ReaderAt, size int64) (*Reader, error)",
        "type": "archive"
    },
    "zip.NewWriter": {
        "descr": "NewWriter returns a new Writer writing a zip file to w.",
        "name": "zip.NewWriter",
        "params": [],
        "path": "go/archive/zip/index#NewWriter",
        "syntax": "func NewWriter(w io.Writer) *Writer",
        "type": "archive"
    },
    "zip.OpenReader": {
        "descr": "OpenReader will open the Zip file specified by name and return a ReadCloser.",
        "name": "zip.OpenReader",
        "params": [],
        "path": "go/archive/zip/index#OpenReader",
        "syntax": "func OpenReader(name string) (*ReadCloser, error)",
        "type": "archive"
    },
    "zip.ReadCloser": {
        "descr": "",
        "name": "zip.ReadCloser",
        "params": [],
        "path": "go/archive/zip/index#ReadCloser",
        "syntax": "type ReadCloser struct { Reader // contains filtered or unexported fields }",
        "type": "archive"
    },
    "zip.ReadCloser.Close": {
        "descr": "Close closes the Zip file, rendering it unusable for I/O.",
        "name": "zip.ReadCloser.Close",
        "params": [],
        "path": "go/archive/zip/index#ReadCloser.Close",
        "syntax": "func (rc *ReadCloser) Close() error",
        "type": "archive"
    },
    "zip.Reader": {
        "descr": "",
        "name": "zip.Reader",
        "params": [],
        "path": "go/archive/zip/index#Reader",
        "syntax": "type Reader struct { File []*File Comment string // contains filtered or unexported fields }",
        "type": "archive"
    },
    "zip.Reader.RegisterDecompressor": {
        "descr": "RegisterDecompressor registers or overrides a custom decompressor for a specific method ID. If a decompressor for a given method is not found, Reader will default to looking up the decompressor at the package level.",
        "name": "zip.Reader.RegisterDecompressor",
        "params": [],
        "path": "go/archive/zip/index#Reader.RegisterDecompressor",
        "syntax": "func (z *Reader) RegisterDecompressor(method uint16, dcomp Decompressor)",
        "type": "archive"
    },
    "zip.RegisterCompressor": {
        "descr": "RegisterCompressor registers custom compressors for a specified method ID. The common methods Store and Deflate are built in.",
        "name": "zip.RegisterCompressor",
        "params": [],
        "path": "go/archive/zip/index#RegisterCompressor",
        "syntax": "func RegisterCompressor(method uint16, comp Compressor)",
        "type": "archive"
    },
    "zip.RegisterDecompressor": {
        "descr": "RegisterDecompressor allows custom decompressors for a specified method ID. The common methods Store and Deflate are built in.",
        "name": "zip.RegisterDecompressor",
        "params": [],
        "path": "go/archive/zip/index#RegisterDecompressor",
        "syntax": "func RegisterDecompressor(method uint16, dcomp Decompressor)",
        "type": "archive"
    },
    "zip.Writer": {
        "descr": "Writer implements a zip file writer.",
        "name": "zip.Writer",
        "params": [],
        "path": "go/archive/zip/index#Writer",
        "syntax": "type Writer struct { // contains filtered or unexported fields }",
        "type": "archive"
    },
    "zip.Writer.Close": {
        "descr": "Close finishes writing the zip file by writing the central directory. It does not close the underlying writer.",
        "name": "zip.Writer.Close",
        "params": [],
        "path": "go/archive/zip/index#Writer.Close",
        "syntax": "func (w *Writer) Close() error",
        "type": "archive"
    },
    "zip.Writer.Create": {
        "descr": "Create adds a file to the zip file using the provided name. It returns a Writer to which the file contents should be written. The file contents will be compressed using the Deflate method. The name must be a relative path: it must not start with a drive letter (e.g. C:) or leading slash, and only forward slashes are allowed. To create a directory instead of a file, add a trailing slash to the name. The file's contents must be written to the io.Writer before the next call to Create, CreateHeader, or Close.",
        "name": "zip.Writer.Create",
        "params": [],
        "path": "go/archive/zip/index#Writer.Create",
        "syntax": "func (w *Writer) Create(name string) (io.Writer, error)",
        "type": "archive"
    },
    "zip.Writer.CreateHeader": {
        "descr": "CreateHeader adds a file to the zip archive using the provided FileHeader for the file metadata. Writer takes ownership of fh and may mutate its fields. The caller must not modify fh after calling CreateHeader.",
        "name": "zip.Writer.CreateHeader",
        "params": [],
        "path": "go/archive/zip/index#Writer.CreateHeader",
        "syntax": "func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error)",
        "type": "archive"
    },
    "zip.Writer.Flush": {
        "descr": "Flush flushes any buffered data to the underlying writer. Calling Flush is not normally necessary; calling Close is sufficient.",
        "name": "zip.Writer.Flush",
        "params": [],
        "path": "go/archive/zip/index#Writer.Flush",
        "syntax": "func (w *Writer) Flush() error",
        "type": "archive"
    },
    "zip.Writer.RegisterCompressor": {
        "descr": "RegisterCompressor registers or overrides a custom compressor for a specific method ID. If a compressor for a given method is not found, Writer will default to looking up the compressor at the package level.",
        "name": "zip.Writer.RegisterCompressor",
        "params": [],
        "path": "go/archive/zip/index#Writer.RegisterCompressor",
        "syntax": "func (w *Writer) RegisterCompressor(method uint16, comp Compressor)",
        "type": "archive"
    },
    "zip.Writer.SetComment": {
        "descr": "SetComment sets the end-of-central-directory comment field. It can only be called before Close.",
        "name": "zip.Writer.SetComment",
        "params": [],
        "path": "go/archive/zip/index#Writer.SetComment",
        "syntax": "func (w *Writer) SetComment(comment string) error",
        "type": "archive"
    },
    "zip.Writer.SetOffset": {
        "descr": "SetOffset sets the offset of the beginning of the zip data within the underlying writer. It should be used when the zip data is appended to an existing file, such as a binary executable. It must be called before any data is written.",
        "name": "zip.Writer.SetOffset",
        "params": [],
        "path": "go/archive/zip/index#Writer.SetOffset",
        "syntax": "func (w *Writer) SetOffset(n int64)",
        "type": "archive"
    },
    "zlib.NewReader": {
        "descr": "NewReader creates a new ReadCloser. Reads from the returned ReadCloser read and decompress data from r. If r does not implement io.ByteReader, the decompressor may read more data than necessary from r. It is the caller's responsibility to call Close on the ReadCloser when done.",
        "name": "zlib.NewReader",
        "params": [],
        "path": "go/compress/zlib/index#NewReader",
        "syntax": "func NewReader(r io.Reader) (io.ReadCloser, error)",
        "type": "compress"
    },
    "zlib.NewReaderDict": {
        "descr": "NewReaderDict is like NewReader but uses a preset dictionary. NewReaderDict ignores the dictionary if the compressed data does not refer to it. If the compressed data refers to a different dictionary, NewReaderDict returns ErrDictionary.",
        "name": "zlib.NewReaderDict",
        "params": [],
        "path": "go/compress/zlib/index#NewReaderDict",
        "syntax": "func NewReaderDict(r io.Reader, dict []byte) (io.ReadCloser, error)",
        "type": "compress"
    },
    "zlib.NewWriter": {
        "descr": "NewWriter creates a new Writer. Writes to the returned Writer are compressed and written to w.",
        "name": "zlib.NewWriter",
        "params": [],
        "path": "go/compress/zlib/index#NewWriter",
        "syntax": "func NewWriter(w io.Writer) *Writer",
        "type": "compress"
    },
    "zlib.NewWriterLevel": {
        "descr": "NewWriterLevel is like NewWriter but specifies the compression level instead of assuming DefaultCompression.",
        "name": "zlib.NewWriterLevel",
        "params": [],
        "path": "go/compress/zlib/index#NewWriterLevel",
        "syntax": "func NewWriterLevel(w io.Writer, level int) (*Writer, error)",
        "type": "compress"
    },
    "zlib.NewWriterLevelDict": {
        "descr": "NewWriterLevelDict is like NewWriterLevel but specifies a dictionary to compress with.",
        "name": "zlib.NewWriterLevelDict",
        "params": [],
        "path": "go/compress/zlib/index#NewWriterLevelDict",
        "syntax": "func NewWriterLevelDict(w io.Writer, level int, dict []byte) (*Writer, error)",
        "type": "compress"
    },
    "zlib.Resetter": {
        "descr": "Resetter resets a ReadCloser returned by NewReader or NewReaderDict to to switch to a new underlying Reader. This permits reusing a ReadCloser instead of allocating a new one.",
        "name": "zlib.Resetter",
        "params": [],
        "path": "go/compress/zlib/index#Resetter",
        "syntax": "type Resetter interface { // Reset discards any buffered data and resets the Resetter as if it was // newly initialized with the given reader. Reset(r io.Reader, dict []byte) error }",
        "type": "compress"
    },
    "zlib.Writer": {
        "descr": "A Writer takes data written to it and writes the compressed form of that data to an underlying writer (see NewWriter).",
        "name": "zlib.Writer",
        "params": [],
        "path": "go/compress/zlib/index#Writer",
        "syntax": "type Writer struct { // contains filtered or unexported fields }",
        "type": "compress"
    },
    "zlib.Writer.Close": {
        "descr": "Close closes the Writer, flushing any unwritten data to the underlying io.Writer, but does not close the underlying io.Writer.",
        "name": "zlib.Writer.Close",
        "params": [],
        "path": "go/compress/zlib/index#Writer.Close",
        "syntax": "func (z *Writer) Close() error",
        "type": "compress"
    },
    "zlib.Writer.Flush": {
        "descr": "Flush flushes the Writer to its underlying io.Writer.",
        "name": "zlib.Writer.Flush",
        "params": [],
        "path": "go/compress/zlib/index#Writer.Flush",
        "syntax": "func (z *Writer) Flush() error",
        "type": "compress"
    },
    "zlib.Writer.Reset": {
        "descr": "Reset clears the state of the Writer z such that it is equivalent to its initial state from NewWriterLevel or NewWriterLevelDict, but instead writing to w.",
        "name": "zlib.Writer.Reset",
        "params": [],
        "path": "go/compress/zlib/index#Writer.Reset",
        "syntax": "func (z *Writer) Reset(w io.Writer)",
        "type": "compress"
    },
    "zlib.Writer.Write": {
        "descr": "Write writes a compressed form of p to the underlying io.Writer. The compressed bytes are not necessarily flushed until the Writer is closed or explicitly flushed.",
        "name": "zlib.Writer.Write",
        "params": [],
        "path": "go/compress/zlib/index#Writer.Write",
        "syntax": "func (z *Writer) Write(p []byte) (n int, err error)",
        "type": "compress"
    }
}